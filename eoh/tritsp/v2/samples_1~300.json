[
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([obj[0] + obj[1] + obj[2] for _, obj in archive]) / sum(obj[0] + obj[1] + obj[2] for _, obj in archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid 2-opt and insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to perform 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (insertion heuristic)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7151735509379223,
            1.1682403445243836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([obj[0] + obj[1] + obj[2] for _, obj in archive]) / sum(obj[0] + obj[1] + obj[2] for _, obj in archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid 2-opt and insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to perform 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (insertion heuristic)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([obj[0] + obj[1] + obj[2] for _, obj in archive]) / sum(obj[0] + obj[1] + obj[2] for _, obj in archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid 2-opt and insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to perform 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (insertion heuristic)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7151735509379223,
            1.1682403445243836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([obj[0] + obj[1] + obj[2] for _, obj in archive]) / sum(obj[0] + obj[1] + obj[2] for _, obj in archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid 2-opt and insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to perform 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (insertion heuristic)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([obj[0] + obj[1] + obj[2] for _, obj in archive]) / sum(obj[0] + obj[1] + obj[2] for _, obj in archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid 2-opt and insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to perform 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (insertion heuristic)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7151735509379223,
            1.1682403445243836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.array([obj[0] + obj[1] + obj[2] for _, obj in archive]) / sum(obj[0] + obj[1] + obj[2] for _, obj in archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid 2-opt and insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to perform 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to reinsert (insertion heuristic)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment\n    if len(segment) >= 2:\n        k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n        segment[k:l+1] = segment[k:l+1][::-1]\n\n    # Objective-aware swap: find nodes that could improve any objective\n    for _ in range(3):  # Try a few random swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        if a != b:\n            # Calculate potential improvement in all objectives\n            orig_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            )\n            new_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                distance_matrix_3[new_solution[b-1], new_solution[a]]\n            )\n            if new_cost < orig_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6900745738178112,
            1.6439775109291077
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment\n    if len(segment) >= 2:\n        k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n        segment[k:l+1] = segment[k:l+1][::-1]\n\n    # Objective-aware swap: find nodes that could improve any objective\n    for _ in range(3):  # Try a few random swaps\n        a, b = np.random.choice(n, 2, replace=False)\n        if a != b:\n            # Calculate potential improvement in all objectives\n            orig_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                distance_matrix_3[new_solution[b-1], new_solution[b]]\n            )\n            new_cost = (\n                distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                distance_matrix_3[new_solution[b-1], new_solution[a]]\n            )\n            if new_cost < orig_cost:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution is valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains feasibility (no revisits or skips)\n    if i != j and k != l:\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Verify the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5754688871715017,
            1.2035919308662415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains feasibility (no revisits or skips)\n    if i != j and k != l:\n        # Perform the swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Verify the solution remains valid (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select a segment to perturb\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Apply a 2-opt move on the segment\n        if len(segment) > 2:\n            k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n            segment[k:l+1] = segment[k:l+1][::-1]\n\n        # Insert the perturbed segment back into the solution\n        new_solution[i:j+1] = segment\n\n        # Apply edge swap with objective-aware selection\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a != b:\n            # Calculate the change in objectives\n            delta_obj1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                          distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n            delta_obj2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            delta_obj3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                          distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n            # Accept the swap if it improves at least one objective\n            if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6459391970285843,
            2.6166176319122316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select a segment to perturb\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[i:j+1]\n\n        # Apply a 2-opt move on the segment\n        if len(segment) > 2:\n            k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n            segment[k:l+1] = segment[k:l+1][::-1]\n\n        # Insert the perturbed segment back into the solution\n        new_solution[i:j+1] = segment\n\n        # Apply edge swap with objective-aware selection\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if a != b:\n            # Calculate the change in objectives\n            delta_obj1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b], new_solution[(a+1)%n]] -\n                          distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n            delta_obj2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b], new_solution[(a+1)%n]] -\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            delta_obj3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_3[new_solution[b], new_solution[(a+1)%n]] -\n                          distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_3[new_solution[b], new_solution[(b+1)%n]])\n\n            # Accept the swap if it improves at least one objective\n            if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n    new_solution[k:l+1] = selected_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simpler 2-opt if the swap is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6967487227812589,
            0.9170545339584351
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n    new_solution[k:l+1] = selected_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simpler 2-opt if the swap is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n    new_solution[k:l+1] = selected_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simpler 2-opt if the swap is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6967487227812589,
            0.9170545339584351
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n    new_solution[k:l+1] = selected_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simpler 2-opt if the swap is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest combined objective)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    new_solution[i:j] = selected_solution[i:j][::-1]\n    new_solution[k:l] = selected_solution[k:l][::-1]\n\n    # Objective-aware edge swap: swap edges that improve at least one objective\n    for _ in range(5):  # Limit the number of swaps to prevent excessive computation\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        c, d = random.sample(range(n), 2)\n        if c > d:\n            c, d = d, c\n\n        # Calculate current and new distances for all three objectives\n        current_dist1 = (distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_1[selected_solution[b-1], selected_solution[b]])\n        new_dist1 = (distance_matrix_1[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_1[selected_solution[b-1], selected_solution[a]])\n\n        current_dist2 = (distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_2[selected_solution[b-1], selected_solution[b]])\n        new_dist2 = (distance_matrix_2[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_2[selected_solution[b-1], selected_solution[a]])\n\n        current_dist3 = (distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_3[selected_solution[b-1], selected_solution[b]])\n        new_dist3 = (distance_matrix_3[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_3[selected_solution[b-1], selected_solution[a]])\n\n        # If the swap improves at least one objective, perform it\n        if (new_dist1 < current_dist1 or new_dist2 < current_dist2 or new_dist3 < current_dist3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7480137270026155,
            1.0116178274154664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest combined objective)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    new_solution[i:j] = selected_solution[i:j][::-1]\n    new_solution[k:l] = selected_solution[k:l][::-1]\n\n    # Objective-aware edge swap: swap edges that improve at least one objective\n    for _ in range(5):  # Limit the number of swaps to prevent excessive computation\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        c, d = random.sample(range(n), 2)\n        if c > d:\n            c, d = d, c\n\n        # Calculate current and new distances for all three objectives\n        current_dist1 = (distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_1[selected_solution[b-1], selected_solution[b]])\n        new_dist1 = (distance_matrix_1[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_1[selected_solution[b-1], selected_solution[a]])\n\n        current_dist2 = (distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_2[selected_solution[b-1], selected_solution[b]])\n        new_dist2 = (distance_matrix_2[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_2[selected_solution[b-1], selected_solution[a]])\n\n        current_dist3 = (distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_3[selected_solution[b-1], selected_solution[b]])\n        new_dist3 = (distance_matrix_3[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_3[selected_solution[b-1], selected_solution[a]])\n\n        # If the swap improves at least one objective, perform it\n        if (new_dist1 < current_dist1 or new_dist2 < current_dist2 or new_dist3 < current_dist3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest combined objective)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    new_solution[i:j] = selected_solution[i:j][::-1]\n    new_solution[k:l] = selected_solution[k:l][::-1]\n\n    # Objective-aware edge swap: swap edges that improve at least one objective\n    for _ in range(5):  # Limit the number of swaps to prevent excessive computation\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        c, d = random.sample(range(n), 2)\n        if c > d:\n            c, d = d, c\n\n        # Calculate current and new distances for all three objectives\n        current_dist1 = (distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_1[selected_solution[b-1], selected_solution[b]])\n        new_dist1 = (distance_matrix_1[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_1[selected_solution[b-1], selected_solution[a]])\n\n        current_dist2 = (distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_2[selected_solution[b-1], selected_solution[b]])\n        new_dist2 = (distance_matrix_2[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_2[selected_solution[b-1], selected_solution[a]])\n\n        current_dist3 = (distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_3[selected_solution[b-1], selected_solution[b]])\n        new_dist3 = (distance_matrix_3[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_3[selected_solution[b-1], selected_solution[a]])\n\n        # If the swap improves at least one objective, perform it\n        if (new_dist1 < current_dist1 or new_dist2 < current_dist2 or new_dist3 < current_dist3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7480137270026155,
            1.0116178274154664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest combined objective)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt move\n    new_solution[i:j] = selected_solution[i:j][::-1]\n    new_solution[k:l] = selected_solution[k:l][::-1]\n\n    # Objective-aware edge swap: swap edges that improve at least one objective\n    for _ in range(5):  # Limit the number of swaps to prevent excessive computation\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        c, d = random.sample(range(n), 2)\n        if c > d:\n            c, d = d, c\n\n        # Calculate current and new distances for all three objectives\n        current_dist1 = (distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_1[selected_solution[b-1], selected_solution[b]])\n        new_dist1 = (distance_matrix_1[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_1[selected_solution[b-1], selected_solution[a]])\n\n        current_dist2 = (distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_2[selected_solution[b-1], selected_solution[b]])\n        new_dist2 = (distance_matrix_2[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_2[selected_solution[b-1], selected_solution[a]])\n\n        current_dist3 = (distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n                         distance_matrix_3[selected_solution[b-1], selected_solution[b]])\n        new_dist3 = (distance_matrix_3[selected_solution[a-1], selected_solution[b]] +\n                     distance_matrix_3[selected_solution[b-1], selected_solution[a]])\n\n        # If the swap improves at least one objective, perform it\n        if (new_dist1 < current_dist1 or new_dist2 < current_dist2 or new_dist3 < current_dist3):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt-like move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Insert a random node into a random position (node insertion)\n    k = np.random.randint(0, n)\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.6905104259089744,
            1.557234787940979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt-like move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Insert a random node into a random position (node insertion)\n    k = np.random.randint(0, n)\n    node_to_insert = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, l, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator combining 2-opt, relocate, and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Relocate move\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Objective-aware swap: swap nodes with high distance in at least one objective space\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n        d1 = distance_matrix_1[node_a, node_b]\n        d2 = distance_matrix_2[node_a, node_b]\n        d3 = distance_matrix_3[node_a, node_b]\n\n        if max(d1, d2, d3) > np.median([distance_matrix_1[node_a, node_b] for node_b in new_solution]):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7482790478714849,
            1.643791878223419
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator combining 2-opt, relocate, and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Relocate move\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Objective-aware swap: swap nodes with high distance in at least one objective space\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n        d1 = distance_matrix_1[node_a, node_b]\n        d2 = distance_matrix_2[node_a, node_b]\n        d3 = distance_matrix_3[node_a, node_b]\n\n        if max(d1, d2, d3) > np.median([distance_matrix_1[node_a, node_b] for node_b in new_solution]):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator combining 2-opt, relocate, and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Relocate move\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Objective-aware swap: swap nodes with high distance in at least one objective space\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n        d1 = distance_matrix_1[node_a, node_b]\n        d2 = distance_matrix_2[node_a, node_b]\n        d3 = distance_matrix_3[node_a, node_b]\n\n        if max(d1, d2, d3) > np.median([distance_matrix_1[node_a, node_b] for node_b in new_solution]):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7482790478714849,
            1.643791878223419
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator combining 2-opt, relocate, and objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.randint(0, n)\n\n    # 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Relocate move\n    node = new_solution[k]\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:], [node]])\n\n    # Objective-aware swap: swap nodes with high distance in at least one objective space\n    for _ in range(2):\n        a, b = np.random.choice(n, 2, replace=False)\n        node_a, node_b = new_solution[a], new_solution[b]\n        d1 = distance_matrix_1[node_a, node_b]\n        d2 = distance_matrix_2[node_a, node_b]\n        d3 = distance_matrix_3[node_a, node_b]\n\n        if max(d1, d2, d3) > np.median([distance_matrix_1[node_a, node_b] for node_b in new_solution]):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive, applies a hybrid local search combining 2-opt and multi-objective edge exchange, and ensures feasibility by validating the tour structure while optimizing across three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue  # Skip adjacent nodes to ensure meaningful exchange\n\n        # Evaluate the current and potential new edges\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n\n        # Propose a new tour by reversing the segment between i and j\n        proposed_solution = new_solution.copy()\n        proposed_solution[i:j+1] = proposed_solution[i:j+1][::-1]\n\n        # Evaluate the new edges\n        new_edges = [\n            (proposed_solution[i-1], proposed_solution[i]),\n            (proposed_solution[j], proposed_solution[(j+1)%n]),\n            (proposed_solution[i], proposed_solution[(i+1)%n]),\n            (proposed_solution[j-1], proposed_solution[j])\n        ]\n\n        # Calculate the change in objectives\n        delta_obj1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in current_edges)\n        delta_obj2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in current_edges)\n        delta_obj3 = sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in current_edges)\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0:\n            new_solution = proposed_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7887805866404365,
            1.5008943319320678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue  # Skip adjacent nodes to ensure meaningful exchange\n\n        # Evaluate the current and potential new edges\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n\n        # Propose a new tour by reversing the segment between i and j\n        proposed_solution = new_solution.copy()\n        proposed_solution[i:j+1] = proposed_solution[i:j+1][::-1]\n\n        # Evaluate the new edges\n        new_edges = [\n            (proposed_solution[i-1], proposed_solution[i]),\n            (proposed_solution[j], proposed_solution[(j+1)%n]),\n            (proposed_solution[i], proposed_solution[(i+1)%n]),\n            (proposed_solution[j-1], proposed_solution[j])\n        ]\n\n        # Calculate the change in objectives\n        delta_obj1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in current_edges)\n        delta_obj2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in current_edges)\n        delta_obj3 = sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in current_edges)\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0:\n            new_solution = proposed_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This algorithm intelligently selects a high-potential solution from the archive, applies a hybrid local search combining 2-opt and multi-objective edge exchange, and ensures feasibility by validating the tour structure while optimizing across three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue  # Skip adjacent nodes to ensure meaningful exchange\n\n        # Evaluate the current and potential new edges\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n\n        # Propose a new tour by reversing the segment between i and j\n        proposed_solution = new_solution.copy()\n        proposed_solution[i:j+1] = proposed_solution[i:j+1][::-1]\n\n        # Evaluate the new edges\n        new_edges = [\n            (proposed_solution[i-1], proposed_solution[i]),\n            (proposed_solution[j], proposed_solution[(j+1)%n]),\n            (proposed_solution[i], proposed_solution[(i+1)%n]),\n            (proposed_solution[j-1], proposed_solution[j])\n        ]\n\n        # Calculate the change in objectives\n        delta_obj1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in current_edges)\n        delta_obj2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in current_edges)\n        delta_obj3 = sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in current_edges)\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0:\n            new_solution = proposed_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7887805866404365,
            1.5008943319320678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution from the archive (intelligent random selection)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i == 1:\n            continue  # Skip adjacent nodes to ensure meaningful exchange\n\n        # Evaluate the current and potential new edges\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n\n        # Propose a new tour by reversing the segment between i and j\n        proposed_solution = new_solution.copy()\n        proposed_solution[i:j+1] = proposed_solution[i:j+1][::-1]\n\n        # Evaluate the new edges\n        new_edges = [\n            (proposed_solution[i-1], proposed_solution[i]),\n            (proposed_solution[j], proposed_solution[(j+1)%n]),\n            (proposed_solution[i], proposed_solution[(i+1)%n]),\n            (proposed_solution[j-1], proposed_solution[j])\n        ]\n\n        # Calculate the change in objectives\n        delta_obj1 = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in current_edges)\n        delta_obj2 = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in current_edges)\n        delta_obj3 = sum(distance_matrix_3[a][b] for a, b in new_edges) - sum(distance_matrix_3[a][b] for a, b in current_edges)\n\n        # Accept the move if it improves at least one objective\n        if delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0:\n            new_solution = proposed_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search strategy intelligently selects a parent solution from the archive based on objective diversity and dominance, then applies a combination of 2-opt and segment reversal operators to explore diverse neighborhoods while maintaining feasibility, ultimately generating high-quality multi-objective TSP solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a parent solution with high potential for improvement\n    parent_solution, parent_objectives = archive[np.random.randint(len(archive))]\n\n    # Copy the parent solution to create a new solution\n    new_solution = parent_solution.copy()\n\n    # Determine the objective with the highest potential for improvement\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    normalized_avg = avg_objectives / np.sum(avg_objectives)\n\n    # Choose the objective to focus on for local search\n    obj_idx = np.random.choice(3, p=normalized_avg / np.sum(normalized_avg))\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal for the chosen objective\n    if obj_idx == 0:\n        # Focus on distance_matrix_1\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n    elif obj_idx == 1:\n        # Focus on distance_matrix_2\n        m, n = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m:n+1] = new_solution[m:n+1][::-1]\n    else:\n        # Focus on distance_matrix_3\n        p, q = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[p:q+1] = new_solution[p:q+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7912683600487025,
            1.7339365482330322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a parent solution with high potential for improvement\n    parent_solution, parent_objectives = archive[np.random.randint(len(archive))]\n\n    # Copy the parent solution to create a new solution\n    new_solution = parent_solution.copy()\n\n    # Determine the objective with the highest potential for improvement\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    normalized_avg = avg_objectives / np.sum(avg_objectives)\n\n    # Choose the objective to focus on for local search\n    obj_idx = np.random.choice(3, p=normalized_avg / np.sum(normalized_avg))\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal for the chosen objective\n    if obj_idx == 0:\n        # Focus on distance_matrix_1\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n    elif obj_idx == 1:\n        # Focus on distance_matrix_2\n        m, n = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m:n+1] = new_solution[m:n+1][::-1]\n    else:\n        # Focus on distance_matrix_3\n        p, q = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[p:q+1] = new_solution[p:q+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search strategy intelligently selects a parent solution from the archive based on objective diversity and dominance, then applies a combination of 2-opt and segment reversal operators to explore diverse neighborhoods while maintaining feasibility, ultimately generating high-quality multi-objective TSP solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a parent solution with high potential for improvement\n    parent_solution, parent_objectives = archive[np.random.randint(len(archive))]\n\n    # Copy the parent solution to create a new solution\n    new_solution = parent_solution.copy()\n\n    # Determine the objective with the highest potential for improvement\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    normalized_avg = avg_objectives / np.sum(avg_objectives)\n\n    # Choose the objective to focus on for local search\n    obj_idx = np.random.choice(3, p=normalized_avg / np.sum(normalized_avg))\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal for the chosen objective\n    if obj_idx == 0:\n        # Focus on distance_matrix_1\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n    elif obj_idx == 1:\n        # Focus on distance_matrix_2\n        m, n = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m:n+1] = new_solution[m:n+1][::-1]\n    else:\n        # Focus on distance_matrix_3\n        p, q = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[p:q+1] = new_solution[p:q+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7912683600487025,
            1.7339365482330322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a parent solution with high potential for improvement\n    parent_solution, parent_objectives = archive[np.random.randint(len(archive))]\n\n    # Copy the parent solution to create a new solution\n    new_solution = parent_solution.copy()\n\n    # Determine the objective with the highest potential for improvement\n    objectives = [obj for _, obj in archive]\n    avg_objectives = np.mean(objectives, axis=0)\n    normalized_avg = avg_objectives / np.sum(avg_objectives)\n\n    # Choose the objective to focus on for local search\n    obj_idx = np.random.choice(3, p=normalized_avg / np.sum(normalized_avg))\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply segment reversal for the chosen objective\n    if obj_idx == 0:\n        # Focus on distance_matrix_1\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n    elif obj_idx == 1:\n        # Focus on distance_matrix_2\n        m, n = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[m:n+1] = new_solution[m:n+1][::-1]\n    else:\n        # Focus on distance_matrix_3\n        p, q = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[p:q+1] = new_solution[p:q+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest diversity in objectives to explore promising regions\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance in the archive\n    obj_variances = [np.var([obj[i] for _, obj in archive]) for i in range(3)]\n    obj_to_optimize = np.argmax(obj_variances)\n\n    # Select two random edges and reverse the segment between them (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware swaps: swap nodes that improve the worst objective\n    for _ in range(5):  # Limit swaps to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objectives\n        def calculate_objective(sol, dist_matrix):\n            return sum(dist_matrix[sol[k], sol[(k+1)%n]] for k in range(n))\n\n        new_obj1 = calculate_objective(temp_solution, distance_matrix_1)\n        new_obj2 = calculate_objective(temp_solution, distance_matrix_2)\n        new_obj3 = calculate_objective(temp_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_obj1 < archive[selected_idx][1][0] or\n            new_obj2 < archive[selected_idx][1][1] or\n            new_obj3 < archive[selected_idx][1][2]):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6706204917326042,
            2.40852632522583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest diversity in objectives to explore promising regions\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance in the archive\n    obj_variances = [np.var([obj[i] for _, obj in archive]) for i in range(3)]\n    obj_to_optimize = np.argmax(obj_variances)\n\n    # Select two random edges and reverse the segment between them (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware swaps: swap nodes that improve the worst objective\n    for _ in range(5):  # Limit swaps to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objectives\n        def calculate_objective(sol, dist_matrix):\n            return sum(dist_matrix[sol[k], sol[(k+1)%n]] for k in range(n))\n\n        new_obj1 = calculate_objective(temp_solution, distance_matrix_1)\n        new_obj2 = calculate_objective(temp_solution, distance_matrix_2)\n        new_obj3 = calculate_objective(temp_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_obj1 < archive[selected_idx][1][0] or\n            new_obj2 < archive[selected_idx][1][1] or\n            new_obj3 < archive[selected_idx][1][2]):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        normalized_objectives.append((sol, obj, sum(norm_obj)))\n\n    # Select the solution with the lowest normalized total cost\n    selected_sol = min(normalized_objectives, key=lambda x: x[2])[0]\n    new_solution = selected_sol.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Choose two random segments and reverse one of them to create a new neighbor\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, 1)\n\n    if k == 0:\n        # Reverse a segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap two nodes\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6328752745060102,
            3.5842042922973634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        normalized_objectives.append((sol, obj, sum(norm_obj)))\n\n    # Select the solution with the lowest normalized total cost\n    selected_sol = min(normalized_objectives, key=lambda x: x[2])[0]\n    new_solution = selected_sol.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Choose two random segments and reverse one of them to create a new neighbor\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, 1)\n\n    if k == 0:\n        # Reverse a segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Swap two nodes\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the variance of each objective across the archive\n        variance = np.var(objectives, axis=0)\n        # Select the solution with the highest variance in any objective\n        selected_idx = np.argmax(np.max(variance))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select two distinct edges to perform 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Perform 2-opt swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Randomly select a node to reinsert elsewhere\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        # Remove the node\n        new_solution = np.delete(new_solution, k)\n        # Insert it at a new random position\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6777990332488095,
            3.1694665789604186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Calculate the variance of each objective across the archive\n        variance = np.var(objectives, axis=0)\n        # Select the solution with the highest variance in any objective\n        selected_idx = np.argmax(np.max(variance))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Randomly select two distinct edges to perform 2-opt\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Perform 2-opt swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Randomly select a node to reinsert elsewhere\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        # Remove the node\n        new_solution = np.delete(new_solution, k)\n        # Insert it at a new random position\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest current cost\n    obj_costs = selected[1]\n    worst_obj = np.argmax(obj_costs)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        if dist_matrix[u, v] > max_dist:\n            max_dist = dist_matrix[u, v]\n            worst_edge = i\n    if worst_edge is not None:\n        # Try to improve by reversing the segment between worst_edge and a random point\n        k = np.random.randint(worst_edge + 1, n)\n        new_solution[worst_edge:k] = new_solution[worst_edge:k][::-1]\n\n    # Perform an objective-aware swap to balance objectives\n    if np.random.random() < 0.3:  # 30% chance of swap\n        i, j = np.random.choice(n, 2, replace=False)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.6794788166653998,
            2.2351834177970886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with the lowest sum of objectives (promising for improvement)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest current cost\n    obj_costs = selected[1]\n    worst_obj = np.argmax(obj_costs)\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst edge in the selected objective\n    worst_edge = None\n    max_dist = -1\n    for i in range(n-1):\n        u, v = new_solution[i], new_solution[i+1]\n        if dist_matrix[u, v] > max_dist:\n            max_dist = dist_matrix[u, v]\n            worst_edge = i\n    if worst_edge is not None:\n        # Try to improve by reversing the segment between worst_edge and a random point\n        k = np.random.randint(worst_edge + 1, n)\n        new_solution[worst_edge:k] = new_solution[worst_edge:k][::-1]\n\n    # Perform an objective-aware swap to balance objectives\n    if np.random.random() < 0.3:  # 30% chance of swap\n        i, j = np.random.choice(n, 2, replace=False)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = archive[np.random.choice(len(archive))]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and insertion moves\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Apply 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply insertion move\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7813273680449921,
            1.2506174921989441
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = archive[np.random.choice(len(archive))]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and insertion moves\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Apply 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply insertion move\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to find the least dominated solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% of solutions and pick a random one\n        selected_idx = random.randint(0, max(0, int(len(archive_sorted) * 0.3) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid 3-objective local search\n    # Choose between three specialized operators based on objective dominance\n    operator_choice = random.choice(['2opt', 'swap', 'reverse'])\n\n    if operator_choice == '2opt':\n        # 2-opt for the objective with the highest current cost\n        # Calculate current objectives\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n\n        # Determine which objective to prioritize\n        if obj1 >= max(obj1, obj2, obj3):\n            # Apply 2-opt on distance_matrix_1\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif obj2 >= max(obj1, obj2, obj3):\n            # Apply 2-opt on distance_matrix_2\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Apply 2-opt on distance_matrix_3\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator_choice == 'swap':\n        # Random swap with bias toward improving the worst objective\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n\n        # Determine which objective to prioritize\n        if obj1 >= max(obj1, obj2, obj3):\n            # Find the worst edge in distance_matrix_1 and try to improve it\n            max_dist = -1\n            max_idx = -1\n            for i in range(len(new_solution)):\n                dist = distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_idx = i\n            # Swap with a random neighbor\n            neighbor = random.choice([(max_idx-1)%len(new_solution), (max_idx+1)%len(new_solution)])\n            new_solution[max_idx], new_solution[neighbor] = new_solution[neighbor], new_solution[max_idx]\n        elif obj2 >= max(obj1, obj2, obj3):\n            # Find the worst edge in distance_matrix_2 and try to improve it\n            max_dist = -1\n            max_idx = -1\n            for i in range(len(new_solution)):\n                dist = distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_idx = i\n            # Swap with a random neighbor\n            neighbor = random.choice([(max_idx-1)%len(new_solution), (max_idx+1)%len(new_solution)])\n            new_solution[max_idx], new_solution[neighbor] = new_solution[neighbor], new_solution[max_idx]\n        else:\n            # Find the worst edge in distance_matrix_3 and try to improve it\n            max_dist = -1\n            max_idx = -1\n            for i in range(len(new_solution)):\n                dist = distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_idx = i\n            # Swap with a random neighbor\n            neighbor = random.choice([(max_idx-1)%len(new_solution), (max_idx+1)%len(new_solution)])\n            new_solution[max_idx], new_solution[neighbor] = new_solution[neighbor], new_solution[max_idx]\n\n    elif operator_choice == 'reverse':\n        # Reverse a segment with consideration for all objectives\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        # Calculate the change in objectives\n        old_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        old_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        old_obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n\n        # Revert if no improvement in any objective\n        if (new_obj1 >= old_obj1 and new_obj2 >= old_obj2 and new_obj3 >= old_obj3):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6736711605028872,
            2.0657944321632384
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to find the least dominated solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% of solutions and pick a random one\n        selected_idx = random.randint(0, max(0, int(len(archive_sorted) * 0.3) - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid 3-objective local search\n    # Choose between three specialized operators based on objective dominance\n    operator_choice = random.choice(['2opt', 'swap', 'reverse'])\n\n    if operator_choice == '2opt':\n        # 2-opt for the objective with the highest current cost\n        # Calculate current objectives\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n\n        # Determine which objective to prioritize\n        if obj1 >= max(obj1, obj2, obj3):\n            # Apply 2-opt on distance_matrix_1\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif obj2 >= max(obj1, obj2, obj3):\n            # Apply 2-opt on distance_matrix_2\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Apply 2-opt on distance_matrix_3\n            i, j = sorted(random.sample(range(len(new_solution)), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator_choice == 'swap':\n        # Random swap with bias toward improving the worst objective\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]] for i in range(len(new_solution)))\n\n        # Determine which objective to prioritize\n        if obj1 >= max(obj1, obj2, obj3):\n            # Find the worst edge in distance_matrix_1 and try to improve it\n            max_dist = -1\n            max_idx = -1\n            for i in range(len(new_solution)):\n                dist = distance_matrix_1[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_idx = i\n            # Swap with a random neighbor\n            neighbor = random.choice([(max_idx-1)%len(new_solution), (max_idx+1)%len(new_solution)])\n            new_solution[max_idx], new_solution[neighbor] = new_solution[neighbor], new_solution[max_idx]\n        elif obj2 >= max(obj1, obj2, obj3):\n            # Find the worst edge in distance_matrix_2 and try to improve it\n            max_dist = -1\n            max_idx = -1\n            for i in range(len(new_solution)):\n                dist = distance_matrix_2[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_idx = i\n            # Swap with a random neighbor\n            neighbor = random.choice([(max_idx-1)%len(new_solution), (max_idx+1)%len(new_solution)])\n            new_solution[max_idx], new_solution[neighbor] = new_solution[neighbor], new_solution[max_idx]\n        else:\n            # Find the worst edge in distance_matrix_3 and try to improve it\n            max_dist = -1\n            max_idx = -1\n            for i in range(len(new_solution)):\n                dist = distance_matrix_3[new_solution[i], new_solution[(i+1)%len(new_solution)]]\n                if dist > max_dist:\n                    max_dist = dist\n                    max_idx = i\n            # Swap with a random neighbor\n            neighbor = random.choice([(max_idx-1)%len(new_solution), (max_idx+1)%len(new_solution)])\n            new_solution[max_idx], new_solution[neighbor] = new_solution[neighbor], new_solution[max_idx]\n\n    elif operator_choice == 'reverse':\n        # Reverse a segment with consideration for all objectives\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        # Calculate the change in objectives\n        old_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        old_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        old_obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        new_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        new_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n        new_obj3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%len(new_solution)]]\n\n        # Revert if no improvement in any objective\n        if (new_obj1 >= old_obj1 and new_obj2 >= old_obj2 and new_obj3 >= old_obj3):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives to explore diverse regions\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variances, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge replacement\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i <= 1:\n            continue\n\n        # Evaluate the current and reversed segment in all three objectives\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        reversed_edges = [\n            (new_solution[i-1], new_solution[j-1]),\n            (new_solution[i], new_solution[j])\n        ]\n\n        current_cost = sum([\n            distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]]\n            for e in current_edges\n        ])\n        reversed_cost = sum([\n            distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]]\n            for e in reversed_edges\n        ])\n\n        if reversed_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge replacement\n        if np.random.rand() < 0.3:  # Probability to try edge replacement\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k == l or (k == i and l == j) or (k == j and l == i):\n                continue\n\n            # Calculate potential improvement across all objectives\n            old_edges = [\n                (new_solution[k-1], new_solution[k]),\n                (new_solution[l-1], new_solution[l])\n            ]\n            new_edges = [\n                (new_solution[k-1], new_solution[l]),\n                (new_solution[k], new_solution[l-1])\n            ]\n\n            old_cost = sum([\n                distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]]\n                for e in old_edges\n            ])\n            new_cost = sum([\n                distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]]\n                for e in new_edges\n            ])\n\n            if new_cost < old_cost:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6927310814019578,
            2.6092878341674806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high variance in objectives to explore diverse regions\n    objectives = np.array([obj for _, obj in archive])\n    objective_variances = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variances, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt with objective-aware edge replacement\n    for _ in range(10):  # Limit iterations to balance exploration and computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i <= 1:\n            continue\n\n        # Evaluate the current and reversed segment in all three objectives\n        current_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        reversed_edges = [\n            (new_solution[i-1], new_solution[j-1]),\n            (new_solution[i], new_solution[j])\n        ]\n\n        current_cost = sum([\n            distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]]\n            for e in current_edges\n        ])\n        reversed_cost = sum([\n            distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]]\n            for e in reversed_edges\n        ])\n\n        if reversed_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge replacement\n        if np.random.rand() < 0.3:  # Probability to try edge replacement\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            if k == l or (k == i and l == j) or (k == j and l == i):\n                continue\n\n            # Calculate potential improvement across all objectives\n            old_edges = [\n                (new_solution[k-1], new_solution[k]),\n                (new_solution[l-1], new_solution[l])\n            ]\n            new_edges = [\n                (new_solution[k-1], new_solution[l]),\n                (new_solution[k], new_solution[l-1])\n            ]\n\n            old_cost = sum([\n                distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]]\n                for e in old_edges\n            ])\n            new_cost = sum([\n                distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] + distance_matrix_3[e[0], e[1]]\n                for e in new_edges\n            ])\n\n            if new_cost < old_cost:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective selection criteria with a tailored 3D edge-swap operator to generate high-quality neighbors by intelligently balancing improvements across all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3D edge-swap operator\n    for _ in range(5):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Ensure valid edges and no node repetition\n        if (i != j) and (k != l) and (i != k) and (j != l):\n            # Calculate objective improvements\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[j-1], new_solution[l]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[j-1], new_solution[l]]\n\n            old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[k]] + distance_matrix_3[new_solution[j-1], new_solution[l]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7286470692301722,
            0.4659803628921509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3D edge-swap operator\n    for _ in range(5):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Ensure valid edges and no node repetition\n        if (i != j) and (k != l) and (i != k) and (j != l):\n            # Calculate objective improvements\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[j-1], new_solution[l]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[j-1], new_solution[l]]\n\n            old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[k]] + distance_matrix_3[new_solution[j-1], new_solution[l]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective selection criteria with a tailored 3D edge-swap operator to generate high-quality neighbors by intelligently balancing improvements across all three objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3D edge-swap operator\n    for _ in range(5):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Ensure valid edges and no node repetition\n        if (i != j) and (k != l) and (i != k) and (j != l):\n            # Calculate objective improvements\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[j-1], new_solution[l]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[j-1], new_solution[l]]\n\n            old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[k]] + distance_matrix_3[new_solution[j-1], new_solution[l]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.7286470692301722,
            0.4659803628921509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(10, len(archive_sorted) - 1)  # Select from top 10 or all if archive is small\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid 3D edge-swap operator\n    for _ in range(5):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Ensure valid edges and no node repetition\n        if (i != j) and (k != l) and (i != k) and (j != l):\n            # Calculate objective improvements\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[k]] + distance_matrix_1[new_solution[j-1], new_solution[l]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[k]] + distance_matrix_2[new_solution[j-1], new_solution[l]]\n\n            old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n            new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[k]] + distance_matrix_3[new_solution[j-1], new_solution[l]]\n\n            # Accept if at least one objective improves\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2) or (new_cost3 < old_cost3):\n                # Perform the swap\n                new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    base_solution = selected[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt with a multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform a 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    new_obj = calculate_objective(new_solution)\n    old_obj = selected[1]\n\n    # If the new solution is not dominated by the old one, accept it\n    if not all(no >= oo for no, oo in zip(new_obj, old_obj)):\n        return new_solution\n\n    # Otherwise, try a multi-objective aware edge swap\n    # Find the worst objective in the current solution\n    worst_obj_idx = np.argmax(old_obj)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_idx]\n\n    # Find the edge with the highest cost in the worst objective\n    max_cost = -1\n    max_i = 0\n    for k in range(n-1):\n        cost = distance_matrix[new_solution[k], new_solution[k+1]]\n        if cost > max_cost:\n            max_cost = cost\n            max_i = k\n    cost = distance_matrix[new_solution[-1], new_solution[0]]\n    if cost > max_cost:\n        max_i = n-1\n\n    # Swap the nodes connected by this edge\n    if max_i == n-1:\n        new_solution[0], new_solution[-1] = new_solution[-1], new_solution[0]\n    else:\n        new_solution[max_i], new_solution[max_i+1] = new_solution[max_i+1], new_solution[max_i]\n\n    return new_solution\n\n",
        "score": [
            -0.7428254300234911,
            1.945095384120941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]) / len(x[1]))\n    base_solution = selected[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt with a multi-objective aware edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform a 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    new_obj = calculate_objective(new_solution)\n    old_obj = selected[1]\n\n    # If the new solution is not dominated by the old one, accept it\n    if not all(no >= oo for no, oo in zip(new_obj, old_obj)):\n        return new_solution\n\n    # Otherwise, try a multi-objective aware edge swap\n    # Find the worst objective in the current solution\n    worst_obj_idx = np.argmax(old_obj)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_idx]\n\n    # Find the edge with the highest cost in the worst objective\n    max_cost = -1\n    max_i = 0\n    for k in range(n-1):\n        cost = distance_matrix[new_solution[k], new_solution[k+1]]\n        if cost > max_cost:\n            max_cost = cost\n            max_i = k\n    cost = distance_matrix[new_solution[-1], new_solution[0]]\n    if cost > max_cost:\n        max_i = n-1\n\n    # Swap the nodes connected by this edge\n    if max_i == n-1:\n        new_solution[0], new_solution[-1] = new_solution[-1], new_solution[0]\n    else:\n        new_solution[max_i], new_solution[max_i+1] = new_solution[max_i+1], new_solution[max_i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objective_variance * objectives, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-objective local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to break (ensuring no duplicates)\n    edges = np.random.choice(n, size=3, replace=False)\n    edges.sort()\n\n    # Perform 3-opt move while considering all three objectives\n    i, j, k = edges\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Evaluate all possible connections in the 3-opt move\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n    ]\n\n    # Evaluate each candidate based on the sum of normalized objective improvements\n    base_costs = archive[selected_idx][1]\n    best_candidate = None\n    best_score = -np.inf\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Normalize improvements (higher is better)\n        improvement = (\n            (base_costs[0] - cost1) / base_costs[0] +\n            (base_costs[1] - cost2) / base_costs[1] +\n            (base_costs[2] - cost3) / base_costs[2]\n        )\n\n        if improvement > best_score:\n            best_score = improvement\n            best_candidate = candidate.copy()\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7174113828209006,
            2.87968133687973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objective_variance * objectives, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a multi-objective local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to break (ensuring no duplicates)\n    edges = np.random.choice(n, size=3, replace=False)\n    edges.sort()\n\n    # Perform 3-opt move while considering all three objectives\n    i, j, k = edges\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Evaluate all possible connections in the 3-opt move\n    candidates = [\n        np.concatenate([segment1, segment2, segment3, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n    ]\n\n    # Evaluate each candidate based on the sum of normalized objective improvements\n    base_costs = archive[selected_idx][1]\n    best_candidate = None\n    best_score = -np.inf\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Normalize improvements (higher is better)\n        improvement = (\n            (base_costs[0] - cost1) / base_costs[0] +\n            (base_costs[1] - cost2) / base_costs[1] +\n            (base_costs[2] - cost3) / base_costs[2]\n        )\n\n        if improvement > best_score:\n            best_score = improvement\n            best_candidate = candidate.copy()\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j to form a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution is invalid\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6281729371544021,
            1.4065591096878052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j to form a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (visits each node exactly once)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution is invalid\n        new_solution = base_solution.copy()\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Optionally, insert a randomly selected node at a new position (node insertion)\n    if np.random.rand() < 0.3:\n        k = np.random.randint(n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    assert len(np.unique(new_solution)) == n, \"Invalid neighbor solution (duplicate nodes)\"\n    assert set(new_solution) == set(base_solution), \"Invalid neighbor solution (missing nodes)\"\n\n    return new_solution\n\n",
        "score": [
            -0.7330639596745889,
            1.5852813839912414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n    new_solution[i:j+1] = reversed_segment\n\n    # Optionally, insert a randomly selected node at a new position (node insertion)\n    if np.random.rand() < 0.3:\n        k = np.random.randint(n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = np.random.randint(n-1)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility by checking for duplicates and missing nodes\n    assert len(np.unique(new_solution)) == n, \"Invalid neighbor solution (duplicate nodes)\"\n    assert set(new_solution) == set(base_solution), \"Invalid neighbor solution (missing nodes)\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest sum of objectives (best overall)\n    best_idx = np.argmin(objective_sums)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and 3-opt moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt move if the segment is small\n    if j - i <= 2:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply 3-opt move for larger segments\n        k = random.randint(i, j)\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n        new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n    # Ensure the solution remains feasible and valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If the solution is invalid, revert to the original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6961953704698837,
            1.7117797017097474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest sum of objectives (best overall)\n    best_idx = np.argmin(objective_sums)\n    base_solution = archive_solutions[best_idx].copy()\n\n    # Hybrid local search: apply a combination of 2-opt and 3-opt moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt move if the segment is small\n    if j - i <= 2:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply 3-opt move for larger segments\n        k = random.randint(i, j)\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n        new_solution[k:j+1] = new_solution[k:j+1][::-1]\n\n    # Ensure the solution remains feasible and valid\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If the solution is invalid, revert to the original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and segment reversal with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (ensuring feasibility)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply 2-opt if the segment reversal doesn't improve all objectives\n    if np.random.rand() < 0.5:  # 50% chance to try 2-opt\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.6674930844002945,
            1.6786326885223388
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and segment reversal with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (ensuring feasibility)\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply 2-opt if the segment reversal doesn't improve all objectives\n    if np.random.rand() < 0.5:  # 50% chance to try 2-opt\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array([(o1, o2, o3) for o1, o2, o3 in objectives])\n    normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0))\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges whose removal and reconnection improves at least one objective\n    improved = False\n    for _ in range(100):  # Limit iterations to avoid long computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential new objectives\n        current_obj = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # Propose a 2-opt move\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        new_obj = [\n            sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_o < curr_o for new_o, curr_o in zip(new_obj, current_obj)):\n            new_solution = candidate\n            improved = True\n            break\n\n    # If no improvement found, perform a random 2-opt move\n    if not improved:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7580331288671995,
            1.513402020931244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array([(o1, o2, o3) for o1, o2, o3 in objectives])\n    normalized_objectives = (normalized_objectives - normalized_objectives.min(axis=0)) / (normalized_objectives.max(axis=0) - normalized_objectives.min(axis=0))\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges whose removal and reconnection improves at least one objective\n    improved = False\n    for _ in range(100):  # Limit iterations to avoid long computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential new objectives\n        current_obj = [\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        ]\n\n        # Propose a 2-opt move\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        new_obj = [\n            sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        ]\n\n        # Accept if at least one objective improves\n        if any(new_o < curr_o for new_o, curr_o in zip(new_obj, current_obj)):\n            new_solution = candidate\n            improved = True\n            break\n\n    # If no improvement found, perform a random 2-opt move\n    if not improved:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solutions = sorted(archive, key=lambda x: sum(x[1]))[-max(1, len(archive) // 3):]\n    base_solution, _ = random.choice(selected_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, 2)  # Randomly select one of the three objectives\n\n    # Evaluate edge swaps considering the selected objective\n    def evaluate_swap(a, b, c, d):\n        original_cost = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n        new_cost = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n        return new_cost - original_cost if k == 0 else 0\n\n    # Perform the swap if it improves the selected objective\n    if evaluate_swap(new_solution[i-1], new_solution[i], new_solution[j-1], new_solution[j]) < 0:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional 2-opt for other objectives (if time allows)\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] > \\\n           distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6554009252534081,
            1.3997422456741333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solutions = sorted(archive, key=lambda x: sum(x[1]))[-max(1, len(archive) // 3):]\n    base_solution, _ = random.choice(selected_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, 2)  # Randomly select one of the three objectives\n\n    # Evaluate edge swaps considering the selected objective\n    def evaluate_swap(a, b, c, d):\n        original_cost = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n        new_cost = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n        return new_cost - original_cost if k == 0 else 0\n\n    # Perform the swap if it improves the selected objective\n    if evaluate_swap(new_solution[i-1], new_solution[i], new_solution[j-1], new_solution[j]) < 0:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Additional 2-opt for other objectives (if time allows)\n    for _ in range(2):\n        a, b = sorted(random.sample(range(n), 2))\n        if distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] > \\\n           distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its objective diversity and applies a hybrid local search combining 2-opt, 3-opt, and a novel multi-objective edge exchange operator to generate a neighbor solution while ensuring feasibility and potential for multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective differences to identify diverse solutions\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    if random.random() < 0.5:\n        # 2-opt or 3-opt move\n        if random.random() < 0.5:\n            # 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # 3-opt\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    else:\n        # Multi-objective edge exchange\n        # Select edges from different objectives\n        obj1_edges = []\n        obj2_edges = []\n        obj3_edges = []\n\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            obj1_edges.append(distance_matrix_1[u, v])\n            obj2_edges.append(distance_matrix_2[u, v])\n            obj3_edges.append(distance_matrix_3[u, v])\n\n        # Find edges with high potential for improvement\n        obj1_threshold = np.percentile(obj1_edges, 75)\n        obj2_threshold = np.percentile(obj2_edges, 75)\n        obj3_threshold = np.percentile(obj3_edges, 75)\n\n        candidates = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            if (distance_matrix_1[u, v] > obj1_threshold or\n                distance_matrix_2[u, v] > obj2_threshold or\n                distance_matrix_3[u, v] > obj3_threshold):\n                candidates.append(i)\n\n        if candidates:\n            # Perform edge exchange\n            idx = random.choice(candidates)\n            u, v = new_solution[idx], new_solution[(idx+1)%n]\n            # Find a better edge to replace with\n            best_edge = None\n            best_improvement = 0\n            for i in range(n):\n                if i == idx or i == (idx-1)%n or i == (idx+1)%n:\n                    continue\n                a, b = new_solution[i], new_solution[(i+1)%n]\n                # Calculate improvement across all objectives\n                improvement = (distance_matrix_1[u, v] + distance_matrix_1[a, b] -\n                              (distance_matrix_1[u, a] + distance_matrix_1[v, b]) +\n                              distance_matrix_2[u, v] + distance_matrix_2[a, b] -\n                              (distance_matrix_2[u, a] + distance_matrix_2[v, b]) +\n                              distance_matrix_3[u, v] + distance_matrix_3[a, b] -\n                              (distance_matrix_3[u, a] + distance_matrix_3[v, b]))\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (i, a, b)\n\n            if best_edge:\n                i, a, b = best_edge\n                # Perform the exchange\n                new_solution[(idx+1)%n] = a\n                new_solution[(i+1)%n] = v\n\n    return new_solution\n\n",
        "score": [
            -0.5244960436715631,
            2.0230042219161986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective differences to identify diverse solutions\n        objectives = np.array([obj for _, obj in archive])\n        mean_obj = np.mean(objectives, axis=0)\n        diversity_scores = np.sum(np.abs(objectives - mean_obj), axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    if random.random() < 0.5:\n        # 2-opt or 3-opt move\n        if random.random() < 0.5:\n            # 2-opt\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # 3-opt\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n    else:\n        # Multi-objective edge exchange\n        # Select edges from different objectives\n        obj1_edges = []\n        obj2_edges = []\n        obj3_edges = []\n\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            obj1_edges.append(distance_matrix_1[u, v])\n            obj2_edges.append(distance_matrix_2[u, v])\n            obj3_edges.append(distance_matrix_3[u, v])\n\n        # Find edges with high potential for improvement\n        obj1_threshold = np.percentile(obj1_edges, 75)\n        obj2_threshold = np.percentile(obj2_edges, 75)\n        obj3_threshold = np.percentile(obj3_edges, 75)\n\n        candidates = []\n        for i in range(n):\n            u, v = new_solution[i], new_solution[(i+1)%n]\n            if (distance_matrix_1[u, v] > obj1_threshold or\n                distance_matrix_2[u, v] > obj2_threshold or\n                distance_matrix_3[u, v] > obj3_threshold):\n                candidates.append(i)\n\n        if candidates:\n            # Perform edge exchange\n            idx = random.choice(candidates)\n            u, v = new_solution[idx], new_solution[(idx+1)%n]\n            # Find a better edge to replace with\n            best_edge = None\n            best_improvement = 0\n            for i in range(n):\n                if i == idx or i == (idx-1)%n or i == (idx+1)%n:\n                    continue\n                a, b = new_solution[i], new_solution[(i+1)%n]\n                # Calculate improvement across all objectives\n                improvement = (distance_matrix_1[u, v] + distance_matrix_1[a, b] -\n                              (distance_matrix_1[u, a] + distance_matrix_1[v, b]) +\n                              distance_matrix_2[u, v] + distance_matrix_2[a, b] -\n                              (distance_matrix_2[u, a] + distance_matrix_2[v, b]) +\n                              distance_matrix_3[u, v] + distance_matrix_3[a, b] -\n                              (distance_matrix_3[u, a] + distance_matrix_3[v, b]))\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (i, a, b)\n\n            if best_edge:\n                i, a, b = best_edge\n                # Perform the exchange\n                new_solution[(idx+1)%n] = a\n                new_solution[(i+1)%n] = v\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel hybrid local search strategy combines 2-opt exchanges with a multi-objective-aware perturbation mechanism, dynamically selecting edges based on their impact across all three objectives to generate high-quality neighbors while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find promising candidates\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from top candidates\n        selected_idx = np.random.randint(0, len(top_candidates))\n        base_solution = top_candidates[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # 2-opt exchange\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective-aware perturbation\n    if np.random.random() < 0.3:  # 30% chance to apply perturbation\n        # Find edges with high potential for improvement across objectives\n        current_costs = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n\n        # Try to find a better edge to replace\n        for _ in range(10):  # Limited attempts to find improvement\n            a, b = np.random.randint(0, n, size=2)\n            if a == b:\n                continue\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[a], candidate[b] = candidate[b], candidate[a]\n\n            # Calculate new costs\n            new_costs = (\n                sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n                sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n                sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            )\n\n            # Accept if at least one objective improves\n            if any(new_costs[i] < current_costs[i] for i in range(3)):\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.671729388449948,
            1.7609236717224122
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives to find promising candidates\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% of solutions\n        top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from top candidates\n        selected_idx = np.random.randint(0, len(top_candidates))\n        base_solution = top_candidates[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n\n    # 2-opt exchange\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective-aware perturbation\n    if np.random.random() < 0.3:  # 30% chance to apply perturbation\n        # Find edges with high potential for improvement across objectives\n        current_costs = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n\n        # Try to find a better edge to replace\n        for _ in range(10):  # Limited attempts to find improvement\n            a, b = np.random.randint(0, n, size=2)\n            if a == b:\n                continue\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[a], candidate[b] = candidate[b], candidate[a]\n\n            # Calculate new costs\n            new_costs = (\n                sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n                sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n)),\n                sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            )\n\n            # Accept if at least one objective improves\n            if any(new_costs[i] < current_costs[i] for i in range(3)):\n                new_solution = candidate\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: find the worst edge in any objective and swap it with a better alternative\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Calculate current objective value\n        current_obj = sum(distance_matrix[new_solution[k], new_solution[(k+1)%len(new_solution)]] for k in range(len(new_solution)))\n\n        # Find the worst edge (highest cost)\n        worst_edge = None\n        worst_cost = -1\n        for k in range(len(new_solution)):\n            cost = distance_matrix[new_solution[k], new_solution[(k+1)%len(new_solution)]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = (k, (k+1)%len(new_solution))\n\n        if worst_edge is not None:\n            # Find a better edge to replace the worst one\n            k, l = worst_edge\n            candidates = []\n            for m in range(len(new_solution)):\n                if m != k and m != l and m != (k-1)%len(new_solution) and m != (l+1)%len(new_solution):\n                    new_cost = distance_matrix[new_solution[k], new_solution[m]] + distance_matrix[new_solution[m], new_solution[l]]\n                    if new_cost < worst_cost:\n                        candidates.append((m, new_cost))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                m = best_candidate[0]\n                # Perform the swap\n                if m > k:\n                    new_solution[k+1:m+1] = new_solution[k+1:m+1][::-1]\n                else:\n                    new_solution[m:k+1] = new_solution[m:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8822304815098928,
            1.6360335946083069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: find the worst edge in any objective and swap it with a better alternative\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Calculate current objective value\n        current_obj = sum(distance_matrix[new_solution[k], new_solution[(k+1)%len(new_solution)]] for k in range(len(new_solution)))\n\n        # Find the worst edge (highest cost)\n        worst_edge = None\n        worst_cost = -1\n        for k in range(len(new_solution)):\n            cost = distance_matrix[new_solution[k], new_solution[(k+1)%len(new_solution)]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = (k, (k+1)%len(new_solution))\n\n        if worst_edge is not None:\n            # Find a better edge to replace the worst one\n            k, l = worst_edge\n            candidates = []\n            for m in range(len(new_solution)):\n                if m != k and m != l and m != (k-1)%len(new_solution) and m != (l+1)%len(new_solution):\n                    new_cost = distance_matrix[new_solution[k], new_solution[m]] + distance_matrix[new_solution[m], new_solution[l]]\n                    if new_cost < worst_cost:\n                        candidates.append((m, new_cost))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                m = best_candidate[0]\n                # Perform the swap\n                if m > k:\n                    new_solution[k+1:m+1] = new_solution[k+1:m+1][::-1]\n                else:\n                    new_solution[m:k+1] = new_solution[m:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: find the worst edge in any objective and swap it with a better alternative\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Calculate current objective value\n        current_obj = sum(distance_matrix[new_solution[k], new_solution[(k+1)%len(new_solution)]] for k in range(len(new_solution)))\n\n        # Find the worst edge (highest cost)\n        worst_edge = None\n        worst_cost = -1\n        for k in range(len(new_solution)):\n            cost = distance_matrix[new_solution[k], new_solution[(k+1)%len(new_solution)]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = (k, (k+1)%len(new_solution))\n\n        if worst_edge is not None:\n            # Find a better edge to replace the worst one\n            k, l = worst_edge\n            candidates = []\n            for m in range(len(new_solution)):\n                if m != k and m != l and m != (k-1)%len(new_solution) and m != (l+1)%len(new_solution):\n                    new_cost = distance_matrix[new_solution[k], new_solution[m]] + distance_matrix[new_solution[m], new_solution[l]]\n                    if new_cost < worst_cost:\n                        candidates.append((m, new_cost))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                m = best_candidate[0]\n                # Perform the swap\n                if m > k:\n                    new_solution[k+1:m+1] = new_solution[k+1:m+1][::-1]\n                else:\n                    new_solution[m:k+1] = new_solution[m:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8822304815098928,
            1.6360335946083069
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: find the worst edge in any objective and swap it with a better alternative\n    for obj_idx, distance_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n        # Calculate current objective value\n        current_obj = sum(distance_matrix[new_solution[k], new_solution[(k+1)%len(new_solution)]] for k in range(len(new_solution)))\n\n        # Find the worst edge (highest cost)\n        worst_edge = None\n        worst_cost = -1\n        for k in range(len(new_solution)):\n            cost = distance_matrix[new_solution[k], new_solution[(k+1)%len(new_solution)]]\n            if cost > worst_cost:\n                worst_cost = cost\n                worst_edge = (k, (k+1)%len(new_solution))\n\n        if worst_edge is not None:\n            # Find a better edge to replace the worst one\n            k, l = worst_edge\n            candidates = []\n            for m in range(len(new_solution)):\n                if m != k and m != l and m != (k-1)%len(new_solution) and m != (l+1)%len(new_solution):\n                    new_cost = distance_matrix[new_solution[k], new_solution[m]] + distance_matrix[new_solution[m], new_solution[l]]\n                    if new_cost < worst_cost:\n                        candidates.append((m, new_cost))\n\n            if candidates:\n                best_candidate = min(candidates, key=lambda x: x[1])\n                m = best_candidate[0]\n                # Perform the swap\n                if m > k:\n                    new_solution[k+1:m+1] = new_solution[k+1:m+1][::-1]\n                else:\n                    new_solution[m:k+1] = new_solution[m:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives using a weighted sum\n    def objective_score(obj):\n        return -(obj[0] + obj[1] + obj[2])  # Negative for minimization\n\n    ranked_solutions = sorted(archive, key=lambda x: objective_score(x[1]))\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them (2-opt)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swap: consider edges with high potential for improvement\n    for _ in range(5):  # Limit the number of swaps for efficiency\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Calculate the current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        swapped_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n        # Accept the swap if it improves at least one objective\n        if any(s < c for s, c in zip(swapped_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6936651923186887,
            1.802318799495697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best balance across objectives using a weighted sum\n    def objective_score(obj):\n        return -(obj[0] + obj[1] + obj[2])  # Negative for minimization\n\n    ranked_solutions = sorted(archive, key=lambda x: objective_score(x[1]))\n    selected_solution = ranked_solutions[0][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and reverse them (2-opt)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swap: consider edges with high potential for improvement\n    for _ in range(5):  # Limit the number of swaps for efficiency\n        a, b = np.random.choice(range(n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Calculate the current and potential costs for all three objectives\n        current_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]],\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]],\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        ]\n        swapped_costs = [\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]],\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]],\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        ]\n        # Accept the swap if it improves at least one objective\n        if any(s < c for s, c in zip(swapped_costs, current_costs)):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware node swapping\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt to reduce tour length in one objective space\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Select an objective space to prioritize\n    obj_idx = np.random.choice(3)\n    if obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst node in the selected objective space\n    worst_node = -1\n    max_cost = -1\n    for k in range(n):\n        prev = base_solution[k-1]\n        curr = base_solution[k]\n        next_node = base_solution[(k+1) % n]\n        cost = distance_matrix[prev, curr] + distance_matrix[curr, next_node]\n        if cost > max_cost:\n            max_cost = cost\n            worst_node = k\n\n    # Swap the worst node with a random node to diversify\n    if worst_node != -1:\n        swap_pos = np.random.choice(n)\n        new_solution[worst_node], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            -0.8468145208019238,
            1.412553894519806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already in the archive)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware node swapping\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt to reduce tour length in one objective space\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Select an objective space to prioritize\n    obj_idx = np.random.choice(3)\n    if obj_idx == 0:\n        distance_matrix = distance_matrix_1\n    elif obj_idx == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst node in the selected objective space\n    worst_node = -1\n    max_cost = -1\n    for k in range(n):\n        prev = base_solution[k-1]\n        curr = base_solution[k]\n        next_node = base_solution[(k+1) % n]\n        cost = distance_matrix[prev, curr] + distance_matrix[curr, next_node]\n        if cost > max_cost:\n            max_cost = cost\n            worst_node = k\n\n    # Swap the worst node with a random node to diversify\n    if worst_node != -1:\n        swap_pos = np.random.choice(n)\n        new_solution[worst_node], new_solution[swap_pos] = new_solution[swap_pos], new_solution[worst_node]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Calculate edge costs in all three objectives\n        cost_before = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        cost_after = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n        if cost_after < cost_before:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6848590342233624,
            3.2133036851882935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Calculate edge costs in all three objectives\n        cost_before = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n        cost_after = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n        if cost_after < cost_before:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse the segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.5601162782220674,
            1.9851641178131103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse the segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment of the tour (3-5 nodes)\n    n_nodes = len(new_solution)\n    segment_length = np.random.randint(3, min(5, n_nodes))\n    start_idx = np.random.randint(0, n_nodes - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Evaluate the segment's contribution to each objective\n    def segment_cost(sol, start, length):\n        cost1 = 0\n        cost2 = 0\n        cost3 = 0\n        for i in range(length - 1):\n            u = sol[start + i]\n            v = sol[start + i + 1]\n            cost1 += distance_matrix_1[u, v]\n            cost2 += distance_matrix_2[u, v]\n            cost3 += distance_matrix_3[u, v]\n        # Add the cost of connecting back to the tour\n        u = sol[start + length - 1]\n        v = sol[(start + length) % n_nodes]\n        cost1 += distance_matrix_1[u, v]\n        u = sol[start - 1]\n        v = sol[start]\n        cost1 += distance_matrix_1[u, v]\n        return cost1, cost2, cost3\n\n    original_cost = segment_cost(new_solution, start_idx, segment_length)\n\n    # Try reversing the segment\n    reversed_segment = segment[::-1]\n    new_solution[start_idx:start_idx + segment_length] = reversed_segment\n    reversed_cost = segment_cost(new_solution, start_idx, segment_length)\n\n    # If reversing improves at least one objective, keep it; otherwise, revert\n    if any(reversed_cost[i] < original_cost[i] for i in range(3)):\n        pass  # Keep the reversed segment\n    else:\n        new_solution[start_idx:start_idx + segment_length] = segment  # Revert\n\n    # Try swapping two random nodes in the segment\n    if segment_length >= 2:\n        i, j = np.random.choice(range(segment_length), 2, replace=False)\n        new_solution[start_idx + i], new_solution[start_idx + j] = new_solution[start_idx + j], new_solution[start_idx + i]\n\n    return new_solution\n\n",
        "score": [
            -0.6431405141181747,
            2.386266016960144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0]\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment of the tour (3-5 nodes)\n    n_nodes = len(new_solution)\n    segment_length = np.random.randint(3, min(5, n_nodes))\n    start_idx = np.random.randint(0, n_nodes - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Evaluate the segment's contribution to each objective\n    def segment_cost(sol, start, length):\n        cost1 = 0\n        cost2 = 0\n        cost3 = 0\n        for i in range(length - 1):\n            u = sol[start + i]\n            v = sol[start + i + 1]\n            cost1 += distance_matrix_1[u, v]\n            cost2 += distance_matrix_2[u, v]\n            cost3 += distance_matrix_3[u, v]\n        # Add the cost of connecting back to the tour\n        u = sol[start + length - 1]\n        v = sol[(start + length) % n_nodes]\n        cost1 += distance_matrix_1[u, v]\n        u = sol[start - 1]\n        v = sol[start]\n        cost1 += distance_matrix_1[u, v]\n        return cost1, cost2, cost3\n\n    original_cost = segment_cost(new_solution, start_idx, segment_length)\n\n    # Try reversing the segment\n    reversed_segment = segment[::-1]\n    new_solution[start_idx:start_idx + segment_length] = reversed_segment\n    reversed_cost = segment_cost(new_solution, start_idx, segment_length)\n\n    # If reversing improves at least one objective, keep it; otherwise, revert\n    if any(reversed_cost[i] < original_cost[i] for i in range(3)):\n        pass  # Keep the reversed segment\n    else:\n        new_solution[start_idx:start_idx + segment_length] = segment  # Revert\n\n    # Try swapping two random nodes in the segment\n    if segment_length >= 2:\n        i, j = np.random.choice(range(segment_length), 2, replace=False)\n        new_solution[start_idx + i], new_solution[start_idx + j] = new_solution[start_idx + j], new_solution[start_idx + i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    diversity_scores = []\n    for obj in objectives:\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(3) if i != j)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt move)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select two nodes to swap (swap move)\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a node to insert elsewhere (insertion move)\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.4817070979812934,
            2.227094328403473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    diversity_scores = []\n    for obj in objectives:\n        diversity = sum(abs(obj[i] - obj[j]) for i in range(3) for j in range(3) if i != j)\n        diversity_scores.append(diversity)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt move)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select two nodes to swap (swap move)\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a node to insert elsewhere (insertion move)\n    if np.random.rand() < 0.5:\n        node = np.random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n        pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.choice(range(n))\n\n    # Ensure the reconnection is valid and improves at least one objective\n    current_costs = (\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    )\n\n    # Try different reconnections and keep the one that improves at least one objective\n    best_new_solution = new_solution.copy()\n    best_improvement = 0\n\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a == b:\n                continue\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n            new_costs = (\n                sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n            )\n\n            improvement = sum((current_costs[i] - new_costs[i]) / (current_costs[i] + 1e-10) for i in range(3))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_new_solution = temp_solution.copy()\n\n    return best_new_solution\n\n",
        "score": [
            -0.7521714019949007,
            2.9095064043998717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.choice(range(n))\n\n    # Ensure the reconnection is valid and improves at least one objective\n    current_costs = (\n        sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n        sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n    )\n\n    # Try different reconnections and keep the one that improves at least one objective\n    best_new_solution = new_solution.copy()\n    best_improvement = 0\n\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a == b:\n                continue\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n            new_costs = (\n                sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n            )\n\n            improvement = sum((current_costs[i] - new_costs[i]) / (current_costs[i] + 1e-10) for i in range(3))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_new_solution = temp_solution.copy()\n\n    return best_new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt with a focus on reducing the worst objective\n    n = len(new_solution)\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Calculate the change in objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n            # If the worst objective improves, accept the move\n            if min(delta1, delta2, delta3) < 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                break\n\n    # Apply a random swap to explore new regions\n    if np.random.rand() < 0.3:\n        a, b = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7170744493420406,
            1.938726544380188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt with a focus on reducing the worst objective\n    n = len(new_solution)\n    for i in range(n - 1):\n        for j in range(i + 2, n - 1):\n            # Calculate the change in objectives\n            delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j], new_solution[j+1]])\n\n            delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n            delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[j+1]]) - \\\n                    (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n            # If the worst objective improves, accept the move\n            if min(delta1, delta2, delta3) < 0:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                break\n\n    # Apply a random swap to explore new regions\n    if np.random.rand() < 0.3:\n        a, b = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The heuristic function employs a hybrid local search strategy that combines 2-opt swaps with a novel multi-objective edge insertion heuristic, intelligently selecting promising solutions from the archive based on their Pareto dominance and diversity, and applies a dynamic neighborhood exploration to balance exploration and exploitation across the three objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt swap for one objective\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective edge insertion\n    else:\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7870987197219965,
            1.112095582485199
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Apply 2-opt swap for one objective\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(len(new_solution)), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective edge insertion\n    else:\n        i = random.randint(0, len(new_solution) - 1)\n        j = random.randint(0, len(new_solution) - 1)\n        if i != j:\n            # Remove node at i and insert at j\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{The algorithm selects a promising solution from the archive based on its objective values, then applies a hybrid local search operator combining 2-opt, 3-opt, and a novel multi-objective edge-swap strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = np.random.choice(len(archive_solutions))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt, 3-opt, or multi-objective edge swap\n    operator_choice = random.random()\n\n    if operator_choice < 0.33:\n        # 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator_choice < 0.66:\n        # 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Multi-objective edge swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Calculate total cost before swap\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n            # Perform swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Calculate total cost after swap\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n            # If the swap doesn't improve at least one objective, revert\n            if (new_cost1 >= old_cost1 and new_cost2 >= old_cost2 and new_cost3 >= old_cost3):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7897827877921662,
            1.336738395690918
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_idx = np.random.choice(len(archive_solutions))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt, 3-opt, or multi-objective edge swap\n    operator_choice = random.random()\n\n    if operator_choice < 0.33:\n        # 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif operator_choice < 0.66:\n        # 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n    else:\n        # Multi-objective edge swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Calculate total cost before swap\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            old_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n            # Perform swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Calculate total cost after swap\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost3 = distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]]\n\n            # If the swap doesn't improve at least one objective, revert\n            if (new_cost1 >= old_cost1 and new_cost2 >= old_cost2 and new_cost3 >= old_cost3):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap, preferring edges with high improvement potential\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure valid swap and feasibility\n    if i != j and k != l and abs(i - j) > 1 and abs(k - l) > 1:\n        # Reverse segments between edges\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # Fallback to simple 2-opt if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.648960526198328,
            1.3947224736213684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap, preferring edges with high improvement potential\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure valid swap and feasibility\n    if i != j and k != l and abs(i - j) > 1 and abs(k - l) > 1:\n        # Reverse segments between edges\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # Fallback to simple 2-opt if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{This heuristic function selects a promising solution from the archive by prioritizing those with lower average objective values, then applies a novel multi-objective local search that combines 2-opt with a biased random walk to explore diverse neighborhoods while ensuring feasibility and maintaining non-dominated properties across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower average objective value\n    selected_idx = np.argmin([sum(obj) / 3 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # 2-opt with multi-objective bias\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        if j - i < 2:\n            continue\n\n        # Evaluate the current and reversed segment\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves or if it's a tie\n        if reversed_cost <= current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply a biased random walk for multi-objective exploration\n        if np.random.rand() < 0.3:\n            k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n            if l - k >= 2:\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6428983939650058,
            2.8840237140655516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower average objective value\n    selected_idx = np.argmin([sum(obj) / 3 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # 2-opt with multi-objective bias\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        if j - i < 2:\n            continue\n\n        # Evaluate the current and reversed segment\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        reversed_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if any objective improves or if it's a tie\n        if reversed_cost <= current_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply a biased random walk for multi-objective exploration\n        if np.random.rand() < 0.3:\n            k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n            if l - k >= 2:\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Randomly select two distinct positions to swap\n    n = len(best_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform the swap to create a neighbor\n    new_solution = best_solution.copy()\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6637316483594734,
            1.2194914937019348
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Randomly select two distinct positions to swap\n    n = len(best_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n\n    # Perform the swap to create a neighbor\n    new_solution = best_solution.copy()\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest sum of normalized objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-specific edge swaps\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the swap causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6621150582858849,
            1.5439629554748535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest sum of normalized objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with objective-specific edge swaps\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the swap causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement based on objective diversity\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = np.random.randint(0, n, 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swap: select edges with high potential to reduce multiple objectives\n    for _ in range(2):  # Perform 2 edge swaps\n        a, b, c, d = np.random.choice(n, 4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Calculate potential improvement in all three objectives\n        original_cost = (distance_matrix_1[base_solution[a], base_solution[b]] +\n                         distance_matrix_1[base_solution[c], base_solution[d]] +\n                         distance_matrix_2[base_solution[a], base_solution[b]] +\n                         distance_matrix_2[base_solution[c], base_solution[d]] +\n                         distance_matrix_3[base_solution[a], base_solution[b]] +\n                         distance_matrix_3[base_solution[c], base_solution[d]])\n\n        new_cost = (distance_matrix_1[base_solution[a], base_solution[c]] +\n                    distance_matrix_1[base_solution[b], base_solution[d]] +\n                    distance_matrix_2[base_solution[a], base_solution[c]] +\n                    distance_matrix_2[base_solution[b], base_solution[d]] +\n                    distance_matrix_3[base_solution[a], base_solution[c]] +\n                    distance_matrix_3[base_solution[b], base_solution[d]])\n\n        if new_cost < original_cost:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.5933401259960884,
            1.4106544494628905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement based on objective diversity\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = np.random.randint(0, n, 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swap: select edges with high potential to reduce multiple objectives\n    for _ in range(2):  # Perform 2 edge swaps\n        a, b, c, d = np.random.choice(n, 4, replace=False)\n        if a > b:\n            a, b = b, a\n        if c > d:\n            c, d = d, c\n\n        # Calculate potential improvement in all three objectives\n        original_cost = (distance_matrix_1[base_solution[a], base_solution[b]] +\n                         distance_matrix_1[base_solution[c], base_solution[d]] +\n                         distance_matrix_2[base_solution[a], base_solution[b]] +\n                         distance_matrix_2[base_solution[c], base_solution[d]] +\n                         distance_matrix_3[base_solution[a], base_solution[b]] +\n                         distance_matrix_3[base_solution[c], base_solution[d]])\n\n        new_cost = (distance_matrix_1[base_solution[a], base_solution[c]] +\n                    distance_matrix_1[base_solution[b], base_solution[d]] +\n                    distance_matrix_2[base_solution[a], base_solution[c]] +\n                    distance_matrix_2[base_solution[b], base_solution[d]] +\n                    distance_matrix_3[base_solution[a], base_solution[c]] +\n                    distance_matrix_3[base_solution[b], base_solution[d]])\n\n        if new_cost < original_cost:\n            new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n            new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective improvement: check if swapping nodes improves any objective\n    for _ in range(3):  # Try multiple random swaps\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                           distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                           distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n        if potential_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6226735773118396,
            0.9725300073623657
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective improvement: check if swapping nodes improves any objective\n    for _ in range(3):  # Try multiple random swaps\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                           distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                           distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n        if potential_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement by evaluating the diversity and non-dominated status of solutions, then applies a multi-objective local search that combines edge exchange and segment reversal operations to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search operation\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Ensure i < j for segment reversal\n    if i > j:\n        i, j = j, i\n\n    # Apply a segment reversal operation (2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Optionally apply an edge exchange (3-opt) to further diversify\n    if np.random.rand() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8024998195050481,
            1.482122278213501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search operation\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Ensure i < j for segment reversal\n    if i > j:\n        i, j = j, i\n\n    # Apply a segment reversal operation (2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Optionally apply an edge exchange (3-opt) to further diversify\n    if np.random.rand() < 0.5:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k > l:\n            k, l = l, k\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Perform a hybrid local search operator combining 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments for 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to relocate\n    k = np.random.randint(0, n)\n    node_to_relocate = new_solution[k]\n\n    # Remove the node and reinsert it at a random position\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node_to_relocate)\n\n    # Step 3: Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Solution is not feasible\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Solution contains missing or duplicate nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.6583269078925105,
            3.481061112880707
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Perform a hybrid local search operator combining 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments for 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node to relocate\n    k = np.random.randint(0, n)\n    node_to_relocate = new_solution[k]\n\n    # Remove the node and reinsert it at a random position\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, new_pos, node_to_relocate)\n\n    # Step 3: Ensure the solution remains feasible (no duplicates, all nodes present)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Solution is not feasible\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Solution contains missing or duplicate nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Calculate total cost for each solution (sum of all three objectives)\n        total_costs = [sum(obj) for _, obj in archive]\n        # Normalize to create a probability distribution\n        max_cost = max(total_costs)\n        probabilities = [1 - (cost / max_cost) for cost in total_costs]\n        total_prob = sum(probabilities)\n        probabilities = [p / total_prob for p in probabilities]\n        # Select a solution based on the probability distribution\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator\n    if n > 2:\n        # Randomly choose between edge swap or node shift\n        if np.random.rand() < 0.5:\n            # Edge swap: select two random edges and swap their nodes\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Node shift: select a node and insert it in a random position\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            # Remove the node\n            new_solution = np.delete(new_solution, node_idx)\n            # Insert it at a random position\n            insert_pos = np.random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7995369021370479,
            1.2737497568130494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        selected_solution = archive[0][0].copy()\n    else:\n        # Calculate total cost for each solution (sum of all three objectives)\n        total_costs = [sum(obj) for _, obj in archive]\n        # Normalize to create a probability distribution\n        max_cost = max(total_costs)\n        probabilities = [1 - (cost / max_cost) for cost in total_costs]\n        total_prob = sum(probabilities)\n        probabilities = [p / total_prob for p in probabilities]\n        # Select a solution based on the probability distribution\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        selected_solution = archive[selected_idx][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search operator\n    if n > 2:\n        # Randomly choose between edge swap or node shift\n        if np.random.rand() < 0.5:\n            # Edge swap: select two random edges and swap their nodes\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Node shift: select a node and insert it in a random position\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            # Remove the node\n            new_solution = np.delete(new_solution, node_idx)\n            # Insert it at a random position\n            insert_pos = np.random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (sum(obj) + 1e-10) for obj in [sol[1] for sol in archive]])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Choose the edge to flip based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Get the edges in the current and proposed segments\n    current_edges = [(base_solution[i-1], base_solution[i]), (base_solution[j-1], base_solution[j])]\n    proposed_edges = [(base_solution[i-1], base_solution[j-1]), (base_solution[i], base_solution[j])]\n\n    # Calculate the change in the worst objective\n    delta = 0\n    for (u, v) in current_edges:\n        delta -= distance_matrix_1[u, v] if worst_obj == 0 else (distance_matrix_2[u, v] if worst_obj == 1 else distance_matrix_3[u, v])\n    for (u, v) in proposed_edges:\n        delta += distance_matrix_1[u, v] if worst_obj == 0 else (distance_matrix_2[u, v] if worst_obj == 1 else distance_matrix_3[u, v])\n\n    # Apply 2-opt if it improves the worst objective\n    if delta < 0 or random.random() < 0.3:  # Allow some randomness for exploration\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Apply a random 2-opt to ensure diversity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7746795121738762,
            1.585179829597473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (sum(obj) + 1e-10) for obj in [sol[1] for sol in archive]])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Choose the edge to flip based on the worst objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    # Get the edges in the current and proposed segments\n    current_edges = [(base_solution[i-1], base_solution[i]), (base_solution[j-1], base_solution[j])]\n    proposed_edges = [(base_solution[i-1], base_solution[j-1]), (base_solution[i], base_solution[j])]\n\n    # Calculate the change in the worst objective\n    delta = 0\n    for (u, v) in current_edges:\n        delta -= distance_matrix_1[u, v] if worst_obj == 0 else (distance_matrix_2[u, v] if worst_obj == 1 else distance_matrix_3[u, v])\n    for (u, v) in proposed_edges:\n        delta += distance_matrix_1[u, v] if worst_obj == 0 else (distance_matrix_2[u, v] if worst_obj == 1 else distance_matrix_3[u, v])\n\n    # Apply 2-opt if it improves the worst objective\n    if delta < 0 or random.random() < 0.3:  # Allow some randomness for exploration\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Apply a random 2-opt to ensure diversity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and swap-based moves\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or swap-based move\n    if np.random.rand() < 0.5:\n        # 2-opt move: select two random edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap-based move: select two random nodes and swap them\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.737204900390623,
            1.340431821346283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and swap-based moves\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly choose between 2-opt or swap-based move\n    if np.random.rand() < 0.5:\n        # 2-opt move: select two random edges and reverse the segment between them\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap-based move: select two random nodes and swap them\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the spread of objectives to identify promising solutions\n        objectives = np.array([obj for _, obj in archive])\n        spread = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select the solution with the highest spread (indicating potential for improvement)\n        selected_index = np.argmax(np.sum(spread * (objectives - np.mean(objectives, axis=0)), axis=1))\n    else:\n        selected_index = 0\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange move if it improves the solution\n    if i != k and j != l:\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n        temp_solution[j], temp_solution[l] = temp_solution[l], temp_solution[j]\n\n        # Evaluate the new solution in all three objectives\n        def calculate_objective(solution):\n            obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (obj1, obj2, obj3)\n\n        current_obj = calculate_objective(new_solution)\n        temp_obj = calculate_objective(temp_solution)\n\n        # Accept the move if it improves at least one objective\n        if any(temp_obj[i] < current_obj[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.48090996839189637,
            2.1263463735580443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the spread of objectives to identify promising solutions\n        objectives = np.array([obj for _, obj in archive])\n        spread = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        # Select the solution with the highest spread (indicating potential for improvement)\n        selected_index = np.argmax(np.sum(spread * (objectives - np.mean(objectives, axis=0)), axis=1))\n    else:\n        selected_index = 0\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge exchange with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform edge exchange move if it improves the solution\n    if i != k and j != l:\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n        temp_solution[j], temp_solution[l] = temp_solution[l], temp_solution[j]\n\n        # Evaluate the new solution in all three objectives\n        def calculate_objective(solution):\n            obj1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n            obj2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n            obj3 = sum(distance_matrix_3[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n            return (obj1, obj2, obj3)\n\n        current_obj = calculate_objective(new_solution)\n        temp_obj = calculate_objective(temp_solution)\n\n        # Accept the move if it improves at least one objective\n        if any(temp_obj[i] < current_obj[i] for i in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 2.1: Objective-specific 2-opt for each objective space\n    for _ in range(3):  # Apply 2-opt for each objective space\n        # Randomly select a segment to optimize\n        start, end = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        segment = new_solution[start:end+1]\n\n        # Try to reverse the segment\n        reversed_segment = segment[::-1]\n        candidate = new_solution.copy()\n        candidate[start:end+1] = reversed_segment\n\n        # Evaluate the candidate in all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        if (cost1 < archive[selected_idx][1][0]) or (cost2 < archive[selected_idx][1][1]) or (cost3 < archive[selected_idx][1][2]):\n            new_solution = candidate\n\n    # Step 2.2: Multi-objective edge exchange\n    # Select two random edges and try to exchange them\n    edge1, edge2 = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    candidate = new_solution.copy()\n    candidate[edge1], candidate[edge2] = candidate[edge2], candidate[edge1]\n\n    # Evaluate the candidate in all three objectives\n    cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n    cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n    cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n    # Accept if at least one objective improves\n    if (cost1 < archive[selected_idx][1][0]) or (cost2 < archive[selected_idx][1][1]) or (cost3 < archive[selected_idx][1][2]):\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7824929033011566,
            2.257242977619171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Step 2.1: Objective-specific 2-opt for each objective space\n    for _ in range(3):  # Apply 2-opt for each objective space\n        # Randomly select a segment to optimize\n        start, end = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        segment = new_solution[start:end+1]\n\n        # Try to reverse the segment\n        reversed_segment = segment[::-1]\n        candidate = new_solution.copy()\n        candidate[start:end+1] = reversed_segment\n\n        # Evaluate the candidate in all three objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        if (cost1 < archive[selected_idx][1][0]) or (cost2 < archive[selected_idx][1][1]) or (cost3 < archive[selected_idx][1][2]):\n            new_solution = candidate\n\n    # Step 2.2: Multi-objective edge exchange\n    # Select two random edges and try to exchange them\n    edge1, edge2 = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    candidate = new_solution.copy()\n    candidate[edge1], candidate[edge2] = candidate[edge2], candidate[edge1]\n\n    # Evaluate the candidate in all three objectives\n    cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n    cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n    cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n    # Accept if at least one objective improves\n    if (cost1 < archive[selected_idx][1][0]) or (cost2 < archive[selected_idx][1][1]) or (cost3 < archive[selected_idx][1][2]):\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)  # Average objective value as selection criterion\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with objective-aware node insertion\n    n = len(base_solution)\n    for _ in range(5):  # Number of perturbation steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(0, n)\n\n        # Edge exchange between i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Objective-aware node insertion\n        best_insert_pos = k\n        best_improvement = 0\n        for pos in range(n):\n            if pos != k:\n                # Calculate improvement in all three objectives\n                original_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] +\n                                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n                new_cost = (distance_matrix_1[new_solution[pos-1], new_solution[k]] +\n                           distance_matrix_2[new_solution[pos-1], new_solution[k]] +\n                           distance_matrix_3[new_solution[pos-1], new_solution[k]] +\n                           distance_matrix_1[new_solution[k], new_solution[pos]] +\n                           distance_matrix_2[new_solution[k], new_solution[pos]] +\n                           distance_matrix_3[new_solution[k], new_solution[pos]])\n\n                improvement = original_cost - new_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insert_pos = pos\n\n        # Perform the insertion if it improves at least one objective\n        if best_improvement > 0:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.700699080186977,
            4.091754579544068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)  # Average objective value as selection criterion\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with objective-aware node insertion\n    n = len(base_solution)\n    for _ in range(5):  # Number of perturbation steps\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(0, n)\n\n        # Edge exchange between i and j\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Objective-aware node insertion\n        best_insert_pos = k\n        best_improvement = 0\n        for pos in range(n):\n            if pos != k:\n                # Calculate improvement in all three objectives\n                original_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                                distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                                distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] +\n                                distance_matrix_3[new_solution[k], new_solution[(k+1)%n]])\n\n                new_cost = (distance_matrix_1[new_solution[pos-1], new_solution[k]] +\n                           distance_matrix_2[new_solution[pos-1], new_solution[k]] +\n                           distance_matrix_3[new_solution[pos-1], new_solution[k]] +\n                           distance_matrix_1[new_solution[k], new_solution[pos]] +\n                           distance_matrix_2[new_solution[k], new_solution[pos]] +\n                           distance_matrix_3[new_solution[k], new_solution[pos]])\n\n                improvement = original_cost - new_cost\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_insert_pos = pos\n\n        # Perform the insertion if it improves at least one objective\n        if best_improvement > 0:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the objective with the highest current cost\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj3_cost = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if max(obj1_cost, obj2_cost, obj3_cost) == obj1_cost:\n        # 2-opt for objective 1\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swap for the other objectives\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6348834998321469,
            1.2854772567749024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the objective with the highest current cost\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj3_cost = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if max(obj1_cost, obj2_cost, obj3_cost) == obj1_cost:\n        # 2-opt for objective 1\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Objective-aware swap for the other objectives\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel objective-aware edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt swap\n    if i != k and j != l:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: select edges with high potential for improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the change in objectives for swapping these nodes\n        delta1 = (distance_matrix_1[node_a, new_solution[(a+1)%n]] + distance_matrix_1[new_solution[(a-1)%n], node_a] +\n                  distance_matrix_1[node_b, new_solution[(b+1)%n]] + distance_matrix_1[new_solution[(b-1)%n], node_b] -\n                  (distance_matrix_1[node_a, new_solution[(b+1)%n]] + distance_matrix_1[new_solution[(b-1)%n], node_a] +\n                   distance_matrix_1[node_b, new_solution[(a+1)%n]] + distance_matrix_1[new_solution[(a-1)%n], node_b]))\n\n        delta2 = (distance_matrix_2[node_a, new_solution[(a+1)%n]] + distance_matrix_2[new_solution[(a-1)%n], node_a] +\n                  distance_matrix_2[node_b, new_solution[(b+1)%n]] + distance_matrix_2[new_solution[(b-1)%n], node_b] -\n                  (distance_matrix_2[node_a, new_solution[(b+1)%n]] + distance_matrix_2[new_solution[(b-1)%n], node_a] +\n                   distance_matrix_2[node_b, new_solution[(a+1)%n]] + distance_matrix_2[new_solution[(a-1)%n], node_b]))\n\n        delta3 = (distance_matrix_3[node_a, new_solution[(a+1)%n]] + distance_matrix_3[new_solution[(a-1)%n], node_a] +\n                  distance_matrix_3[node_b, new_solution[(b+1)%n]] + distance_matrix_3[new_solution[(b-1)%n], node_b] -\n                  (distance_matrix_3[node_a, new_solution[(b+1)%n]] + distance_matrix_3[new_solution[(b-1)%n], node_a] +\n                   distance_matrix_3[node_b, new_solution[(a+1)%n]] + distance_matrix_3[new_solution[(a-1)%n], node_b]))\n\n        # If the swap improves any objective, perform it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5929703393563683,
            1.1855096340179443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel objective-aware edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a 2-opt swap\n    if i != k and j != l:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: select edges with high potential for improvement\n    for _ in range(2):\n        a, b = random.sample(range(n), 2)\n        node_a, node_b = new_solution[a], new_solution[b]\n\n        # Calculate the change in objectives for swapping these nodes\n        delta1 = (distance_matrix_1[node_a, new_solution[(a+1)%n]] + distance_matrix_1[new_solution[(a-1)%n], node_a] +\n                  distance_matrix_1[node_b, new_solution[(b+1)%n]] + distance_matrix_1[new_solution[(b-1)%n], node_b] -\n                  (distance_matrix_1[node_a, new_solution[(b+1)%n]] + distance_matrix_1[new_solution[(b-1)%n], node_a] +\n                   distance_matrix_1[node_b, new_solution[(a+1)%n]] + distance_matrix_1[new_solution[(a-1)%n], node_b]))\n\n        delta2 = (distance_matrix_2[node_a, new_solution[(a+1)%n]] + distance_matrix_2[new_solution[(a-1)%n], node_a] +\n                  distance_matrix_2[node_b, new_solution[(b+1)%n]] + distance_matrix_2[new_solution[(b-1)%n], node_b] -\n                  (distance_matrix_2[node_a, new_solution[(b+1)%n]] + distance_matrix_2[new_solution[(b-1)%n], node_a] +\n                   distance_matrix_2[node_b, new_solution[(a+1)%n]] + distance_matrix_2[new_solution[(a-1)%n], node_b]))\n\n        delta3 = (distance_matrix_3[node_a, new_solution[(a+1)%n]] + distance_matrix_3[new_solution[(a-1)%n], node_a] +\n                  distance_matrix_3[node_b, new_solution[(b+1)%n]] + distance_matrix_3[new_solution[(b-1)%n], node_b] -\n                  (distance_matrix_3[node_a, new_solution[(b+1)%n]] + distance_matrix_3[new_solution[(b-1)%n], node_a] +\n                   distance_matrix_3[node_b, new_solution[(a+1)%n]] + distance_matrix_3[new_solution[(a-1)%n], node_b]))\n\n        # If the swap improves any objective, perform it\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a novel multi-objective edge swap for the other objectives\n    if n > 3:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != i and l != j:\n            # Ensure the swap maintains feasibility\n            temp = new_solution[k]\n            new_solution[k] = new_solution[l]\n            new_solution[l] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.6860560063955392,
            1.0169307947158814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a novel multi-objective edge swap for the other objectives\n    if n > 3:\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        if k != i and l != j:\n            # Ensure the swap maintains feasibility\n            temp = new_solution[k]\n            new_solution[k] = new_solution[l]\n            new_solution[l] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement across all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[k-1], new_solution[k]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[k-1], new_solution[k]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:  # If any objective improves\n            # Apply 2-opt on both segments\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6939974619262198,
            2.487623155117035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Calculate potential improvement across all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[k-1], new_solution[k]])\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[k-1], new_solution[k]])\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[l]]\n                 - distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:  # If any objective improves\n            # Apply 2-opt on both segments\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the worst-performing objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    # Choose the appropriate distance matrix\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the tour\n    max_dist = -1\n    i, j = -1, -1\n    for k in range(n):\n        a, b = new_solution[k], new_solution[(k+1)%n]\n        dist = distance_matrix[a, b]\n        if dist > max_dist:\n            max_dist = dist\n            i, j = k, (k+1)%n\n\n    # Perform 2-opt swap\n    if i != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform objective-aware swaps (try to improve all objectives)\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Accept if all objectives are improved or at least one is improved\n        if (new_obj1 <= obj1 and new_obj2 <= obj2 and new_obj3 <= obj3) or \\\n           (new_obj1 < obj1 or new_obj2 < obj2 or new_obj3 < obj3):\n            new_solution = temp_solution\n            obj1, obj2, obj3 = new_obj1, new_obj2, new_obj3\n\n    return new_solution\n\n",
        "score": [
            -0.8370808141651087,
            1.719607162475586
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the worst-performing objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    # Choose the appropriate distance matrix\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the tour\n    max_dist = -1\n    i, j = -1, -1\n    for k in range(n):\n        a, b = new_solution[k], new_solution[(k+1)%n]\n        dist = distance_matrix[a, b]\n        if dist > max_dist:\n            max_dist = dist\n            i, j = k, (k+1)%n\n\n    # Perform 2-opt swap\n    if i != j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Perform objective-aware swaps (try to improve all objectives)\n    for _ in range(3):\n        a, b = np.random.choice(n, 2, replace=False)\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Accept if all objectives are improved or at least one is improved\n        if (new_obj1 <= obj1 and new_obj2 <= obj2 and new_obj3 <= obj3) or \\\n           (new_obj1 < obj1 or new_obj2 < obj2 or new_obj3 < obj3):\n            new_solution = temp_solution\n            obj1, obj2, obj3 = new_obj1, new_obj2, new_obj3\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        # Avoid invalid tour by ensuring the tour remains circular\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: prefer edges that improve the worst objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n        new_obj = (\n            sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        )\n        # Accept if at least one objective improves\n        if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.679214000591144,
            4.0127274751663204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        # Avoid invalid tour by ensuring the tour remains circular\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: prefer edges that improve the worst objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        current_obj = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        )\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n        new_obj = (\n            sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        )\n        # Accept if at least one objective improves\n        if any(new_o < current_o for new_o, current_o in zip(new_obj, current_obj)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with non-dominated objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with adaptive step size based on objective diversity\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j to create a neighbor\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering the worst-performing objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Local search to improve the worst objective\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        current_cost = sum(distance_matrix[new_solution[k-1], new_solution[k]] for k in range(n))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate_cost = sum(distance_matrix[candidate[k-1], candidate[k]] for k in range(n))\n        if candidate_cost < current_cost:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7048191077985047,
            1.2578988194465637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with non-dominated objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with adaptive step size based on objective diversity\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Reverse the segment between i and j to create a neighbor\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering the worst-performing objective\n    worst_obj = np.argmax(archive[selected_idx][1])\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Local search to improve the worst objective\n    for _ in range(3):\n        i, j = np.random.choice(n, size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        current_cost = sum(distance_matrix[new_solution[k-1], new_solution[k]] for k in range(n))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate_cost = sum(distance_matrix[candidate[k-1], candidate[k]] for k in range(n))\n        if candidate_cost < current_cost:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher potential for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    # Hybrid of 2-opt and 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    improved = False\n\n    # Try 2-opt first\n    for i in range(n - 1):\n        if improved:\n            break\n        for j in range(i + 2, n - 1):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[i+1], new_solution[j+1]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j], new_solution[j+1]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i+1], new_solution[j+1]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j], new_solution[j+1]])\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i+1], new_solution[j+1]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n            # If any objective improves, perform the move\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                improved = True\n                break\n\n    # If no improvement with 2-opt, try 3-opt\n    if not improved:\n        for i in range(n - 2):\n            if improved:\n                break\n            for j in range(i + 2, n - 1):\n                if improved:\n                    break\n                for k in range(j + 2, n - 1):\n                    # Try all three possible 3-opt moves\n                    for move in range(3):\n                        if move == 0:\n                            # Move 1: Reverse segment i+1 to j\n                            temp_sol = new_solution.copy()\n                            temp_sol[i+1:j+1] = temp_sol[i+1:j+1][::-1]\n                        elif move == 1:\n                            # Move 2: Reverse segment j+1 to k\n                            temp_sol = new_solution.copy()\n                            temp_sol[j+1:k+1] = temp_sol[j+1:k+1][::-1]\n                        else:\n                            # Move 3: Reverse segment i+1 to k and then reverse j+1 to k\n                            temp_sol = new_solution.copy()\n                            temp_sol[i+1:k+1] = temp_sol[i+1:k+1][::-1]\n                            temp_sol[j+1:k+1] = temp_sol[j+1:k+1][::-1]\n\n                        # Calculate the change in all three objectives\n                        delta1 = (sum(distance_matrix_1[temp_sol[i:i+2]]) +\n                                 sum(distance_matrix_1[temp_sol[j:j+2]]) +\n                                 sum(distance_matrix_1[temp_sol[k:k+2]])) - \\\n                                (sum(distance_matrix_1[new_solution[i:i+2]]) +\n                                 sum(distance_matrix_1[new_solution[j:j+2]]) +\n                                 sum(distance_matrix_1[new_solution[k:k+2]]))\n                        delta2 = (sum(distance_matrix_2[temp_sol[i:i+2]]) +\n                                 sum(distance_matrix_2[temp_sol[j:j+2]]) +\n                                 sum(distance_matrix_2[temp_sol[k:k+2]])) - \\\n                                (sum(distance_matrix_2[new_solution[i:i+2]]) +\n                                 sum(distance_matrix_2[new_solution[j:j+2]]) +\n                                 sum(distance_matrix_2[new_solution[k:k+2]]))\n                        delta3 = (sum(distance_matrix_3[temp_sol[i:i+2]]) +\n                                 sum(distance_matrix_3[temp_sol[j:j+2]]) +\n                                 sum(distance_matrix_3[temp_sol[k:k+2]])) - \\\n                                (sum(distance_matrix_3[new_solution[i:i+2]]) +\n                                 sum(distance_matrix_3[new_solution[j:j+2]]) +\n                                 sum(distance_matrix_3[new_solution[k:k+2]]))\n\n                        # If any objective improves, perform the move\n                        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                            new_solution = temp_sol\n                            improved = True\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.6310464535306813,
            1.3778047442436219
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher potential for improvement)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to balance exploration and exploitation\n        base_solution = sorted_archive[len(sorted_archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    # Hybrid of 2-opt and 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    improved = False\n\n    # Try 2-opt first\n    for i in range(n - 1):\n        if improved:\n            break\n        for j in range(i + 2, n - 1):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[i+1], new_solution[j+1]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j], new_solution[j+1]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i+1], new_solution[j+1]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j], new_solution[j+1]])\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i+1], new_solution[j+1]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_3[new_solution[j], new_solution[j+1]])\n\n            # If any objective improves, perform the move\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                improved = True\n                break\n\n    # If no improvement with 2-opt, try 3-opt\n    if not improved:\n        for i in range(n - 2):\n            if improved:\n                break\n            for j in range(i + 2, n - 1):\n                if improved:\n                    break\n                for k in range(j + 2, n - 1):\n                    # Try all three possible 3-opt moves\n                    for move in range(3):\n                        if move == 0:\n                            # Move 1: Reverse segment i+1 to j\n                            temp_sol = new_solution.copy()\n                            temp_sol[i+1:j+1] = temp_sol[i+1:j+1][::-1]\n                        elif move == 1:\n                            # Move 2: Reverse segment j+1 to k\n                            temp_sol = new_solution.copy()\n                            temp_sol[j+1:k+1] = temp_sol[j+1:k+1][::-1]\n                        else:\n                            # Move 3: Reverse segment i+1 to k and then reverse j+1 to k\n                            temp_sol = new_solution.copy()\n                            temp_sol[i+1:k+1] = temp_sol[i+1:k+1][::-1]\n                            temp_sol[j+1:k+1] = temp_sol[j+1:k+1][::-1]\n\n                        # Calculate the change in all three objectives\n                        delta1 = (sum(distance_matrix_1[temp_sol[i:i+2]]) +\n                                 sum(distance_matrix_1[temp_sol[j:j+2]]) +\n                                 sum(distance_matrix_1[temp_sol[k:k+2]])) - \\\n                                (sum(distance_matrix_1[new_solution[i:i+2]]) +\n                                 sum(distance_matrix_1[new_solution[j:j+2]]) +\n                                 sum(distance_matrix_1[new_solution[k:k+2]]))\n                        delta2 = (sum(distance_matrix_2[temp_sol[i:i+2]]) +\n                                 sum(distance_matrix_2[temp_sol[j:j+2]]) +\n                                 sum(distance_matrix_2[temp_sol[k:k+2]])) - \\\n                                (sum(distance_matrix_2[new_solution[i:i+2]]) +\n                                 sum(distance_matrix_2[new_solution[j:j+2]]) +\n                                 sum(distance_matrix_2[new_solution[k:k+2]]))\n                        delta3 = (sum(distance_matrix_3[temp_sol[i:i+2]]) +\n                                 sum(distance_matrix_3[temp_sol[j:j+2]]) +\n                                 sum(distance_matrix_3[temp_sol[k:k+2]])) - \\\n                                (sum(distance_matrix_3[new_solution[i:i+2]]) +\n                                 sum(distance_matrix_3[new_solution[j:j+2]]) +\n                                 sum(distance_matrix_3[new_solution[k:k+2]]))\n\n                        # If any objective improves, perform the move\n                        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                            new_solution = temp_sol\n                            improved = True\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate potential edges to reconnect\n    best_improvement = 0\n    best_k, best_l = -1, -1\n\n    for k in range(i + 1, j):\n        for l in range(k + 1, j + 1):\n            # Calculate the change in all three objectives\n            delta_1 = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]] -\n                       distance_matrix_1[new_solution[i], new_solution[j]] - distance_matrix_1[new_solution[k], new_solution[l]])\n            delta_2 = (distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]] -\n                       distance_matrix_2[new_solution[i], new_solution[j]] - distance_matrix_2[new_solution[k], new_solution[l]])\n            delta_3 = (distance_matrix_3[new_solution[i], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[l]] -\n                       distance_matrix_3[new_solution[i], new_solution[j]] - distance_matrix_3[new_solution[k], new_solution[l]])\n\n            # Objective-aware selection: prefer moves that improve at least one objective\n            if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n                total_improvement = (delta_1 + delta_2 + delta_3) / 3\n                if total_improvement < best_improvement:\n                    best_improvement = total_improvement\n                    best_k, best_l = k, l\n\n    if best_k != -1 and best_l != -1:\n        # Apply the best move found\n        new_solution[i+1:j+1] = np.concatenate([new_solution[best_k:best_l+1][::-1], new_solution[i+1:best_k], new_solution[best_l+1:j+1]])\n\n    return new_solution\n\n",
        "score": [
            -0.4165933132095098,
            2.754225420951843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: max(x[1]) - min(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = np.random.choice(n_nodes, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate potential edges to reconnect\n    best_improvement = 0\n    best_k, best_l = -1, -1\n\n    for k in range(i + 1, j):\n        for l in range(k + 1, j + 1):\n            # Calculate the change in all three objectives\n            delta_1 = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]] -\n                       distance_matrix_1[new_solution[i], new_solution[j]] - distance_matrix_1[new_solution[k], new_solution[l]])\n            delta_2 = (distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]] -\n                       distance_matrix_2[new_solution[i], new_solution[j]] - distance_matrix_2[new_solution[k], new_solution[l]])\n            delta_3 = (distance_matrix_3[new_solution[i], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[l]] -\n                       distance_matrix_3[new_solution[i], new_solution[j]] - distance_matrix_3[new_solution[k], new_solution[l]])\n\n            # Objective-aware selection: prefer moves that improve at least one objective\n            if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n                total_improvement = (delta_1 + delta_2 + delta_3) / 3\n                if total_improvement < best_improvement:\n                    best_improvement = total_improvement\n                    best_k, best_l = k, l\n\n    if best_k != -1 and best_l != -1:\n        # Apply the best move found\n        new_solution[i+1:j+1] = np.concatenate([new_solution[best_k:best_l+1][::-1], new_solution[i+1:best_k], new_solution[best_l+1:j+1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    sum_objectives = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective-aware segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective-aware segment reversal: reverse a segment if it improves at least one objective\n    for _ in range(5):  # Limit iterations to balance exploration and computation\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Calculate new objectives\n        def calculate_objective(solution, distance_matrix):\n            total = 0\n            for k in range(n):\n                total += distance_matrix[solution[k], solution[(k+1)%n]]\n            return total\n\n        new_obj1 = calculate_objective(candidate, distance_matrix_1)\n        new_obj2 = calculate_objective(candidate, distance_matrix_2)\n        new_obj3 = calculate_objective(candidate, distance_matrix_3)\n\n        old_obj1 = calculate_objective(new_solution, distance_matrix_1)\n        old_obj2 = calculate_objective(new_solution, distance_matrix_2)\n        old_obj3 = calculate_objective(new_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_obj1 < old_obj1) or (new_obj2 < old_obj2) or (new_obj3 < old_obj3):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7208688422727987,
            3.121246373653412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    sum_objectives = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(sum_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective-aware segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective-aware segment reversal: reverse a segment if it improves at least one objective\n    for _ in range(5):  # Limit iterations to balance exploration and computation\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Calculate new objectives\n        def calculate_objective(solution, distance_matrix):\n            total = 0\n            for k in range(n):\n                total += distance_matrix[solution[k], solution[(k+1)%n]]\n            return total\n\n        new_obj1 = calculate_objective(candidate, distance_matrix_1)\n        new_obj2 = calculate_objective(candidate, distance_matrix_2)\n        new_obj3 = calculate_objective(candidate, distance_matrix_3)\n\n        old_obj1 = calculate_objective(new_solution, distance_matrix_1)\n        old_obj2 = calculate_objective(new_solution, distance_matrix_2)\n        old_obj3 = calculate_objective(new_solution, distance_matrix_3)\n\n        # Accept if at least one objective improves\n        if (new_obj1 < old_obj1) or (new_obj2 < old_obj2) or (new_obj3 < old_obj3):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance\n    obj1_var = np.var([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n    obj2_var = np.var([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n    obj3_var = np.var([distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n\n    if obj1_var > obj2_var and obj1_var > obj3_var:\n        # Apply 2-opt on first objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2_var > obj3_var:\n        # Apply 2-opt on second objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply 3-opt on third objective\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6705851150619001,
            1.4100041389465332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and 3-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance\n    obj1_var = np.var([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n    obj2_var = np.var([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n    obj3_var = np.var([distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n\n    if obj1_var > obj2_var and obj1_var > obj3_var:\n        # Apply 2-opt on first objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2_var > obj3_var:\n        # Apply 2-opt on second objective\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Apply 3-opt on third objective\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_solution[i:k+1] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt and relocate moves, weighted by objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective to prioritize for the move\n    obj_weights = np.array(archive_sorted[0][1])\n    obj_weights = obj_weights / np.sum(obj_weights)  # Normalize weights\n\n    # Randomly select a move type based on objective weights\n    move_type = np.random.choice(['2opt', 'relocate'], p=[0.7, 0.3])\n\n    if move_type == '2opt':\n        # Perform 2-opt swap with high potential for improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform relocate move with high potential for improvement\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [new_solution[i]], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.41419590076450097,
            0.9941761255264282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: max(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt and relocate moves, weighted by objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective to prioritize for the move\n    obj_weights = np.array(archive_sorted[0][1])\n    obj_weights = obj_weights / np.sum(obj_weights)  # Normalize weights\n\n    # Randomly select a move type based on objective weights\n    move_type = np.random.choice(['2opt', 'relocate'], p=[0.7, 0.3])\n\n    if move_type == '2opt':\n        # Perform 2-opt swap with high potential for improvement\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform relocate move with high potential for improvement\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [new_solution[i]], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 20% by objective sum)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_candidates = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_idx = np.random.randint(0, len(top_candidates))\n    base_solution = top_candidates[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to optimize\n    segment_start = np.random.randint(0, n)\n    segment_length = min(5, n - segment_start)\n    segment = new_solution[segment_start:segment_start+segment_length]\n\n    # Find the worst edge in the segment in any objective space\n    worst_edge = -1\n    worst_obj = -1\n    for i in range(len(segment)-1):\n        u, v = segment[i], segment[i+1]\n        obj1 = distance_matrix_1[u, v]\n        obj2 = distance_matrix_2[u, v]\n        obj3 = distance_matrix_3[u, v]\n        current_obj = max(obj1, obj2, obj3)\n        if current_obj > worst_obj:\n            worst_obj = current_obj\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Perform 2-opt on the worst edge\n        i = worst_edge\n        j = (i + 1) % len(segment)\n        if i < j:\n            segment[i:j+1] = segment[i:j+1][::-1]\n        else:\n            segment = np.concatenate([segment[j+1:], segment[:i+1][::-1]])\n\n        # Update the solution\n        new_solution[segment_start:segment_start+segment_length] = segment\n\n    # Optional: Apply a small random perturbation to escape local optima\n    if np.random.random() < 0.1:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6230819774450811,
            2.5551142573356627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly among top 20% by objective sum)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_candidates = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_idx = np.random.randint(0, len(top_candidates))\n    base_solution = top_candidates[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to optimize\n    segment_start = np.random.randint(0, n)\n    segment_length = min(5, n - segment_start)\n    segment = new_solution[segment_start:segment_start+segment_length]\n\n    # Find the worst edge in the segment in any objective space\n    worst_edge = -1\n    worst_obj = -1\n    for i in range(len(segment)-1):\n        u, v = segment[i], segment[i+1]\n        obj1 = distance_matrix_1[u, v]\n        obj2 = distance_matrix_2[u, v]\n        obj3 = distance_matrix_3[u, v]\n        current_obj = max(obj1, obj2, obj3)\n        if current_obj > worst_obj:\n            worst_obj = current_obj\n            worst_edge = i\n\n    if worst_edge != -1:\n        # Perform 2-opt on the worst edge\n        i = worst_edge\n        j = (i + 1) % len(segment)\n        if i < j:\n            segment[i:j+1] = segment[i:j+1][::-1]\n        else:\n            segment = np.concatenate([segment[j+1:], segment[:i+1][::-1]])\n\n        # Update the solution\n        new_solution[segment_start:segment_start+segment_length] = segment\n\n    # Optional: Apply a small random perturbation to escape local optima\n    if np.random.random() < 0.1:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and node insertion\n    new_solution = base_solution.copy()\n\n    # 2-opt for the first objective\n    i, j = np.random.randint(0, len(new_solution), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion for the second objective\n    k = np.random.randint(0, len(new_solution))\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6908274502304937,
            1.8834328532218934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and node insertion\n    new_solution = base_solution.copy()\n\n    # 2-opt for the first objective\n    i, j = np.random.randint(0, len(new_solution), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Node insertion for the second objective\n    k = np.random.randint(0, len(new_solution))\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective edge swap for further improvement\n    for _ in range(3):  # Limit the number of swaps to control computation\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n\n        # Evaluate the current and swapped configurations across all objectives\n        current_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n        )\n\n        swapped_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[k], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[k], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[k], new_solution[(j+1)%n]],\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[i], new_solution[(l+1)%n]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[i], new_solution[(l+1)%n]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[i], new_solution[(l+1)%n]]\n        )\n\n        # Accept swap if it improves at least one objective without worsening others\n        if (swapped_costs[0] <= current_costs[0] and swapped_costs[1] <= current_costs[1]) or \\\n           (swapped_costs[0] <= current_costs[0] and swapped_costs[1] >= current_costs[1] and objectives[0] < objectives[1]) or \\\n           (swapped_costs[0] >= current_costs[0] and swapped_costs[1] <= current_costs[1] and objectives[0] > objectives[1]):\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8275991175138561,
            1.2824483513832092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low objective values\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform multi-objective edge swap for further improvement\n    for _ in range(3):  # Limit the number of swaps to control computation\n        k, l = np.random.choice(n, size=2, replace=False)\n        if k > l:\n            k, l = l, k\n\n        # Evaluate the current and swapped configurations across all objectives\n        current_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_1[new_solution[k-1], new_solution[k]] +\n            distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_2[new_solution[k-1], new_solution[k]] +\n            distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n            distance_matrix_3[new_solution[k-1], new_solution[k]] +\n            distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n        )\n\n        swapped_costs = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[k], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[k], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[k], new_solution[(j+1)%n]],\n            distance_matrix_1[new_solution[k-1], new_solution[l]] +\n            distance_matrix_1[new_solution[i], new_solution[(l+1)%n]] +\n            distance_matrix_2[new_solution[k-1], new_solution[l]] +\n            distance_matrix_2[new_solution[i], new_solution[(l+1)%n]] +\n            distance_matrix_3[new_solution[k-1], new_solution[l]] +\n            distance_matrix_3[new_solution[i], new_solution[(l+1)%n]]\n        )\n\n        # Accept swap if it improves at least one objective without worsening others\n        if (swapped_costs[0] <= current_costs[0] and swapped_costs[1] <= current_costs[1]) or \\\n           (swapped_costs[0] <= current_costs[0] and swapped_costs[1] >= current_costs[1] and objectives[0] < objectives[1]) or \\\n           (swapped_costs[0] >= current_costs[0] and swapped_costs[1] <= current_costs[1] and objectives[0] > objectives[1]):\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: diversity_score(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid 3-opt local search: randomly choose between 2-opt and 3-opt moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.rand() < 0.5:  # 2-opt move\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 3-opt move\n        i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware edge selection: if the new solution is worse in all objectives, revert to the original\n    def is_dominated(a, b):\n        return all(x <= y for x, y in zip(a, b)) and any(x < y for x, y in zip(a, b))\n\n    original_obj = archive_sorted[0][1]\n    new_obj = (\n        np.sum([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n        np.sum([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n        np.sum([distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n    )\n\n    if is_dominated(new_obj, original_obj):\n        return base_solution\n    else:\n        return new_solution\n\n",
        "score": [
            -0.48647352259860605,
            2.338660275936127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def diversity_score(obj):\n        return max(obj) - min(obj)\n\n    archive_sorted = sorted(archive, key=lambda x: diversity_score(x[1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid 3-opt local search: randomly choose between 2-opt and 3-opt moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.rand() < 0.5:  # 2-opt move\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 3-opt move\n        i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Objective-aware edge selection: if the new solution is worse in all objectives, revert to the original\n    def is_dominated(a, b):\n        return all(x <= y for x, y in zip(a, b)) and any(x < y for x, y in zip(a, b))\n\n    original_obj = archive_sorted[0][1]\n    new_obj = (\n        np.sum([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n        np.sum([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n        np.sum([distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n    )\n\n    if is_dominated(new_obj, original_obj):\n        return base_solution\n    else:\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt for the first objective, then swap for others\n    new_solution = selected.copy()\n\n    # 2-opt for the first objective\n    i, j = np.random.randint(0, len(new_solution)-1, 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random swap to improve other objectives\n    k, l = np.random.randint(0, len(new_solution), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.47803951920655247,
            1.093818461894989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt for the first objective, then swap for others\n    new_solution = selected.copy()\n\n    # 2-opt for the first objective\n    i, j = np.random.randint(0, len(new_solution)-1, 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Random swap to improve other objectives\n    k, l = np.random.randint(0, len(new_solution), 2)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{A novel hybrid local search algorithm that combines 3-opt moves with objective-aware edge swaps to simultaneously optimize across all three objectives by intelligently selecting and perturbing edges based on their impact on multiple distance matrices.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Calculate total change in all three objectives\n        def get_change(a, b, c, d):\n            old_edges = [\n                (a, b), (b, c), (c, d),\n                (a, (a+1)%n), ((a+1)%n, b), (c, (c+1)%n), ((c+1)%n, d)\n            ]\n            new_edges = [\n                (a, c), (c, b), (b, d),\n                (a, c), (c, (c+1)%n), (b, (b+1)%n), ((b+1)%n, d)\n            ]\n            change = 0\n            for (u, v), (x, y) in zip(old_edges, new_edges):\n                change += (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) - \\\n                          (distance_matrix_1[x, y] + distance_matrix_2[x, y] + distance_matrix_3[x, y])\n            return change\n\n        current_change = get_change(i, j, k, (k+1)%n)\n\n        # Apply the move if it improves at least one objective\n        if current_change < 0:\n            # Perform 3-opt move\n            segment = new_solution[j:k+1]\n            new_solution[j:k+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7374990367027853,
            1.7892719149589538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (obj[0] + obj[1] + obj[2] + 1e-6) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(5):  # Number of perturbation attempts\n        # Select three distinct edges to modify\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Calculate total change in all three objectives\n        def get_change(a, b, c, d):\n            old_edges = [\n                (a, b), (b, c), (c, d),\n                (a, (a+1)%n), ((a+1)%n, b), (c, (c+1)%n), ((c+1)%n, d)\n            ]\n            new_edges = [\n                (a, c), (c, b), (b, d),\n                (a, c), (c, (c+1)%n), (b, (b+1)%n), ((b+1)%n, d)\n            ]\n            change = 0\n            for (u, v), (x, y) in zip(old_edges, new_edges):\n                change += (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) - \\\n                          (distance_matrix_1[x, y] + distance_matrix_2[x, y] + distance_matrix_3[x, y])\n            return change\n\n        current_change = get_change(i, j, k, (k+1)%n)\n\n        # Apply the move if it improves at least one objective\n        if current_change < 0:\n            # Perform 3-opt move\n            segment = new_solution[j:k+1]\n            new_solution[j:k+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware move selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment with probability based on objective improvement\n    if random.random() < 0.7:  # Higher probability for more exploration\n        segment = segment[::-1]\n\n    # Check feasibility and compute new objectives\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5637806547060535,
            2.6008375883102417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware move selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Reverse the segment with probability based on objective improvement\n    if random.random() < 0.7:  # Higher probability for more exploration\n        segment = segment[::-1]\n\n    # Check feasibility and compute new objectives\n    new_solution[a:b+1] = segment\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Determine the worst objective to focus on improving\n    worst_obj = np.argmax(np.array([obj for _, obj in archive]))\n\n    # Apply a hybrid local search: 2-opt with objective-aware segment swaps\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a segment to swap with another segment, prioritizing the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the most expensive segment in the worst objective\n    max_cost = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            cost = dist_matrix[new_solution[i-1], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n            if cost > max_cost:\n                max_cost = cost\n                best_i, best_j = i, j\n\n    # Swap the segments to potentially reduce cost\n    if best_i != best_j:\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6756795050678287,
            3.2950904726982118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Determine the worst objective to focus on improving\n    worst_obj = np.argmax(np.array([obj for _, obj in archive]))\n\n    # Apply a hybrid local search: 2-opt with objective-aware segment swaps\n    new_solution = best_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a segment to swap with another segment, prioritizing the worst objective\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the most expensive segment in the worst objective\n    max_cost = -1\n    best_i, best_j = 0, 0\n    for i in range(n):\n        for j in range(i+1, n):\n            cost = dist_matrix[new_solution[i-1], new_solution[i]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n            if cost > max_cost:\n                max_cost = cost\n                best_i, best_j = i, j\n\n    # Swap the segments to potentially reduce cost\n    if best_i != best_j:\n        new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Apply 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware perturbation: swap nodes if it improves the worst objective\n    for _ in range(3):  # Try up to 3 random swaps\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # If any objective improves, keep the swap\n        if any(new_obj < old_obj for new_obj, old_obj in zip([new_obj1, new_obj2, new_obj3], archive[selected_idx][1])):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6540993776661694,
            1.5815040588378906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware perturbation\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Apply 2-opt\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware perturbation: swap nodes if it improves the worst objective\n    for _ in range(3):  # Try up to 3 random swaps\n        a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_obj3 = sum(distance_matrix_3[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # If any objective improves, keep the swap\n        if any(new_obj < old_obj for new_obj, old_obj in zip([new_obj1, new_obj2, new_obj3], archive[selected_idx][1])):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Identify the worst-performing segment in any of the three objectives\n    worst_segment = None\n    max_cost = -1\n    for i in range(len(new_solution) - 1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[i+1]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost > max_cost:\n            max_cost = total_cost\n            worst_segment = (i, i+1)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    if worst_segment:\n        i, j = worst_segment\n        # Try reversing the segment between i and j\n        reversed_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Additionally, try swapping edges to improve the worst objective\n        worst_obj = np.argmax([sum(x[1]) for x in archive])\n        if worst_obj == 0:\n            d_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            d_matrix = distance_matrix_2\n        else:\n            d_matrix = distance_matrix_3\n\n        # Find the best possible edge swap to improve the worst objective\n        best_improvement = 0\n        best_swap = None\n        for k in range(i, j+1):\n            for l in range(k+1, j+1):\n                a, b = new_solution[k], new_solution[l]\n                if d_matrix[a][b] < d_matrix[new_solution[k]][new_solution[k+1]]:\n                    improvement = d_matrix[new_solution[k]][new_solution[k+1]] - d_matrix[a][b]\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (k, l)\n\n        if best_swap:\n            k, l = best_swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6427156221283518,
            1.7909520149230957
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Identify the worst-performing segment in any of the three objectives\n    worst_segment = None\n    max_cost = -1\n    for i in range(len(new_solution) - 1):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[i+1]]\n        total_cost = cost1 + cost2 + cost3\n        if total_cost > max_cost:\n            max_cost = total_cost\n            worst_segment = (i, i+1)\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    if worst_segment:\n        i, j = worst_segment\n        # Try reversing the segment between i and j\n        reversed_segment = new_solution[i:j+1][::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Additionally, try swapping edges to improve the worst objective\n        worst_obj = np.argmax([sum(x[1]) for x in archive])\n        if worst_obj == 0:\n            d_matrix = distance_matrix_1\n        elif worst_obj == 1:\n            d_matrix = distance_matrix_2\n        else:\n            d_matrix = distance_matrix_3\n\n        # Find the best possible edge swap to improve the worst objective\n        best_improvement = 0\n        best_swap = None\n        for k in range(i, j+1):\n            for l in range(k+1, j+1):\n                a, b = new_solution[k], new_solution[l]\n                if d_matrix[a][b] < d_matrix[new_solution[k]][new_solution[k+1]]:\n                    improvement = d_matrix[new_solution[k]][new_solution[k+1]] - d_matrix[a][b]\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_swap = (k, l)\n\n        if best_swap:\n            k, l = best_swap\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to optimize\n    start = np.random.randint(0, n - 1)\n    end = np.random.randint(start + 1, n)\n\n    # Calculate the current cost of the segment in all three objectives\n    current_cost = (\n        sum(distance_matrix_1[new_solution[i]][new_solution[(i + 1) % n]] for i in range(start, end + 1)),\n        sum(distance_matrix_2[new_solution[i]][new_solution[(i + 1) % n]] for i in range(start, end + 1)),\n        sum(distance_matrix_3[new_solution[i]][new_solution[(i + 1) % n]] for i in range(start, end + 1))\n    )\n\n    # Try reversing the segment\n    reversed_segment = np.concatenate([new_solution[:start], new_solution[start:end+1][::-1], new_solution[end+1:]])\n    reversed_cost = (\n        sum(distance_matrix_1[reversed_segment[i]][reversed_segment[(i + 1) % n]] for i in range(start, end + 1)),\n        sum(distance_matrix_2[reversed_segment[i]][reversed_segment[(i + 1) % n]] for i in range(start, end + 1)),\n        sum(distance_matrix_3[reversed_segment[i]][reversed_segment[(i + 1) % n]] for i in range(start, end + 1))\n    )\n\n    # If reversing improves at least one objective, accept it\n    if any(reversed_cost[i] < current_cost[i] for i in range(3)):\n        new_solution = reversed_segment\n\n    # Additionally, try swapping two nodes if it improves the trade-off across objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    swapped_solution = new_solution.copy()\n    swapped_solution[i], swapped_solution[j] = swapped_solution[j], swapped_solution[i]\n\n    swapped_cost = (\n        sum(distance_matrix_1[swapped_solution[k]][swapped_solution[(k + 1) % n]] for k in range(n)),\n        sum(distance_matrix_2[swapped_solution[k]][swapped_solution[(k + 1) % n]] for k in range(n)),\n        sum(distance_matrix_3[swapped_solution[k]][swapped_solution[(k + 1) % n]] for k in range(n))\n    )\n\n    # Accept swap if it improves the average objective value\n    if (swapped_cost[0] + swapped_cost[1] + swapped_cost[2]) / 3 < (current_cost[0] + current_cost[1] + current_cost[2]) / 3:\n        new_solution = swapped_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6651164908993774,
            1.852927565574646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to optimize\n    start = np.random.randint(0, n - 1)\n    end = np.random.randint(start + 1, n)\n\n    # Calculate the current cost of the segment in all three objectives\n    current_cost = (\n        sum(distance_matrix_1[new_solution[i]][new_solution[(i + 1) % n]] for i in range(start, end + 1)),\n        sum(distance_matrix_2[new_solution[i]][new_solution[(i + 1) % n]] for i in range(start, end + 1)),\n        sum(distance_matrix_3[new_solution[i]][new_solution[(i + 1) % n]] for i in range(start, end + 1))\n    )\n\n    # Try reversing the segment\n    reversed_segment = np.concatenate([new_solution[:start], new_solution[start:end+1][::-1], new_solution[end+1:]])\n    reversed_cost = (\n        sum(distance_matrix_1[reversed_segment[i]][reversed_segment[(i + 1) % n]] for i in range(start, end + 1)),\n        sum(distance_matrix_2[reversed_segment[i]][reversed_segment[(i + 1) % n]] for i in range(start, end + 1)),\n        sum(distance_matrix_3[reversed_segment[i]][reversed_segment[(i + 1) % n]] for i in range(start, end + 1))\n    )\n\n    # If reversing improves at least one objective, accept it\n    if any(reversed_cost[i] < current_cost[i] for i in range(3)):\n        new_solution = reversed_segment\n\n    # Additionally, try swapping two nodes if it improves the trade-off across objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    swapped_solution = new_solution.copy()\n    swapped_solution[i], swapped_solution[j] = swapped_solution[j], swapped_solution[i]\n\n    swapped_cost = (\n        sum(distance_matrix_1[swapped_solution[k]][swapped_solution[(k + 1) % n]] for k in range(n)),\n        sum(distance_matrix_2[swapped_solution[k]][swapped_solution[(k + 1) % n]] for k in range(n)),\n        sum(distance_matrix_3[swapped_solution[k]][swapped_solution[(k + 1) % n]] for k in range(n))\n    )\n\n    # Accept swap if it improves the average objective value\n    if (swapped_cost[0] + swapped_cost[1] + swapped_cost[2]) / 3 < (current_cost[0] + current_cost[1] + current_cost[2]) / 3:\n        new_solution = swapped_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high edge diversity and poor objectives\n        diversity_scores = []\n        for sol, obj in archive:\n            # Calculate edge diversity (number of unique edges in all three spaces)\n            edges = set()\n            for i in range(len(sol) - 1):\n                edges.add((sol[i], sol[i+1]))\n            diversity = len(edges)\n\n            # Calculate objective score (sum of normalized objectives)\n            obj_score = sum(obj) / (sum(archive[0][1]) + 1e-6)  # Avoid division by zero\n\n            diversity_scores.append(diversity * obj_score)\n\n        # Select solution with highest diversity * objective score\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a multi-objective-aware local search\n    n = len(base_solution)\n    if n > 3:\n        # Randomly select a segment to modify\n        seg_start = np.random.randint(0, n - 2)\n        seg_length = min(np.random.randint(1, n // 2), n - seg_start - 1)\n\n        # Extract the segment\n        segment = base_solution[seg_start:seg_start + seg_length + 1]\n\n        # Evaluate the segment's performance in all three objectives\n        seg_costs = [0.0, 0.0, 0.0]\n        for i in range(len(segment) - 1):\n            u, v = segment[i], segment[i+1]\n            seg_costs[0] += distance_matrix_1[u, v]\n            seg_costs[1] += distance_matrix_2[u, v]\n            seg_costs[2] += distance_matrix_3[u, v]\n\n        # Identify the worst objective in this segment\n        worst_obj = np.argmax(seg_costs)\n\n        # Apply a local search specific to the worst objective\n        if worst_obj == 0:\n            # For first objective, perform a 2-opt on this segment\n            if len(segment) > 2:\n                i, j = np.random.choice(len(segment) - 1, 2, replace=False)\n                i, j = min(i, j), max(i, j)\n                segment[i:j+1] = segment[i:j+1][::-1]\n        elif worst_obj == 1:\n            # For second objective, perform a node swap\n            if len(segment) > 1:\n                i, j = np.random.choice(len(segment), 2, replace=False)\n                segment[i], segment[j] = segment[j], segment[i]\n        else:\n            # For third objective, perform a node insertion\n            if len(segment) > 2:\n                i, j = np.random.choice(len(segment), 2, replace=False)\n                node = segment[j]\n                segment = np.delete(segment, j)\n                segment = np.insert(segment, i, node)\n\n        # Replace the segment in the solution\n        new_solution[seg_start:seg_start + seg_length + 1] = segment\n\n        # Ensure the solution remains a valid tour\n        if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7139258997021904,
            4.171407246589661
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high edge diversity and poor objectives\n        diversity_scores = []\n        for sol, obj in archive:\n            # Calculate edge diversity (number of unique edges in all three spaces)\n            edges = set()\n            for i in range(len(sol) - 1):\n                edges.add((sol[i], sol[i+1]))\n            diversity = len(edges)\n\n            # Calculate objective score (sum of normalized objectives)\n            obj_score = sum(obj) / (sum(archive[0][1]) + 1e-6)  # Avoid division by zero\n\n            diversity_scores.append(diversity * obj_score)\n\n        # Select solution with highest diversity * objective score\n        selected_idx = np.argmax(diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a multi-objective-aware local search\n    n = len(base_solution)\n    if n > 3:\n        # Randomly select a segment to modify\n        seg_start = np.random.randint(0, n - 2)\n        seg_length = min(np.random.randint(1, n // 2), n - seg_start - 1)\n\n        # Extract the segment\n        segment = base_solution[seg_start:seg_start + seg_length + 1]\n\n        # Evaluate the segment's performance in all three objectives\n        seg_costs = [0.0, 0.0, 0.0]\n        for i in range(len(segment) - 1):\n            u, v = segment[i], segment[i+1]\n            seg_costs[0] += distance_matrix_1[u, v]\n            seg_costs[1] += distance_matrix_2[u, v]\n            seg_costs[2] += distance_matrix_3[u, v]\n\n        # Identify the worst objective in this segment\n        worst_obj = np.argmax(seg_costs)\n\n        # Apply a local search specific to the worst objective\n        if worst_obj == 0:\n            # For first objective, perform a 2-opt on this segment\n            if len(segment) > 2:\n                i, j = np.random.choice(len(segment) - 1, 2, replace=False)\n                i, j = min(i, j), max(i, j)\n                segment[i:j+1] = segment[i:j+1][::-1]\n        elif worst_obj == 1:\n            # For second objective, perform a node swap\n            if len(segment) > 1:\n                i, j = np.random.choice(len(segment), 2, replace=False)\n                segment[i], segment[j] = segment[j], segment[i]\n        else:\n            # For third objective, perform a node insertion\n            if len(segment) > 2:\n                i, j = np.random.choice(len(segment), 2, replace=False)\n                node = segment[j]\n                segment = np.delete(segment, j)\n                segment = np.insert(segment, i, node)\n\n        # Replace the segment in the solution\n        new_solution[seg_start:seg_start + seg_length + 1] = segment\n\n        # Ensure the solution remains a valid tour\n        if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Perform a 2-opt move targeting the objective with the highest cost\n    obj1, obj2, obj3 = archive[0][1]\n    if obj1 >= obj2 and obj1 >= obj3:\n        # 2-opt in the first objective space\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 >= obj1 and obj2 >= obj3:\n        # 2-opt in the second objective space\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 2-opt in the third objective space\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility by checking for duplicate nodes\n    if len(set(new_solution)) != len(new_solution):\n        # If invalid, revert to a simple swap\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.67072579164465,
            1.6291157960891725
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Perform a 2-opt move targeting the objective with the highest cost\n    obj1, obj2, obj3 = archive[0][1]\n    if obj1 >= obj2 and obj1 >= obj3:\n        # 2-opt in the first objective space\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif obj2 >= obj1 and obj2 >= obj3:\n        # 2-opt in the second objective space\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 2-opt in the third objective space\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility by checking for duplicate nodes\n    if len(set(new_solution)) != len(new_solution):\n        # If invalid, revert to a simple swap\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7415540360034564,
            1.5676247000694274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a novel edge swap based on objective improvement potential\n    for _ in range(3):  # Limit iterations to balance exploration/exploitation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential objective values\n        current_obj = (\n            distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_1[selected_solution[b], selected_solution[(b+1)%n]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_2[selected_solution[b], selected_solution[(b+1)%n]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_3[selected_solution[b], selected_solution[(b+1)%n]]\n        )\n\n        potential_obj = (\n            distance_matrix_1[selected_solution[a-1], selected_solution[b]] +\n            distance_matrix_1[selected_solution[a], selected_solution[(b+1)%n]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[b]] +\n            distance_matrix_2[selected_solution[a], selected_solution[(b+1)%n]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[b]] +\n            distance_matrix_3[selected_solution[a], selected_solution[(b+1)%n]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_obj, current_obj)):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7389052099876331,
            1.6535884737968445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap (2-opt move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a novel edge swap based on objective improvement potential\n    for _ in range(3):  # Limit iterations to balance exploration/exploitation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential objective values\n        current_obj = (\n            distance_matrix_1[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_1[selected_solution[b], selected_solution[(b+1)%n]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_2[selected_solution[b], selected_solution[(b+1)%n]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[a]] +\n            distance_matrix_3[selected_solution[b], selected_solution[(b+1)%n]]\n        )\n\n        potential_obj = (\n            distance_matrix_1[selected_solution[a-1], selected_solution[b]] +\n            distance_matrix_1[selected_solution[a], selected_solution[(b+1)%n]],\n            distance_matrix_2[selected_solution[a-1], selected_solution[b]] +\n            distance_matrix_2[selected_solution[a], selected_solution[(b+1)%n]],\n            distance_matrix_3[selected_solution[a-1], selected_solution[b]] +\n            distance_matrix_3[selected_solution[a], selected_solution[(b+1)%n]]\n        )\n\n        # Accept if at least one objective improves\n        if any(p < c for p, c in zip(potential_obj, current_obj)):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or least dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt swap\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.5:\n        node_to_move = np.random.choice(base_solution)\n        pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, pos, node_to_move)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][1])\n\n    # Objective-aware swapping\n    if np.random.rand() < 0.3:\n        obj_weights = np.random.rand(3)\n        obj_weights /= obj_weights.sum()\n\n        # Calculate edge costs in all three objectives\n        def edge_cost(i, j):\n            return (obj_weights[0] * distance_matrix_1[i, j] +\n                    obj_weights[1] * distance_matrix_2[i, j] +\n                    obj_weights[2] * distance_matrix_3[i, j])\n\n        # Find the best swap\n        best_cost = float('inf')\n        best_swap = None\n        for i in range(n):\n            for j in range(i+1, n):\n                # Current cost\n                current_cost = (edge_cost(base_solution[i-1], base_solution[i]) +\n                               edge_cost(base_solution[j-1], base_solution[j]) +\n                               edge_cost(base_solution[i], base_solution[j]))\n\n                # Swapped cost\n                swapped_cost = (edge_cost(base_solution[i-1], base_solution[j]) +\n                               edge_cost(base_solution[j-1], base_solution[i]) +\n                               edge_cost(base_solution[j], base_solution[i]))\n\n                if swapped_cost < best_cost:\n                    best_cost = swapped_cost\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7546445202367003,
            3.349270391464233
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or least dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt swap\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Objective-aware node insertion\n    if np.random.rand() < 0.5:\n        node_to_move = np.random.choice(base_solution)\n        pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, pos, node_to_move)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][1])\n\n    # Objective-aware swapping\n    if np.random.rand() < 0.3:\n        obj_weights = np.random.rand(3)\n        obj_weights /= obj_weights.sum()\n\n        # Calculate edge costs in all three objectives\n        def edge_cost(i, j):\n            return (obj_weights[0] * distance_matrix_1[i, j] +\n                    obj_weights[1] * distance_matrix_2[i, j] +\n                    obj_weights[2] * distance_matrix_3[i, j])\n\n        # Find the best swap\n        best_cost = float('inf')\n        best_swap = None\n        for i in range(n):\n            for j in range(i+1, n):\n                # Current cost\n                current_cost = (edge_cost(base_solution[i-1], base_solution[i]) +\n                               edge_cost(base_solution[j-1], base_solution[j]) +\n                               edge_cost(base_solution[i], base_solution[j]))\n\n                # Swapped cost\n                swapped_cost = (edge_cost(base_solution[i-1], base_solution[j]) +\n                               edge_cost(base_solution[j-1], base_solution[i]) +\n                               edge_cost(base_solution[j], base_solution[i]))\n\n                if swapped_cost < best_cost:\n                    best_cost = swapped_cost\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            i, j = best_swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel multi-objective edge swap: identify edges with high potential for improvement\n    # across all three objectives\n    for _ in range(3):  # Perform multiple swaps to explore different improvements\n        # Find the worst edge in terms of all three objectives\n        worst_edge = -1\n        worst_value = -float('inf')\n\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1) % n]\n            # Calculate the sum of distances across all three objectives\n            total_dist = (distance_matrix_1[node1, node2] +\n                          distance_matrix_2[node1, node2] +\n                          distance_matrix_3[node1, node2])\n            if total_dist > worst_value:\n                worst_value = total_dist\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Find the best possible swap to replace this worst edge\n            best_swap = -1\n            best_value = float('inf')\n\n            for l in range(n):\n                if l == worst_edge or l == (worst_edge + 1) % n:\n                    continue\n\n                # Try swapping node at worst_edge with node at l\n                temp_solution = new_solution.copy()\n                temp_solution[worst_edge], temp_solution[l] = temp_solution[l], temp_solution[worst_edge]\n\n                # Calculate new total distance\n                node1 = temp_solution[worst_edge]\n                node2 = temp_solution[(worst_edge + 1) % n]\n                total_dist = (distance_matrix_1[node1, node2] +\n                              distance_matrix_2[node1, node2] +\n                              distance_matrix_3[node1, node2])\n\n                if total_dist < best_value:\n                    best_value = total_dist\n                    best_swap = l\n\n            if best_swap != -1:\n                new_solution[worst_edge], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.6237350571152769,
            1.8163127660751344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel multi-objective edge swap: identify edges with high potential for improvement\n    # across all three objectives\n    for _ in range(3):  # Perform multiple swaps to explore different improvements\n        # Find the worst edge in terms of all three objectives\n        worst_edge = -1\n        worst_value = -float('inf')\n\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1) % n]\n            # Calculate the sum of distances across all three objectives\n            total_dist = (distance_matrix_1[node1, node2] +\n                          distance_matrix_2[node1, node2] +\n                          distance_matrix_3[node1, node2])\n            if total_dist > worst_value:\n                worst_value = total_dist\n                worst_edge = k\n\n        if worst_edge != -1:\n            # Find the best possible swap to replace this worst edge\n            best_swap = -1\n            best_value = float('inf')\n\n            for l in range(n):\n                if l == worst_edge or l == (worst_edge + 1) % n:\n                    continue\n\n                # Try swapping node at worst_edge with node at l\n                temp_solution = new_solution.copy()\n                temp_solution[worst_edge], temp_solution[l] = temp_solution[l], temp_solution[worst_edge]\n\n                # Calculate new total distance\n                node1 = temp_solution[worst_edge]\n                node2 = temp_solution[(worst_edge + 1) % n]\n                total_dist = (distance_matrix_1[node1, node2] +\n                              distance_matrix_2[node1, node2] +\n                              distance_matrix_3[node1, node2])\n\n                if total_dist < best_value:\n                    best_value = total_dist\n                    best_swap = l\n\n            if best_swap != -1:\n                new_solution[worst_edge], new_solution[best_swap] = new_solution[best_swap], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high diversity or low cost\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate edges in all three objectives\n    edges = []\n    for k in range(i, j):\n        node1 = base_solution[k]\n        node2 = base_solution[(k + 1) % n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        edges.append((cost1 + cost2 + cost3, k))\n\n    if edges:\n        # Select the worst edge to improve based on combined objectives\n        worst_edge = max(edges, key=lambda x: x[0])[1]\n        # Reverse the segment between worst_edge and j\n        new_solution[worst_edge:j+1] = base_solution[worst_edge:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7529968081182866,
            1.5034884691238404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high diversity or low cost\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Evaluate edges in all three objectives\n    edges = []\n    for k in range(i, j):\n        node1 = base_solution[k]\n        node2 = base_solution[(k + 1) % n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        cost3 = distance_matrix_3[node1, node2]\n        edges.append((cost1 + cost2 + cost3, k))\n\n    if edges:\n        # Select the worst edge to improve based on combined objectives\n        worst_edge = max(edges, key=lambda x: x[0])[1]\n        # Reverse the segment between worst_edge and j\n        new_solution[worst_edge:j+1] = base_solution[worst_edge:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt combined with objective-aware edge swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap between edges (i,j) and (k,l)\n    if i < k:\n        new_solution[i:k] = base_solution[i:k][::-1]\n        new_solution[k:j] = base_solution[k:j][::-1]\n    else:\n        new_solution[k:i] = base_solution[k:i][::-1]\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Further refine by swapping edges based on the worst-performing objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the worst objective space\n    worst_edge = None\n    max_dist = -1\n    for idx in range(n):\n        u = base_solution[idx]\n        v = base_solution[(idx + 1) % n]\n        if distance_matrix[u, v] > max_dist:\n            max_dist = distance_matrix[u, v]\n            worst_edge = idx\n\n    # Replace the worst edge with a random better edge\n    if worst_edge is not None:\n        candidates = []\n        for idx in range(n):\n            if idx != worst_edge:\n                u = base_solution[idx]\n                v = base_solution[(idx + 1) % n]\n                if distance_matrix[u, v] < max_dist:\n                    candidates.append(idx)\n\n        if candidates:\n            swap_idx = np.random.choice(candidates)\n            new_solution[worst_edge], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.7819554897442764,
            1.4698484063148498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt combined with objective-aware edge swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap between edges (i,j) and (k,l)\n    if i < k:\n        new_solution[i:k] = base_solution[i:k][::-1]\n        new_solution[k:j] = base_solution[k:j][::-1]\n    else:\n        new_solution[k:i] = base_solution[k:i][::-1]\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Further refine by swapping edges based on the worst-performing objective\n    objectives = archive[selected_idx][1]\n    worst_obj = np.argmax(objectives)\n\n    if worst_obj == 0:\n        distance_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        distance_matrix = distance_matrix_2\n    else:\n        distance_matrix = distance_matrix_3\n\n    # Find the worst edge in the worst objective space\n    worst_edge = None\n    max_dist = -1\n    for idx in range(n):\n        u = base_solution[idx]\n        v = base_solution[(idx + 1) % n]\n        if distance_matrix[u, v] > max_dist:\n            max_dist = distance_matrix[u, v]\n            worst_edge = idx\n\n    # Replace the worst edge with a random better edge\n    if worst_edge is not None:\n        candidates = []\n        for idx in range(n):\n            if idx != worst_edge:\n                u = base_solution[idx]\n                v = base_solution[(idx + 1) % n]\n                if distance_matrix[u, v] < max_dist:\n                    candidates.append(idx)\n\n        if candidates:\n            swap_idx = np.random.choice(candidates)\n            new_solution[worst_edge], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with high potential\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Randomly select from the top 30% of solutions\n        selected_idx = np.random.randint(0, max(1, int(0.3 * len(sorted_solutions))))\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with objective-aware perturbations\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Objective-aware edge swap\n        # Select a random segment and reverse it\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n))\n        end = (start + length) % n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            segment = segment[::-1]\n            new_solution = np.concatenate([segment[-(n-start):], new_solution[end:start], segment[:-(n-start)]])\n\n        # Objective-aware perturbation: swap nodes based on the most improving objective\n        i, j = np.random.choice(n, 2, replace=False)\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        ]\n\n        # Accept the swap if it improves at least one objective\n        if any(new_costs[k] < current_costs[k] for k in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7443594148330726,
            1.714569866657257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with high potential\n        sorted_solutions = sorted(archive, key=lambda x: sum(x[1]))\n        # Randomly select from the top 30% of solutions\n        selected_idx = np.random.randint(0, max(1, int(0.3 * len(sorted_solutions))))\n        base_solution = sorted_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with objective-aware perturbations\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for small instances\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Objective-aware edge swap\n        # Select a random segment and reverse it\n        start = np.random.randint(0, n)\n        length = np.random.randint(2, min(5, n))\n        end = (start + length) % n\n        if start < end:\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end]])\n            segment = segment[::-1]\n            new_solution = np.concatenate([segment[-(n-start):], new_solution[end:start], segment[:-(n-start)]])\n\n        # Objective-aware perturbation: swap nodes based on the most improving objective\n        i, j = np.random.choice(n, 2, replace=False)\n        current_costs = [\n            sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k-1], new_solution[k]] for k in range(n))\n        ]\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        new_costs = [\n            sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n)),\n            sum(distance_matrix_3[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        ]\n\n        # Accept the swap if it improves at least one objective\n        if any(new_costs[k] < current_costs[k] for k in range(3)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a 3-opt move to further improve the solution\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible\n    _, counts = np.unique(new_solution, return_counts=True)\n    if not np.all(counts == 1):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7876182462835436,
            1.6215683221817017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a 3-opt move to further improve the solution\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n    # Ensure the solution remains feasible\n    _, counts = np.unique(new_solution, return_counts=True)\n    if not np.all(counts == 1):\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects solutions from the archive based on their objective diversity and applies a multi-objective 3-opt move with adaptive perturbation to explore trade-offs across the three objective spaces, ensuring feasibility while promoting high-quality solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(solution):\n        obj1, obj2, obj3 = solution[1]\n        return abs(obj1 - obj2) + abs(obj2 - obj3) + abs(obj3 - obj1)\n\n    archive_with_diversity = [(sol, obj, objective_diversity((sol, obj))) for sol, obj in archive]\n    archive_with_diversity.sort(key=lambda x: -x[2])\n\n    # Select top 20% of solutions with highest diversity\n    top_diversity = archive_with_diversity[:max(1, len(archive_with_diversity) // 5)]\n    selected_solution = random.choice(top_diversity)[0].copy()\n\n    # Apply multi-objective 3-opt with adaptive perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Determine which objective to prioritize for the move\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights by default\n    obj_values = np.array([distance_matrix_1[new_solution[i], new_solution[j]],\n                           distance_matrix_2[new_solution[i], new_solution[j]],\n                           distance_matrix_3[new_solution[i], new_solution[j]]])\n\n    # Adaptive perturbation based on objective values\n    if np.sum(obj_values) > 0:\n        obj_weights = obj_values / np.sum(obj_values)\n\n    # Apply the 3-opt move with weighted probability\n    if random.random() < obj_weights[0]:\n        # Standard 3-opt move in first objective space\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif random.random() < obj_weights[1]:\n        # 3-opt with perturbation in second objective space\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n    else:\n        # 3-opt with perturbation in third objective space\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler 2-opt move if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5291818606606957,
            1.6951814413070678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    def objective_diversity(solution):\n        obj1, obj2, obj3 = solution[1]\n        return abs(obj1 - obj2) + abs(obj2 - obj3) + abs(obj3 - obj1)\n\n    archive_with_diversity = [(sol, obj, objective_diversity((sol, obj))) for sol, obj in archive]\n    archive_with_diversity.sort(key=lambda x: -x[2])\n\n    # Select top 20% of solutions with highest diversity\n    top_diversity = archive_with_diversity[:max(1, len(archive_with_diversity) // 5)]\n    selected_solution = random.choice(top_diversity)[0].copy()\n\n    # Apply multi-objective 3-opt with adaptive perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Determine which objective to prioritize for the move\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights by default\n    obj_values = np.array([distance_matrix_1[new_solution[i], new_solution[j]],\n                           distance_matrix_2[new_solution[i], new_solution[j]],\n                           distance_matrix_3[new_solution[i], new_solution[j]]])\n\n    # Adaptive perturbation based on objective values\n    if np.sum(obj_values) > 0:\n        obj_weights = obj_values / np.sum(obj_values)\n\n    # Apply the 3-opt move with weighted probability\n    if random.random() < obj_weights[0]:\n        # Standard 3-opt move in first objective space\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    elif random.random() < obj_weights[1]:\n        # 3-opt with perturbation in second objective space\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n    else:\n        # 3-opt with perturbation in third objective space\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler 2-opt move if invalid\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Ensure edges are distinct and non-overlapping\n    while abs(i - j) <= 1 or abs(k - l) <= 1 or {i, j} & {k, l}:\n        i, j = np.random.choice(n, 2, replace=False)\n        k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Verify feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert and try a different approach\n        new_solution = base_solution.copy()\n        # Apply 2-opt with the most promising edge based on distance matrices\n        for _ in range(10):  # Try 10 random 2-opts\n            i, j = np.random.choice(n, 2, replace=False)\n            if abs(i - j) > 1:\n                # Calculate total improvement across all objectives\n                delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j+1]]) + \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[j+1]])\n                if delta < 0:  # If improvement, perform the swap\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6595321011592217,
            1.5674658060073852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    k, l = np.random.choice(n, 2, replace=False)\n\n    # Ensure edges are distinct and non-overlapping\n    while abs(i - j) <= 1 or abs(k - l) <= 1 or {i, j} & {k, l}:\n        i, j = np.random.choice(n, 2, replace=False)\n        k, l = np.random.choice(n, 2, replace=False)\n\n    # Perform the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Verify feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert and try a different approach\n        new_solution = base_solution.copy()\n        # Apply 2-opt with the most promising edge based on distance matrices\n        for _ in range(10):  # Try 10 random 2-opts\n            i, j = np.random.choice(n, 2, replace=False)\n            if abs(i - j) > 1:\n                # Calculate total improvement across all objectives\n                delta = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j+1]] -\n                         distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[j], new_solution[j+1]]) + \\\n                        (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j+1]] -\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[j], new_solution[j+1]]) + \\\n                        (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[j+1]] -\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[j], new_solution[j+1]])\n                if delta < 0:  # If improvement, perform the swap\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    best_improvement = -1\n    best_i, best_j = -1, -1\n\n    # Evaluate all possible 2-opt moves across objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Current edges: (i, i+1) and (j, j+1)\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            # New edges: (a, c) and (b, d)\n            obj1 = distance_matrix_1[a, c] + distance_matrix_1[b, d] - distance_matrix_1[a, b] - distance_matrix_1[c, d]\n            obj2 = distance_matrix_2[a, c] + distance_matrix_2[b, d] - distance_matrix_2[a, b] - distance_matrix_2[c, d]\n            obj3 = distance_matrix_3[a, c] + distance_matrix_3[b, d] - distance_matrix_3[a, b] - distance_matrix_3[c, d]\n\n            # Calculate weighted improvement (prioritize objectives with higher potential)\n            improvement = - (obj1 + obj2 + obj3)  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Apply the best 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7381872933188014,
            3.63622909784317
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    best_improvement = -1\n    best_i, best_j = -1, -1\n\n    # Evaluate all possible 2-opt moves across objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Current edges: (i, i+1) and (j, j+1)\n            a, b = new_solution[i], new_solution[(i+1)%n]\n            c, d = new_solution[j], new_solution[(j+1)%n]\n\n            # New edges: (a, c) and (b, d)\n            obj1 = distance_matrix_1[a, c] + distance_matrix_1[b, d] - distance_matrix_1[a, b] - distance_matrix_1[c, d]\n            obj2 = distance_matrix_2[a, c] + distance_matrix_2[b, d] - distance_matrix_2[a, b] - distance_matrix_2[c, d]\n            obj3 = distance_matrix_3[a, c] + distance_matrix_3[b, d] - distance_matrix_3[a, b] - distance_matrix_3[c, d]\n\n            # Calculate weighted improvement (prioritize objectives with higher potential)\n            improvement = - (obj1 + obj2 + obj3)  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Apply the best 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.std(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt for two objectives, 3-opt for the third\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(i + 1, j) if j - i > 1 else -1\n\n        # Apply 2-opt for objectives 1 and 2\n        if np.random.rand() < 0.7:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply 3-opt for objective 3 (if possible)\n        if k != -1 and np.random.rand() < 0.3:\n            segment = new_solution[i:j]\n            segment = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n            new_solution[i:j] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.5635555265621915,
            4.406428074836731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.std(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt for two objectives, 3-opt for the third\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k = np.random.randint(i + 1, j) if j - i > 1 else -1\n\n        # Apply 2-opt for objectives 1 and 2\n        if np.random.rand() < 0.7:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply 3-opt for objective 3 (if possible)\n        if k != -1 and np.random.rand() < 0.3:\n            segment = new_solution[i:j]\n            segment = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n            new_solution[i:j] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()  # Select worst solution in archive\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 2-opt on a random segment\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l and (k+1) % n != l:\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7235540425348732,
            1.4407962679862976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()  # Select worst solution in archive\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with random segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 2-opt on a random segment\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l and (k+1) % n != l:\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def normalize_objective(obj):\n        return (obj[0] / max(distance_matrix_1.sum(), 1e-6),\n                obj[1] / max(distance_matrix_2.sum(), 1e-6),\n                obj[2] / max(distance_matrix_3.sum(), 1e-6))\n\n    normalized_archive = [(sol, normalize_objective(obj)) for sol, obj in archive]\n    selected_solution = max(normalized_archive, key=lambda x: sum(x[1]))[0]\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (ensuring no revisits)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains a valid tour\n    if i != k and j != l:\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7137021408521951,
            4.1745269179344175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def normalize_objective(obj):\n        return (obj[0] / max(distance_matrix_1.sum(), 1e-6),\n                obj[1] / max(distance_matrix_2.sum(), 1e-6),\n                obj[2] / max(distance_matrix_3.sum(), 1e-6))\n\n    normalized_archive = [(sol, normalize_objective(obj)) for sol, obj in archive]\n    selected_solution = max(normalized_archive, key=lambda x: sum(x[1]))[0]\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (ensuring no revisits)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains a valid tour\n    if i != k and j != l:\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt and relocate moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt like move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Relocate a random node to a random position\n    k = np.random.randint(n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7176385663918803,
            1.3585272669792174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt and relocate moves\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt like move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Relocate a random node to a random position\n    k = np.random.randint(n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_pos = np.random.randint(n-1)\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{A novel tri-objective local search heuristic that intelligently selects solutions from the archive based on their objective diversity and applies a hybrid 2-opt and node-swapping operator tailored for three objectives to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid 2-opt and node-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node-swapping\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node-swapping move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicate nodes\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if infeasible\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6624055215991087,
            1.7244550943374635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid 2-opt and node-swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and node-swapping\n    if np.random.rand() < 0.5:\n        # 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node-swapping move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicate nodes\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if infeasible\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives to prioritize those with higher potential\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[-1][0].copy()  # Select the solution with the highest sum of objectives\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Hybrid operator: Combine 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Evaluate the impact on all three objectives\n        delta_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] +\n                   distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[k]]) - \\\n                  (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] +\n                   distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[k]]) - \\\n                  (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        delta_3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[i]] +\n                   distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l], new_solution[k]]) - \\\n                  (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n        # Accept the move if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6470815988236661,
            2.5176236152648928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives to prioritize those with higher potential\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[-1][0].copy()  # Select the solution with the highest sum of objectives\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n\n    # Hybrid operator: Combine 2-opt with multi-objective edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit the number of iterations to balance exploration and exploitation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Evaluate the impact on all three objectives\n        delta_1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] +\n                   distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[l], new_solution[k]]) - \\\n                  (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]])\n\n        delta_2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] +\n                   distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[l], new_solution[k]]) - \\\n                  (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]])\n\n        delta_3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[i]] +\n                   distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[l], new_solution[k]]) - \\\n                  (distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                   distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l-1], new_solution[l]])\n\n        # Accept the move if it improves at least one objective\n        if delta_1 < 0 or delta_2 < 0 or delta_3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective consideration\n    N = len(base_solution)\n    i, j = sorted(np.random.choice(N, 2, replace=False))\n\n    # Check if reversing the segment improves any objective\n    current_cost = (\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%N]] for k in range(N)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%N]] for k in range(N)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%N]] for k in range(N))\n    )\n\n    # Create candidate solution with reversed segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new cost\n    new_cost = (\n        sum(distance_matrix_1[candidate[k], candidate[(k+1)%N]] for k in range(N)),\n        sum(distance_matrix_2[candidate[k], candidate[(k+1)%N]] for k in range(N)),\n        sum(distance_matrix_3[candidate[k], candidate[(k+1)%N]] for k in range(N))\n    )\n\n    # Accept if at least one objective improves\n    if any(new_cost[obj] < current_cost[obj] for obj in range(3)):\n        new_solution = candidate\n\n    # Additional improvement: try a random 2-opt with probability 0.3\n    if np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7055858374238433,
            1.7892520904541016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective consideration\n    N = len(base_solution)\n    i, j = sorted(np.random.choice(N, 2, replace=False))\n\n    # Check if reversing the segment improves any objective\n    current_cost = (\n        sum(distance_matrix_1[base_solution[k], base_solution[(k+1)%N]] for k in range(N)),\n        sum(distance_matrix_2[base_solution[k], base_solution[(k+1)%N]] for k in range(N)),\n        sum(distance_matrix_3[base_solution[k], base_solution[(k+1)%N]] for k in range(N))\n    )\n\n    # Create candidate solution with reversed segment\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new cost\n    new_cost = (\n        sum(distance_matrix_1[candidate[k], candidate[(k+1)%N]] for k in range(N)),\n        sum(distance_matrix_2[candidate[k], candidate[(k+1)%N]] for k in range(N)),\n        sum(distance_matrix_3[candidate[k], candidate[(k+1)%N]] for k in range(N))\n    )\n\n    # Accept if at least one objective improves\n    if any(new_cost[obj] < current_cost[obj] for obj in range(3)):\n        new_solution = candidate\n\n    # Additional improvement: try a random 2-opt with probability 0.3\n    if np.random.random() < 0.3:\n        i, j = sorted(np.random.choice(N, 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Perform a hybrid 3-opt local search with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate all possible 3-opt moves and evaluate their impact on all three objectives\n    best_move = None\n    best_improvement = 0\n\n    # Try all possible 3-opt configurations\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n        candidate[b:c] = candidate[b:c][::-1]\n        candidate[a:c] = candidate[a:c][::-1]\n\n        # Calculate improvement across all three objectives\n        current_cost = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n        new_cost = (\n            sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        )\n\n        # Calculate weighted improvement (prioritize objectives with larger gaps)\n        improvement = sum((current_cost[i] - new_cost[i]) / (archive[0][1][i] + 1e-6) for i in range(3))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = candidate\n\n    if best_move is not None:\n        new_solution = best_move\n\n    # Apply a second-level perturbation if no improvement found\n    if best_improvement <= 0:\n        # Perform a random 2-opt move to escape local optima\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6525188822512903,
            3.3826875567436216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Perform a hybrid 3-opt local search with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to modify\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Generate all possible 3-opt moves and evaluate their impact on all three objectives\n    best_move = None\n    best_improvement = 0\n\n    # Try all possible 3-opt configurations\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n        candidate[b:c] = candidate[b:c][::-1]\n        candidate[a:c] = candidate[a:c][::-1]\n\n        # Calculate improvement across all three objectives\n        current_cost = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n        new_cost = (\n            sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        )\n\n        # Calculate weighted improvement (prioritize objectives with larger gaps)\n        improvement = sum((current_cost[i] - new_cost[i]) / (archive[0][1][i] + 1e-6) for i in range(3))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_move = candidate\n\n    if best_move is not None:\n        new_solution = best_move\n\n    # Apply a second-level perturbation if no improvement found\n    if best_improvement <= 0:\n        # Perform a random 2-opt move to escape local optima\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{A novel multi-objective local search heuristic that intelligently selects a solution from the archive based on its diversity and potential for improvement, then applies a hybrid operator combining 2-opt and adaptive segment swapping to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly choose between 2-opt or segment swap\n    if random.random() < 0.5:\n        # 2-opt operator\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Adaptive segment swap\n        segment_length = min(3, n // 2)\n        i = random.randint(0, n - segment_length)\n        j = random.randint(0, n - segment_length)\n        new_solution[i:i+segment_length], new_solution[j:j+segment_length] = new_solution[j:j+segment_length], new_solution[i:i+segment_length]\n\n    # Ensure feasibility (no duplicates)\n    if len(set(new_solution)) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7194373297925536,
            1.9732651233673095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly choose between 2-opt or segment swap\n    if random.random() < 0.5:\n        # 2-opt operator\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Adaptive segment swap\n        segment_length = min(3, n // 2)\n        i = random.randint(0, n - segment_length)\n        j = random.randint(0, n - segment_length)\n        new_solution[i:i+segment_length], new_solution[j:j+segment_length] = new_solution[j:j+segment_length], new_solution[i:i+segment_length]\n\n    # Ensure feasibility (no duplicates)\n    if len(set(new_solution)) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)[0]\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.45011382281060125,
            1.5317512154579163
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][1] - x[1][2])**2 + (x[1][2] - x[1][0])**2)[0]\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, n-1)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform node insertion\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, len(new_solution)-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the worst objective in one space)\n    worst_obj_index = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[worst_obj_index][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4484324152812483,
            1.1604955196380615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the worst objective in one space)\n    worst_obj_index = np.argmax([obj[0] for _, obj in archive])\n    base_solution = archive[worst_obj_index][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse the segment between i and j to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance in the objective space\n    def crowding_distance(sol):\n        objectives = [obj for _, obj in archive]\n        obj1 = [o[0] for o in objectives]\n        obj2 = [o[1] for o in objectives]\n        obj3 = [o[2] for o in objectives]\n\n        # Normalize objectives\n        min1, max1 = min(obj1), max(obj1)\n        min2, max2 = min(obj2), max(obj2)\n        min3, max3 = min(obj3), max(obj3)\n\n        norm_obj1 = [(o[0] - min1) / (max1 - min1) if max1 != min1 else 0 for _, o in archive]\n        norm_obj2 = [(o[1] - min2) / (max2 - min2) if max2 != min2 else 0 for _, o in archive]\n        norm_obj3 = [(o[2] - min3) / (max3 - min3) if max3 != min3 else 0 for _, o in archive]\n\n        # Calculate crowding distance\n        distances = []\n        for i in range(len(archive)):\n            left = i - 1 if i > 0 else len(archive) - 1\n            right = i + 1 if i < len(archive) - 1 else 0\n            distance = (abs(norm_obj1[right] - norm_obj1[left]) +\n                        abs(norm_obj2[right] - norm_obj2[left]) +\n                        abs(norm_obj3[right] - norm_obj3[left]))\n            distances.append(distance)\n\n        return distances\n\n    distances = crowding_distance(None)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a standard 2-opt\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform a multi-objective aware edge swap\n    def edge_swap_cost(a, b, c, d):\n        # Calculate cost difference for all three objectives\n        cost1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d] -\n                 distance_matrix_1[a, c] - distance_matrix_1[b, d])\n        cost2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d] -\n                 distance_matrix_2[a, c] - distance_matrix_2[b, d])\n        cost3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d] -\n                 distance_matrix_3[a, c] - distance_matrix_3[b, d])\n        return (cost1, cost2, cost3)\n\n    # Select a random edge to swap\n    a = random.randint(0, n-1)\n    b = (a + 1) % n\n    c = random.randint(0, n-1)\n    d = (c + 1) % n\n\n    # Ensure we don't create invalid edges\n    if a != c and a != d and b != c and b != d:\n        cost1, cost2, cost3 = edge_swap_cost(new_solution[a], new_solution[b],\n                                            new_solution[c], new_solution[d])\n        # Accept if it improves at least one objective\n        if cost1 < 0 or cost2 < 0 or cost3 < 0:\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.7635656493291247,
            1.6964406609535216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance in the objective space\n    def crowding_distance(sol):\n        objectives = [obj for _, obj in archive]\n        obj1 = [o[0] for o in objectives]\n        obj2 = [o[1] for o in objectives]\n        obj3 = [o[2] for o in objectives]\n\n        # Normalize objectives\n        min1, max1 = min(obj1), max(obj1)\n        min2, max2 = min(obj2), max(obj2)\n        min3, max3 = min(obj3), max(obj3)\n\n        norm_obj1 = [(o[0] - min1) / (max1 - min1) if max1 != min1 else 0 for _, o in archive]\n        norm_obj2 = [(o[1] - min2) / (max2 - min2) if max2 != min2 else 0 for _, o in archive]\n        norm_obj3 = [(o[2] - min3) / (max3 - min3) if max3 != min3 else 0 for _, o in archive]\n\n        # Calculate crowding distance\n        distances = []\n        for i in range(len(archive)):\n            left = i - 1 if i > 0 else len(archive) - 1\n            right = i + 1 if i < len(archive) - 1 else 0\n            distance = (abs(norm_obj1[right] - norm_obj1[left]) +\n                        abs(norm_obj2[right] - norm_obj2[left]) +\n                        abs(norm_obj3[right] - norm_obj3[left]))\n            distances.append(distance)\n\n        return distances\n\n    distances = crowding_distance(None)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First perform a standard 2-opt\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then perform a multi-objective aware edge swap\n    def edge_swap_cost(a, b, c, d):\n        # Calculate cost difference for all three objectives\n        cost1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d] -\n                 distance_matrix_1[a, c] - distance_matrix_1[b, d])\n        cost2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d] -\n                 distance_matrix_2[a, c] - distance_matrix_2[b, d])\n        cost3 = (distance_matrix_3[a, b] + distance_matrix_3[c, d] -\n                 distance_matrix_3[a, c] - distance_matrix_3[b, d])\n        return (cost1, cost2, cost3)\n\n    # Select a random edge to swap\n    a = random.randint(0, n-1)\n    b = (a + 1) % n\n    c = random.randint(0, n-1)\n    d = (c + 1) % n\n\n    # Ensure we don't create invalid edges\n    if a != c and a != d and b != c and b != d:\n        cost1, cost2, cost3 = edge_swap_cost(new_solution[a], new_solution[b],\n                                            new_solution[c], new_solution[d])\n        # Accept if it improves at least one objective\n        if cost1 < 0 or cost2 < 0 or cost3 < 0:\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(np.abs(x[1][0] - x[1][1])))  # Select based on objective diversity\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: combine 2-opt with a novel 3-way swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to maintain efficiency\n        # Randomly select three distinct positions\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply a 3-way swap to create a new neighbor\n        new_solution[a:b] = base_solution[a:b][::-1]  # Reverse segment\n        new_solution[b:c] = base_solution[b:c][::-1]  # Reverse another segment\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Perform a 2-opt swap to refine the solution\n    for _ in range(10):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n        # Ensure the solution remains valid\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.518480529927035,
            3.0564492106437684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.sum(np.abs(x[1][0] - x[1][1])))  # Select based on objective diversity\n    base_solution = selected_solution[0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: combine 2-opt with a novel 3-way swap\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to maintain efficiency\n        # Randomly select three distinct positions\n        a, b, c = np.random.choice(n, size=3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply a 3-way swap to create a new neighbor\n        new_solution[a:b] = base_solution[a:b][::-1]  # Reverse segment\n        new_solution[b:c] = base_solution[b:c][::-1]  # Reverse another segment\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Perform a 2-opt swap to refine the solution\n    for _ in range(10):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n        # Ensure the solution remains valid\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    selected_solution, selected_objective = min(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Objective-aware edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Calculate the change in objectives for the swap\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] if j < n-1 else distance_matrix_1[new_solution[j], new_solution[0]])\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[j+1]] if j < n-1 else distance_matrix_2[new_solution[j], new_solution[0]])\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[j+1]] if j < n-1 else distance_matrix_3[new_solution[j], new_solution[0]])\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-aware node insertion\n    for _ in range(5):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i != j:\n            # Calculate the change in objectives for the insertion\n            delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                        distance_matrix_1[new_solution[i-1], new_solution[i]]\n            delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                        distance_matrix_2[new_solution[i-1], new_solution[i]]\n            delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                        distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n            # Accept if at least one objective improves\n            if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(new_solution) or len(new_solution) != len(selected_solution):\n        new_solution = selected_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7048055570817319,
            2.4754398584365847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest objective values)\n    selected_solution, selected_objective = min(archive, key=lambda x: sum(x[1]))\n\n    # Make a copy of the selected solution\n    new_solution = selected_solution.copy()\n\n    # Objective-aware edge exchange\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Calculate the change in objectives for the swap\n        delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[j+1]] if j < n-1 else distance_matrix_1[new_solution[j], new_solution[0]])\n        delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[j+1]] if j < n-1 else distance_matrix_2[new_solution[j], new_solution[0]])\n        delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_3[new_solution[j], new_solution[j+1]] if j < n-1 else distance_matrix_3[new_solution[j], new_solution[0]])\n\n        # Accept if at least one objective improves\n        if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Objective-aware node insertion\n    for _ in range(5):\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i != j:\n            # Calculate the change in objectives for the insertion\n            delta_obj1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                        distance_matrix_1[new_solution[i-1], new_solution[i]]\n            delta_obj2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                        distance_matrix_2[new_solution[i-1], new_solution[i]]\n            delta_obj3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[j], new_solution[(i+1)%n]]) - \\\n                        distance_matrix_3[new_solution[i-1], new_solution[i]]\n\n            # Accept if at least one objective improves\n            if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                new_solution = np.insert(new_solution, i, new_solution[j])\n                new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(new_solution) or len(new_solution) != len(selected_solution):\n        new_solution = selected_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel tri-objective local search heuristic selects a solution from the archive with high potential for improvement, then applies a hybrid of edge-swap and segment-reversal operators tailored to the three objectives, while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        candidate_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        selected_idx = np.random.choice(len(candidate_solutions))\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid of edge-swap and segment-reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge-swap or segment-reversal\n    if np.random.random() < 0.5:\n        # Edge-swap: swap two adjacent edges\n        i = np.random.randint(0, n - 1)\n        new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n    else:\n        # Segment-reversal: reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to edge-swap as fallback\n        i = np.random.randint(0, n - 1)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6694487757832075,
            1.6088908553123473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        candidate_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        selected_idx = np.random.choice(len(candidate_solutions))\n        base_solution = candidate_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid of edge-swap and segment-reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between edge-swap or segment-reversal\n    if np.random.random() < 0.5:\n        # Edge-swap: swap two adjacent edges\n        i = np.random.randint(0, n - 1)\n        new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n    else:\n        # Segment-reversal: reverse a random segment\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to edge-swap as fallback\n        i = np.random.randint(0, n - 1)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already well-optimized)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    objectives = selected[1]\n\n    # Create a copy to modify\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Apply 2-opt to improve the solution in one objective\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Apply node insertion to improve another objective\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Apply objective-aware swaps to balance objectives\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]) + \\\n                 (distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]) + \\\n                 (distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]) + \\\n                 (distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7281397178939926,
            1.5942217588424683
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already well-optimized)\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    objectives = selected[1]\n\n    # Create a copy to modify\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Apply 2-opt to improve the solution in one objective\n    for _ in range(10):\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Apply node insertion to improve another objective\n    for _ in range(5):\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i == j:\n            continue\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 3: Apply objective-aware swaps to balance objectives\n    for _ in range(5):\n        i, j = random.sample(range(n), 2)\n        # Swap nodes if it improves at least one objective\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]) + \\\n                 (distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]) + \\\n                 (distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[j], new_solution[(i+1)%n]] -\n                  distance_matrix_3[new_solution[i-1], new_solution[i]] - distance_matrix_3[new_solution[i], new_solution[(i+1)%n]]) + \\\n                 (distance_matrix_3[new_solution[j-1], new_solution[i]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]] -\n                  distance_matrix_3[new_solution[j-1], new_solution[j]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure the swap maintains tour validity\n    if a != c and b != d:\n        # Perform the swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        # Apply objective-aware refinement: check if the swap improves any objective\n        original_cost = (\n            sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        )\n        new_cost = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Revert if no improvement in any objective\n        if all(new_cost[i] >= original_cost[i] for i in range(3)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.593270837082345,
            1.1468333005905151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure the swap maintains tour validity\n    if a != c and b != d:\n        # Perform the swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n        # Apply objective-aware refinement: check if the swap improves any objective\n        original_cost = (\n            sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        )\n        new_cost = (\n            sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        )\n\n        # Revert if no improvement in any objective\n        if all(new_cost[i] >= original_cost[i] for i in range(3)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments where improvement is likely\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the delta for each objective\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # If any objective improves, perform the swap\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7274479569686229,
            1.9365784168243407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Identify critical segments where improvement is likely\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the delta for each objective\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # If any objective improves, perform the swap\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two distinct random edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the edges are not adjacent or overlapping\n    while (j == k) or (abs(i - j) < 2) or (abs(k - l) < 2):\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Verify the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6738192904952182,
            1.4022084474563599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    best_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two distinct random edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the edges are not adjacent or overlapping\n    while (j == k) or (abs(i - j) < 2) or (abs(k - l) < 2):\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Verify the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the diversity of each solution in the archive (sum of normalized objective differences)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = np.sum(np.abs(normalized_objectives[:, np.newaxis, :] - normalized_objectives[np.newaxis, :, :]), axis=-1)\n    diversity = np.sum(diversity, axis=1)\n\n    # Select the solution with the highest diversity (most promising for improvement)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Perform a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n // 2))\n    seg_end = (seg_start + seg_length) % n\n\n    if seg_start < seg_end:\n        segment = new_solution[seg_start:seg_end]\n    else:\n        segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n\n    # Reverse the segment to create a 2-opt move\n    reversed_segment = segment[::-1]\n\n    # Update the solution\n    if seg_start < seg_end:\n        new_solution[seg_start:seg_end] = reversed_segment\n    else:\n        new_solution[seg_start:] = reversed_segment[:n-seg_start]\n        new_solution[:seg_end] = reversed_segment[n-seg_start:]\n\n    # Step 3: Apply a 3-opt move to further improve the solution\n    # Select three random edges to reconnect\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    # Reconnect the edges to form a new tour\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1],\n        new_solution[k+1:]\n    ])\n\n    return new_solution\n\n",
        "score": [
            -0.7009448965871027,
            2.713213932514191
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the diversity of each solution in the archive (sum of normalized objective differences)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity = np.sum(np.abs(normalized_objectives[:, np.newaxis, :] - normalized_objectives[np.newaxis, :, :]), axis=-1)\n    diversity = np.sum(diversity, axis=1)\n\n    # Select the solution with the highest diversity (most promising for improvement)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Perform a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n // 2))\n    seg_end = (seg_start + seg_length) % n\n\n    if seg_start < seg_end:\n        segment = new_solution[seg_start:seg_end]\n    else:\n        segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n\n    # Reverse the segment to create a 2-opt move\n    reversed_segment = segment[::-1]\n\n    # Update the solution\n    if seg_start < seg_end:\n        new_solution[seg_start:seg_end] = reversed_segment\n    else:\n        new_solution[seg_start:] = reversed_segment[:n-seg_start]\n        new_solution[:seg_end] = reversed_segment[n-seg_start:]\n\n    # Step 3: Apply a 3-opt move to further improve the solution\n    # Select three random edges to reconnect\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    # Reconnect the edges to form a new tour\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1],\n        new_solution[k+1:]\n    ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment for 2-opt\n    new_solution[i:j+1] = segment[::-1]\n\n    # Objective-aware swap: if the new solution is worse in one objective, try to improve it\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate original and new costs for all three objectives\n        original_costs = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        # Accept if at least one objective improves\n        if new_costs < original_costs:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5747534436474375,
            1.9867301821708678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment for 2-opt\n    new_solution[i:j+1] = segment[::-1]\n\n    # Objective-aware swap: if the new solution is worse in one objective, try to improve it\n    for _ in range(3):  # Limit iterations to avoid excessive computation\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate original and new costs for all three objectives\n        original_costs = (\n            distance_matrix_1[new_solution[a-1], new_solution[a]] +\n            distance_matrix_1[new_solution[b-1], new_solution[b]] +\n            distance_matrix_2[new_solution[a-1], new_solution[a]] +\n            distance_matrix_2[new_solution[b-1], new_solution[b]] +\n            distance_matrix_3[new_solution[a-1], new_solution[a]] +\n            distance_matrix_3[new_solution[b-1], new_solution[b]]\n        )\n\n        new_costs = (\n            distance_matrix_1[new_solution[a-1], new_solution[b]] +\n            distance_matrix_1[new_solution[b-1], new_solution[a]] +\n            distance_matrix_2[new_solution[a-1], new_solution[b]] +\n            distance_matrix_2[new_solution[b-1], new_solution[a]] +\n            distance_matrix_3[new_solution[a-1], new_solution[b]] +\n            distance_matrix_3[new_solution[b-1], new_solution[a]]\n        )\n\n        # Accept if at least one objective improves\n        if new_costs < original_costs:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential(solution):\n        obj1, obj2, obj3 = solution[1]\n        return obj1 + obj2 + obj3  # Sum of objectives as a proxy for potential\n\n    # Sort archive by potential (ascending) and select the one with the highest potential\n    archive_sorted = sorted(archive, key=lambda x: potential(x))\n    if len(archive_sorted) > 1:\n        base_solution = archive_sorted[-1][0].copy()\n    else:\n        base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid of 2-opt and edge exchange, tailored for tri-objective optimization\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt on the first two segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange on the second two segments\n    if k < l and j < i:  # Ensure no overlap\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != len(new_solution):\n        # Fallback to a simple 2-opt if edge exchange causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6829352345693731,
            1.4247138857841493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential(solution):\n        obj1, obj2, obj3 = solution[1]\n        return obj1 + obj2 + obj3  # Sum of objectives as a proxy for potential\n\n    # Sort archive by potential (ascending) and select the one with the highest potential\n    archive_sorted = sorted(archive, key=lambda x: potential(x))\n    if len(archive_sorted) > 1:\n        base_solution = archive_sorted[-1][0].copy()\n    else:\n        base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid of 2-opt and edge exchange, tailored for tri-objective optimization\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt on the first two segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange on the second two segments\n    if k < l and j < i:  # Ensure no overlap\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates\n    if len(set(new_solution)) != len(new_solution):\n        # Fallback to a simple 2-opt if edge exchange causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # 3D-aware 2-opt local search with objective-aware edge selection\n    for _ in range(5):  # Perform multiple iterations\n        # Select two edges to swap based on their impact on multiple objectives\n        i, j = sorted(np.random.choice(len(new_solution) - 1, 2, replace=False))\n        k, l = sorted(np.random.choice(len(new_solution) - 1, 2, replace=False))\n\n        # Calculate potential improvement across all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]] -\n                 (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]))\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]] -\n                 (distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]))\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[k], new_solution[l]] -\n                 (distance_matrix_3[new_solution[i], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[l]]))\n\n        # Accept the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Perform the 2-opt swap\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    # Ensure the solution remains a valid TSP tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7093238088477378,
            1.8826583743095398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # 3D-aware 2-opt local search with objective-aware edge selection\n    for _ in range(5):  # Perform multiple iterations\n        # Select two edges to swap based on their impact on multiple objectives\n        i, j = sorted(np.random.choice(len(new_solution) - 1, 2, replace=False))\n        k, l = sorted(np.random.choice(len(new_solution) - 1, 2, replace=False))\n\n        # Calculate potential improvement across all three objectives\n        delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]] -\n                 (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]))\n        delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]] -\n                 (distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]))\n        delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[k], new_solution[l]] -\n                 (distance_matrix_3[new_solution[i], new_solution[k]] + distance_matrix_3[new_solution[j], new_solution[l]]))\n\n        # Accept the move if it improves at least one objective\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            # Perform the 2-opt swap\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    # Ensure the solution remains a valid TSP tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments and reverse them (2-opt)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and reinsert it at a different position (node insertion)\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node))\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.67781747026483,
            1.4450363516807556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator combining 2-opt and node insertion\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments and reverse them (2-opt)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and reinsert it at a different position (node insertion)\n    node = random.choice(new_solution)\n    new_solution = np.delete(new_solution, np.where(new_solution == node))\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on a hybrid objective score\n    def compute_score(objective):\n        # Combine objectives into a single score using a weighted sum\n        # Weights can be adjusted based on problem characteristics\n        return 0.4 * objective[0] + 0.3 * objective[1] + 0.3 * objective[2]\n\n    # Sort solutions by their combined score (lower is better)\n    sorted_archive = sorted(archive, key=lambda x: compute_score(x[1]))\n    # Select top 10% of solutions for consideration\n    top_candidates = sorted_archive[:max(1, len(sorted_archive) // 10)]\n    # Randomly select one from top candidates\n    selected_idx = np.random.randint(0, len(top_candidates))\n    base_solution = top_candidates[selected_idx][0].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 2-opt with objective-aware edge swaps\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select two edges to modify\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt style move (swap edges)\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge swap\n        for _ in range(2):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if a != b:\n                # Calculate change in all three objectives\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b], new_solution[a]] -\n                          distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_1[new_solution[b], new_solution[b-1 if b < n-1 else 0]])\n\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b], new_solution[a]] -\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_2[new_solution[b], new_solution[b-1 if b < n-1 else 0]])\n\n                delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_3[new_solution[b], new_solution[a]] -\n                          distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_3[new_solution[b], new_solution[b-1 if b < n-1 else 0]])\n\n                # Accept if it improves at least one objective\n                if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7485957553572402,
            2.1642268896102905
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on a hybrid objective score\n    def compute_score(objective):\n        # Combine objectives into a single score using a weighted sum\n        # Weights can be adjusted based on problem characteristics\n        return 0.4 * objective[0] + 0.3 * objective[1] + 0.3 * objective[2]\n\n    # Sort solutions by their combined score (lower is better)\n    sorted_archive = sorted(archive, key=lambda x: compute_score(x[1]))\n    # Select top 10% of solutions for consideration\n    top_candidates = sorted_archive[:max(1, len(sorted_archive) // 10)]\n    # Randomly select one from top candidates\n    selected_idx = np.random.randint(0, len(top_candidates))\n    base_solution = top_candidates[selected_idx][0].copy()\n\n    # Step 2: Apply a novel hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 2-opt with objective-aware edge swaps\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select two edges to modify\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n\n        # 2-opt style move (swap edges)\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Objective-aware edge swap\n        for _ in range(2):\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            if a != b:\n                # Calculate change in all three objectives\n                delta1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b], new_solution[a]] -\n                          distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_1[new_solution[b], new_solution[b-1 if b < n-1 else 0]])\n\n                delta2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b], new_solution[a]] -\n                          distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_2[new_solution[b], new_solution[b-1 if b < n-1 else 0]])\n\n                delta3 = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_3[new_solution[b], new_solution[a]] -\n                          distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                          distance_matrix_3[new_solution[b], new_solution[b-1 if b < n-1 else 0]])\n\n                # Accept if it improves at least one objective\n                if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and path relinking\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: 2-opt local search to improve one objective\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Path relinking to balance objectives\n    k = np.random.randint(1, n)\n    for l in range(k, n):\n        if np.random.rand() < 0.5:\n            new_solution[l] = base_solution[l]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    missing = np.setdiff1d(np.arange(n), unique)\n    duplicates = unique[counts > 1]\n\n    for d in duplicates:\n        idx = np.where(new_solution == d)[0][1:]\n        for i in idx:\n            new_solution[i] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.760331066264631,
            1.8355472087860107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and path relinking\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: 2-opt local search to improve one objective\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Path relinking to balance objectives\n    k = np.random.randint(1, n)\n    for l in range(k, n):\n        if np.random.rand() < 0.5:\n            new_solution[l] = base_solution[l]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    missing = np.setdiff1d(np.arange(n), unique)\n    duplicates = unique[counts > 1]\n\n    for d in duplicates:\n        idx = np.where(new_solution == d)[0][1:]\n        for i in idx:\n            new_solution[i] = missing[0]\n            missing = missing[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt swap with objective-aware selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform the 2-opt swap\n    new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7043935217566373,
            1.9523559093475342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt swap with objective-aware selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform the 2-opt swap\n    new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search combining 2-opt and 3-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Randomly select segments for modification\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n\n        # Evaluate potential swap in each objective space\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n\n        # Create candidate solution by reversing segments\n        candidate = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n        candidate_costs = [\n            sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]],\n            sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]],\n            sum(distance_matrix_3[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(candidate_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7100586916748666,
            4.425532531738281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search combining 2-opt and 3-opt with objective-aware swaps\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Randomly select segments for modification\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n\n        # Evaluate potential swap in each objective space\n        original_costs = [\n            sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        ]\n\n        # Create candidate solution by reversing segments\n        candidate = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n        candidate_costs = [\n            sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_1[candidate[-1], candidate[0]],\n            sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_2[candidate[-1], candidate[0]],\n            sum(distance_matrix_3[candidate[i-1], candidate[i]] for i in range(n)) + distance_matrix_3[candidate[-1], candidate[0]]\n        ]\n\n        # Accept if at least one objective improves\n        if any(candidate_costs[i] < original_costs[i] for i in range(3)):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j to create a neighbor\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) == n and all(node in new_solution for node in range(n)):\n        return new_solution\n    else:\n        # If infeasible, revert to the original solution\n        return selected_solution\n\n",
        "score": [
            -0.5585363298234907,
            1.8681223034858703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j to create a neighbor\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Verify feasibility (no duplicates and all nodes visited)\n    if len(set(new_solution)) == n and all(node in new_solution for node in range(n)):\n        return new_solution\n    else:\n        # If infeasible, revert to the original solution\n        return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{A novel multi-objective local search heuristic selects a solution from the archive based on objective diversity and applies a hybrid of edge-swapping and path-relinking to generate neighbors, ensuring feasibility and balancing improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj1, obj2, obj3 = zip(*objectives)\n    std_devs = (np.std(obj1), np.std(obj2), np.std(obj3))\n    selected_idx = np.argmax(std_devs) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge-swapping and path-relinking\n    if random.random() < 0.5:\n        # Edge-swapping for one objective\n        obj_idx = random.randint(0, 2)\n        distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_idx]\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Path-relinking between two solutions\n        ref_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n-2)\n        new_solution[crossover_point:] = ref_solution[crossover_point:]\n\n    # Ensure feasibility by repairing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = [node for node in range(n) if node not in new_solution]\n        if missing:\n            replace_idx = np.where(new_solution == dup)[0][1]\n            new_solution[replace_idx] = random.choice(missing)\n\n    return new_solution\n\n",
        "score": [
            -0.8239943973158954,
            2.3789659976959228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj1, obj2, obj3 = zip(*objectives)\n    std_devs = (np.std(obj1), np.std(obj2), np.std(obj3))\n    selected_idx = np.argmax(std_devs) if random.random() < 0.7 else random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge-swapping and path-relinking\n    if random.random() < 0.5:\n        # Edge-swapping for one objective\n        obj_idx = random.randint(0, 2)\n        distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_idx]\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Path-relinking between two solutions\n        ref_solution = random.choice(archive)[0]\n        crossover_point = random.randint(1, n-2)\n        new_solution[crossover_point:] = ref_solution[crossover_point:]\n\n    # Ensure feasibility by repairing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for dup in duplicates:\n        missing = [node for node in range(n) if node not in new_solution]\n        if missing:\n            replace_idx = np.where(new_solution == dup)[0][1]\n            new_solution[replace_idx] = random.choice(missing)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest total distance in any objective space\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]))\n\n    # Create a neighbor using a hybrid 3-opt local search tailored for tri-objective optimization\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse segments between selected edges\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt creates duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.3891595594272923,
            1.2520486116409302
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest total distance in any objective space\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]))\n\n    # Create a neighbor using a hybrid 3-opt local search tailored for tri-objective optimization\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse segments between selected edges\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt creates duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective awareness\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform the swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no revisits, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6168047482991457,
            1.7107998371124267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective awareness\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform the swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility (no revisits, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes to perform meaningful operations\n\n    # Randomly choose between 2-opt or edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i-1:-1], new_solution[i:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if edge insertion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6159858003361649,
            1.217081034183502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes to perform meaningful operations\n\n    # Randomly choose between 2-opt or edge insertion\n    if random.random() < 0.5:\n        # 2-opt local search\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i-1:-1], new_solution[i:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if edge insertion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j to form a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the tour is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return selected_solution\n\n",
        "score": [
            -0.5914663968948207,
            1.4279748439788817
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j to form a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the tour is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge costs across all three objectives\n    edge_costs = np.zeros(n)\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_costs[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n\n    # Identify the worst edges (highest cost) to potentially improve\n    worst_edges = np.argsort(edge_costs)[-max(2, n//10):]\n\n    # Try to improve by reinserting nodes from worst edges\n    for i in worst_edges:\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n\n        # Find the best insertion point for u and v\n        min_insert_cost = float('inf')\n        best_insert_pos = -1\n\n        for j in range(n):\n            if j == i or j == (i + 1) % n:\n                continue\n\n            # Calculate insertion cost for u and v\n            prev_node = new_solution[(j - 1) % n]\n            next_node = new_solution[j]\n\n            cost = (distance_matrix_1[prev_node, u] + distance_matrix_2[prev_node, u] + distance_matrix_3[prev_node, u] +\n                    distance_matrix_1[u, next_node] + distance_matrix_2[u, next_node] + distance_matrix_3[u, next_node])\n\n            if cost < min_insert_cost:\n                min_insert_cost = cost\n                best_insert_pos = j\n\n        if best_insert_pos != -1:\n            # Perform the insertion\n            new_solution = np.roll(new_solution, -best_insert_pos)\n            new_solution[0] = u\n            new_solution = np.roll(new_solution, best_insert_pos)\n\n    return new_solution\n\n",
        "score": [
            -0.7407335919806677,
            3.6214067697525025
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge costs across all three objectives\n    edge_costs = np.zeros(n)\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        edge_costs[i] = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v])\n\n    # Identify the worst edges (highest cost) to potentially improve\n    worst_edges = np.argsort(edge_costs)[-max(2, n//10):]\n\n    # Try to improve by reinserting nodes from worst edges\n    for i in worst_edges:\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n\n        # Find the best insertion point for u and v\n        min_insert_cost = float('inf')\n        best_insert_pos = -1\n\n        for j in range(n):\n            if j == i or j == (i + 1) % n:\n                continue\n\n            # Calculate insertion cost for u and v\n            prev_node = new_solution[(j - 1) % n]\n            next_node = new_solution[j]\n\n            cost = (distance_matrix_1[prev_node, u] + distance_matrix_2[prev_node, u] + distance_matrix_3[prev_node, u] +\n                    distance_matrix_1[u, next_node] + distance_matrix_2[u, next_node] + distance_matrix_3[u, next_node])\n\n            if cost < min_insert_cost:\n                min_insert_cost = cost\n                best_insert_pos = j\n\n        if best_insert_pos != -1:\n            # Perform the insertion\n            new_solution = np.roll(new_solution, -best_insert_pos)\n            new_solution[0] = u\n            new_solution = np.roll(new_solution, best_insert_pos)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt with a guided random walk\n    new_solution = best_solution.copy()\n\n    # Randomly select two distinct edges to perform 2-opt\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j to form a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # With 50% probability, perform a guided random walk to escape local optima\n    if random.random() < 0.5:\n        # Randomly select a segment and shift it to a new position\n        k = random.randint(1, n // 2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.5775885658215801,
            1.2804082751274108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: combine 2-opt with a guided random walk\n    new_solution = best_solution.copy()\n\n    # Randomly select two distinct edges to perform 2-opt\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment between i and j to form a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # With 50% probability, perform a guided random walk to escape local optima\n    if random.random() < 0.5:\n        # Randomly select a segment and shift it to a new position\n        k = random.randint(1, n // 2)\n        segment = new_solution[:k]\n        new_solution = np.concatenate([new_solution[k:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{A novel tri-objective local search heuristic that intelligently selects a promising solution from the archive, applies a hybrid 2-opt and segment-swap operator tailored to three objectives, and prioritizes edges with high potential for improvement across all objectives to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (randomly for diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine the number of nodes\n    num_nodes = len(base_solution)\n\n    # Hybrid local search operator: 2-opt with tri-objective edge selection\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select two edges to swap (2-opt)\n        i = random.randint(0, num_nodes - 1)\n        j = random.randint(0, num_nodes - 1)\n        if i == j:\n            continue\n\n        # Ensure i < j for simplicity\n        if i > j:\n            i, j = j, i\n\n        # Get the current edges and their costs\n        a, b = base_solution[i], base_solution[(i + 1) % num_nodes]\n        c, d = base_solution[j], base_solution[(j + 1) % num_nodes]\n\n        current_cost = (\n            distance_matrix_1[a, b] + distance_matrix_1[c, d],\n            distance_matrix_2[a, b] + distance_matrix_2[c, d],\n            distance_matrix_3[a, b] + distance_matrix_3[c, d]\n        )\n\n        # Get the new edges if we swap\n        new_edges = (\n            (a, c), (b, d)\n        )\n        new_cost = (\n            distance_matrix_1[a, c] + distance_matrix_1[b, d],\n            distance_matrix_2[a, c] + distance_matrix_2[b, d],\n            distance_matrix_3[a, c] + distance_matrix_3[b, d]\n        )\n\n        # Check if the swap improves at least one objective\n        if any(new_cost[k] < current_cost[k] for k in range(3)):\n            # Perform the 2-opt swap\n            new_solution[i + 1:j + 1] = base_solution[i + 1:j + 1][::-1]\n            base_solution = new_solution.copy()\n\n    # Additional segment-swap for tri-objective optimization\n    if num_nodes > 3:\n        # Select a random segment to move\n        seg_start = random.randint(0, num_nodes - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 3, num_nodes - 1))\n        segment = base_solution[seg_start:seg_end + 1]\n\n        # Find the best insertion point for the segment\n        best_pos = seg_start\n        best_improvement = 0\n\n        for pos in range(0, num_nodes - len(segment)):\n            if pos >= seg_start and pos < seg_end:\n                continue  # Skip the original position\n\n            # Calculate the cost of removing the segment\n            remove_cost = (\n                distance_matrix_1[base_solution[seg_start - 1], base_solution[seg_start]] +\n                distance_matrix_1[base_solution[seg_end], base_solution[(seg_end + 1) % num_nodes]],\n                distance_matrix_2[base_solution[seg_start - 1], base_solution[seg_start]] +\n                distance_matrix_2[base_solution[seg_end], base_solution[(seg_end + 1) % num_nodes]],\n                distance_matrix_3[base_solution[seg_start - 1], base_solution[seg_start]] +\n                distance_matrix_3[base_solution[seg_end], base_solution[(seg_end + 1) % num_nodes]]\n            )\n\n            # Calculate the cost of inserting the segment at new position\n            insert_cost = (\n                distance_matrix_1[base_solution[pos - 1], segment[0]] +\n                distance_matrix_1[segment[-1], base_solution[(pos + len(segment)) % num_nodes]],\n                distance_matrix_2[base_solution[pos - 1], segment[0]] +\n                distance_matrix_2[segment[-1], base_solution[(pos + len(segment)) % num_nodes]],\n                distance_matrix_3[base_solution[pos - 1], segment[0]] +\n                distance_matrix_3[segment[-1], base_solution[(pos + len(segment)) % num_nodes]]\n            )\n\n            # Calculate the total improvement\n            total_improvement = sum(remove_cost[k] - insert_cost[k] for k in range(3))\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        # Perform the segment move if it improves at least one objective\n        if best_improvement > 0:\n            # Remove the segment\n            new_solution = np.concatenate([\n                base_solution[:seg_start],\n                base_solution[seg_end + 1:]\n            ])\n\n            # Insert the segment at the best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    return new_solution\n\n",
        "score": [
            -0.7782065065774186,
            1.9520657062530518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive (randomly for diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine the number of nodes\n    num_nodes = len(base_solution)\n\n    # Hybrid local search operator: 2-opt with tri-objective edge selection\n    for _ in range(10):  # Number of perturbation attempts\n        # Randomly select two edges to swap (2-opt)\n        i = random.randint(0, num_nodes - 1)\n        j = random.randint(0, num_nodes - 1)\n        if i == j:\n            continue\n\n        # Ensure i < j for simplicity\n        if i > j:\n            i, j = j, i\n\n        # Get the current edges and their costs\n        a, b = base_solution[i], base_solution[(i + 1) % num_nodes]\n        c, d = base_solution[j], base_solution[(j + 1) % num_nodes]\n\n        current_cost = (\n            distance_matrix_1[a, b] + distance_matrix_1[c, d],\n            distance_matrix_2[a, b] + distance_matrix_2[c, d],\n            distance_matrix_3[a, b] + distance_matrix_3[c, d]\n        )\n\n        # Get the new edges if we swap\n        new_edges = (\n            (a, c), (b, d)\n        )\n        new_cost = (\n            distance_matrix_1[a, c] + distance_matrix_1[b, d],\n            distance_matrix_2[a, c] + distance_matrix_2[b, d],\n            distance_matrix_3[a, c] + distance_matrix_3[b, d]\n        )\n\n        # Check if the swap improves at least one objective\n        if any(new_cost[k] < current_cost[k] for k in range(3)):\n            # Perform the 2-opt swap\n            new_solution[i + 1:j + 1] = base_solution[i + 1:j + 1][::-1]\n            base_solution = new_solution.copy()\n\n    # Additional segment-swap for tri-objective optimization\n    if num_nodes > 3:\n        # Select a random segment to move\n        seg_start = random.randint(0, num_nodes - 2)\n        seg_end = random.randint(seg_start + 1, min(seg_start + 3, num_nodes - 1))\n        segment = base_solution[seg_start:seg_end + 1]\n\n        # Find the best insertion point for the segment\n        best_pos = seg_start\n        best_improvement = 0\n\n        for pos in range(0, num_nodes - len(segment)):\n            if pos >= seg_start and pos < seg_end:\n                continue  # Skip the original position\n\n            # Calculate the cost of removing the segment\n            remove_cost = (\n                distance_matrix_1[base_solution[seg_start - 1], base_solution[seg_start]] +\n                distance_matrix_1[base_solution[seg_end], base_solution[(seg_end + 1) % num_nodes]],\n                distance_matrix_2[base_solution[seg_start - 1], base_solution[seg_start]] +\n                distance_matrix_2[base_solution[seg_end], base_solution[(seg_end + 1) % num_nodes]],\n                distance_matrix_3[base_solution[seg_start - 1], base_solution[seg_start]] +\n                distance_matrix_3[base_solution[seg_end], base_solution[(seg_end + 1) % num_nodes]]\n            )\n\n            # Calculate the cost of inserting the segment at new position\n            insert_cost = (\n                distance_matrix_1[base_solution[pos - 1], segment[0]] +\n                distance_matrix_1[segment[-1], base_solution[(pos + len(segment)) % num_nodes]],\n                distance_matrix_2[base_solution[pos - 1], segment[0]] +\n                distance_matrix_2[segment[-1], base_solution[(pos + len(segment)) % num_nodes]],\n                distance_matrix_3[base_solution[pos - 1], segment[0]] +\n                distance_matrix_3[segment[-1], base_solution[(pos + len(segment)) % num_nodes]]\n            )\n\n            # Calculate the total improvement\n            total_improvement = sum(remove_cost[k] - insert_cost[k] for k in range(3))\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        # Perform the segment move if it improves at least one objective\n        if best_improvement > 0:\n            # Remove the segment\n            new_solution = np.concatenate([\n                base_solution[:seg_start],\n                base_solution[seg_end + 1:]\n            ])\n\n            # Insert the segment at the best position\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further improve by checking objective-aware swaps\n    for _ in range(3):  # Limit iterations for efficiency\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                          distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n        if potential_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6198845167304614,
            1.529709017276764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further improve by checking objective-aware swaps\n    for _ in range(3):  # Limit iterations for efficiency\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_3[new_solution[b-1], new_solution[b]])\n\n        potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[a]] +\n                          distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_3[new_solution[b-1], new_solution[a]])\n\n        if potential_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Create all possible 3-opt moves and evaluate their impact on all three objectives\n    moves = [\n        (i, j, k, [new_solution[i], new_solution[j], new_solution[k]]),\n        (i, j, k, [new_solution[i], new_solution[k], new_solution[j]]),\n        (i, k, j, [new_solution[i], new_solution[j], new_solution[k]]),\n        (i, k, j, [new_solution[i], new_solution[k], new_solution[j]])\n    ]\n\n    best_move = None\n    best_score = float('inf')\n\n    for move in moves:\n        a, b, c, seq = move\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[a-1], seq[0]] + distance_matrix_1[seq[2], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], seq[1]] + distance_matrix_1[seq[1], new_solution[b]] +\n                      distance_matrix_1[new_solution[c-1], seq[2]] + distance_matrix_1[seq[0], new_solution[c]]) - \\\n                     (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[a-1], seq[0]] + distance_matrix_2[seq[2], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], seq[1]] + distance_matrix_2[seq[1], new_solution[b]] +\n                      distance_matrix_2[new_solution[c-1], seq[2]] + distance_matrix_2[seq[0], new_solution[c]]) - \\\n                     (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[a-1], seq[0]] + distance_matrix_3[seq[2], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], seq[1]] + distance_matrix_3[seq[1], new_solution[b]] +\n                      distance_matrix_3[new_solution[c-1], seq[2]] + distance_matrix_3[seq[0], new_solution[c]]) - \\\n                     (distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        # Use a weighted sum of objective changes as the selection criterion\n        total_delta = delta_obj1 + delta_obj2 + delta_obj3\n\n        if total_delta < best_score:\n            best_score = total_delta\n            best_move = move\n\n    if best_move is not None:\n        a, b, c, seq = best_move\n        # Apply the best move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        # Ensure the solution remains a valid tour\n        if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.696047577162333,
            1.7214253306388856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Create all possible 3-opt moves and evaluate their impact on all three objectives\n    moves = [\n        (i, j, k, [new_solution[i], new_solution[j], new_solution[k]]),\n        (i, j, k, [new_solution[i], new_solution[k], new_solution[j]]),\n        (i, k, j, [new_solution[i], new_solution[j], new_solution[k]]),\n        (i, k, j, [new_solution[i], new_solution[k], new_solution[j]])\n    ]\n\n    best_move = None\n    best_score = float('inf')\n\n    for move in moves:\n        a, b, c, seq = move\n        # Calculate the change in all three objectives\n        delta_obj1 = (distance_matrix_1[new_solution[a-1], seq[0]] + distance_matrix_1[seq[2], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], seq[1]] + distance_matrix_1[seq[1], new_solution[b]] +\n                      distance_matrix_1[new_solution[c-1], seq[2]] + distance_matrix_1[seq[0], new_solution[c]]) - \\\n                     (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[c]])\n\n        delta_obj2 = (distance_matrix_2[new_solution[a-1], seq[0]] + distance_matrix_2[seq[2], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], seq[1]] + distance_matrix_2[seq[1], new_solution[b]] +\n                      distance_matrix_2[new_solution[c-1], seq[2]] + distance_matrix_2[seq[0], new_solution[c]]) - \\\n                     (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        delta_obj3 = (distance_matrix_3[new_solution[a-1], seq[0]] + distance_matrix_3[seq[2], new_solution[a]] +\n                      distance_matrix_3[new_solution[b-1], seq[1]] + distance_matrix_3[seq[1], new_solution[b]] +\n                      distance_matrix_3[new_solution[c-1], seq[2]] + distance_matrix_3[seq[0], new_solution[c]]) - \\\n                     (distance_matrix_3[new_solution[a-1], new_solution[a]] + distance_matrix_3[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_3[new_solution[c-1], new_solution[c]])\n\n        # Use a weighted sum of objective changes as the selection criterion\n        total_delta = delta_obj1 + delta_obj2 + delta_obj3\n\n        if total_delta < best_score:\n            best_score = total_delta\n            best_move = move\n\n    if best_move is not None:\n        a, b, c, seq = best_move\n        # Apply the best move\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        # Ensure the solution remains a valid tour\n        if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap, prioritizing those with high objective values\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    # Apply additional 3-opt to further improve the solution\n    if n >= 3:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Rearrange the segment to potentially improve all three objectives\n        segment = new_solution[a:b+1]\n        new_segment = np.concatenate([segment[:c-a], segment[c-a:][::-1]])\n        new_solution[a:b+1] = new_segment\n\n    return new_solution\n\n",
        "score": [
            -0.6767746041056044,
            1.4217367768287659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap, prioritizing those with high objective values\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    # Apply additional 3-opt to further improve the solution\n    if n >= 3:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Rearrange the segment to potentially improve all three objectives\n        segment = new_solution[a:b+1]\n        new_segment = np.concatenate([segment[:c-a], segment[c-a:][::-1]])\n        new_solution[a:b+1] = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, obj_tuple)) for _, obj_tuple in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Apply a random 2-opt move with high probability\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply an objective-aware edge swap with lower probability\n    elif np.random.rand() < 0.3:\n        # Select two edges that are critical in at least one objective\n        obj_1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(-1, len(new_solution)-1))\n        obj_2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(-1, len(new_solution)-1))\n        obj_3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(-1, len(new_solution)-1))\n\n        # Find edges with high contribution to any objective\n        edge_contributions = []\n        for i in range(len(new_solution)-1):\n            contrib = (distance_matrix_1[new_solution[i], new_solution[i+1]] / obj_1 +\n                       distance_matrix_2[new_solution[i], new_solution[i+1]] / obj_2 +\n                       distance_matrix_3[new_solution[i], new_solution[i+1]] / obj_3)\n            edge_contributions.append((contrib, i))\n\n        # Select the two edges with highest contribution\n        edge_contributions.sort(reverse=True, key=lambda x: x[0])\n        i, j = edge_contributions[0][1], edge_contributions[1][1]\n\n        # Swap the edges\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7524066176708005,
            4.0461194038391115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1)[0]\n    scores = [sum(w * obj for w, obj in zip(weights, obj_tuple)) for _, obj_tuple in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Apply a random 2-opt move with high probability\n    if np.random.rand() < 0.7:\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply an objective-aware edge swap with lower probability\n    elif np.random.rand() < 0.3:\n        # Select two edges that are critical in at least one objective\n        obj_1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(-1, len(new_solution)-1))\n        obj_2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(-1, len(new_solution)-1))\n        obj_3 = sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(-1, len(new_solution)-1))\n\n        # Find edges with high contribution to any objective\n        edge_contributions = []\n        for i in range(len(new_solution)-1):\n            contrib = (distance_matrix_1[new_solution[i], new_solution[i+1]] / obj_1 +\n                       distance_matrix_2[new_solution[i], new_solution[i+1]] / obj_2 +\n                       distance_matrix_3[new_solution[i], new_solution[i+1]] / obj_3)\n            edge_contributions.append((contrib, i))\n\n        # Select the two edges with highest contribution\n        edge_contributions.sort(reverse=True, key=lambda x: x[0])\n        i, j = edge_contributions[0][1], edge_contributions[1][1]\n\n        # Swap the edges\n        if abs(i - j) > 1:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid neighbor generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge swaps, 2-opt, and objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swap (swap two adjacent edges)\n    if n > 2:\n        i = random.randint(0, n - 2)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Step 2: 2-opt move (reverse a segment to reduce tour length)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Objective-aware perturbation (swap nodes based on worst-performing objective)\n    worst_obj = np.argmax(objectives)\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst node in the worst objective space\n    worst_node = None\n    max_cost = -1\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n        current_cost = dist_matrix[prev_node, new_solution[i]] + dist_matrix[new_solution[i], next_node]\n        if current_cost > max_cost:\n            max_cost = current_cost\n            worst_node = i\n\n    # Swap with a random better node\n    if worst_node is not None:\n        candidates = [i for i in range(n) if i != worst_node]\n        random.shuffle(candidates)\n        for candidate in candidates:\n            new_solution[worst_node], new_solution[candidate] = new_solution[candidate], new_solution[worst_node]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.7405450749946891,
            0.90984548330307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: combine edge swaps, 2-opt, and objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge swap (swap two adjacent edges)\n    if n > 2:\n        i = random.randint(0, n - 2)\n        new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Step 2: 2-opt move (reverse a segment to reduce tour length)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 3: Objective-aware perturbation (swap nodes based on worst-performing objective)\n    worst_obj = np.argmax(objectives)\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst node in the worst objective space\n    worst_node = None\n    max_cost = -1\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n        current_cost = dist_matrix[prev_node, new_solution[i]] + dist_matrix[new_solution[i], next_node]\n        if current_cost > max_cost:\n            max_cost = current_cost\n            worst_node = i\n\n    # Swap with a random better node\n    if worst_node is not None:\n        candidates = [i for i in range(n) if i != worst_node]\n        random.shuffle(candidates)\n        for candidate in candidates:\n            new_solution[worst_node], new_solution[candidate] = new_solution[candidate], new_solution[worst_node]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for sol, obj in archive]\n    worst_indices = [np.argmax([obj[i] for obj in objectives]) for i in range(3)]\n    selected_index = worst_indices[np.random.choice([0, 1, 2])]  # Randomly select one of the worst objectives\n    base_solution = archive[selected_index][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: swap edges that are worst in any objective\n    for _ in range(3):  # Try up to 3 swaps\n        # Calculate edge costs in all objectives\n        edge_costs = []\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            cost3 = distance_matrix_3[u, v]\n            edge_costs.append((cost1, cost2, cost3))\n\n        # Find the worst edge in any objective\n        worst_edge_idx = np.argmax([max(cost) for cost in edge_costs])\n        if worst_edge_idx == 0:  # Don't modify the first edge if it's the worst\n            continue\n\n        # Swap nodes to potentially improve the worst edge\n        k = worst_edge_idx\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.608413910851713,
            1.628848373889923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for sol, obj in archive]\n    worst_indices = [np.argmax([obj[i] for obj in objectives]) for i in range(3)]\n    selected_index = worst_indices[np.random.choice([0, 1, 2])]  # Randomly select one of the worst objectives\n    base_solution = archive[selected_index][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: swap edges that are worst in any objective\n    for _ in range(3):  # Try up to 3 swaps\n        # Calculate edge costs in all objectives\n        edge_costs = []\n        for k in range(n):\n            u, v = new_solution[k], new_solution[(k+1)%n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            cost3 = distance_matrix_3[u, v]\n            edge_costs.append((cost1, cost2, cost3))\n\n        # Find the worst edge in any objective\n        worst_edge_idx = np.argmax([max(cost) for cost in edge_costs])\n        if worst_edge_idx == 0:  # Don't modify the first edge if it's the worst\n            continue\n\n        # Swap nodes to potentially improve the worst edge\n        k = worst_edge_idx\n        new_solution[k], new_solution[(k+1)%n] = new_solution[(k+1)%n], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][0] - x[1][2])**2 + (x[1][1] - x[1][2])**2)[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware node swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware node swap\n    # Calculate the total distance for each objective\n    def total_distance(sol, matrix):\n        return sum(matrix[sol[i], sol[(i+1)%n]] for i in range(n))\n\n    current_dist1 = total_distance(new_solution, distance_matrix_1)\n    current_dist2 = total_distance(new_solution, distance_matrix_2)\n    current_dist3 = total_distance(new_solution, distance_matrix_3)\n\n    # Find the most imbalanced objective\n    max_diff = max(current_dist1 - current_dist2, current_dist1 - current_dist3, current_dist2 - current_dist3)\n    if max_diff > 0:\n        # Swap nodes to improve the most imbalanced objective\n        for _ in range(10):  # Try up to 10 random swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            candidate = new_solution.copy()\n            candidate[a], candidate[b] = candidate[b], candidate[a]\n\n            new_dist1 = total_distance(candidate, distance_matrix_1)\n            new_dist2 = total_distance(candidate, distance_matrix_2)\n            new_dist3 = total_distance(candidate, distance_matrix_3)\n\n            # Check if the swap improves the most imbalanced objective\n            if (max_diff == current_dist1 - current_dist2 and new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n               (max_diff == current_dist1 - current_dist3 and new_dist1 < current_dist1 and new_dist3 < current_dist3) or \\\n               (max_diff == current_dist2 - current_dist3 and new_dist2 < current_dist2 and new_dist3 < current_dist3):\n                new_solution = candidate\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.4824418447599449,
            2.59034903049469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] - x[1][1])**2 + (x[1][0] - x[1][2])**2 + (x[1][1] - x[1][2])**2)[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware node swapping\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform an objective-aware node swap\n    # Calculate the total distance for each objective\n    def total_distance(sol, matrix):\n        return sum(matrix[sol[i], sol[(i+1)%n]] for i in range(n))\n\n    current_dist1 = total_distance(new_solution, distance_matrix_1)\n    current_dist2 = total_distance(new_solution, distance_matrix_2)\n    current_dist3 = total_distance(new_solution, distance_matrix_3)\n\n    # Find the most imbalanced objective\n    max_diff = max(current_dist1 - current_dist2, current_dist1 - current_dist3, current_dist2 - current_dist3)\n    if max_diff > 0:\n        # Swap nodes to improve the most imbalanced objective\n        for _ in range(10):  # Try up to 10 random swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            candidate = new_solution.copy()\n            candidate[a], candidate[b] = candidate[b], candidate[a]\n\n            new_dist1 = total_distance(candidate, distance_matrix_1)\n            new_dist2 = total_distance(candidate, distance_matrix_2)\n            new_dist3 = total_distance(candidate, distance_matrix_3)\n\n            # Check if the swap improves the most imbalanced objective\n            if (max_diff == current_dist1 - current_dist2 and new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n               (max_diff == current_dist1 - current_dist3 and new_dist1 < current_dist1 and new_dist3 < current_dist3) or \\\n               (max_diff == current_dist2 - current_dist3 and new_dist2 < current_dist2 and new_dist3 < current_dist3):\n                new_solution = candidate\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the change in all three objectives\n            a, b, c = new_solution[i], new_solution[i+1], new_solution[j]\n            delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[a, c] + distance_matrix_1[b, new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[a, c] + distance_matrix_2[b, new_solution[(j+1)%n]])\n            delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_3[a, c] + distance_matrix_3[b, new_solution[(j+1)%n]])\n\n            # If improvement in at least one objective, apply 2-opt\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    # If no improvement found, perform a random swap to maintain diversity\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7598944752036285,
            1.866108810901642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the change in all three objectives\n            a, b, c = new_solution[i], new_solution[i+1], new_solution[j]\n            delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[a, c] + distance_matrix_1[b, new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[a, c] + distance_matrix_2[b, new_solution[(j+1)%n]])\n            delta3 = (distance_matrix_3[a, b] + distance_matrix_3[c, new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_3[a, c] + distance_matrix_3[b, new_solution[(j+1)%n]])\n\n            # If improvement in at least one objective, apply 2-opt\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    # If no improvement found, perform a random swap to maintain diversity\n    if np.array_equal(new_solution, base_solution):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for local improvement, then applies a hybrid local search strategy combining 2-opt moves, random segment reversals, and objective-aware edge swaps to generate a neighbor solution while ensuring feasibility and multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for very small tours\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for this move\n        obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights by default\n        if random.random() < 0.3:  # 30% chance to bias toward a specific objective\n            obj_weights = np.random.dirichlet([1, 1, 1])\n\n        # Calculate current objective values\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return np.array([cost1, cost2, cost3])\n\n        current_obj = calculate_objective(new_solution)\n\n        # Try different local search moves\n        best_new_solution = new_solution.copy()\n        best_new_obj = current_obj.copy()\n\n        # 1. 2-opt move (standard for TSP)\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate_obj = calculate_objective(candidate)\n        if np.all(candidate_obj <= best_new_obj):\n            best_new_solution = candidate\n            best_new_obj = candidate_obj\n\n        # 2. Random segment reversal with objective awareness\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_length)\n        candidate = new_solution.copy()\n        candidate[start:start+segment_length] = candidate[start:start+segment_length][::-1]\n        candidate_obj = calculate_objective(candidate)\n        if np.all(candidate_obj <= best_new_obj):\n            best_new_solution = candidate\n            best_new_obj = candidate_obj\n\n        # 3. Objective-aware edge swap\n        for _ in range(3):  # Try a few swaps\n            i, j = random.sample(range(n), 2)\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidate_obj = calculate_objective(candidate)\n            weighted_diff = np.dot(obj_weights, candidate_obj - current_obj)\n            if weighted_diff < 0 or (weighted_diff == 0 and random.random() < 0.3):\n                best_new_solution = candidate\n                best_new_obj = candidate_obj\n\n        new_solution = best_new_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6850452181686011,
            4.247378611564637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        # Simple swap for very small tours\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Determine which objective to prioritize for this move\n        obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights by default\n        if random.random() < 0.3:  # 30% chance to bias toward a specific objective\n            obj_weights = np.random.dirichlet([1, 1, 1])\n\n        # Calculate current objective values\n        def calculate_objective(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            cost3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n            return np.array([cost1, cost2, cost3])\n\n        current_obj = calculate_objective(new_solution)\n\n        # Try different local search moves\n        best_new_solution = new_solution.copy()\n        best_new_obj = current_obj.copy()\n\n        # 1. 2-opt move (standard for TSP)\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n        candidate_obj = calculate_objective(candidate)\n        if np.all(candidate_obj <= best_new_obj):\n            best_new_solution = candidate\n            best_new_obj = candidate_obj\n\n        # 2. Random segment reversal with objective awareness\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n-segment_length)\n        candidate = new_solution.copy()\n        candidate[start:start+segment_length] = candidate[start:start+segment_length][::-1]\n        candidate_obj = calculate_objective(candidate)\n        if np.all(candidate_obj <= best_new_obj):\n            best_new_solution = candidate\n            best_new_obj = candidate_obj\n\n        # 3. Objective-aware edge swap\n        for _ in range(3):  # Try a few swaps\n            i, j = random.sample(range(n), 2)\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidate_obj = calculate_objective(candidate)\n            weighted_diff = np.dot(obj_weights, candidate_obj - current_obj)\n            if weighted_diff < 0 or (weighted_diff == 0 and random.random() < 0.3):\n                best_new_solution = candidate\n                best_new_obj = candidate_obj\n\n        new_solution = best_new_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(np.arange(n), size=2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: identify the worst edge and swap it with a better one\n    total_cost = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n)) + \\\n                 sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n)) + \\\n                 sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(n))\n\n    # Find the worst edge in any of the three objectives\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for k in range(n):\n        cost1 = distance_matrix_1[base_solution[k-1], base_solution[k]]\n        cost2 = distance_matrix_2[base_solution[k-1], base_solution[k]]\n        cost3 = distance_matrix_3[base_solution[k-1], base_solution[k]]\n        total_edge_cost = cost1 + cost2 + cost3\n        if total_edge_cost > worst_edge_cost:\n            worst_edge_cost = total_edge_cost\n            worst_edge_idx = k\n\n    if worst_edge_idx != -1:\n        # Find a better edge to replace the worst one\n        a, b = worst_edge_idx-1, worst_edge_idx\n        for k in range(n):\n            if k != a and k != b and k != (a+1)%n and k != (b+1)%n:\n                new_cost1 = distance_matrix_1[base_solution[a], base_solution[k]] + distance_matrix_1[base_solution[k], base_solution[b]]\n                new_cost2 = distance_matrix_2[base_solution[a], base_solution[k]] + distance_matrix_2[base_solution[k], base_solution[b]]\n                new_cost3 = distance_matrix_3[base_solution[a], base_solution[k]] + distance_matrix_3[base_solution[k], base_solution[b]]\n                new_total_cost = new_cost1 + new_cost2 + new_cost3\n\n                if new_total_cost < worst_edge_cost:\n                    # Perform the swap\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6415819405291943,
            2.0704832911491393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective aware swap\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(np.arange(n), size=2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective aware swap: identify the worst edge and swap it with a better one\n    total_cost = sum(distance_matrix_1[base_solution[k-1], base_solution[k]] for k in range(n)) + \\\n                 sum(distance_matrix_2[base_solution[k-1], base_solution[k]] for k in range(n)) + \\\n                 sum(distance_matrix_3[base_solution[k-1], base_solution[k]] for k in range(n))\n\n    # Find the worst edge in any of the three objectives\n    worst_edge_idx = -1\n    worst_edge_cost = -1\n    for k in range(n):\n        cost1 = distance_matrix_1[base_solution[k-1], base_solution[k]]\n        cost2 = distance_matrix_2[base_solution[k-1], base_solution[k]]\n        cost3 = distance_matrix_3[base_solution[k-1], base_solution[k]]\n        total_edge_cost = cost1 + cost2 + cost3\n        if total_edge_cost > worst_edge_cost:\n            worst_edge_cost = total_edge_cost\n            worst_edge_idx = k\n\n    if worst_edge_idx != -1:\n        # Find a better edge to replace the worst one\n        a, b = worst_edge_idx-1, worst_edge_idx\n        for k in range(n):\n            if k != a and k != b and k != (a+1)%n and k != (b+1)%n:\n                new_cost1 = distance_matrix_1[base_solution[a], base_solution[k]] + distance_matrix_1[base_solution[k], base_solution[b]]\n                new_cost2 = distance_matrix_2[base_solution[a], base_solution[k]] + distance_matrix_2[base_solution[k], base_solution[b]]\n                new_cost3 = distance_matrix_3[base_solution[a], base_solution[k]] + distance_matrix_3[base_solution[k], base_solution[b]]\n                new_total_cost = new_cost1 + new_cost2 + new_cost3\n\n                if new_total_cost < worst_edge_cost:\n                    # Perform the swap\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to perturb\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: consider edges with high potential for improvement\n    for _ in range(3):  # Apply multiple objective-aware perturbations\n        # Calculate edge costs across all objectives\n        edge_costs = []\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            cost3 = distance_matrix_3[node1, node2]\n            edge_costs.append((cost1 + cost2 + cost3, k))\n\n        # Select edges with high total cost (potential for improvement)\n        edge_costs.sort(reverse=True)\n        selected_edges = [idx for (_, idx) in edge_costs[:3]]\n\n        for idx in selected_edges:\n            # Apply 2-opt on the selected edge\n            k = idx\n            l = (k + 1) % n\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution[k+1:l] = new_solution[k+1:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6137977479292005,
            1.5269361853599548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to perturb\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge selection: consider edges with high potential for improvement\n    for _ in range(3):  # Apply multiple objective-aware perturbations\n        # Calculate edge costs across all objectives\n        edge_costs = []\n        for k in range(n):\n            node1 = new_solution[k]\n            node2 = new_solution[(k+1) % n]\n            cost1 = distance_matrix_1[node1, node2]\n            cost2 = distance_matrix_2[node1, node2]\n            cost3 = distance_matrix_3[node1, node2]\n            edge_costs.append((cost1 + cost2 + cost3, k))\n\n        # Select edges with high total cost (potential for improvement)\n        edge_costs.sort(reverse=True)\n        selected_edges = [idx for (_, idx) in edge_costs[:3]]\n\n        for idx in selected_edges:\n            # Apply 2-opt on the selected edge\n            k = idx\n            l = (k + 1) % n\n            if k > l:\n                k, l = l, k\n            if l - k > 1:\n                new_solution[k+1:l] = new_solution[k+1:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy:\n    # 1. Randomly select a segment of the tour and reverse it (2-opt)\n    # 2. Then, apply a novel 3-objective-aware swap: identify nodes with high marginal improvement in any objective\n    #    and swap them with nodes that would worsen the other objectives less.\n\n    new_solution = base_solution.copy()\n\n    # 2-opt: Reverse a random segment\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-objective-aware swap\n    # Compute marginal improvements for each node\n    marginal_improvements = []\n    for k in range(n):\n        # Compute the change in all three objectives if node k is swapped with k+1\n        if k == n - 1:\n            prev_node = new_solution[k-1]\n            next_node = new_solution[0]\n        else:\n            prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n            next_node = new_solution[k+1]\n\n        # Original edges: prev_node -> k -> next_node\n        # New edges: prev_node -> k+1 -> next_node\n        original_cost1 = distance_matrix_1[prev_node, k] + distance_matrix_1[k, next_node]\n        new_cost1 = distance_matrix_1[prev_node, (k+1)%n] + distance_matrix_1[(k+1)%n, next_node]\n        delta1 = new_cost1 - original_cost1\n\n        original_cost2 = distance_matrix_2[prev_node, k] + distance_matrix_2[k, next_node]\n        new_cost2 = distance_matrix_2[prev_node, (k+1)%n] + distance_matrix_2[(k+1)%n, next_node]\n        delta2 = new_cost2 - original_cost2\n\n        original_cost3 = distance_matrix_3[prev_node, k] + distance_matrix_3[k, next_node]\n        new_cost3 = distance_matrix_3[prev_node, (k+1)%n] + distance_matrix_3[(k+1)%n, next_node]\n        delta3 = new_cost3 - original_cost3\n\n        marginal_improvements.append((delta1, delta2, delta3))\n\n    # Find the best swap (minimizes the worst delta)\n    best_k = None\n    best_score = float('inf')\n    for k in range(n):\n        delta1, delta2, delta3 = marginal_improvements[k]\n        # Score is the worst delta (minimizing this improves the most objective)\n        score = max(delta1, delta2, delta3)\n        if score < best_score:\n            best_score = score\n            best_k = k\n\n    if best_k is not None:\n        # Perform the swap\n        new_solution[best_k], new_solution[(best_k+1)%n] = new_solution[(best_k+1)%n], new_solution[best_k]\n\n    return new_solution\n\n",
        "score": [
            -0.8194946459635981,
            1.847206723690033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy:\n    # 1. Randomly select a segment of the tour and reverse it (2-opt)\n    # 2. Then, apply a novel 3-objective-aware swap: identify nodes with high marginal improvement in any objective\n    #    and swap them with nodes that would worsen the other objectives less.\n\n    new_solution = base_solution.copy()\n\n    # 2-opt: Reverse a random segment\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 3-objective-aware swap\n    # Compute marginal improvements for each node\n    marginal_improvements = []\n    for k in range(n):\n        # Compute the change in all three objectives if node k is swapped with k+1\n        if k == n - 1:\n            prev_node = new_solution[k-1]\n            next_node = new_solution[0]\n        else:\n            prev_node = new_solution[k-1] if k > 0 else new_solution[-1]\n            next_node = new_solution[k+1]\n\n        # Original edges: prev_node -> k -> next_node\n        # New edges: prev_node -> k+1 -> next_node\n        original_cost1 = distance_matrix_1[prev_node, k] + distance_matrix_1[k, next_node]\n        new_cost1 = distance_matrix_1[prev_node, (k+1)%n] + distance_matrix_1[(k+1)%n, next_node]\n        delta1 = new_cost1 - original_cost1\n\n        original_cost2 = distance_matrix_2[prev_node, k] + distance_matrix_2[k, next_node]\n        new_cost2 = distance_matrix_2[prev_node, (k+1)%n] + distance_matrix_2[(k+1)%n, next_node]\n        delta2 = new_cost2 - original_cost2\n\n        original_cost3 = distance_matrix_3[prev_node, k] + distance_matrix_3[k, next_node]\n        new_cost3 = distance_matrix_3[prev_node, (k+1)%n] + distance_matrix_3[(k+1)%n, next_node]\n        delta3 = new_cost3 - original_cost3\n\n        marginal_improvements.append((delta1, delta2, delta3))\n\n    # Find the best swap (minimizes the worst delta)\n    best_k = None\n    best_score = float('inf')\n    for k in range(n):\n        delta1, delta2, delta3 = marginal_improvements[k]\n        # Score is the worst delta (minimizing this improves the most objective)\n        score = max(delta1, delta2, delta3)\n        if score < best_score:\n            best_score = score\n            best_k = k\n\n    if best_k is not None:\n        # Perform the swap\n        new_solution[best_k], new_solution[(best_k+1)%n] = new_solution[(best_k+1)%n], new_solution[best_k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a multi-objective-aware 2-opt swap\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Apply a weighted edge swap based on objective dominance\n    obj_weights = np.array([sum(o) for o in zip(*[x[1] for x in archive])])\n    obj_weights = obj_weights / np.sum(obj_weights)  # Normalize\n\n    if np.random.random() < 0.3:  # 30% chance to apply weighted swap\n        # Find edges with highest weighted improvement potential\n        improvements = []\n        for k in range(n):\n            for l in range(k+1, n):\n                # Calculate improvement in all three objectives\n                delta1 = (distance_matrix_1[base_solution[k-1], base_solution[l]] +\n                          distance_matrix_1[base_solution[k], base_solution[(l+1)%n]]) - \\\n                         (distance_matrix_1[base_solution[k-1], base_solution[k]] +\n                          distance_matrix_1[base_solution[l], base_solution[(l+1)%n]])\n                delta2 = (distance_matrix_2[base_solution[k-1], base_solution[l]] +\n                          distance_matrix_2[base_solution[k], base_solution[(l+1)%n]]) - \\\n                         (distance_matrix_2[base_solution[k-1], base_solution[k]] +\n                          distance_matrix_2[base_solution[l], base_solution[(l+1)%n]])\n                delta3 = (distance_matrix_3[base_solution[k-1], base_solution[l]] +\n                          distance_matrix_3[base_solution[k], base_solution[(l+1)%n]]) - \\\n                         (distance_matrix_3[base_solution[k-1], base_solution[k]] +\n                          distance_matrix_3[base_solution[l], base_solution[(l+1)%n]])\n\n                weighted_improvement = obj_weights[0]*delta1 + obj_weights[1]*delta2 + obj_weights[2]*delta3\n                improvements.append((weighted_improvement, k, l))\n\n        if improvements:\n            best_improvement = max(improvements, key=lambda x: x[0])\n            k, l = best_improvement[1], best_improvement[2]\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7523729026239075,
            2.7000888347625733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a multi-objective-aware 2-opt swap\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Apply a weighted edge swap based on objective dominance\n    obj_weights = np.array([sum(o) for o in zip(*[x[1] for x in archive])])\n    obj_weights = obj_weights / np.sum(obj_weights)  # Normalize\n\n    if np.random.random() < 0.3:  # 30% chance to apply weighted swap\n        # Find edges with highest weighted improvement potential\n        improvements = []\n        for k in range(n):\n            for l in range(k+1, n):\n                # Calculate improvement in all three objectives\n                delta1 = (distance_matrix_1[base_solution[k-1], base_solution[l]] +\n                          distance_matrix_1[base_solution[k], base_solution[(l+1)%n]]) - \\\n                         (distance_matrix_1[base_solution[k-1], base_solution[k]] +\n                          distance_matrix_1[base_solution[l], base_solution[(l+1)%n]])\n                delta2 = (distance_matrix_2[base_solution[k-1], base_solution[l]] +\n                          distance_matrix_2[base_solution[k], base_solution[(l+1)%n]]) - \\\n                         (distance_matrix_2[base_solution[k-1], base_solution[k]] +\n                          distance_matrix_2[base_solution[l], base_solution[(l+1)%n]])\n                delta3 = (distance_matrix_3[base_solution[k-1], base_solution[l]] +\n                          distance_matrix_3[base_solution[k], base_solution[(l+1)%n]]) - \\\n                         (distance_matrix_3[base_solution[k-1], base_solution[k]] +\n                          distance_matrix_3[base_solution[l], base_solution[(l+1)%n]])\n\n                weighted_improvement = obj_weights[0]*delta1 + obj_weights[1]*delta2 + obj_weights[2]*delta3\n                improvements.append((weighted_improvement, k, l))\n\n        if improvements:\n            best_improvement = max(improvements, key=lambda x: x[0])\n            k, l = best_improvement[1], best_improvement[2]\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate a score for each solution based on the combined objectives (lower is better)\n        scores = [sum(obj) for (_, obj) in archive]\n        # Select a solution with probability proportional to its inverse score\n        selected_idx = random.choices(range(len(archive)), weights=[1/s for s in scores], k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution\n\n    # Determine the search space based on the objectives\n    # Calculate the relative improvement potential for each objective\n    obj_scores = np.array([sum(obj) for (_, obj) in archive])\n    if len(obj_scores) > 1:\n        obj_weights = (np.max(obj_scores) - obj_scores) / np.sum(np.max(obj_scores) - obj_scores)\n    else:\n        obj_weights = np.array([1.0, 0.0, 0.0])  # Default weights if only one solution\n\n    # Decide between 2-opt or node insertion based on the objective weights\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion: move a node to a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7674237264061701,
            1.8937899827957154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate a score for each solution based on the combined objectives (lower is better)\n        scores = [sum(obj) for (_, obj) in archive]\n        # Select a solution with probability proportional to its inverse score\n        selected_idx = random.choices(range(len(archive)), weights=[1/s for s in scores], k=1)[0]\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: a combination of 2-opt and node insertion\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution\n\n    # Determine the search space based on the objectives\n    # Calculate the relative improvement potential for each objective\n    obj_scores = np.array([sum(obj) for (_, obj) in archive])\n    if len(obj_scores) > 1:\n        obj_weights = (np.max(obj_scores) - obj_scores) / np.sum(np.max(obj_scores) - obj_scores)\n    else:\n        obj_weights = np.array([1.0, 0.0, 0.0])  # Default weights if only one solution\n\n    # Decide between 2-opt or node insertion based on the objective weights\n    if random.random() < 0.7:  # Higher probability for 2-opt\n        # 2-opt move: select two edges and reverse the segment between them\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node insertion: move a node to a different position\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values but not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: apply a combination of 2-opt and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to invert (segment inversion)\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply 2-opt on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if inversion causes duplicates\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7991538957304974,
            1.3147672176361085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values but not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search: apply a combination of 2-opt and segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to invert (segment inversion)\n    start, end = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply 2-opt on a random segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if inversion causes duplicates\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two distinct nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Apply node insertion for further improvement\n    for _ in range(5):\n        # Randomly select a node and its new position\n        node = np.random.choice(new_solution)\n        pos = np.random.randint(n)\n        new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)[0]), pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5908237426059959,
            2.1858391761779785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the highest potential for improvement\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two distinct nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    # Apply node insertion for further improvement\n    for _ in range(5):\n        # Randomly select a node and its new position\n        node = np.random.choice(new_solution)\n        pos = np.random.randint(n)\n        new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node)[0]), pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest objective sum (most promising for improvement)\n    selected_idx = np.argmin(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure no duplicate nodes in the new edges\n    while (i == k or j == l or i == l or j == k):\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Create new edges by reconnecting\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution is still a valid tour (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to standard 2-opt if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6837953172499291,
            1.4270321488380433
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest objective sum (most promising for improvement)\n    selected_idx = np.argmin(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break and reconnect\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure no duplicate nodes in the new edges\n    while (i == k or j == l or i == l or j == k):\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Create new edges by reconnecting\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution is still a valid tour (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to standard 2-opt if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{A novel heuristic function selects a high-potential solution from the archive, then applies a hybrid local search combining 2-opt swaps, node insertion, and objective-aware edge selection to generate a non-dominated neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, the one with the best trade-off across objectives)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n\n    # Step 1: 2-opt swap with objective-aware edge selection\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(1, n), 2))\n        if j - i > 1:  # Ensure at least one node between i and j\n            # Calculate cost change for all three objectives\n            old_edges = [\n                (new_solution[i-1], new_solution[i]),\n                (new_solution[j-1], new_solution[j])\n            ]\n            new_edges = [\n                (new_solution[i-1], new_solution[j-1]),\n                (new_solution[i], new_solution[j])\n            ]\n\n            cost_change = [\n                (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] - distance_matrix_1[old_edges[1][0], old_edges[1][1]]),\n                (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] - distance_matrix_2[old_edges[1][0], old_edges[1][1]]),\n                (distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] - distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n            ]\n\n            # Accept if at least one objective improves\n            if any(change < 0 for change in cost_change):\n                new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    # Step 2: Node insertion with objective-aware selection\n    for _ in range(5):\n        node = random.randint(0, n-1)\n        pos = random.randint(0, n-1)\n        if node != pos and (node != pos + 1 or pos == n-1):\n            # Calculate cost change for all three objectives\n            old_edges = [\n                (new_solution[pos-1], new_solution[pos]),\n                (new_solution[node-1], new_solution[node])\n            ]\n            new_edges = [\n                (new_solution[pos-1], new_solution[node]),\n                (new_solution[node], new_solution[pos])\n            ]\n\n            cost_change = [\n                (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] - distance_matrix_1[old_edges[1][0], old_edges[1][1]]),\n                (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] - distance_matrix_2[old_edges[1][0], old_edges[1][1]]),\n                (distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] - distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n            ]\n\n            # Accept if at least one objective improves\n            if any(change < 0 for change in cost_change):\n                new_solution = np.insert(np.delete(new_solution, node), pos, new_solution[node])\n\n    return new_solution\n\n",
        "score": [
            -0.8122198751982909,
            1.5084192991256713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, the one with the best trade-off across objectives)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n\n    # Step 1: 2-opt swap with objective-aware edge selection\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = sorted(random.sample(range(1, n), 2))\n        if j - i > 1:  # Ensure at least one node between i and j\n            # Calculate cost change for all three objectives\n            old_edges = [\n                (new_solution[i-1], new_solution[i]),\n                (new_solution[j-1], new_solution[j])\n            ]\n            new_edges = [\n                (new_solution[i-1], new_solution[j-1]),\n                (new_solution[i], new_solution[j])\n            ]\n\n            cost_change = [\n                (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] - distance_matrix_1[old_edges[1][0], old_edges[1][1]]),\n                (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] - distance_matrix_2[old_edges[1][0], old_edges[1][1]]),\n                (distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] - distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n            ]\n\n            # Accept if at least one objective improves\n            if any(change < 0 for change in cost_change):\n                new_solution[i:j] = new_solution[j-1:i-1:-1]\n\n    # Step 2: Node insertion with objective-aware selection\n    for _ in range(5):\n        node = random.randint(0, n-1)\n        pos = random.randint(0, n-1)\n        if node != pos and (node != pos + 1 or pos == n-1):\n            # Calculate cost change for all three objectives\n            old_edges = [\n                (new_solution[pos-1], new_solution[pos]),\n                (new_solution[node-1], new_solution[node])\n            ]\n            new_edges = [\n                (new_solution[pos-1], new_solution[node]),\n                (new_solution[node], new_solution[pos])\n            ]\n\n            cost_change = [\n                (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_1[old_edges[0][0], old_edges[0][1]] - distance_matrix_1[old_edges[1][0], old_edges[1][1]]),\n                (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_2[old_edges[0][0], old_edges[0][1]] - distance_matrix_2[old_edges[1][0], old_edges[1][1]]),\n                (distance_matrix_3[new_edges[0][0], new_edges[0][1]] + distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                 distance_matrix_3[old_edges[0][0], old_edges[0][1]] - distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n            ]\n\n            # Accept if at least one objective improves\n            if any(change < 0 for change in cost_change):\n                new_solution = np.insert(np.delete(new_solution, node), pos, new_solution[node])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform two 2-opt swaps to ensure feasibility\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Multi-objective aware swap: swap nodes that are not adjacent in the current solution\n    if np.random.rand() < 0.3:  # 30% chance to apply this swap\n        non_adjacent = [idx for idx in range(n) if idx != 0 and base_solution[idx] != base_solution[idx-1]]\n        if len(non_adjacent) >= 2:\n            a, b = np.random.choice(non_adjacent, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.649217174854761,
            0.9573139071464538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform two 2-opt swaps to ensure feasibility\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n    new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n    # Multi-objective aware swap: swap nodes that are not adjacent in the current solution\n    if np.random.rand() < 0.3:  # 30% chance to apply this swap\n        non_adjacent = [idx for idx in range(n) if idx != 0 and base_solution[idx] != base_solution[idx-1]]\n        if len(non_adjacent) >= 2:\n            a, b = np.random.choice(non_adjacent, 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_objectives = selected[1]\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the new edges are valid and improve at least one objective\n    def is_valid_and_improving(a, b, c, d):\n        # Check if the new edges are valid and improve at least one objective\n        new_edges = [(new_solution[a], new_solution[b]), (new_solution[c], new_solution[d])]\n        old_edges = [(new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n\n        # Calculate the change in objectives\n        delta1 = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[c], new_solution[d]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Check if at least one objective improves\n        return (delta1 < 0) or (delta2 < 0) or (delta3 < 0)\n\n    # Try to find a valid and improving move\n    max_attempts = 10\n    for _ in range(max_attempts):\n        if is_valid_and_improving(i, j, k, l):\n            # Reconnect the edges\n            new_solution = np.concatenate((new_solution[:i+1], new_solution[k:l+1][::-1], new_solution[j+1:]))\n            break\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n    # If no improving move found, perform a random 2-opt\n    if not np.array_equal(new_solution, base_solution):\n        return new_solution\n    else:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate((new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]))\n        return new_solution\n\n",
        "score": [
            -0.6886741896836448,
            0.15758390426635743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_objectives = selected[1]\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the new edges are valid and improve at least one objective\n    def is_valid_and_improving(a, b, c, d):\n        # Check if the new edges are valid and improve at least one objective\n        new_edges = [(new_solution[a], new_solution[b]), (new_solution[c], new_solution[d])]\n        old_edges = [(new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n\n        # Calculate the change in objectives\n        delta1 = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[c], new_solution[d]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Check if at least one objective improves\n        return (delta1 < 0) or (delta2 < 0) or (delta3 < 0)\n\n    # Try to find a valid and improving move\n    max_attempts = 10\n    for _ in range(max_attempts):\n        if is_valid_and_improving(i, j, k, l):\n            # Reconnect the edges\n            new_solution = np.concatenate((new_solution[:i+1], new_solution[k:l+1][::-1], new_solution[j+1:]))\n            break\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n    # If no improving move found, perform a random 2-opt\n    if not np.array_equal(new_solution, base_solution):\n        return new_solution\n    else:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate((new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]))\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_objectives = selected[1]\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the new edges are valid and improve at least one objective\n    def is_valid_and_improving(a, b, c, d):\n        # Check if the new edges are valid and improve at least one objective\n        new_edges = [(new_solution[a], new_solution[b]), (new_solution[c], new_solution[d])]\n        old_edges = [(new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n\n        # Calculate the change in objectives\n        delta1 = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[c], new_solution[d]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Check if at least one objective improves\n        return (delta1 < 0) or (delta2 < 0) or (delta3 < 0)\n\n    # Try to find a valid and improving move\n    max_attempts = 10\n    for _ in range(max_attempts):\n        if is_valid_and_improving(i, j, k, l):\n            # Reconnect the edges\n            new_solution = np.concatenate((new_solution[:i+1], new_solution[k:l+1][::-1], new_solution[j+1:]))\n            break\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n    # If no improving move found, perform a random 2-opt\n    if not np.array_equal(new_solution, base_solution):\n        return new_solution\n    else:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate((new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]))\n        return new_solution\n\n",
        "score": [
            -0.6886741896836448,
            0.15758390426635743
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    current_objectives = selected[1]\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the new edges are valid and improve at least one objective\n    def is_valid_and_improving(a, b, c, d):\n        # Check if the new edges are valid and improve at least one objective\n        new_edges = [(new_solution[a], new_solution[b]), (new_solution[c], new_solution[d])]\n        old_edges = [(new_solution[i], new_solution[(i+1)%n]), (new_solution[j], new_solution[(j+1)%n])]\n\n        # Calculate the change in objectives\n        delta1 = (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]] -\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        delta2 = (distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]] -\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        delta3 = (distance_matrix_3[new_solution[a], new_solution[b]] + distance_matrix_3[new_solution[c], new_solution[d]] -\n                  distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] - distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Check if at least one objective improves\n        return (delta1 < 0) or (delta2 < 0) or (delta3 < 0)\n\n    # Try to find a valid and improving move\n    max_attempts = 10\n    for _ in range(max_attempts):\n        if is_valid_and_improving(i, j, k, l):\n            # Reconnect the edges\n            new_solution = np.concatenate((new_solution[:i+1], new_solution[k:l+1][::-1], new_solution[j+1:]))\n            break\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n    # If no improving move found, perform a random 2-opt\n    if not np.array_equal(new_solution, base_solution):\n        return new_solution\n    else:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate((new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]))\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Choose a segment of the tour to reverse (2-opt or 3-opt)\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply the reverse operator to create a neighbor\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7110817429027165,
            1.1291752457618713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Choose a segment of the tour to reverse (2-opt or 3-opt)\n    n = len(selected_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply the reverse operator to create a neighbor\n    new_solution = selected_solution.copy()\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a multi-objective 2-opt move\n    if i != k and j != l:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the segment between k and l\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Additionally, perform a multi-objective edge swap based on the worst objective\n    # Identify the worst objective among the three\n    objective_values = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                       sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                       sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    worst_obj = np.argmax(objective_values)\n\n    # Select edges to swap based on the worst objective\n    if worst_obj == 0:\n        # Swap edges in the first objective space\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Swap edges in the second objective space\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Swap edges in the third objective space\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7118898125029992,
            1.5363396883010865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform a multi-objective 2-opt move\n    if i != k and j != l:\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Reverse the segment between k and l\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Additionally, perform a multi-objective edge swap based on the worst objective\n    # Identify the worst objective among the three\n    objective_values = [sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                       sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)),\n                       sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))]\n    worst_obj = np.argmax(objective_values)\n\n    # Select edges to swap based on the worst objective\n    if worst_obj == 0:\n        # Swap edges in the first objective space\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    elif worst_obj == 1:\n        # Swap edges in the second objective space\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    else:\n        # Swap edges in the third objective space\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    improvement_potentials = []\n    for sol, obj in archive:\n        # Calculate potential improvement by comparing to the best objectives in the archive\n        best_obj1 = min([o[0] for _, o in archive])\n        best_obj2 = min([o[1] for _, o in archive])\n        best_obj3 = min([o[2] for _, o in archive])\n        potential = (obj[0] - best_obj1) + (obj[1] - best_obj2) + (obj[2] - best_obj3)\n        improvement_potentials.append(potential)\n\n    # Select the solution with the highest potential for improvement\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2-opt with objective-aware edge selection\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select a random segment to reverse\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        # Calculate the delta in objectives\n        delta_obj1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta_obj2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta_obj3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        # Accept if any objective improves\n        if delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0:\n            # Reverse the segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Apply adaptive segment inversion based on objective diversity\n    for _ in range(5):\n        # Select a segment with high diversity in objectives\n        segment_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Calculate the objectives for the segment\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj3 = sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Calculate the objectives if we reverse the segment\n        reversed_obj1 = sum(distance_matrix_1[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        reversed_obj2 = sum(distance_matrix_2[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        reversed_obj3 = sum(distance_matrix_3[segment[i+1], segment[i]] for i in range(len(segment)-1))\n\n        # Accept if any objective improves\n        if (reversed_obj1 <= obj1 or reversed_obj2 <= obj2 or reversed_obj3 <= obj3):\n            new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6935979227012632,
            3.1086889624595644
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    improvement_potentials = []\n    for sol, obj in archive:\n        # Calculate potential improvement by comparing to the best objectives in the archive\n        best_obj1 = min([o[0] for _, o in archive])\n        best_obj2 = min([o[1] for _, o in archive])\n        best_obj3 = min([o[2] for _, o in archive])\n        potential = (obj[0] - best_obj1) + (obj[1] - best_obj2) + (obj[2] - best_obj3)\n        improvement_potentials.append(potential)\n\n    # Select the solution with the highest potential for improvement\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive 2-opt with objective-aware edge selection\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Select a random segment to reverse\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the change in objectives\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n])\n        ]\n\n        # Calculate the delta in objectives\n        delta_obj1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_1[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_1[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n\n        delta_obj2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_2[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_2[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        delta_obj3 = (distance_matrix_3[new_edges[0][0], new_edges[0][1]] +\n                      distance_matrix_3[new_edges[1][0], new_edges[1][1]] -\n                      distance_matrix_3[old_edges[0][0], old_edges[0][1]] -\n                      distance_matrix_3[old_edges[1][0], old_edges[1][1]])\n\n        # Accept if any objective improves\n        if delta_obj1 <= 0 or delta_obj2 <= 0 or delta_obj3 <= 0:\n            # Reverse the segment\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 3: Apply adaptive segment inversion based on objective diversity\n    for _ in range(5):\n        # Select a segment with high diversity in objectives\n        segment_size = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Calculate the objectives for the segment\n        obj1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        obj3 = sum(distance_matrix_3[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n        # Calculate the objectives if we reverse the segment\n        reversed_obj1 = sum(distance_matrix_1[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        reversed_obj2 = sum(distance_matrix_2[segment[i+1], segment[i]] for i in range(len(segment)-1))\n        reversed_obj3 = sum(distance_matrix_3[segment[i+1], segment[i]] for i in range(len(segment)-1))\n\n        # Accept if any objective improves\n        if (reversed_obj1 <= obj1 or reversed_obj2 <= obj2 or reversed_obj3 <= obj3):\n            new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives to prioritize improvement\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Check if the solution remains feasible (visits all nodes exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If not, revert to the original solution\n        new_solution = base_solution.copy()\n\n    # Further refine by swapping edges that improve at least one objective\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Create a candidate solution with the swap\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n        candidate[c], candidate[d] = candidate[d], candidate[c]\n\n        # Check feasibility\n        if len(np.unique(candidate)) != n:\n            continue\n\n        # Evaluate the candidate's objectives\n        obj1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective is improved\n        if (obj1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n           (obj2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]) or \\\n           (obj3 < sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.824881773462821,
            3.344572734832764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of objectives to prioritize improvement\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Check if the solution remains feasible (visits all nodes exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If not, revert to the original solution\n        new_solution = base_solution.copy()\n\n    # Further refine by swapping edges that improve at least one objective\n    for _ in range(5):  # Limit the number of attempts to avoid excessive computation\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        c, d = sorted(np.random.choice(n, size=2, replace=False))\n\n        # Create a candidate solution with the swap\n        candidate = new_solution.copy()\n        candidate[a], candidate[b] = candidate[b], candidate[a]\n        candidate[c], candidate[d] = candidate[d], candidate[c]\n\n        # Check feasibility\n        if len(np.unique(candidate)) != n:\n            continue\n\n        # Evaluate the candidate's objectives\n        obj1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective is improved\n        if (obj1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n           (obj2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]) or \\\n           (obj3 < sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply 2-opt on the objective with the highest variance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective variances\n    obj1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n    obj2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n    obj3 = [distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n    var1 = np.var(obj1)\n    var2 = np.var(obj2)\n    var3 = np.var(obj3)\n\n    # Select the objective with highest variance for 2-opt\n    if var1 >= var2 and var1 >= var3:\n        dist_matrix = distance_matrix_1\n    elif var2 >= var1 and var2 >= var3:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt with probabilistic acceptance\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i+1)%n or j == (i-1)%n:\n            continue\n\n        # Calculate current and new distances\n        current_dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n        new_dist = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if new_dist <= current_dist:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        elif np.random.rand() < 0.2:  # Probabilistic acceptance for exploration\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7966385607344098,
            2.266760528087616
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply 2-opt on the objective with the highest variance\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate objective variances\n    obj1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n    obj2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n    obj3 = [distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n    var1 = np.var(obj1)\n    var2 = np.var(obj2)\n    var3 = np.var(obj3)\n\n    # Select the objective with highest variance for 2-opt\n    if var1 >= var2 and var1 >= var3:\n        dist_matrix = distance_matrix_1\n    elif var2 >= var1 and var2 >= var3:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt with probabilistic acceptance\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i+1)%n or j == (i-1)%n:\n            continue\n\n        # Calculate current and new distances\n        current_dist = dist_matrix[new_solution[i], new_solution[(i+1)%n]] + dist_matrix[new_solution[j], new_solution[(j+1)%n]]\n        new_dist = dist_matrix[new_solution[i], new_solution[j]] + dist_matrix[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if new_dist <= current_dist:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n        elif np.random.rand() < 0.2:  # Probabilistic acceptance for exploration\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb (avoiding endpoints to maintain feasibility)\n    start = np.random.randint(1, n-2)\n    end = np.random.randint(start+1, n-1)\n\n    # Evaluate edges in the segment for potential improvement\n    segment = new_solution[start:end+1]\n    segment_costs = np.zeros((len(segment), len(segment), 3))\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                node_i = segment[i]\n                node_j = segment[j]\n                segment_costs[i, j, 0] = distance_matrix_1[node_i, node_j]\n                segment_costs[i, j, 1] = distance_matrix_2[node_i, node_j]\n                segment_costs[i, j, 2] = distance_matrix_3[node_i, node_j]\n\n    # Find edges that improve at least one objective while not worsening others too much\n    improvement_candidates = []\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                original_costs = [\n                    distance_matrix_1[segment[i-1], segment[i]] + distance_matrix_1[segment[j], segment[(j+1)%len(segment)]],\n                    distance_matrix_2[segment[i-1], segment[i]] + distance_matrix_2[segment[j], segment[(j+1)%len(segment)]],\n                    distance_matrix_3[segment[i-1], segment[i]] + distance_matrix_3[segment[j], segment[(j+1)%len(segment)]]\n                ]\n                new_costs = [\n                    distance_matrix_1[segment[i-1], segment[j]] + distance_matrix_1[segment[i], segment[(j+1)%len(segment)]],\n                    distance_matrix_2[segment[i-1], segment[j]] + distance_matrix_2[segment[i], segment[(j+1)%len(segment)]],\n                    distance_matrix_3[segment[i-1], segment[j]] + distance_matrix_3[segment[i], segment[(j+1)%len(segment)]]\n                ]\n\n                # Check if at least one objective improves while others don't worsen by more than 10%\n                if (any(new_costs[k] < original_costs[k] for k in range(3)) and\n                    all(new_costs[k] <= 1.1 * original_costs[k] for k in range(3))):\n                    improvement_candidates.append((i, j))\n\n    # Apply the best improvement if found\n    if improvement_candidates:\n        i, j = improvement_candidates[np.random.choice(len(improvement_candidates))]\n        new_solution[start+i], new_solution[start+j] = new_solution[start+j], new_solution[start+i]\n\n    return new_solution\n\n",
        "score": [
            -0.6347755594024808,
            3.246707189083099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb (avoiding endpoints to maintain feasibility)\n    start = np.random.randint(1, n-2)\n    end = np.random.randint(start+1, n-1)\n\n    # Evaluate edges in the segment for potential improvement\n    segment = new_solution[start:end+1]\n    segment_costs = np.zeros((len(segment), len(segment), 3))\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                node_i = segment[i]\n                node_j = segment[j]\n                segment_costs[i, j, 0] = distance_matrix_1[node_i, node_j]\n                segment_costs[i, j, 1] = distance_matrix_2[node_i, node_j]\n                segment_costs[i, j, 2] = distance_matrix_3[node_i, node_j]\n\n    # Find edges that improve at least one objective while not worsening others too much\n    improvement_candidates = []\n    for i in range(len(segment)):\n        for j in range(len(segment)):\n            if i != j:\n                original_costs = [\n                    distance_matrix_1[segment[i-1], segment[i]] + distance_matrix_1[segment[j], segment[(j+1)%len(segment)]],\n                    distance_matrix_2[segment[i-1], segment[i]] + distance_matrix_2[segment[j], segment[(j+1)%len(segment)]],\n                    distance_matrix_3[segment[i-1], segment[i]] + distance_matrix_3[segment[j], segment[(j+1)%len(segment)]]\n                ]\n                new_costs = [\n                    distance_matrix_1[segment[i-1], segment[j]] + distance_matrix_1[segment[i], segment[(j+1)%len(segment)]],\n                    distance_matrix_2[segment[i-1], segment[j]] + distance_matrix_2[segment[i], segment[(j+1)%len(segment)]],\n                    distance_matrix_3[segment[i-1], segment[j]] + distance_matrix_3[segment[i], segment[(j+1)%len(segment)]]\n                ]\n\n                # Check if at least one objective improves while others don't worsen by more than 10%\n                if (any(new_costs[k] < original_costs[k] for k in range(3)) and\n                    all(new_costs[k] <= 1.1 * original_costs[k] for k in range(3))):\n                    improvement_candidates.append((i, j))\n\n    # Apply the best improvement if found\n    if improvement_candidates:\n        i, j = improvement_candidates[np.random.choice(len(improvement_candidates))]\n        new_solution[start+i], new_solution[start+j] = new_solution[start+j], new_solution[start+i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the variance of objectives to identify under-explored dimensions\n    objectives = np.array([obj for (_, obj) in archive])\n    objective_variances = np.var(objectives, axis=0)\n\n    # Select the solution with the highest variance in the least explored objective\n    selected_idx = np.argmax(objective_variances[np.argmin(objective_variances)])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a multi-objective aware swap: identify the worst edge in any objective and swap it\n    worst_edge_idx = -1\n    worst_edge_value = -1\n\n    for k in range(n):\n        node_a = new_solution[k]\n        node_b = new_solution[(k + 1) % n]\n\n        # Calculate the sum of distances in all three objectives\n        total_distance = (\n            distance_matrix_1[node_a, node_b] +\n            distance_matrix_2[node_a, node_b] +\n            distance_matrix_3[node_a, node_b]\n        )\n\n        if total_distance > worst_edge_value:\n            worst_edge_value = total_distance\n            worst_edge_idx = k\n\n    # Swap the worst edge with a random candidate\n    if worst_edge_idx != -1:\n        candidates = [i for i in range(n) if i != worst_edge_idx and i != (worst_edge_idx + 1) % n]\n        if candidates:\n            swap_idx = random.choice(candidates)\n            new_solution[worst_edge_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_edge_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7235872592769884,
            1.0922425031661986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the variance of objectives to identify under-explored dimensions\n    objectives = np.array([obj for (_, obj) in archive])\n    objective_variances = np.var(objectives, axis=0)\n\n    # Select the solution with the highest variance in the least explored objective\n    selected_idx = np.argmax(objective_variances[np.argmin(objective_variances)])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt to reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a multi-objective aware swap: identify the worst edge in any objective and swap it\n    worst_edge_idx = -1\n    worst_edge_value = -1\n\n    for k in range(n):\n        node_a = new_solution[k]\n        node_b = new_solution[(k + 1) % n]\n\n        # Calculate the sum of distances in all three objectives\n        total_distance = (\n            distance_matrix_1[node_a, node_b] +\n            distance_matrix_2[node_a, node_b] +\n            distance_matrix_3[node_a, node_b]\n        )\n\n        if total_distance > worst_edge_value:\n            worst_edge_value = total_distance\n            worst_edge_idx = k\n\n    # Swap the worst edge with a random candidate\n    if worst_edge_idx != -1:\n        candidates = [i for i in range(n) if i != worst_edge_idx and i != (worst_edge_idx + 1) % n]\n        if candidates:\n            swap_idx = random.choice(candidates)\n            new_solution[worst_edge_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[worst_edge_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the swap while ensuring feasibility\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5921133414565514,
            1.2855921864509583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform the swap while ensuring feasibility\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest combined improvement potential across objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt swap with objective-aware edge selection\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate edge swaps based on combined objective improvement\n    best_improvement = 0\n    best_swap = None\n\n    for k in range(i, j):\n        # Propose a 2-opt swap\n        candidate = new_solution.copy()\n        candidate[i:k+1] = new_solution[i:k+1][::-1]\n\n        # Calculate total objective improvement\n        obj1 = sum(distance_matrix_1[candidate[m], candidate[m+1]] for m in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[m], candidate[m+1]] for m in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[m], candidate[m+1]] for m in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        current_obj1 = sum(distance_matrix_1[base_solution[m], base_solution[m+1]] for m in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n        current_obj2 = sum(distance_matrix_2[base_solution[m], base_solution[m+1]] for m in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n        current_obj3 = sum(distance_matrix_3[base_solution[m], base_solution[m+1]] for m in range(n-1)) + distance_matrix_3[base_solution[-1], base_solution[0]]\n\n        improvement = (current_obj1 - obj1) + (current_obj2 - obj2) + (current_obj3 - obj3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = candidate\n\n    if best_swap is not None:\n        new_solution = best_swap\n\n    # Apply a randomized edge insertion for further exploration\n    if np.random.rand() < 0.3:\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution = np.roll(new_solution, shift=np.random.randint(1, n))\n\n    return new_solution\n\n",
        "score": [
            -0.6940971230340292,
            3.0651664614677427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest combined improvement potential across objectives\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: 2-opt swap with objective-aware edge selection\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate edge swaps based on combined objective improvement\n    best_improvement = 0\n    best_swap = None\n\n    for k in range(i, j):\n        # Propose a 2-opt swap\n        candidate = new_solution.copy()\n        candidate[i:k+1] = new_solution[i:k+1][::-1]\n\n        # Calculate total objective improvement\n        obj1 = sum(distance_matrix_1[candidate[m], candidate[m+1]] for m in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[m], candidate[m+1]] for m in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[m], candidate[m+1]] for m in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        current_obj1 = sum(distance_matrix_1[base_solution[m], base_solution[m+1]] for m in range(n-1)) + distance_matrix_1[base_solution[-1], base_solution[0]]\n        current_obj2 = sum(distance_matrix_2[base_solution[m], base_solution[m+1]] for m in range(n-1)) + distance_matrix_2[base_solution[-1], base_solution[0]]\n        current_obj3 = sum(distance_matrix_3[base_solution[m], base_solution[m+1]] for m in range(n-1)) + distance_matrix_3[base_solution[-1], base_solution[0]]\n\n        improvement = (current_obj1 - obj1) + (current_obj2 - obj2) + (current_obj3 - obj3)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_swap = candidate\n\n    if best_swap is not None:\n        new_solution = best_swap\n\n    # Apply a randomized edge insertion for further exploration\n    if np.random.rand() < 0.3:\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution = np.roll(new_solution, shift=np.random.randint(1, n))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-way edge swap\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # First, perform a 2-opt move (swap two edges)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-way edge swap (novel operator)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7973121324206371,
            0.9632619380950928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel 3-way edge swap\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # First, perform a 2-opt move (swap two edges)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-way edge swap (novel operator)\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n    new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_index = np.random.choice(np.where(scores == scores.max())[0])\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = base_solution[i:j+1]\n\n    # Reverse the segment to create a 2-opt move\n    new_segment = segment[::-1]\n    new_solution[i:j+1] = new_segment\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    new_obj = calculate_objective(new_solution)\n    old_obj = calculate_objective(base_solution)\n\n    # Accept the move if it improves at least one objective\n    if any(new_obj[k] < old_obj[k] for k in range(3)):\n        return new_solution\n    else:\n        # If no improvement, try a different 2-opt move\n        for _ in range(10):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = base_solution[i:j+1]\n            new_segment = segment[::-1]\n            candidate_solution = base_solution.copy()\n            candidate_solution[i:j+1] = new_segment\n            candidate_obj = calculate_objective(candidate_solution)\n            if any(candidate_obj[k] < old_obj[k] for k in range(3)):\n                return candidate_solution\n\n    return base_solution\n\n",
        "score": [
            -0.6786866475674745,
            1.6014872670173645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_index = np.random.choice(np.where(scores == scores.max())[0])\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = base_solution[i:j+1]\n\n    # Reverse the segment to create a 2-opt move\n    new_segment = segment[::-1]\n    new_solution[i:j+1] = new_segment\n\n    # Evaluate the new solution's objectives\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        obj2 = sum(distance_matrix_2[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        obj3 = sum(distance_matrix_3[solution[k], solution[k+1]] for k in range(n-1)) + distance_matrix_3[solution[-1], solution[0]]\n        return (obj1, obj2, obj3)\n\n    new_obj = calculate_objective(new_solution)\n    old_obj = calculate_objective(base_solution)\n\n    # Accept the move if it improves at least one objective\n    if any(new_obj[k] < old_obj[k] for k in range(3)):\n        return new_solution\n    else:\n        # If no improvement, try a different 2-opt move\n        for _ in range(10):\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = base_solution[i:j+1]\n            new_segment = segment[::-1]\n            candidate_solution = base_solution.copy()\n            candidate_solution[i:j+1] = new_segment\n            candidate_obj = calculate_objective(candidate_solution)\n            if any(candidate_obj[k] < old_obj[k] for k in range(3)):\n                return candidate_solution\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{This algorithm selects a promising solution from the archive by prioritizing those with the best objective values, then applies a hybrid local search operator that combines 2-opt and edge exchange strategies tailored for tri-objective optimization, ensuring feasibility and diversity in the generated neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with the best combined objective)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to prioritize solutions with better trade-offs\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - np.min(normalized_objectives, axis=0)) / (np.max(normalized_objectives, axis=0) - np.min(normalized_objectives, axis=0) + 1e-10)\n    combined_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(combined_scores)  # Select the solution with the best trade-off\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with edge exchange and objective-aware swaps\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Apply 2-opt swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply edge exchange (swap edges between two segments)\n        if k != i and l != j:\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n        # Objective-aware swap: prioritize swaps that improve at least one objective\n        if random.random() < 0.3:  # 30% chance to apply objective-aware swap\n            obj1_before = np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2_before = np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3_before = np.sum(distance_matrix_3[new_solution[:-1], new_solution[1:]]) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # Try swapping two random nodes\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            obj1_after = np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2_after = np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3_after = np.sum(distance_matrix_3[new_solution[:-1], new_solution[1:]]) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # Revert if no improvement in any objective\n            if (obj1_after >= obj1_before and obj2_after >= obj2_before and obj3_after >= obj3_before):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6941779201589094,
            2.278388488292694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (e.g., with the best combined objective)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to prioritize solutions with better trade-offs\n    normalized_objectives = np.array(archive_objectives)\n    normalized_objectives = (normalized_objectives - np.min(normalized_objectives, axis=0)) / (np.max(normalized_objectives, axis=0) - np.min(normalized_objectives, axis=0) + 1e-10)\n    combined_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(combined_scores)  # Select the solution with the best trade-off\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with edge exchange and objective-aware swaps\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Apply 2-opt swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply edge exchange (swap edges between two segments)\n        if k != i and l != j:\n            new_solution[k:l] = new_solution[k:l][::-1]\n\n        # Objective-aware swap: prioritize swaps that improve at least one objective\n        if random.random() < 0.3:  # 30% chance to apply objective-aware swap\n            obj1_before = np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2_before = np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3_before = np.sum(distance_matrix_3[new_solution[:-1], new_solution[1:]]) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # Try swapping two random nodes\n            a, b = random.sample(range(n), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            obj1_after = np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2_after = np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3_after = np.sum(distance_matrix_3[new_solution[:-1], new_solution[1:]]) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # Revert if no improvement in any objective\n            if (obj1_after >= obj1_before and obj2_after >= obj2_before and obj3_after >= obj3_before):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware node swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the worst objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst pair in the current tour\n    worst_pair = None\n    worst_pair_value = -1\n    for i in range(n):\n        j = (i + 1) % n\n        current_value = dist_matrix[new_solution[i], new_solution[j]]\n        if current_value > worst_pair_value:\n            worst_pair_value = current_value\n            worst_pair = (i, j)\n\n    if worst_pair:\n        i, j = worst_pair\n        # Try to replace with a better pair\n        best_improvement = 0\n        best_k = -1\n        for k in range(n):\n            if k == i or k == j or k == (i - 1) % n or k == (j + 1) % n:\n                continue\n            # Calculate potential improvement\n            improvement = (dist_matrix[new_solution[i], new_solution[k]] +\n                          dist_matrix[new_solution[j], new_solution[(k + 1) % n]] -\n                          dist_matrix[new_solution[i], new_solution[j]] -\n                          dist_matrix[new_solution[k], new_solution[(k + 1) % n]])\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_k = k\n\n        if best_k != -1:\n            # Perform the swap\n            new_solution[i], new_solution[best_k] = new_solution[best_k], new_solution[i]\n\n    # Additional objective-aware node swaps\n    for _ in range(2):  # Perform a few random swaps for diversification\n        a, b = np.random.choice(n, size=2, replace=False)\n        # Check if swap improves at least one objective\n        orig_obj1 = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                     dist_matrix[new_solution[b-1], new_solution[b]])\n        new_obj1 = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                    dist_matrix[new_solution[b-1], new_solution[a]])\n\n        if new_obj1 < orig_obj1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6588513092108976,
            1.5280459880828858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware node swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt to improve the worst objective\n    obj1, obj2, obj3 = archive[selected_idx][1]\n    worst_obj = np.argmax([obj1, obj2, obj3])\n\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the worst pair in the current tour\n    worst_pair = None\n    worst_pair_value = -1\n    for i in range(n):\n        j = (i + 1) % n\n        current_value = dist_matrix[new_solution[i], new_solution[j]]\n        if current_value > worst_pair_value:\n            worst_pair_value = current_value\n            worst_pair = (i, j)\n\n    if worst_pair:\n        i, j = worst_pair\n        # Try to replace with a better pair\n        best_improvement = 0\n        best_k = -1\n        for k in range(n):\n            if k == i or k == j or k == (i - 1) % n or k == (j + 1) % n:\n                continue\n            # Calculate potential improvement\n            improvement = (dist_matrix[new_solution[i], new_solution[k]] +\n                          dist_matrix[new_solution[j], new_solution[(k + 1) % n]] -\n                          dist_matrix[new_solution[i], new_solution[j]] -\n                          dist_matrix[new_solution[k], new_solution[(k + 1) % n]])\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_k = k\n\n        if best_k != -1:\n            # Perform the swap\n            new_solution[i], new_solution[best_k] = new_solution[best_k], new_solution[i]\n\n    # Additional objective-aware node swaps\n    for _ in range(2):  # Perform a few random swaps for diversification\n        a, b = np.random.choice(n, size=2, replace=False)\n        # Check if swap improves at least one objective\n        orig_obj1 = (dist_matrix[new_solution[a-1], new_solution[a]] +\n                     dist_matrix[new_solution[b-1], new_solution[b]])\n        new_obj1 = (dist_matrix[new_solution[a-1], new_solution[b]] +\n                    dist_matrix[new_solution[b-1], new_solution[a]])\n\n        if new_obj1 < orig_obj1:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Apply 2-opt and 3-opt with objective-aware edge selection\n    n = len(base_solution)\n    improved = False\n\n    # 2-opt with objective-aware edge selection\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            if (distance_matrix_1[base_solution[i], base_solution[i+1]] +\n                distance_matrix_1[base_solution[j], base_solution[j-1]]) > (\n                distance_matrix_1[base_solution[i], base_solution[j]] +\n                distance_matrix_1[base_solution[i+1], base_solution[j-1]]):\n                if (distance_matrix_2[base_solution[i], base_solution[i+1]] +\n                    distance_matrix_2[base_solution[j], base_solution[j-1]]) > (\n                    distance_matrix_2[base_solution[i], base_solution[j]] +\n                    distance_matrix_2[base_solution[i+1], base_solution[j-1]]):\n                    if (distance_matrix_3[base_solution[i], base_solution[i+1]] +\n                        distance_matrix_3[base_solution[j], base_solution[j-1]]) > (\n                        distance_matrix_3[base_solution[i], base_solution[j]] +\n                        distance_matrix_3[base_solution[i+1], base_solution[j-1]]):\n                        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                        improved = True\n                        break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try 3-opt\n    if not improved:\n        for i in range(n - 3):\n            for j in range(i + 2, n - 1):\n                for k in range(j + 2, n):\n                    # Check all possible 3-opt moves\n                    for move in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n                        a, b, c = move\n                        # Reconstruct the tour with the move\n                        temp_solution = new_solution.copy()\n                        temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n                        temp_solution[b:c+1] = temp_solution[b:c+1][::-1]\n                        temp_solution[a:c+1] = temp_solution[a:c+1][::-1]\n\n                        # Check if this move improves all objectives\n                        if (sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n)) <\n                            sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n))):\n                            if (sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n)) <\n                                sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n))):\n                                if (sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n)) <\n                                    sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n))):\n                                    new_solution = temp_solution\n                                    improved = True\n                                    break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.650580482049034,
            1.1748703002929688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Apply 2-opt and 3-opt with objective-aware edge selection\n    n = len(base_solution)\n    improved = False\n\n    # 2-opt with objective-aware edge selection\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            if (distance_matrix_1[base_solution[i], base_solution[i+1]] +\n                distance_matrix_1[base_solution[j], base_solution[j-1]]) > (\n                distance_matrix_1[base_solution[i], base_solution[j]] +\n                distance_matrix_1[base_solution[i+1], base_solution[j-1]]):\n                if (distance_matrix_2[base_solution[i], base_solution[i+1]] +\n                    distance_matrix_2[base_solution[j], base_solution[j-1]]) > (\n                    distance_matrix_2[base_solution[i], base_solution[j]] +\n                    distance_matrix_2[base_solution[i+1], base_solution[j-1]]):\n                    if (distance_matrix_3[base_solution[i], base_solution[i+1]] +\n                        distance_matrix_3[base_solution[j], base_solution[j-1]]) > (\n                        distance_matrix_3[base_solution[i], base_solution[j]] +\n                        distance_matrix_3[base_solution[i+1], base_solution[j-1]]):\n                        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                        improved = True\n                        break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try 3-opt\n    if not improved:\n        for i in range(n - 3):\n            for j in range(i + 2, n - 1):\n                for k in range(j + 2, n):\n                    # Check all possible 3-opt moves\n                    for move in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n                        a, b, c = move\n                        # Reconstruct the tour with the move\n                        temp_solution = new_solution.copy()\n                        temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n                        temp_solution[b:c+1] = temp_solution[b:c+1][::-1]\n                        temp_solution[a:c+1] = temp_solution[a:c+1][::-1]\n\n                        # Check if this move improves all objectives\n                        if (sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n)) <\n                            sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n))):\n                            if (sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n)) <\n                                sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n))):\n                                if (sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n)) <\n                                    sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n))):\n                                    new_solution = temp_solution\n                                    improved = True\n                                    break\n                    if improved:\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{A novel heuristic function that intelligently selects a solution from the archive based on objective diversity and applies a hybrid local search operator combining 2-opt and edge insertion to generate a neighbor solution while ensuring feasibility and multi-objective optimization.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions with diverse objectives and sort by a combined metric\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = normalized_objectives.std(axis=1)\n    combined_scores = diversity_scores + 0.1 * (1 / (1 + objectives.sum(axis=1)))\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(base_solution)\n    for _ in range(10):  # Number of iterations for local search\n        # Randomly choose a local search operator\n        operator = random.choice(['2-opt', 'edge-insertion'])\n\n        if operator == '2-opt':\n            # Perform 2-opt on a random segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Perform edge insertion\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7278210831818566,
            1.283213698863983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions with diverse objectives and sort by a combined metric\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = normalized_objectives.std(axis=1)\n    combined_scores = diversity_scores + 0.1 * (1 / (1 + objectives.sum(axis=1)))\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    n = len(base_solution)\n    for _ in range(10):  # Number of iterations for local search\n        # Randomly choose a local search operator\n        operator = random.choice(['2-opt', 'edge-insertion'])\n\n        if operator == '2-opt':\n            # Perform 2-opt on a random segment\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Perform edge insertion\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Identify edges with high potential for improvement in any of the three objectives\n    candidate_edges = []\n    for i in range(n):\n        u = best_solution[i]\n        v = best_solution[(i + 1) % n]\n        # Calculate improvement potential in each objective\n        improvement_potential = (\n            distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        )\n        candidate_edges.append((improvement_potential, i))\n\n    # Sort edges by improvement potential (descending)\n    candidate_edges.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 5 edges to consider for 2-opt\n    top_edges = [edge[1] for edge in candidate_edges[:min(5, len(candidate_edges))]]\n\n    # Perform 2-opt on selected edges\n    for i in top_edges:\n        for j in range(i + 2, n):\n            # Check if swapping edges i and j improves any objective\n            u1, v1 = best_solution[i], best_solution[(i + 1) % n]\n            u2, v2 = best_solution[j], best_solution[(j + 1) % n]\n\n            # Calculate current and new edge costs\n            current_cost = (\n                distance_matrix_1[u1, v1] + distance_matrix_2[u1, v1] + distance_matrix_3[u1, v1] +\n                distance_matrix_1[u2, v2] + distance_matrix_2[u2, v2] + distance_matrix_3[u2, v2]\n            )\n            new_cost = (\n                distance_matrix_1[u1, u2] + distance_matrix_2[u1, u2] + distance_matrix_3[u1, u2] +\n                distance_matrix_1[v1, v2] + distance_matrix_2[v1, v2] + distance_matrix_3[v1, v2]\n            )\n\n            if new_cost < current_cost:\n                # Perform the 2-opt swap\n                new_solution[i+1:j+1] = best_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6917610389377411,
            0.8542826652526856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Identify edges with high potential for improvement in any of the three objectives\n    candidate_edges = []\n    for i in range(n):\n        u = best_solution[i]\n        v = best_solution[(i + 1) % n]\n        # Calculate improvement potential in each objective\n        improvement_potential = (\n            distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        )\n        candidate_edges.append((improvement_potential, i))\n\n    # Sort edges by improvement potential (descending)\n    candidate_edges.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 5 edges to consider for 2-opt\n    top_edges = [edge[1] for edge in candidate_edges[:min(5, len(candidate_edges))]]\n\n    # Perform 2-opt on selected edges\n    for i in top_edges:\n        for j in range(i + 2, n):\n            # Check if swapping edges i and j improves any objective\n            u1, v1 = best_solution[i], best_solution[(i + 1) % n]\n            u2, v2 = best_solution[j], best_solution[(j + 1) % n]\n\n            # Calculate current and new edge costs\n            current_cost = (\n                distance_matrix_1[u1, v1] + distance_matrix_2[u1, v1] + distance_matrix_3[u1, v1] +\n                distance_matrix_1[u2, v2] + distance_matrix_2[u2, v2] + distance_matrix_3[u2, v2]\n            )\n            new_cost = (\n                distance_matrix_1[u1, u2] + distance_matrix_2[u1, u2] + distance_matrix_3[u1, u2] +\n                distance_matrix_1[v1, v2] + distance_matrix_2[v1, v2] + distance_matrix_3[v1, v2]\n            )\n\n            if new_cost < current_cost:\n                # Perform the 2-opt swap\n                new_solution[i+1:j+1] = best_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt for nodes with high combined distance in any objective\n    n = len(new_solution)\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Check if swapping edges i->i+1 and j->j+1 improves any objective\n            original_cost = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j]] +\n                        distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]])\n\n            if new_cost < original_cost:\n                # Reverse the segment between i+1 and j to form a valid tour\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                return new_solution\n\n    # If no improvement found, perform a random 2-opt move to maintain diversity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7741431555729601,
            4.184570384025574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt for nodes with high combined distance in any objective\n    n = len(new_solution)\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Check if swapping edges i->i+1 and j->j+1 improves any objective\n            original_cost = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                             distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                             distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                             distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                        distance_matrix_2[new_solution[i], new_solution[j]] +\n                        distance_matrix_3[new_solution[i], new_solution[j]] +\n                        distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]] +\n                        distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]])\n\n            if new_cost < original_cost:\n                # Reverse the segment between i+1 and j to form a valid tour\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                return new_solution\n\n    # If no improvement found, perform a random 2-opt move to maintain diversity\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Perform a 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware swaps to further optimize\n    for _ in range(3):  # Perform 3 objective-aware swaps\n        # Compute the current objective values\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Find the worst objective and try to improve it\n        worst_obj = np.argmax([obj1, obj2, obj3])\n\n        # Select a random edge and swap it with another edge in the worst objective space\n        if worst_obj == 0:\n            mat = distance_matrix_1\n        elif worst_obj == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find the most expensive edge in the worst objective space\n        max_edge = -1\n        max_cost = -1\n        for k in range(n):\n            cost = mat[new_solution[k], new_solution[(k+1)%n]]\n            if cost > max_cost:\n                max_cost = cost\n                max_edge = k\n\n        # Swap the nodes connected by this edge\n        if max_edge != -1:\n            new_solution[max_edge], new_solution[(max_edge+1)%n] = new_solution[(max_edge+1)%n], new_solution[max_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.6973027837572188,
            1.5227444410324096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 2-opt with objective-aware swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    # Perform a 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-aware swaps to further optimize\n    for _ in range(3):  # Perform 3 objective-aware swaps\n        # Compute the current objective values\n        obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        # Find the worst objective and try to improve it\n        worst_obj = np.argmax([obj1, obj2, obj3])\n\n        # Select a random edge and swap it with another edge in the worst objective space\n        if worst_obj == 0:\n            mat = distance_matrix_1\n        elif worst_obj == 1:\n            mat = distance_matrix_2\n        else:\n            mat = distance_matrix_3\n\n        # Find the most expensive edge in the worst objective space\n        max_edge = -1\n        max_cost = -1\n        for k in range(n):\n            cost = mat[new_solution[k], new_solution[(k+1)%n]]\n            if cost > max_cost:\n                max_cost = cost\n                max_edge = k\n\n        # Swap the nodes connected by this edge\n        if max_edge != -1:\n            new_solution[max_edge], new_solution[(max_edge+1)%n] = new_solution[(max_edge+1)%n], new_solution[max_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    improved = False\n\n    for i in range(n):\n        for j in range(i + 2, n - 1):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[i+1], base_solution[j+1]]) - (distance_matrix_1[base_solution[i], base_solution[i+1]] + distance_matrix_1[base_solution[j], base_solution[j+1]])\n            delta2 = (distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[i+1], base_solution[j+1]]) - (distance_matrix_2[base_solution[i], base_solution[i+1]] + distance_matrix_2[base_solution[j], base_solution[j+1]])\n            delta3 = (distance_matrix_3[base_solution[i], base_solution[j]] + distance_matrix_3[base_solution[i+1], base_solution[j+1]]) - (distance_matrix_3[base_solution[i], base_solution[i+1]] + distance_matrix_3[base_solution[j], base_solution[j+1]])\n\n            # If any objective improves, apply the move\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = base_solution[j:i:-1]\n                improved = True\n                break\n        if improved:\n            break\n\n    if not improved:\n        # If no improvement found, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7084877872138109,
            1.4750784277915954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(base_solution)\n    improved = False\n\n    for i in range(n):\n        for j in range(i + 2, n - 1):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[i+1], base_solution[j+1]]) - (distance_matrix_1[base_solution[i], base_solution[i+1]] + distance_matrix_1[base_solution[j], base_solution[j+1]])\n            delta2 = (distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[i+1], base_solution[j+1]]) - (distance_matrix_2[base_solution[i], base_solution[i+1]] + distance_matrix_2[base_solution[j], base_solution[j+1]])\n            delta3 = (distance_matrix_3[base_solution[i], base_solution[j]] + distance_matrix_3[base_solution[i+1], base_solution[j+1]]) - (distance_matrix_3[base_solution[i], base_solution[i+1]] + distance_matrix_3[base_solution[j], base_solution[j+1]])\n\n            # If any objective improves, apply the move\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = base_solution[j:i:-1]\n                improved = True\n                break\n        if improved:\n            break\n\n    if not improved:\n        # If no improvement found, perform a random 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel tri-objective local search heuristic selects a solution from the archive based on objective diversity and applies a hybrid 2-opt and edge insertion operator, which intelligently reorders segments to improve multiple objectives simultaneously while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt + edge insertion\n    n = len(new_solution)\n    a, b = np.random.randint(0, n, 2)\n    if a > b:\n        a, b = b, a\n\n    # 2-opt swap\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge insertion for multi-objective improvement\n    for _ in range(2):  # Try a few insertions\n        i, j = np.random.randint(0, n, 2)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[i]] +\n                          distance_matrix_3[new_solution[j], new_solution[i]])\n\n        if potential_cost < current_cost:\n            # Perform insertion\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8138628660755571,
            1.654614806175232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.linspace(0.1, 0.9, len(archive)).sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt + edge insertion\n    n = len(new_solution)\n    a, b = np.random.randint(0, n, 2)\n    if a > b:\n        a, b = b, a\n\n    # 2-opt swap\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Edge insertion for multi-objective improvement\n    for _ in range(2):  # Try a few insertions\n        i, j = np.random.randint(0, n, 2)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[j], new_solution[i]] +\n                          distance_matrix_2[new_solution[j], new_solution[i]] +\n                          distance_matrix_3[new_solution[j], new_solution[i]])\n\n        if potential_cost < current_cost:\n            # Perform insertion\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt for one objective and swap for another\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Randomly choose between 2-opt or swap based on the objective with the highest potential\n    if np.random.rand() < 0.5:\n        # 2-opt move (improves one objective)\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap move (improves another objective)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6749626498251919,
            1.1884770274162293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt for one objective and swap for another\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n\n    # Randomly choose between 2-opt or swap based on the objective with the highest potential\n    if np.random.rand() < 0.5:\n        # 2-opt move (improves one objective)\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Swap move (improves another objective)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: -(sum(x[1]) / 3))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with random segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no revisits)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6603162503077982,
            1.5383670210838318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: -(sum(x[1]) / 3))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with random segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments and reverse them\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no revisits)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest sum of objectives)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective perturbation\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, 2)\n    while i == j or abs(i - j) < 2:  # Ensure meaningful segment reversal\n        i, j = np.random.randint(0, n, 2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt on the segment [i, j]\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: swap two nodes based on their worst objective\n    node_a, node_b = np.random.choice(base_solution, 2, replace=False)\n    idx_a, idx_b = np.where(base_solution == node_a)[0][0], np.where(base_solution == node_b)[0][0]\n\n    # Calculate the worst objective for each node\n    def worst_objective(node):\n        obj1 = distance_matrix_1[node, base_solution[(np.where(base_solution == node)[0][0] + 1) % n]]\n        obj2 = distance_matrix_2[node, base_solution[(np.where(base_solution == node)[0][0] + 1) % n]]\n        obj3 = distance_matrix_3[node, base_solution[(np.where(base_solution == node)[0][0] + 1) % n]]\n        return max(obj1, obj2, obj3)\n\n    if worst_objective(node_a) > worst_objective(node_b):\n        new_solution[idx_a], new_solution[idx_b] = new_solution[idx_b], new_solution[idx_a]\n\n    return new_solution\n\n",
        "score": [
            -0.6337704849283984,
            1.6204012989997865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest sum of objectives)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective perturbation\n    n = len(base_solution)\n    i, j = np.random.randint(0, n, 2)\n    while i == j or abs(i - j) < 2:  # Ensure meaningful segment reversal\n        i, j = np.random.randint(0, n, 2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt on the segment [i, j]\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: swap two nodes based on their worst objective\n    node_a, node_b = np.random.choice(base_solution, 2, replace=False)\n    idx_a, idx_b = np.where(base_solution == node_a)[0][0], np.where(base_solution == node_b)[0][0]\n\n    # Calculate the worst objective for each node\n    def worst_objective(node):\n        obj1 = distance_matrix_1[node, base_solution[(np.where(base_solution == node)[0][0] + 1) % n]]\n        obj2 = distance_matrix_2[node, base_solution[(np.where(base_solution == node)[0][0] + 1) % n]]\n        obj3 = distance_matrix_3[node, base_solution[(np.where(base_solution == node)[0][0] + 1) % n]]\n        return max(obj1, obj2, obj3)\n\n    if worst_objective(node_a) > worst_objective(node_b):\n        new_solution[idx_a], new_solution[idx_b] = new_solution[idx_b], new_solution[idx_a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Check if reversing the segment improves any objective\n    def compute_cost(sol, mat1, mat2, mat3):\n        cost1 = sum(mat1[sol[k], sol[k+1]] for k in range(-1, n-1))\n        cost2 = sum(mat2[sol[k], sol[k+1]] for k in range(-1, n-1))\n        cost3 = sum(mat3[sol[k], sol[k+1]] for k in range(-1, n-1))\n        return (cost1, cost2, cost3)\n\n    current_cost = compute_cost(new_solution, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate_cost = compute_cost(candidate, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Accept if at least one objective improves\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    # Additional: Apply a node swap if it improves the worst objective\n    worst_obj = np.argmin([c / curr for c, curr in zip(candidate_cost, current_cost) if curr > 0])\n    k, l = np.random.choice(n, 2, replace=False)\n    candidate = new_solution.copy()\n    candidate[k], candidate[l] = candidate[l], candidate[k]\n    candidate_cost = compute_cost(candidate, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    if candidate_cost[worst_obj] < current_cost[worst_obj]:\n        new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.5063341231639911,
            2.0410879850387573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Check if reversing the segment improves any objective\n    def compute_cost(sol, mat1, mat2, mat3):\n        cost1 = sum(mat1[sol[k], sol[k+1]] for k in range(-1, n-1))\n        cost2 = sum(mat2[sol[k], sol[k+1]] for k in range(-1, n-1))\n        cost3 = sum(mat3[sol[k], sol[k+1]] for k in range(-1, n-1))\n        return (cost1, cost2, cost3)\n\n    current_cost = compute_cost(new_solution, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n    candidate_cost = compute_cost(candidate, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    # Accept if at least one objective improves\n    if any(c < curr for c, curr in zip(candidate_cost, current_cost)):\n        new_solution = candidate\n\n    # Additional: Apply a node swap if it improves the worst objective\n    worst_obj = np.argmin([c / curr for c, curr in zip(candidate_cost, current_cost) if curr > 0])\n    k, l = np.random.choice(n, 2, replace=False)\n    candidate = new_solution.copy()\n    candidate[k], candidate[l] = candidate[l], candidate[k]\n    candidate_cost = compute_cost(candidate, distance_matrix_1, distance_matrix_2, distance_matrix_3)\n\n    if candidate_cost[worst_obj] < current_cost[worst_obj]:\n        new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[i]] += (sorted_objectives[i + 1] - sorted_objectives[i - 1]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n\n    # Select the solution with the highest crowding distance (most crowded)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 2-opt and 3-opt with objective-aware selection\n    if n >= 4:\n        # Randomly choose between 2-opt and 3-opt\n        if np.random.rand() < 0.5:\n            # 2-opt: Reverse a segment\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt: Reorder three segments\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[:i]\n            segment2 = new_solution[i:j]\n            segment3 = new_solution[j:k]\n            segment4 = new_solution[k:]\n            # Randomly permute the middle three segments\n            segments = [segment2, segment3, segment4]\n            np.random.shuffle(segments)\n            new_solution = np.concatenate([segment1] + segments)\n\n    # Objective-aware perturbation: Swap nodes that are far in the worst-performing objective\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_idx]\n\n    # Find the two nodes with the highest distance in the worst objective\n    max_dist = -1\n    node1, node2 = -1, -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = distance_matrix[new_solution[i], new_solution[j]]\n            if d > max_dist:\n                max_dist = d\n                node1, node2 = i, j\n\n    if node1 != -1 and node2 != -1:\n        # Swap these nodes to potentially improve the worst objective\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n",
        "score": [
            -0.6079941908900921,
            2.743537175655365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the crowding distance for each solution in the archive\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(archive))\n\n    for m in range(3):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        sorted_objectives = objectives[sorted_indices, m]\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[i]] += (sorted_objectives[i + 1] - sorted_objectives[i - 1]) / (sorted_objectives[-1] - sorted_objectives[0] + 1e-10)\n\n    # Select the solution with the highest crowding distance (most crowded)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 2-opt and 3-opt with objective-aware selection\n    if n >= 4:\n        # Randomly choose between 2-opt and 3-opt\n        if np.random.rand() < 0.5:\n            # 2-opt: Reverse a segment\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # 3-opt: Reorder three segments\n            i, j, k = sorted(np.random.choice(n, 3, replace=False))\n            segment1 = new_solution[:i]\n            segment2 = new_solution[i:j]\n            segment3 = new_solution[j:k]\n            segment4 = new_solution[k:]\n            # Randomly permute the middle three segments\n            segments = [segment2, segment3, segment4]\n            np.random.shuffle(segments)\n            new_solution = np.concatenate([segment1] + segments)\n\n    # Objective-aware perturbation: Swap nodes that are far in the worst-performing objective\n    obj_values = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(obj_values)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj_idx]\n\n    # Find the two nodes with the highest distance in the worst objective\n    max_dist = -1\n    node1, node2 = -1, -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = distance_matrix[new_solution[i], new_solution[j]]\n            if d > max_dist:\n                max_dist = d\n                node1, node2 = i, j\n\n    if node1 != -1 and node2 != -1:\n        # Swap these nodes to potentially improve the worst objective\n        new_solution[node1], new_solution[node2] = new_solution[node2], new_solution[node1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Choose a local search operator probabilistically\n    operator = random.choices(\n        ['2opt', 'insertion', 'objective_swap'],\n        weights=[0.4, 0.3, 0.3],\n        k=1\n    )[0]\n\n    if operator == '2opt':\n        # Perform 2-opt local search\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        selected_solution[i:j] = selected_solution[i:j][::-1]\n\n    elif operator == 'insertion':\n        # Perform node insertion\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        node = selected_solution[i]\n        selected_solution = np.concatenate([\n            selected_solution[:i],\n            selected_solution[i+1:j],\n            [node],\n            selected_solution[j:]\n        ])\n\n    elif operator == 'objective_swap':\n        # Perform objective-aware swap (swap nodes that are close in at least one objective space)\n        n = len(selected_solution)\n        i, j = random.sample(range(n), 2)\n\n        # Check if swapping these nodes improves any objective\n        original_cost1 = (distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                          distance_matrix_1[selected_solution[j-1], selected_solution[j]])\n        new_cost1 = (distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                     distance_matrix_1[selected_solution[j-1], selected_solution[i]])\n\n        original_cost2 = (distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                          distance_matrix_2[selected_solution[j-1], selected_solution[j]])\n        new_cost2 = (distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                     distance_matrix_2[selected_solution[j-1], selected_solution[i]])\n\n        original_cost3 = (distance_matrix_3[selected_solution[i-1], selected_solution[i]] +\n                          distance_matrix_3[selected_solution[j-1], selected_solution[j]])\n        new_cost3 = (distance_matrix_3[selected_solution[i-1], selected_solution[j]] +\n                     distance_matrix_3[selected_solution[j-1], selected_solution[i]])\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (new_cost3 < original_cost3):\n            selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n",
        "score": [
            -0.7584146668897541,
            1.111565625667572
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Choose a local search operator probabilistically\n    operator = random.choices(\n        ['2opt', 'insertion', 'objective_swap'],\n        weights=[0.4, 0.3, 0.3],\n        k=1\n    )[0]\n\n    if operator == '2opt':\n        # Perform 2-opt local search\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        selected_solution[i:j] = selected_solution[i:j][::-1]\n\n    elif operator == 'insertion':\n        # Perform node insertion\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        node = selected_solution[i]\n        selected_solution = np.concatenate([\n            selected_solution[:i],\n            selected_solution[i+1:j],\n            [node],\n            selected_solution[j:]\n        ])\n\n    elif operator == 'objective_swap':\n        # Perform objective-aware swap (swap nodes that are close in at least one objective space)\n        n = len(selected_solution)\n        i, j = random.sample(range(n), 2)\n\n        # Check if swapping these nodes improves any objective\n        original_cost1 = (distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                          distance_matrix_1[selected_solution[j-1], selected_solution[j]])\n        new_cost1 = (distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                     distance_matrix_1[selected_solution[j-1], selected_solution[i]])\n\n        original_cost2 = (distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                          distance_matrix_2[selected_solution[j-1], selected_solution[j]])\n        new_cost2 = (distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                     distance_matrix_2[selected_solution[j-1], selected_solution[i]])\n\n        original_cost3 = (distance_matrix_3[selected_solution[i-1], selected_solution[i]] +\n                          distance_matrix_3[selected_solution[j-1], selected_solution[j]])\n        new_cost3 = (distance_matrix_3[selected_solution[i-1], selected_solution[j]] +\n                     distance_matrix_3[selected_solution[j-1], selected_solution[i]])\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (new_cost3 < original_cost3):\n            selected_solution[i], selected_solution[j] = selected_solution[j], selected_solution[i]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj_array = np.array(objectives)\n    diversity_scores = np.std(obj_array, axis=0).sum(axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and path relinking\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt on a random segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply path relinking between two random nodes\n    if k != l:\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7388994123176114,
            1.778413140773773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = [obj for _, obj in archive]\n    obj_array = np.array(objectives)\n    diversity_scores = np.std(obj_array, axis=0).sum(axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid 2-opt and path relinking\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt on a random segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply path relinking between two random nodes\n    if k != l:\n        segment = new_solution[k:l]\n        new_solution = np.concatenate([new_solution[:k], segment[::-1], new_solution[l:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    normalized_costs = [(max_cost - cost + 1e-6) / (max_cost - min_cost + 1e-6) for cost in total_costs]\n    probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with edge exchange probability\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            # 2-opt move: reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform edge exchange\n            # Select two non-adjacent edges and swap their nodes\n            k, l = random.sample(range(n), 2)\n            while abs(k - l) == 1 or k == l:\n                k, l = random.sample(range(n), 2)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(set(new_solution)) == n:\n            # Evaluate the new solution's objectives\n            obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            # If the new solution is better in at least one objective, keep it\n            if obj1 <= archive[selected_idx][1][0] or obj2 <= archive[selected_idx][1][1] or obj3 <= archive[selected_idx][1][2]:\n                return new_solution\n            else:\n                # Revert if not better\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7631056477845591,
            4.102901232242584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    normalized_costs = [(max_cost - cost + 1e-6) / (max_cost - min_cost + 1e-6) for cost in total_costs]\n    probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Create a copy of the solution to modify\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with edge exchange probability\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts\n        i, j = sorted(random.sample(range(n), 2))\n\n        # With 70% probability, perform 2-opt\n        if random.random() < 0.7:\n            # 2-opt move: reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # With 30% probability, perform edge exchange\n            # Select two non-adjacent edges and swap their nodes\n            k, l = random.sample(range(n), 2)\n            while abs(k - l) == 1 or k == l:\n                k, l = random.sample(range(n), 2)\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n        # Ensure the solution remains valid (no duplicates)\n        if len(set(new_solution)) == n:\n            # Evaluate the new solution's objectives\n            obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            # If the new solution is better in at least one objective, keep it\n            if obj1 <= archive[selected_idx][1][0] or obj2 <= archive[selected_idx][1][1] or obj3 <= archive[selected_idx][1][2]:\n                return new_solution\n            else:\n                # Revert if not better\n                new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (prioritize those with higher values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: 3-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify (3-opt)\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Generate all possible 3-opt moves and evaluate them across all objectives\n    candidates = []\n    for i in [a, b, c]:\n        for j in [a, b, c]:\n            if i != j:\n                # Create a new candidate by reversing the segment between i and j\n                candidate = new_solution.copy()\n                candidate[i:j] = candidate[i:j][::-1]\n                candidates.append(candidate)\n\n    # Evaluate each candidate across all three objectives\n    best_candidate = None\n    best_improvement = -np.inf\n\n    for candidate in candidates:\n        # Calculate total cost for each objective\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement (negative means worse, positive means better)\n        improvement = -(cost1 + cost2 + cost3)  # We want to minimize the sum of objectives\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    # Additional objective-aware edge swap (for further refinement)\n    for _ in range(3):  # Perform a few edge swaps\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        # Evaluate the swap across all objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n        swapped_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6517576770738114,
            2.8929335713386535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (prioritize those with higher values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search: 3-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify (3-opt)\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Generate all possible 3-opt moves and evaluate them across all objectives\n    candidates = []\n    for i in [a, b, c]:\n        for j in [a, b, c]:\n            if i != j:\n                # Create a new candidate by reversing the segment between i and j\n                candidate = new_solution.copy()\n                candidate[i:j] = candidate[i:j][::-1]\n                candidates.append(candidate)\n\n    # Evaluate each candidate across all three objectives\n    best_candidate = None\n    best_improvement = -np.inf\n\n    for candidate in candidates:\n        # Calculate total cost for each objective\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement (negative means worse, positive means better)\n        improvement = -(cost1 + cost2 + cost3)  # We want to minimize the sum of objectives\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    # Additional objective-aware edge swap (for further refinement)\n    for _ in range(3):  # Perform a few edge swaps\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        # Evaluate the swap across all objectives\n        original_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n        swapped_cost = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n        if swapped_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the improvement potential for each solution\n        improvement_potentials = []\n        for sol, obj in archive:\n            # Calculate the average improvement potential across all objectives\n            avg_improvement = (obj[0] + obj[1] + obj[2]) / 3\n            improvement_potentials.append(avg_improvement)\n\n        # Select the solution with the highest improvement potential\n        selected_idx = np.argmin(improvement_potentials)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(new_solution)\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end]\n\n    # 2. Apply a 2-opt move within the segment to reduce the worst objective\n    if len(segment) > 2:\n        # Evaluate the segment in all three objectives\n        segment_costs = [0.0, 0.0, 0.0]\n        for i in range(len(segment) - 1):\n            u, v = segment[i], segment[i+1]\n            segment_costs[0] += distance_matrix_1[u, v]\n            segment_costs[1] += distance_matrix_2[u, v]\n            segment_costs[2] += distance_matrix_3[u, v]\n\n        # Identify the worst objective\n        worst_obj = np.argmax(segment_costs)\n\n        # Apply 2-opt to the worst objective\n        best_gain = 0\n        best_i, best_j = -1, -1\n        for i in range(len(segment) - 1):\n            for j in range(i + 1, len(segment)):\n                u1, v1 = segment[i], segment[i+1]\n                u2, v2 = segment[j], segment[j+1] if j+1 < len(segment) else segment[0]\n\n                # Calculate the gain for the worst objective\n                if worst_obj == 0:\n                    gain = (distance_matrix_1[u1, u2] + distance_matrix_1[v1, v2]) - (distance_matrix_1[u1, v1] + distance_matrix_1[u2, v2])\n                elif worst_obj == 1:\n                    gain = (distance_matrix_2[u1, u2] + distance_matrix_2[v1, v2]) - (distance_matrix_2[u1, v1] + distance_matrix_2[u2, v2])\n                else:\n                    gain = (distance_matrix_3[u1, u2] + distance_matrix_3[v1, v2]) - (distance_matrix_3[u1, v1] + distance_matrix_3[u2, v2])\n\n                if gain < best_gain:\n                    best_gain = gain\n                    best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            # Perform the 2-opt move\n            segment[best_i+1:best_j+1] = segment[best_i+1:best_j+1][::-1]\n\n    # 3. Apply a random swap to explore neighboring solutions\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7400099100602497,
            2.930218052864075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the improvement potential for each solution\n        improvement_potentials = []\n        for sol, obj in archive:\n            # Calculate the average improvement potential across all objectives\n            avg_improvement = (obj[0] + obj[1] + obj[2]) / 3\n            improvement_potentials.append(avg_improvement)\n\n        # Select the solution with the highest improvement potential\n        selected_idx = np.argmin(improvement_potentials)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # 1. Randomly select a segment of the tour\n    n = len(new_solution)\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, n - 1)\n    segment = new_solution[start:end]\n\n    # 2. Apply a 2-opt move within the segment to reduce the worst objective\n    if len(segment) > 2:\n        # Evaluate the segment in all three objectives\n        segment_costs = [0.0, 0.0, 0.0]\n        for i in range(len(segment) - 1):\n            u, v = segment[i], segment[i+1]\n            segment_costs[0] += distance_matrix_1[u, v]\n            segment_costs[1] += distance_matrix_2[u, v]\n            segment_costs[2] += distance_matrix_3[u, v]\n\n        # Identify the worst objective\n        worst_obj = np.argmax(segment_costs)\n\n        # Apply 2-opt to the worst objective\n        best_gain = 0\n        best_i, best_j = -1, -1\n        for i in range(len(segment) - 1):\n            for j in range(i + 1, len(segment)):\n                u1, v1 = segment[i], segment[i+1]\n                u2, v2 = segment[j], segment[j+1] if j+1 < len(segment) else segment[0]\n\n                # Calculate the gain for the worst objective\n                if worst_obj == 0:\n                    gain = (distance_matrix_1[u1, u2] + distance_matrix_1[v1, v2]) - (distance_matrix_1[u1, v1] + distance_matrix_1[u2, v2])\n                elif worst_obj == 1:\n                    gain = (distance_matrix_2[u1, u2] + distance_matrix_2[v1, v2]) - (distance_matrix_2[u1, v1] + distance_matrix_2[u2, v2])\n                else:\n                    gain = (distance_matrix_3[u1, u2] + distance_matrix_3[v1, v2]) - (distance_matrix_3[u1, v1] + distance_matrix_3[u2, v2])\n\n                if gain < best_gain:\n                    best_gain = gain\n                    best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            # Perform the 2-opt move\n            segment[best_i+1:best_j+1] = segment[best_i+1:best_j+1][::-1]\n\n    # 3. Apply a random swap to explore neighboring solutions\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{This heuristic selects a solution from the archive with the highest combined improvement potential across objectives, then applies a novel 3D-aware local search that simultaneously perturbs segments of the tour in all three spaces while preserving feasibility, ensuring balanced optimization across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    def improvement_potential(sol):\n        obj1, obj2, obj3 = sol[1]\n        return - (obj1 + obj2 + obj3)  # Negative because we want to maximize potential\n\n    archive.sort(key=improvement_potential)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel 3D-aware local search\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No feasible perturbation possible\n\n    # Randomly select two segments to swap\n    i = np.random.randint(1, n-2)\n    j = np.random.randint(i+1, n-1)\n\n    # Apply 3D-aware perturbation\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If duplicate nodes exist, repair by reordering\n        unique_nodes = list(set(new_solution))\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for idx in range(n):\n            if new_solution[idx] in unique_nodes:\n                unique_nodes.remove(new_solution[idx])\n            else:\n                new_solution[idx] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -0.6925629088321588,
            1.1687445878982543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    def improvement_potential(sol):\n        obj1, obj2, obj3 = sol[1]\n        return - (obj1 + obj2 + obj3)  # Negative because we want to maximize potential\n\n    archive.sort(key=improvement_potential)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel 3D-aware local search\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No feasible perturbation possible\n\n    # Randomly select two segments to swap\n    i = np.random.randint(1, n-2)\n    j = np.random.randint(i+1, n-1)\n\n    # Apply 3D-aware perturbation\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If duplicate nodes exist, repair by reordering\n        unique_nodes = list(set(new_solution))\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for idx in range(n):\n            if new_solution[idx] in unique_nodes:\n                unique_nodes.remove(new_solution[idx])\n            else:\n                new_solution[idx] = missing_nodes.pop(0)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify nodes with high marginal contribution\n    marginal_contributions = []\n    for k in range(n):\n        if k == 0:\n            prev = new_solution[-1]\n            next_node = new_solution[1]\n        elif k == n - 1:\n            prev = new_solution[-2]\n            next_node = new_solution[0]\n        else:\n            prev = new_solution[k - 1]\n            next_node = new_solution[k + 1]\n\n        # Calculate marginal contribution across all objectives\n        delta = (\n            distance_matrix_1[prev, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n            - distance_matrix_1[prev, next_node]\n            + distance_matrix_2[prev, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n            - distance_matrix_2[prev, next_node]\n            + distance_matrix_3[prev, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n            - distance_matrix_3[prev, next_node]\n        )\n        marginal_contributions.append(delta)\n\n    # Swap nodes with high marginal contribution\n    if marginal_contributions:\n        worst_node = np.argmax(marginal_contributions)\n        best_node = np.argmin(marginal_contributions)\n        if worst_node != best_node:\n            new_solution[worst_node], new_solution[best_node] = new_solution[best_node], new_solution[worst_node]\n\n    return new_solution\n\n",
        "score": [
            -0.6813481002949489,
            1.9029439091682434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: identify nodes with high marginal contribution\n    marginal_contributions = []\n    for k in range(n):\n        if k == 0:\n            prev = new_solution[-1]\n            next_node = new_solution[1]\n        elif k == n - 1:\n            prev = new_solution[-2]\n            next_node = new_solution[0]\n        else:\n            prev = new_solution[k - 1]\n            next_node = new_solution[k + 1]\n\n        # Calculate marginal contribution across all objectives\n        delta = (\n            distance_matrix_1[prev, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n            - distance_matrix_1[prev, next_node]\n            + distance_matrix_2[prev, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n            - distance_matrix_2[prev, next_node]\n            + distance_matrix_3[prev, new_solution[k]] + distance_matrix_3[new_solution[k], next_node]\n            - distance_matrix_3[prev, next_node]\n        )\n        marginal_contributions.append(delta)\n\n    # Swap nodes with high marginal contribution\n    if marginal_contributions:\n        worst_node = np.argmax(marginal_contributions)\n        best_node = np.argmin(marginal_contributions)\n        if worst_node != best_node:\n            new_solution[worst_node], new_solution[best_node] = new_solution[best_node], new_solution[worst_node]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    # Randomly select from the top 30% of solutions to ensure diversity\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = np.random.randint(0, len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combines 2-opt with a multi-objective aware swap\n    # First, perform a 2-opt move to reduce the total tour length across all objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a multi-objective aware swap to improve the trade-off between objectives\n    # Select two random nodes and evaluate their swap across all objectives\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    original_cost = (\n        distance_matrix_1[new_solution[a-1], new_solution[a]] +\n        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n        distance_matrix_3[new_solution[b-1], new_solution[b]]\n    )\n    swapped_cost = (\n        distance_matrix_1[new_solution[a-1], new_solution[b]] +\n        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n        distance_matrix_3[new_solution[a-1], new_solution[b]] +\n        distance_matrix_3[new_solution[b-1], new_solution[a]]\n    )\n\n    # If the swap improves the total cost, perform it\n    if swapped_cost < original_cost:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7706297985713367,
            1.699388575553894
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    # Randomly select from the top 30% of solutions to ensure diversity\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_idx = np.random.randint(0, len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combines 2-opt with a multi-objective aware swap\n    # First, perform a 2-opt move to reduce the total tour length across all objectives\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a multi-objective aware swap to improve the trade-off between objectives\n    # Select two random nodes and evaluate their swap across all objectives\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    original_cost = (\n        distance_matrix_1[new_solution[a-1], new_solution[a]] +\n        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n        distance_matrix_2[new_solution[b-1], new_solution[b]] +\n        distance_matrix_3[new_solution[a-1], new_solution[a]] +\n        distance_matrix_3[new_solution[b-1], new_solution[b]]\n    )\n    swapped_cost = (\n        distance_matrix_1[new_solution[a-1], new_solution[b]] +\n        distance_matrix_1[new_solution[b-1], new_solution[a]] +\n        distance_matrix_2[new_solution[a-1], new_solution[b]] +\n        distance_matrix_2[new_solution[b-1], new_solution[a]] +\n        distance_matrix_3[new_solution[a-1], new_solution[b]] +\n        distance_matrix_3[new_solution[b-1], new_solution[a]]\n    )\n\n    # If the swap improves the total cost, perform it\n    if swapped_cost < original_cost:\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with high potential\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Randomly select from top 30% solutions to ensure diversity\n        selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 3))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: try to improve the worst objective\n    objectives = archive[0][1] if len(archive) == 1 else archive[np.random.randint(len(archive))][1]\n    worst_obj = np.argmax(objectives)\n\n    # Find edges with high cost in the worst objective\n    def edge_cost(node1, node2, obj):\n        if obj == 0:\n            return distance_matrix_1[node1, node2]\n        elif obj == 1:\n            return distance_matrix_2[node1, node2]\n        else:\n            return distance_matrix_3[node1, node2]\n\n    # Find the most expensive edge in the worst objective\n    max_cost = -1\n    max_i = 0\n    for idx in range(n):\n        cost = edge_cost(new_solution[idx], new_solution[(idx+1)%n], worst_obj)\n        if cost > max_cost:\n            max_cost = cost\n            max_i = idx\n\n    # Try to replace this edge with a better one\n    for k in range(n):\n        if k != max_i and k != (max_i+1)%n:\n            cost_improvement = (edge_cost(new_solution[max_i], new_solution[k], worst_obj) +\n                               edge_cost(new_solution[(max_i+1)%n], new_solution[(k+1)%n], worst_obj)) - max_cost\n            if cost_improvement < 0:  # If we find a better edge\n                # Perform the swap\n                if max_i < k:\n                    new_solution[max_i+1:k+1] = new_solution[max_i+1:k+1][::-1]\n                else:\n                    new_solution[k+1:max_i+1] = new_solution[k+1:max_i+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7760496884302984,
            1.7105950355529784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives to find those with high potential\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Randomly select from top 30% solutions to ensure diversity\n        selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 3))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware edge swap: try to improve the worst objective\n    objectives = archive[0][1] if len(archive) == 1 else archive[np.random.randint(len(archive))][1]\n    worst_obj = np.argmax(objectives)\n\n    # Find edges with high cost in the worst objective\n    def edge_cost(node1, node2, obj):\n        if obj == 0:\n            return distance_matrix_1[node1, node2]\n        elif obj == 1:\n            return distance_matrix_2[node1, node2]\n        else:\n            return distance_matrix_3[node1, node2]\n\n    # Find the most expensive edge in the worst objective\n    max_cost = -1\n    max_i = 0\n    for idx in range(n):\n        cost = edge_cost(new_solution[idx], new_solution[(idx+1)%n], worst_obj)\n        if cost > max_cost:\n            max_cost = cost\n            max_i = idx\n\n    # Try to replace this edge with a better one\n    for k in range(n):\n        if k != max_i and k != (max_i+1)%n:\n            cost_improvement = (edge_cost(new_solution[max_i], new_solution[k], worst_obj) +\n                               edge_cost(new_solution[(max_i+1)%n], new_solution[(k+1)%n], worst_obj)) - max_cost\n            if cost_improvement < 0:  # If we find a better edge\n                # Perform the swap\n                if max_i < k:\n                    new_solution[max_i+1:k+1] = new_solution[max_i+1:k+1][::-1]\n                else:\n                    new_solution[k+1:max_i+1] = new_solution[k+1:max_i+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a solution from the archive with high potential for improvement, then applies a novel three-objective-aware local search operator that combines 2-opt moves across all three objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Generate a neighbor using a hybrid 2-opt operator across all three objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7369630643443312,
            1.4178867220878602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.randint(0, len(archive))][0].copy()\n\n    # Generate a neighbor using a hybrid 2-opt operator across all three objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to perform 2-opt\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt swap\n    new_solution[i:j] = selected_solution[i:j][::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(selected_solution)):\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and random segment reversal with multi-objective consideration\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and segment reversal\n    if np.random.rand() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no skipped or revisited nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.6732746559834644,
            1.018978440761566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt and random segment reversal with multi-objective consideration\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt and segment reversal\n    if np.random.rand() < 0.5:\n        # 2-opt: randomly select two edges and reverse the segment between them\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        start, end = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no skipped or revisited nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of objectives (promising for improvement)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: 2-opt for the objective with the highest cost\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective has the highest cost\n    obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n\n    if obj1 >= obj2 and obj1 >= obj3:\n        # Apply 2-opt on the first objective space\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                if j - i == 1:\n                    continue\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                # Check if the new solution is better\n                new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n                if new_obj1 < obj1:\n                    break\n                else:\n                    new_solution[i+1:j+1] = new_solution[j:i:-1]\n    elif obj2 >= obj1 and obj2 >= obj3:\n        # Apply 2-opt on the second objective space\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                if j - i == 1:\n                    continue\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                # Check if the new solution is better\n                new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n                if new_obj2 < obj2:\n                    break\n                else:\n                    new_solution[i+1:j+1] = new_solution[j:i:-1]\n    else:\n        # Apply 2-opt on the third objective space\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                if j - i == 1:\n                    continue\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                # Check if the new solution is better\n                new_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n                if new_obj3 < obj3:\n                    break\n                else:\n                    new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6584115921671467,
            2.57979930639267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of objectives (promising for improvement)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Apply a hybrid local search: 2-opt for the objective with the highest cost\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine which objective has the highest cost\n    obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n\n    if obj1 >= obj2 and obj1 >= obj3:\n        # Apply 2-opt on the first objective space\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                if j - i == 1:\n                    continue\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                # Check if the new solution is better\n                new_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n                if new_obj1 < obj1:\n                    break\n                else:\n                    new_solution[i+1:j+1] = new_solution[j:i:-1]\n    elif obj2 >= obj1 and obj2 >= obj3:\n        # Apply 2-opt on the second objective space\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                if j - i == 1:\n                    continue\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                # Check if the new solution is better\n                new_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n                if new_obj2 < obj2:\n                    break\n                else:\n                    new_solution[i+1:j+1] = new_solution[j:i:-1]\n    else:\n        # Apply 2-opt on the third objective space\n        for i in range(n - 1):\n            for j in range(i + 2, n):\n                if j - i == 1:\n                    continue\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                # Check if the new solution is better\n                new_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n                if new_obj3 < obj3:\n                    break\n                else:\n                    new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.var(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments and perform a 2-opt swap\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and swap with another to create a different edge exchange\n    k = np.random.randint(1, n-1)\n    l = np.random.choice([x for x in range(1, n-1) if x != k])\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.49100707869833415,
            4.497505784034729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.var(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments and perform a 2-opt swap\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and swap with another to create a different edge exchange\n    k = np.random.randint(1, n-1)\n    l = np.random.choice([x for x in range(1, n-1) if x != k])\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        selected_indices = np.random.choice(len(archive), size=min(3, len(archive)), replace=False)\n        selected_solutions = [archive[i][0] for i in selected_indices]\n        selected_objectives = [archive[i][1] for i in selected_indices]\n\n        # Calculate diversity of objectives (sum of normalized Euclidean distances between objectives)\n        diversity_scores = []\n        for i in range(len(selected_objectives)):\n            distances = []\n            for j in range(len(selected_objectives)):\n                if i != j:\n                    dist = np.linalg.norm(np.array(selected_objectives[i]) - np.array(selected_objectives[j]))\n                    distances.append(dist)\n            diversity_scores.append(np.mean(distances) if distances else 0)\n\n        # Select the solution with highest diversity\n        base_solution = selected_solutions[np.argmax(diversity_scores)].copy()\n    else:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of 2-opt and node insertion)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or node insertion\n    if np.random.rand() < 0.5:  # 50% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion with objective-aware selection\n        # Select a node to move\n        node_to_move = np.random.randint(n)\n        node_value = new_solution[node_to_move]\n\n        # Calculate potential insertion positions based on all three objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_move or pos == (node_to_move + 1) % n:\n                continue\n\n            # Create temporary solution\n            temp_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n            temp_solution = np.insert(temp_solution, pos, node_value)\n\n            # Calculate total cost for all three objectives\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            cost3 = sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n\n            # Use a weighted sum of objectives (equal weights for simplicity)\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n            new_solution = np.insert(new_solution, best_pos, node_value)\n\n    return new_solution\n\n",
        "score": [
            -0.8347273457571879,
            3.77900710105896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        selected_indices = np.random.choice(len(archive), size=min(3, len(archive)), replace=False)\n        selected_solutions = [archive[i][0] for i in selected_indices]\n        selected_objectives = [archive[i][1] for i in selected_indices]\n\n        # Calculate diversity of objectives (sum of normalized Euclidean distances between objectives)\n        diversity_scores = []\n        for i in range(len(selected_objectives)):\n            distances = []\n            for j in range(len(selected_objectives)):\n                if i != j:\n                    dist = np.linalg.norm(np.array(selected_objectives[i]) - np.array(selected_objectives[j]))\n                    distances.append(dist)\n            diversity_scores.append(np.mean(distances) if distances else 0)\n\n        # Select the solution with highest diversity\n        base_solution = selected_solutions[np.argmax(diversity_scores)].copy()\n    else:\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of 2-opt and node insertion)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or node insertion\n    if np.random.rand() < 0.5:  # 50% chance for 2-opt\n        # 2-opt local search\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion with objective-aware selection\n        # Select a node to move\n        node_to_move = np.random.randint(n)\n        node_value = new_solution[node_to_move]\n\n        # Calculate potential insertion positions based on all three objectives\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n):\n            if pos == node_to_move or pos == (node_to_move + 1) % n:\n                continue\n\n            # Create temporary solution\n            temp_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n            temp_solution = np.insert(temp_solution, pos, node_value)\n\n            # Calculate total cost for all three objectives\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            cost3 = sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n\n            # Use a weighted sum of objectives (equal weights for simplicity)\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the insertion\n            new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n            new_solution = np.insert(new_solution, best_pos, node_value)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0).sum()\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate potential edges in all three objective spaces\n    current_edges = [\n        (new_solution[i-1], new_solution[i]),\n        (new_solution[j], new_solution[(j+1)%n]),\n        (new_solution[i-1], new_solution[j]),\n        (new_solution[i], new_solution[(j+1)%n])\n    ]\n\n    # Calculate edge costs across all objectives\n    edge_costs = []\n    for a, b in current_edges:\n        cost1 = distance_matrix_1[a, b]\n        cost2 = distance_matrix_2[a, b]\n        cost3 = distance_matrix_3[a, b]\n        edge_costs.append((cost1, cost2, cost3))\n\n    # Calculate potential improvement for each objective\n    current_total = sum(edge_costs[0][k] + edge_costs[1][k] for k in range(3))\n    new_total = sum(edge_costs[2][k] + edge_costs[3][k] for k in range(3))\n\n    # Apply 2-opt if it improves at least one objective\n    if new_total < current_total:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # If no improvement, try a different segment\n        k, l = np.random.choice(n, size=2, replace=False)\n        k, l = min(k, l), max(k, l)\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6824277258834952,
            1.9907889366149902
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0).sum()\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate potential edges in all three objective spaces\n    current_edges = [\n        (new_solution[i-1], new_solution[i]),\n        (new_solution[j], new_solution[(j+1)%n]),\n        (new_solution[i-1], new_solution[j]),\n        (new_solution[i], new_solution[(j+1)%n])\n    ]\n\n    # Calculate edge costs across all objectives\n    edge_costs = []\n    for a, b in current_edges:\n        cost1 = distance_matrix_1[a, b]\n        cost2 = distance_matrix_2[a, b]\n        cost3 = distance_matrix_3[a, b]\n        edge_costs.append((cost1, cost2, cost3))\n\n    # Calculate potential improvement for each objective\n    current_total = sum(edge_costs[0][k] + edge_costs[1][k] for k in range(3))\n    new_total = sum(edge_costs[2][k] + edge_costs[3][k] for k in range(3))\n\n    # Apply 2-opt if it improves at least one objective\n    if new_total < current_total:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # If no improvement, try a different segment\n        k, l = np.random.choice(n, size=2, replace=False)\n        k, l = min(k, l), max(k, l)\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts to improve\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Skip circular edges\n\n        # Calculate edge costs in all three objectives\n        edge_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        # Calculate original edge costs\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        # Apply 2-opt if it improves at least one objective\n        if any(ec < oc for ec, oc in zip(edge_costs, original_costs)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7242561842290013,
            2.5207977533340453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of attempts to improve\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 and j == n-1:\n            continue  # Skip circular edges\n\n        # Calculate edge costs in all three objectives\n        edge_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] + distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        ]\n\n        # Calculate original edge costs\n        original_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n\n        # Apply 2-opt if it improves at least one objective\n        if any(ec < oc for ec, oc in zip(edge_costs, original_costs)):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap based on the most critical objectives\n    obj1_total = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_total = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj3_total = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify the most critical objective (highest total cost)\n    critical_obj = max([(obj1_total, 0), (obj2_total, 1), (obj3_total, 2)], key=lambda x: x[0])[1]\n\n    # Select edges to swap based on the critical objective's distance matrix\n    if critical_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif critical_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt with the selected distance matrix\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6700617850393664,
            1.5343101978302003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap based on the most critical objectives\n    obj1_total = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_total = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj3_total = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify the most critical objective (highest total cost)\n    critical_obj = max([(obj1_total, 0), (obj2_total, 1), (obj3_total, 2)], key=lambda x: x[0])[1]\n\n    # Select edges to swap based on the critical objective's distance matrix\n    if critical_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif critical_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Perform 2-opt with the selected distance matrix\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        avg_objectives = [sum(obj) / 3 for (sol, obj) in archive]\n        selected_idx = np.argmax(avg_objectives)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective edge swapping\n    n = len(new_solution)\n    improved = True\n    while improved:\n        improved = False\n        # Try random 2-opt moves\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i + 1 < j:\n            # Reverse the segment between i+1 and j\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            # Check if this improves any objective\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n            new_obj = (obj1, obj2, obj3)\n\n            # If no improvement, revert\n            if new_obj >= archive[selected_idx][1]:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            else:\n                improved = True\n\n        # Try multi-objective edge swapping\n        if not improved and n > 3:\n            # Select two random edges to swap\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if a != c and b != d:\n                # Create new edges (a,c) and (b,d) instead of (a,b) and (c,d)\n                temp = new_solution.copy()\n                temp[a], temp[b] = temp[c], temp[d]\n                # Check feasibility (no duplicates)\n                if len(np.unique(temp)) == n:\n                    # Check if this improves any objective\n                    obj1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    obj2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    obj3 = sum(distance_matrix_3[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_3[temp[-1], temp[0]]\n                    new_obj = (obj1, obj2, obj3)\n\n                    if new_obj < archive[selected_idx][1]:\n                        new_solution = temp\n                        improved = True\n\n    return new_solution\n\n",
        "score": [
            -0.6057284732960082,
            1.9375309228897095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        avg_objectives = [sum(obj) / 3 for (sol, obj) in archive]\n        selected_idx = np.argmax(avg_objectives)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt with multi-objective edge swapping\n    n = len(new_solution)\n    improved = True\n    while improved:\n        improved = False\n        # Try random 2-opt moves\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i + 1 < j:\n            # Reverse the segment between i+1 and j\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            # Check if this improves any objective\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n            new_obj = (obj1, obj2, obj3)\n\n            # If no improvement, revert\n            if new_obj >= archive[selected_idx][1]:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n            else:\n                improved = True\n\n        # Try multi-objective edge swapping\n        if not improved and n > 3:\n            # Select two random edges to swap\n            a, b = sorted(np.random.choice(n, 2, replace=False))\n            c, d = sorted(np.random.choice(n, 2, replace=False))\n            if a != c and b != d:\n                # Create new edges (a,c) and (b,d) instead of (a,b) and (c,d)\n                temp = new_solution.copy()\n                temp[a], temp[b] = temp[c], temp[d]\n                # Check feasibility (no duplicates)\n                if len(np.unique(temp)) == n:\n                    # Check if this improves any objective\n                    obj1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    obj2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n                    obj3 = sum(distance_matrix_3[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_3[temp[-1], temp[0]]\n                    new_obj = (obj1, obj2, obj3)\n\n                    if new_obj < archive[selected_idx][1]:\n                        new_solution = temp\n                        improved = True\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{A heuristic function that intelligently selects a solution from the archive based on its potential for improvement across multiple objectives, then applies a hybrid local search operator combining edge swaps and partial path reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential for improvement (sum of normalized improvements)\n        potential = sum((obj[i] - archive[0][1][i]) / archive[0][1][i] for i in range(3))\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: edge swap or partial path reversal\n    if random.random() < 0.7:  # 70% chance for edge swap\n        # Select two random edges and swap them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:  # 30% chance for partial path reversal\n        # Reverse a random segment of the tour\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6685550370264824,
            1.4463597297668458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n\n    for sol, obj in archive:\n        # Calculate potential for improvement (sum of normalized improvements)\n        potential = sum((obj[i] - archive[0][1][i]) / archive[0][1][i] for i in range(3))\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: edge swap or partial path reversal\n    if random.random() < 0.7:  # 70% chance for edge swap\n        # Select two random edges and swap them\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:  # 30% chance for partial path reversal\n        # Reverse a random segment of the tour\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This heuristic selects a promising solution from the archive based on its potential for multi-objective improvement, then applies a hybrid local search combining 2-opt and path-relinking to explore diverse neighborhoods while preserving feasibility, ensuring the neighbor solution remains a valid TSP tour across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in any objective)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_30 = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(len(top_30))\n    base_solution = top_30[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to one randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply path-relinking to another segment based on distance matrices\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[k:l+1]\n\n    # Choose the best relinking based on combined distance matrices\n    combined_dist = (distance_matrix_1 + distance_matrix_2 + distance_matrix_3) / 3\n    for _ in range(3):  # Limited relinking steps\n        if len(segment) < 2:\n            break\n        a, b = np.random.choice(len(segment), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Swap nodes in segment if it improves combined distance\n        if combined_dist[segment[a-1], segment[b]] + combined_dist[segment[b-1], segment[a]] < \\\n           combined_dist[segment[a-1], segment[a]] + combined_dist[segment[b-1], segment[b]]:\n            segment[a], segment[b] = segment[b], segment[a]\n\n    new_solution[k:l+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7191753391478637,
            1.755667018890381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in any objective)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_30 = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(len(top_30))\n    base_solution = top_30[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to one randomly selected segment\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply path-relinking to another segment based on distance matrices\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[k:l+1]\n\n    # Choose the best relinking based on combined distance matrices\n    combined_dist = (distance_matrix_1 + distance_matrix_2 + distance_matrix_3) / 3\n    for _ in range(3):  # Limited relinking steps\n        if len(segment) < 2:\n            break\n        a, b = np.random.choice(len(segment), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Swap nodes in segment if it improves combined distance\n        if combined_dist[segment[a-1], segment[b]] + combined_dist[segment[b-1], segment[a]] < \\\n           combined_dist[segment[a-1], segment[a]] + combined_dist[segment[b-1], segment[b]]:\n            segment[a], segment[b] = segment[b], segment[a]\n\n    new_solution[k:l+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (e.g., least dominated in at least one objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swapping edges (i, i+1) and (j, j+1) improves at least one objective\n        original_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[j]] +\n            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        ]\n        if any(nc < oc for nc, oc in zip(new_costs, original_costs)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]  # Perform 2-opt\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.6812362533046382,
            1.5028401970863343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (e.g., least dominated in at least one objective)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swapping edges (i, i+1) and (j, j+1) improves at least one objective\n        original_costs = [\n            distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        ]\n        new_costs = [\n            distance_matrix_1[new_solution[i], new_solution[j]] +\n            distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n            distance_matrix_2[new_solution[i], new_solution[j]] +\n            distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]],\n            distance_matrix_3[new_solution[i], new_solution[j]] +\n            distance_matrix_3[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n        ]\n        if any(nc < oc for nc, oc in zip(new_costs, original_costs)):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]  # Perform 2-opt\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            sorted_objectives = objectives[sorted_indices, i]\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                if sorted_objectives[-1] == sorted_objectives[0]:\n                    crowding_distances[sorted_indices[j]] += 0\n                else:\n                    crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1] - sorted_objectives[j-1]) / (sorted_objectives[-1] - sorted_objectives[0])\n        # Select the solution with the highest crowding distance\n        base_idx = np.argmax(crowding_distances)\n        base_solution = archive[base_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: identify edges with high contribution to any objective\n    def edge_contribution(i, j):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        return max(cost1, cost2, cost3)\n\n    # Find the worst edge in terms of maximum objective\n    max_contribution = -1\n    worst_i, worst_j = -1, -1\n    for i in range(n):\n        j = (i + 1) % n\n        contrib = edge_contribution(i, j)\n        if contrib > max_contribution:\n            max_contribution = contrib\n            worst_i, worst_j = i, j\n\n    # Apply 2-opt or 3-opt based on the worst edge\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt: reverse a segment between worst_i and worst_j\n        if worst_i < worst_j:\n            new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n        else:\n            # Handle the circular case\n            segment = np.concatenate([new_solution[worst_i:], new_solution[:worst_j+1]])\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([reversed_segment[len(segment)-worst_j-1:], new_solution[worst_j+1:worst_i], reversed_segment[:len(segment)-worst_j-1]])\n    else:  # 30% chance for 3-opt\n        # 3-opt: select three random edges and reconnect them\n        edges = random.sample(range(n), 3)\n        edges.sort()\n        a, b, c = edges\n        # Create all possible reconnections and choose the best one\n        possible_reconnections = [\n            (a, c, b, a),  # Reconnect a-c, b-a\n            (a, b, c, a),  # Reconnect a-b, c-a\n            (a, b, a, c),  # Reconnect a-b, a-c\n            (a, c, b, c)   # Reconnect a-c, b-c\n        ]\n        best_reconnection = None\n        min_cost = float('inf')\n        for reconnection in possible_reconnections:\n            temp_solution = new_solution.copy()\n            # Apply the reconnection\n            i, j, k, l = reconnection\n            if i < j and j < k and k < l:\n                # Reverse segments\n                temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n                temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n            else:\n                # Handle circular cases\n                pass  # Simplified for brevity\n\n            # Calculate total cost\n            total_cost = 0\n            for m in range(n):\n                total_cost += distance_matrix_1[temp_solution[m], temp_solution[(m+1)%n]]\n                total_cost += distance_matrix_2[temp_solution[m], temp_solution[(m+1)%n]]\n                total_cost += distance_matrix_3[temp_solution[m], temp_solution[(m+1)%n]]\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_reconnection = reconnection\n\n        if best_reconnection:\n            i, j, k, l = best_reconnection\n            if i < j and j < k and k < l:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            else:\n                # Handle circular cases\n                pass  # Simplified for brevity\n\n    return new_solution\n\n",
        "score": [
            -0.7577613408348206,
            4.13355985879898
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Calculate crowding distances for each objective\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            sorted_objectives = objectives[sorted_indices, i]\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                if sorted_objectives[-1] == sorted_objectives[0]:\n                    crowding_distances[sorted_indices[j]] += 0\n                else:\n                    crowding_distances[sorted_indices[j]] += (sorted_objectives[j+1] - sorted_objectives[j-1]) / (sorted_objectives[-1] - sorted_objectives[0])\n        # Select the solution with the highest crowding distance\n        base_idx = np.argmax(crowding_distances)\n        base_solution = archive[base_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt and 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware edge selection: identify edges with high contribution to any objective\n    def edge_contribution(i, j):\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        cost3 = distance_matrix_3[new_solution[i], new_solution[j]]\n        return max(cost1, cost2, cost3)\n\n    # Find the worst edge in terms of maximum objective\n    max_contribution = -1\n    worst_i, worst_j = -1, -1\n    for i in range(n):\n        j = (i + 1) % n\n        contrib = edge_contribution(i, j)\n        if contrib > max_contribution:\n            max_contribution = contrib\n            worst_i, worst_j = i, j\n\n    # Apply 2-opt or 3-opt based on the worst edge\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # 2-opt: reverse a segment between worst_i and worst_j\n        if worst_i < worst_j:\n            new_solution[worst_i:worst_j+1] = new_solution[worst_i:worst_j+1][::-1]\n        else:\n            # Handle the circular case\n            segment = np.concatenate([new_solution[worst_i:], new_solution[:worst_j+1]])\n            reversed_segment = segment[::-1]\n            new_solution = np.concatenate([reversed_segment[len(segment)-worst_j-1:], new_solution[worst_j+1:worst_i], reversed_segment[:len(segment)-worst_j-1]])\n    else:  # 30% chance for 3-opt\n        # 3-opt: select three random edges and reconnect them\n        edges = random.sample(range(n), 3)\n        edges.sort()\n        a, b, c = edges\n        # Create all possible reconnections and choose the best one\n        possible_reconnections = [\n            (a, c, b, a),  # Reconnect a-c, b-a\n            (a, b, c, a),  # Reconnect a-b, c-a\n            (a, b, a, c),  # Reconnect a-b, a-c\n            (a, c, b, c)   # Reconnect a-c, b-c\n        ]\n        best_reconnection = None\n        min_cost = float('inf')\n        for reconnection in possible_reconnections:\n            temp_solution = new_solution.copy()\n            # Apply the reconnection\n            i, j, k, l = reconnection\n            if i < j and j < k and k < l:\n                # Reverse segments\n                temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n                temp_solution[j:k+1] = temp_solution[j:k+1][::-1]\n                temp_solution[k:l+1] = temp_solution[k:l+1][::-1]\n            else:\n                # Handle circular cases\n                pass  # Simplified for brevity\n\n            # Calculate total cost\n            total_cost = 0\n            for m in range(n):\n                total_cost += distance_matrix_1[temp_solution[m], temp_solution[(m+1)%n]]\n                total_cost += distance_matrix_2[temp_solution[m], temp_solution[(m+1)%n]]\n                total_cost += distance_matrix_3[temp_solution[m], temp_solution[(m+1)%n]]\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_reconnection = reconnection\n\n        if best_reconnection:\n            i, j, k, l = best_reconnection\n            if i < j and j < k and k < l:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                new_solution[j:k+1] = new_solution[j:k+1][::-1]\n                new_solution[k:l+1] = new_solution[k:l+1][::-1]\n            else:\n                # Handle circular cases\n                pass  # Simplified for brevity\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high diversity and low dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with 3-way swap\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        # Randomly select segments for 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n        new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n        # Apply 3-way swap for multi-objective optimization\n        if n >= 3:\n            a, b, c = np.random.choice(n, 3, replace=False)\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7372304024851324,
            1.6536492824554443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high diversity and low dominance\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with 3-way swap\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to balance exploration/exploitation\n        # Randomly select segments for 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n        # Apply 2-opt\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n        new_solution[k:l+1] = base_solution[k:l+1][::-1]\n\n        # Apply 3-way swap for multi-objective optimization\n        if n >= 3:\n            a, b, c = np.random.choice(n, 3, replace=False)\n            new_solution[a], new_solution[b], new_solution[c] = new_solution[b], new_solution[c], new_solution[a]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate the change in objectives for the 2-opt move\n    def compute_delta(move_i, move_j):\n        a, b, c, d = new_solution[move_i-1], new_solution[move_i], new_solution[move_j-1], new_solution[move_j]\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n        return delta1, delta2, delta3\n\n    # Evaluate the move's potential to improve any objective\n    delta1, delta2, delta3 = compute_delta(i, j)\n\n    # If the move improves any objective, accept it\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a secondary move: swap two nodes to improve objective diversity\n    if np.random.rand() < 0.3:\n        k, l = np.random.choice(n, 2, replace=False)\n        delta1, delta2, delta3 = compute_delta(k, l)\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6291016417144133,
            1.5960843920707704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate the change in objectives for the 2-opt move\n    def compute_delta(move_i, move_j):\n        a, b, c, d = new_solution[move_i-1], new_solution[move_i], new_solution[move_j-1], new_solution[move_j]\n        delta1 = (distance_matrix_1[a, c] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n        delta2 = (distance_matrix_2[a, c] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n        delta3 = (distance_matrix_3[a, c] + distance_matrix_3[b, d]) - (distance_matrix_3[a, b] + distance_matrix_3[c, d])\n        return delta1, delta2, delta3\n\n    # Evaluate the move's potential to improve any objective\n    delta1, delta2, delta3 = compute_delta(i, j)\n\n    # If the move improves any objective, accept it\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a secondary move: swap two nodes to improve objective diversity\n    if np.random.rand() < 0.3:\n        k, l = np.random.choice(n, 2, replace=False)\n        delta1, delta2, delta3 = compute_delta(k, l)\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1).flatten()  # Random weights for objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to improve one objective\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective swap to improve other objectives\n    if np.random.rand() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7829947819132179,
            2.438369858264923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.random.dirichlet(np.ones(3), size=1).flatten()  # Random weights for objectives\n    scores = [sum(w * o for w, o in zip(weights, obj)) for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a multi-objective swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to improve one objective\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply multi-objective swap to improve other objectives\n    if np.random.rand() < 0.5:\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != len(new_solution):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high potential for improvement across all objectives\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Calculate the improvement potential for each objective\n            obj1_improvement = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            obj2_improvement = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            obj3_improvement = (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_3[new_solution[i], new_solution[i+1]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # If any objective shows improvement, perform the 2-opt swap\n            if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.670524291396939,
            2.4954344511032103
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, base_objectives = max(archive, key=lambda x: sum(x[1]))\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high potential for improvement across all objectives\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Calculate the improvement potential for each objective\n            obj1_improvement = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            obj2_improvement = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            obj3_improvement = (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                              (distance_matrix_3[new_solution[i], new_solution[i+1]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # If any objective shows improvement, perform the 2-opt swap\n            if obj1_improvement < 0 or obj2_improvement < 0 or obj3_improvement < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge swapping\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    # Apply a second local search: move a node to a better position based on all three objectives\n    if n > 3:\n        # Select a random node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from the tour\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position based on the sum of distances in all three objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert the node and calculate the total cost for all three objectives\n            temp_solution = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost3 = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.43256566271335684,
            3.87319997549057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best trade-off between objectives\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge swapping\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    # Apply a second local search: move a node to a better position based on all three objectives\n    if n > 3:\n        # Select a random node to move\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Remove the node from the tour\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position based on the sum of distances in all three objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert the node and calculate the total cost for all three objectives\n            temp_solution = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost3 = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2 + cost3\n\n            if total_cost < best_score:\n                best_score = total_cost\n                best_pos = pos\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective averages\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    obj3_avg = np.mean([obj[2] for _, obj in archive])\n\n    # Select candidate solutions with below-average performance in at least two objectives\n    candidates = [(sol, obj) for sol, obj in archive\n                 if sum(o < avg for o, avg in zip(obj, [obj1_avg, obj2_avg, obj3_avg])) >= 2]\n\n    if not candidates:\n        # If no candidates, select random solution\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select candidate with highest potential for improvement (smallest objective values)\n        base_solution = min(candidates, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly choose between 2-opt and 3-opt with weighted probability\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            # Reconnect segments in one of 4 possible ways\n            choice = random.randint(0, 3)\n            if choice == 0:\n                new_solution[i:k] = np.concatenate([segment1, segment2])\n            elif choice == 1:\n                new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n            elif choice == 2:\n                new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n            else:\n                new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.73445891474623,
            1.1457549929618835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate objective averages\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n    obj3_avg = np.mean([obj[2] for _, obj in archive])\n\n    # Select candidate solutions with below-average performance in at least two objectives\n    candidates = [(sol, obj) for sol, obj in archive\n                 if sum(o < avg for o, avg in zip(obj, [obj1_avg, obj2_avg, obj3_avg])) >= 2]\n\n    if not candidates:\n        # If no candidates, select random solution\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select candidate with highest potential for improvement (smallest objective values)\n        base_solution = min(candidates, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly choose between 2-opt and 3-opt with weighted probability\n        if random.random() < 0.7:  # 70% chance for 2-opt\n            # 2-opt move\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # 3-opt move\n            i, j, k = sorted(random.sample(range(n), 3))\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            # Reconnect segments in one of 4 possible ways\n            choice = random.randint(0, 3)\n            if choice == 0:\n                new_solution[i:k] = np.concatenate([segment1, segment2])\n            elif choice == 1:\n                new_solution[i:k] = np.concatenate([segment1, segment2[::-1]])\n            elif choice == 2:\n                new_solution[i:k] = np.concatenate([segment1[::-1], segment2])\n            else:\n                new_solution[i:k] = np.concatenate([segment1[::-1], segment2[::-1]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by analyzing objective diversity and local search potential, then applies a hybrid local search strategy combining 2-opt moves with adaptive segment reversal to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # 2-opt move in one objective space\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment reversal based on objective diversity\n    if np.random.rand() < 0.3:  # 30% chance for adaptive move\n        # Find the most diverse segment\n        segment_length = min(3, n // 2)\n        segments = []\n        for k in range(n - segment_length + 1):\n            segment = base_solution[k:k+segment_length]\n            costs = [\n                sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length)),\n                sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length)),\n                sum(distance_matrix_3[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n            ]\n            diversity = np.std(costs)\n            segments.append((k, diversity))\n\n        _, best_diversity = max(segments, key=lambda x: x[1])\n        if best_diversity > 0:\n            # Reverse the most diverse segment\n            k = np.random.choice([k for k, d in segments if d == best_diversity])\n            new_solution[k:k+segment_length] = new_solution[k:k+segment_length][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7968151219598103,
            1.8049418568611144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # 2-opt move in one objective space\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Adaptive segment reversal based on objective diversity\n    if np.random.rand() < 0.3:  # 30% chance for adaptive move\n        # Find the most diverse segment\n        segment_length = min(3, n // 2)\n        segments = []\n        for k in range(n - segment_length + 1):\n            segment = base_solution[k:k+segment_length]\n            costs = [\n                sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length)),\n                sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length)),\n                sum(distance_matrix_3[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n            ]\n            diversity = np.std(costs)\n            segments.append((k, diversity))\n\n        _, best_diversity = max(segments, key=lambda x: x[1])\n        if best_diversity > 0:\n            # Reverse the most diverse segment\n            k = np.random.choice([k for k, d in segments if d == best_diversity])\n            new_solution[k:k+segment_length] = new_solution[k:k+segment_length][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objective values (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to improve the worst-performing objective\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    # Calculate improvement potential for each possible swap\n    improvements = []\n    for a in range(n):\n        for b in range(a+1, n):\n            # Evaluate swap in the worst-performing objective space\n            if worst_obj == 0:\n                delta = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[b-1]])\n            elif worst_obj == 1:\n                delta = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[b-1]])\n            else:\n                delta = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[a]] -\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_3[new_solution[b], new_solution[b-1]])\n            improvements.append((delta, a, b))\n\n    # Apply the most beneficial swap for the worst objective\n    if improvements:\n        best_delta, best_a, best_b = min(improvements, key=lambda x: x[0])\n        if best_delta < 0:  # Only accept if improvement\n            new_solution[best_a], new_solution[best_b] = new_solution[best_b], new_solution[best_a]\n\n    return new_solution\n\n",
        "score": [
            -0.7519491869425237,
            2.752220666408539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objective values (promising for multi-objective improvement)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform an objective-aware swap to improve the worst-performing objective\n    obj_values = archive[selected_idx][1]\n    worst_obj = np.argmax(obj_values)\n\n    # Calculate improvement potential for each possible swap\n    improvements = []\n    for a in range(n):\n        for b in range(a+1, n):\n            # Evaluate swap in the worst-performing objective space\n            if worst_obj == 0:\n                delta = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b], new_solution[a]] -\n                         distance_matrix_1[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_1[new_solution[b], new_solution[b-1]])\n            elif worst_obj == 1:\n                delta = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b], new_solution[a]] -\n                         distance_matrix_2[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_2[new_solution[b], new_solution[b-1]])\n            else:\n                delta = (distance_matrix_3[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_3[new_solution[b], new_solution[a]] -\n                         distance_matrix_3[new_solution[a-1], new_solution[a]] -\n                         distance_matrix_3[new_solution[b], new_solution[b-1]])\n            improvements.append((delta, a, b))\n\n    # Apply the most beneficial swap for the worst objective\n    if improvements:\n        best_delta, best_a, best_b = min(improvements, key=lambda x: x[0])\n        if best_delta < 0:  # Only accept if improvement\n            new_solution[best_a], new_solution[best_b] = new_solution[best_b], new_solution[best_a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by prioritizing those with diverse objective values and applies a hybrid local search combining edge-swapping and multi-objective path relinking to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: edge-swapping and multi-objective path relinking\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge-swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective path relinking (simplified)\n    # Select a segment and try to improve it based on multiple objectives\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n\n    # Evaluate segment in all three objectives\n    def segment_cost(seg):\n        cost1 = sum(distance_matrix_1[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n        return cost1, cost2, cost3\n\n    current_cost = segment_cost(segment)\n\n    # Try to improve the segment by reversing it\n    reversed_segment = segment[::-1]\n    reversed_cost = segment_cost(reversed_segment)\n\n    # If reversed segment is better in at least one objective, accept it\n    if any(reversed_cost[i] < current_cost[i] for i in range(3)):\n        new_solution[start:end+1] = reversed_segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7884573516607225,
            1.0878377556800842
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search: edge-swapping and multi-objective path relinking\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge-swapping\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Multi-objective path relinking (simplified)\n    # Select a segment and try to improve it based on multiple objectives\n    start, end = sorted(random.sample(range(n), 2))\n    segment = new_solution[start:end+1]\n\n    # Evaluate segment in all three objectives\n    def segment_cost(seg):\n        cost1 = sum(distance_matrix_1[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n        cost2 = sum(distance_matrix_2[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n        cost3 = sum(distance_matrix_3[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n        return cost1, cost2, cost3\n\n    current_cost = segment_cost(segment)\n\n    # Try to improve the segment by reversing it\n    reversed_segment = segment[::-1]\n    reversed_cost = segment_cost(reversed_segment)\n\n    # If reversed segment is better in at least one objective, accept it\n    if any(reversed_cost[i] < current_cost[i] for i in range(3)):\n        new_solution[start:end+1] = reversed_segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    n = len(new_solution)\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    # Reverse the segment (2-opt)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware node insertion: select a node with high variance in objectives\n    node_scores = []\n    for node in new_solution:\n        d1 = distance_matrix_1[node, :].mean()\n        d2 = distance_matrix_2[node, :].mean()\n        d3 = distance_matrix_3[node, :].mean()\n        variance = np.var([d1, d2, d3])\n        node_scores.append(variance)\n    # Select the node with highest variance for repositioning\n    node_to_move = new_solution[np.argmax(node_scores)]\n    # Remove and reinsert at a random position\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_solution = np.delete(new_solution, pos)\n    new_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7081275063249293,
            3.759261441230774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    n = len(new_solution)\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    # Reverse the segment (2-opt)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware node insertion: select a node with high variance in objectives\n    node_scores = []\n    for node in new_solution:\n        d1 = distance_matrix_1[node, :].mean()\n        d2 = distance_matrix_2[node, :].mean()\n        d3 = distance_matrix_3[node, :].mean()\n        variance = np.var([d1, d2, d3])\n        node_scores.append(variance)\n    # Select the node with highest variance for repositioning\n    node_to_move = new_solution[np.argmax(node_scores)]\n    # Remove and reinsert at a random position\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_solution = np.delete(new_solution, pos)\n    new_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        # Select solution with highest crowding distance\n        base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective-aware 2-opt with random edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Select two random edges that don't share nodes\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Ensure edges are non-overlapping and valid\n        if i != k and j != l and i != l and j != k:\n            # Calculate improvement in all three objectives\n            old_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j-1], new_solution[j]],\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j-1], new_solution[j]],\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j-1], new_solution[j]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[k-1], new_solution[l]],\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[k-1], new_solution[l]],\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[k-1], new_solution[l]]\n            ]\n\n            # Accept if at least one objective improves\n            if any(new < old for new, old in zip(new_costs, old_costs)):\n                # Perform the swap\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7126725028504073,
            1.779113495349884
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for all solutions\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for m in range(3):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m])\n\n        # Select solution with highest crowding distance\n        base_solution = archive[np.argmax(crowding_distances)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: multi-objective-aware 2-opt with random edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Select two random edges that don't share nodes\n        i, j = sorted(random.sample(range(1, n), 2))\n        k, l = sorted(random.sample(range(1, n), 2))\n\n        # Ensure edges are non-overlapping and valid\n        if i != k and j != l and i != l and j != k:\n            # Calculate improvement in all three objectives\n            old_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                distance_matrix_1[new_solution[j-1], new_solution[j]],\n                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                distance_matrix_2[new_solution[j-1], new_solution[j]],\n                distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                distance_matrix_3[new_solution[j-1], new_solution[j]]\n            ]\n\n            new_costs = [\n                distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                distance_matrix_1[new_solution[k-1], new_solution[l]],\n                distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                distance_matrix_2[new_solution[k-1], new_solution[l]],\n                distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                distance_matrix_3[new_solution[k-1], new_solution[l]]\n            ]\n\n            # Accept if at least one objective improves\n            if any(new < old for new, old in zip(new_costs, old_costs)):\n                # Perform the swap\n                new_solution[i:j] = new_solution[i:j][::-1]\n                new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Perform edge swapping followed by objective-aware node reinsertion\n    n = len(base_solution)\n\n    # Edge swapping (2-opt)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware node reinsertion\n    if random.random() < 0.5:  # 50% chance to perform reinsertion\n        # Select a node to reinsert based on its contribution to the worst objective\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        worst_obj = np.argmax([obj1, obj2, obj3])\n\n        if worst_obj == 0:\n            # Find the node with the highest contribution to the first objective\n            contributions = [distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(1, n)]\n            contributions.append(distance_matrix_1[base_solution[-1], base_solution[0]])\n        elif worst_obj == 1:\n            contributions = [distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(1, n)]\n            contributions.append(distance_matrix_2[base_solution[-1], base_solution[0]])\n        else:\n            contributions = [distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(1, n)]\n            contributions.append(distance_matrix_3[base_solution[-1], base_solution[0]])\n\n        worst_node_idx = np.argmax(contributions)\n        worst_node = new_solution[worst_node_idx]\n\n        # Remove the worst node\n        new_solution = np.delete(new_solution, worst_node_idx)\n\n        # Find the best insertion position for the worst node\n        best_pos = 0\n        best_improvement = -float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, worst_node)\n            temp_obj1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n            temp_obj1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            temp_obj2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n            temp_obj2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            temp_obj3 = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n            temp_obj3 += distance_matrix_3[temp_solution[-1], temp_solution[0]]\n\n            # Calculate improvement based on the worst objective\n            if worst_obj == 0:\n                improvement = obj1 - temp_obj1\n            elif worst_obj == 1:\n                improvement = obj2 - temp_obj2\n            else:\n                improvement = obj3 - temp_obj3\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, worst_node)\n\n    return new_solution\n\n",
        "score": [
            -0.645524891229672,
            2.584087598323822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Perform edge swapping followed by objective-aware node reinsertion\n    n = len(base_solution)\n\n    # Edge swapping (2-opt)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware node reinsertion\n    if random.random() < 0.5:  # 50% chance to perform reinsertion\n        # Select a node to reinsert based on its contribution to the worst objective\n        obj1, obj2, obj3 = archive[selected_idx][1]\n        worst_obj = np.argmax([obj1, obj2, obj3])\n\n        if worst_obj == 0:\n            # Find the node with the highest contribution to the first objective\n            contributions = [distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(1, n)]\n            contributions.append(distance_matrix_1[base_solution[-1], base_solution[0]])\n        elif worst_obj == 1:\n            contributions = [distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(1, n)]\n            contributions.append(distance_matrix_2[base_solution[-1], base_solution[0]])\n        else:\n            contributions = [distance_matrix_3[base_solution[i-1], base_solution[i]] for i in range(1, n)]\n            contributions.append(distance_matrix_3[base_solution[-1], base_solution[0]])\n\n        worst_node_idx = np.argmax(contributions)\n        worst_node = new_solution[worst_node_idx]\n\n        # Remove the worst node\n        new_solution = np.delete(new_solution, worst_node_idx)\n\n        # Find the best insertion position for the worst node\n        best_pos = 0\n        best_improvement = -float('inf')\n\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, worst_node)\n            temp_obj1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n            temp_obj1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            temp_obj2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n            temp_obj2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            temp_obj3 = sum(distance_matrix_3[temp_solution[i-1], temp_solution[i]] for i in range(1, n))\n            temp_obj3 += distance_matrix_3[temp_solution[-1], temp_solution[0]]\n\n            # Calculate improvement based on the worst objective\n            if worst_obj == 0:\n                improvement = obj1 - temp_obj1\n            elif worst_obj == 1:\n                improvement = obj2 - temp_obj2\n            else:\n                improvement = obj3 - temp_obj3\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, worst_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for further improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    if n > 3:\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, min(start + 5, n))\n\n        # Reverse the segment (2-opt like move)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # If the move improves at least one objective, keep it; otherwise revert\n        old_costs = [\n            sum(distance_matrix_1[base_solution[i], base_solution[(i + 1) % n]] for i in range(n)),\n            sum(distance_matrix_2[base_solution[i], base_solution[(i + 1) % n]] for i in range(n)),\n            sum(distance_matrix_3[base_solution[i], base_solution[(i + 1) % n]] for i in range(n))\n        ]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i + 1) % n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i + 1) % n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n        ]\n\n        if sum(new_costs) >= sum(old_costs):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6886546569098295,
            1.6159391045570373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest diversity in objectives (promising for further improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    if n > 3:\n        start = np.random.randint(0, n - 3)\n        end = np.random.randint(start + 2, min(start + 5, n))\n\n        # Reverse the segment (2-opt like move)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # If the move improves at least one objective, keep it; otherwise revert\n        old_costs = [\n            sum(distance_matrix_1[base_solution[i], base_solution[(i + 1) % n]] for i in range(n)),\n            sum(distance_matrix_2[base_solution[i], base_solution[(i + 1) % n]] for i in range(n)),\n            sum(distance_matrix_3[base_solution[i], base_solution[(i + 1) % n]] for i in range(n))\n        ]\n        new_costs = [\n            sum(distance_matrix_1[new_solution[i], new_solution[(i + 1) % n]] for i in range(n)),\n            sum(distance_matrix_2[new_solution[i], new_solution[(i + 1) % n]] for i in range(n)),\n            sum(distance_matrix_3[new_solution[i], new_solution[(i + 1) % n]] for i in range(n))\n        ]\n\n        if sum(new_costs) >= sum(old_costs):\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Reverse segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps for the other two objectives\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            # Swap nodes and check if it improves any objective\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            # Calculate new objectives\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            # If any objective is worse, revert\n            original_obj1 = sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            original_obj2 = sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            original_obj3 = sum(distance_matrix_3[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n\n            if (obj1 > original_obj1 and obj2 > original_obj2) or (obj2 > original_obj2 and obj3 > original_obj3) or (obj1 > original_obj1 and obj3 > original_obj3):\n                # Revert if both objectives worsen\n                new_solution[j] = new_solution[i]\n                new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7004549524530443,
            2.1692207932472227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Reverse segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform objective-aware swaps for the other two objectives\n    for _ in range(3):\n        i, j = random.sample(range(n), 2)\n        if i != j:\n            # Swap nodes and check if it improves any objective\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            # Calculate new objectives\n            obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            # If any objective is worse, revert\n            original_obj1 = sum(distance_matrix_1[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            original_obj2 = sum(distance_matrix_2[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n            original_obj3 = sum(distance_matrix_3[selected_solution[k], selected_solution[(k+1)%n]] for k in range(n))\n\n            if (obj1 > original_obj1 and obj2 > original_obj2) or (obj2 > original_obj2 and obj3 > original_obj3) or (obj1 > original_obj1 and obj3 > original_obj3):\n                # Revert if both objectives worsen\n                new_solution[j] = new_solution[i]\n                new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(objective):\n        return sum(objective)  # Simple sum as a proxy for trade-off\n\n    # Sort solutions by dominance score and pick the middle one for diversity\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = len(archive_sorted) // 2\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(1, n), 2))\n\n    # Check if swapping improves at least one objective\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k-1], solution[k]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]  # Reverse the segment\n    new_obj = calculate_objective(temp_solution)\n\n    # Accept if at least one objective improves\n    if any(new_obj[k] < current_obj[k] for k in range(3)):\n        new_solution = temp_solution\n\n    # Apply a second 2-opt with a different pair to further improve\n    i, j = sorted(random.sample(range(1, n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n    new_obj = calculate_objective(temp_solution)\n\n    if any(new_obj[k] < current_obj[k] for k in range(3)):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6735334341397443,
            1.9179932832717896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def dominance_score(objective):\n        return sum(objective)  # Simple sum as a proxy for trade-off\n\n    # Sort solutions by dominance score and pick the middle one for diversity\n    archive_sorted = sorted(archive, key=lambda x: dominance_score(x[1]))\n    selected_idx = len(archive_sorted) // 2\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(1, n), 2))\n\n    # Check if swapping improves at least one objective\n    def calculate_objective(solution):\n        obj1 = sum(distance_matrix_1[solution[k-1], solution[k]] for k in range(n))\n        obj2 = sum(distance_matrix_2[solution[k-1], solution[k]] for k in range(n))\n        obj3 = sum(distance_matrix_3[solution[k-1], solution[k]] for k in range(n))\n        return (obj1, obj2, obj3)\n\n    current_obj = calculate_objective(new_solution)\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]  # Reverse the segment\n    new_obj = calculate_objective(temp_solution)\n\n    # Accept if at least one objective improves\n    if any(new_obj[k] < current_obj[k] for k in range(3)):\n        new_solution = temp_solution\n\n    # Apply a second 2-opt with a different pair to further improve\n    i, j = sorted(random.sample(range(1, n), 2))\n    temp_solution = new_solution.copy()\n    temp_solution[i:j] = temp_solution[i:j][::-1]\n    new_obj = calculate_objective(temp_solution)\n\n    if any(new_obj[k] < current_obj[k] for k in range(3)):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    best_delta = 0\n    best_i, best_j = 0, 0\n\n    # 2-opt local search for the first objective\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i + 1]\n            c, d = new_solution[j], new_solution[j + 1] if j + 1 < n else new_solution[0]\n            delta = (distance_matrix_1[b, c] + distance_matrix_1[a, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_delta < 0:\n        new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    # Multi-objective aware swap for the other two objectives\n    for _ in range(5):  # Limited number of swaps to balance exploration/exploitation\n        i, j = np.random.choice(n, 2, replace=False)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Check if the swap improves at least one objective\n        old_costs = (\n            sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n        )\n        new_costs = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k + 1) % n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k + 1) % n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n        )\n\n        if sum(new_costs) >= sum(old_costs):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7040944615065998,
            4.265684509277344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: combine 2-opt with a multi-objective aware swap\n    n = len(new_solution)\n    best_delta = 0\n    best_i, best_j = 0, 0\n\n    # 2-opt local search for the first objective\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            a, b = new_solution[i], new_solution[i + 1]\n            c, d = new_solution[j], new_solution[j + 1] if j + 1 < n else new_solution[0]\n            delta = (distance_matrix_1[b, c] + distance_matrix_1[a, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n            if delta < best_delta:\n                best_delta = delta\n                best_i, best_j = i, j\n\n    if best_delta < 0:\n        new_solution[best_i + 1:best_j + 1] = new_solution[best_i + 1:best_j + 1][::-1]\n\n    # Multi-objective aware swap for the other two objectives\n    for _ in range(5):  # Limited number of swaps to balance exploration/exploitation\n        i, j = np.random.choice(n, 2, replace=False)\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Check if the swap improves at least one objective\n        old_costs = (\n            sum(distance_matrix_1[base_solution[k], base_solution[(k + 1) % n]] for k in range(n)),\n            sum(distance_matrix_2[base_solution[k], base_solution[(k + 1) % n]] for k in range(n)),\n            sum(distance_matrix_3[base_solution[k], base_solution[(k + 1) % n]] for k in range(n))\n        )\n        new_costs = (\n            sum(distance_matrix_1[new_solution[k], new_solution[(k + 1) % n]] for k in range(n)),\n            sum(distance_matrix_2[new_solution[k], new_solution[(k + 1) % n]] for k in range(n)),\n            sum(distance_matrix_3[new_solution[k], new_solution[(k + 1) % n]] for k in range(n))\n        )\n\n        if sum(new_costs) >= sum(old_costs):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{The algorithm selects a promising solution from the archive by evaluating its potential for local improvement across multiple objectives, then applies a hybrid local search operator that combines edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the potential for improvement (e.g., using objective diversity or dominance)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        diversity = np.std(normalized_objectives, axis=0).sum()\n        # Prefer solutions with higher diversity or non-dominated fronts\n        weights = np.exp(diversity * np.random.rand(len(archive)))\n        weights /= weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n > 3:\n        # Randomly choose between edge swap or segment reversal\n        if random.random() < 0.5:\n            # Edge swap (2-opt)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment reversal (3-opt or similar)\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.7996545215868818,
            1.2751555442810059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the potential for improvement (e.g., using objective diversity or dominance)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        diversity = np.std(normalized_objectives, axis=0).sum()\n        # Prefer solutions with higher diversity or non-dominated fronts\n        weights = np.exp(diversity * np.random.rand(len(archive)))\n        weights /= weights.sum()\n        selected_idx = np.random.choice(len(archive), p=weights)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if n > 3:\n        # Randomly choose between edge swap or segment reversal\n        if random.random() < 0.5:\n            # Edge swap (2-opt)\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Segment reversal (3-opt or similar)\n            i, j, k = sorted(random.sample(range(n), 3))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt for one objective, then adjust for others\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the first objective (distance_matrix_1)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Adjust the tour for the other objectives by swapping segments if it improves the objectives\n    for _ in range(3):  # Try a few adjustments\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[k:l] = candidate[k:l][::-1]\n\n        # Compute new objectives\n        obj1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        if obj1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]] or \\\n           obj2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]] or \\\n           obj3 < sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]:\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.556678784671581,
            1.4781099319458009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]), reverse=True)\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search: 2-opt for one objective, then adjust for others\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the first objective (distance_matrix_1)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Adjust the tour for the other objectives by swapping segments if it improves the objectives\n    for _ in range(3):  # Try a few adjustments\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[k:l] = candidate[k:l][::-1]\n\n        # Compute new objectives\n        obj1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        obj2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        obj3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        if obj1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]] or \\\n           obj2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]] or \\\n           obj3 < sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]:\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined improvement potential across all objectives\n    selected_index = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > 1:\n        # Calculate edge costs in all three objectives\n        edge_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n        # If the combined cost is high, perform the swap\n        if sum(edge_costs) > np.median([sum(obj) for _, obj in archive]):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge insertion\n    if n > 3:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l:\n            # Calculate potential improvement in all objectives\n            improvement = [\n                (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[k], new_solution[l-1]]) -\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]]),\n                (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[k], new_solution[l-1]]) -\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]]),\n                (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_3[new_solution[k], new_solution[l-1]]) -\n                (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_3[new_solution[l-1], new_solution[l]])\n            ]\n            # If improvement is positive in at least one objective, perform the swap\n            if any(imp > 0 for imp in improvement):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7044597060465153,
            1.41578289270401
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined improvement potential across all objectives\n    selected_index = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    if j - i > 1:\n        # Calculate edge costs in all three objectives\n        edge_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n        # If the combined cost is high, perform the swap\n        if sum(edge_costs) > np.median([sum(obj) for _, obj in archive]):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware edge insertion\n    if n > 3:\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l:\n            # Calculate potential improvement in all objectives\n            improvement = [\n                (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_1[new_solution[k], new_solution[l-1]]) -\n                (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_1[new_solution[l-1], new_solution[l]]),\n                (distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_2[new_solution[k], new_solution[l-1]]) -\n                (distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_2[new_solution[l-1], new_solution[l]]),\n                (distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                 distance_matrix_3[new_solution[k], new_solution[l-1]]) -\n                (distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                 distance_matrix_3[new_solution[l-1], new_solution[l]])\n            ]\n            # If improvement is positive in at least one objective, perform the swap\n            if any(imp > 0 for imp in improvement):\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    while abs(i - j) < 2:  # Ensure edges are not adjacent\n        i, j = np.random.choice(n, 2, replace=False)\n\n    # Perform a 2-opt swap\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[i:] = new_solution[i:][::-1]\n        new_solution[:j+1] = new_solution[:j+1][::-1]\n\n    # Objective-aware edge selection: bias toward edges with high potential for improvement\n    if np.random.rand() < 0.3:  # 30% chance to apply objective-aware selection\n        # Calculate potential improvement for each edge in the selected solution\n        improvements = []\n        for k in range(n):\n            node1 = selected_solution[k]\n            node2 = selected_solution[(k+1) % n]\n            # Calculate improvement in all three objectives\n            obj1_improvement = distance_matrix_1[node1, node2] - (distance_matrix_1[node1, selected_solution[(k-1)%n]] + distance_matrix_1[selected_solution[(k+2)%n], node2])\n            obj2_improvement = distance_matrix_2[node1, node2] - (distance_matrix_2[node1, selected_solution[(k-1)%n]] + distance_matrix_2[selected_solution[(k+2)%n], node2])\n            obj3_improvement = distance_matrix_3[node1, node2] - (distance_matrix_3[node1, selected_solution[(k-1)%n]] + distance_matrix_3[selected_solution[(k+2)%n], node2])\n            total_improvement = obj1_improvement + obj2_improvement + obj3_improvement\n            improvements.append(total_improvement)\n\n        # Select the edge with the highest potential improvement to swap\n        best_edge = np.argmax(improvements)\n        # Perform a 2-opt swap on the selected edge\n        new_solution[best_edge:(best_edge+2)] = new_solution[best_edge:(best_edge+2)][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6923161897572012,
            1.5277950048446656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, 2, replace=False)\n    while abs(i - j) < 2:  # Ensure edges are not adjacent\n        i, j = np.random.choice(n, 2, replace=False)\n\n    # Perform a 2-opt swap\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        new_solution[i:] = new_solution[i:][::-1]\n        new_solution[:j+1] = new_solution[:j+1][::-1]\n\n    # Objective-aware edge selection: bias toward edges with high potential for improvement\n    if np.random.rand() < 0.3:  # 30% chance to apply objective-aware selection\n        # Calculate potential improvement for each edge in the selected solution\n        improvements = []\n        for k in range(n):\n            node1 = selected_solution[k]\n            node2 = selected_solution[(k+1) % n]\n            # Calculate improvement in all three objectives\n            obj1_improvement = distance_matrix_1[node1, node2] - (distance_matrix_1[node1, selected_solution[(k-1)%n]] + distance_matrix_1[selected_solution[(k+2)%n], node2])\n            obj2_improvement = distance_matrix_2[node1, node2] - (distance_matrix_2[node1, selected_solution[(k-1)%n]] + distance_matrix_2[selected_solution[(k+2)%n], node2])\n            obj3_improvement = distance_matrix_3[node1, node2] - (distance_matrix_3[node1, selected_solution[(k-1)%n]] + distance_matrix_3[selected_solution[(k+2)%n], node2])\n            total_improvement = obj1_improvement + obj2_improvement + obj3_improvement\n            improvements.append(total_improvement)\n\n        # Select the edge with the highest potential improvement to swap\n        best_edge = np.argmax(improvements)\n        # Perform a 2-opt swap on the selected edge\n        new_solution[best_edge:(best_edge+2)] = new_solution[best_edge:(best_edge+2)][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.std(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swapping edges i-j and i+1-j+1 improves any objective\n        obj1 = (distance_matrix_1[selected_solution[i], selected_solution[j]] +\n                distance_matrix_1[selected_solution[(i+1)%n], selected_solution[(j+1)%n]])\n        obj2 = (distance_matrix_2[selected_solution[i], selected_solution[j]] +\n                distance_matrix_2[selected_solution[(i+1)%n], selected_solution[(j+1)%n]])\n        obj3 = (distance_matrix_3[selected_solution[i], selected_solution[j]] +\n                distance_matrix_3[selected_solution[(i+1)%n], selected_solution[(j+1)%n]])\n        if obj1 + obj2 + obj3 > 0:  # If the current edges are worse in aggregate\n            # Perform the swap\n            selected_solution[i+1:j+1] = selected_solution[i+1:j+1][::-1]\n\n    return selected_solution\n\n",
        "score": [
            -0.5861439840517697,
            3.3724903583526613
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.std(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Check if swapping edges i-j and i+1-j+1 improves any objective\n        obj1 = (distance_matrix_1[selected_solution[i], selected_solution[j]] +\n                distance_matrix_1[selected_solution[(i+1)%n], selected_solution[(j+1)%n]])\n        obj2 = (distance_matrix_2[selected_solution[i], selected_solution[j]] +\n                distance_matrix_2[selected_solution[(i+1)%n], selected_solution[(j+1)%n]])\n        obj3 = (distance_matrix_3[selected_solution[i], selected_solution[j]] +\n                distance_matrix_3[selected_solution[(i+1)%n], selected_solution[(j+1)%n]])\n        if obj1 + obj2 + obj3 > 0:  # If the current edges are worse in aggregate\n            # Perform the swap\n            selected_solution[i+1:j+1] = selected_solution[i+1:j+1][::-1]\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Randomly select a solution with probability proportional to its \"improvement potential\"\n        # Here, we use the sum of normalized objective values to estimate potential\n        objectives = np.array([obj for (sol, obj) in archive])\n        normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-10)\n        potential = normalized.sum(axis=1)\n        probabilities = np.exp(-potential)  # Lower potential (better) solutions have higher probability\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n <= 3:\n        # For small tours, just reverse the order\n        new_solution = new_solution[::-1]\n    else:\n        # Choose between 2-opt or objective-aware swap based on randomness\n        if random.random() < 0.5:\n            # 2-opt move: select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Objective-aware swap: select two nodes and swap them if it improves at least one objective\n            i, j = random.sample(range(n), 2)\n            original_cost = (\n                distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n                distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]] +\n                distance_matrix_3[base_solution[j-1], base_solution[j]] + distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n            )\n            swapped_cost = (\n                distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[j], base_solution[(i+1)%n]] +\n                distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n                distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] +\n                distance_matrix_3[base_solution[j-1], base_solution[i]] + distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n            )\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n    return new_solution\n\n",
        "score": [
            -0.6391699364801469,
            2.6344841957092284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Randomly select a solution with probability proportional to its \"improvement potential\"\n        # Here, we use the sum of normalized objective values to estimate potential\n        objectives = np.array([obj for (sol, obj) in archive])\n        normalized = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-10)\n        potential = normalized.sum(axis=1)\n        probabilities = np.exp(-potential)  # Lower potential (better) solutions have higher probability\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of 2-opt and objective-aware swaps\n    n = len(new_solution)\n    if n <= 3:\n        # For small tours, just reverse the order\n        new_solution = new_solution[::-1]\n    else:\n        # Choose between 2-opt or objective-aware swap based on randomness\n        if random.random() < 0.5:\n            # 2-opt move: select two edges and reverse the segment between them\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Objective-aware swap: select two nodes and swap them if it improves at least one objective\n            i, j = random.sample(range(n), 2)\n            original_cost = (\n                distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_3[base_solution[i-1], base_solution[i]] + distance_matrix_3[base_solution[i], base_solution[(i+1)%n]] +\n                distance_matrix_1[base_solution[j-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n                distance_matrix_2[base_solution[j-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]] +\n                distance_matrix_3[base_solution[j-1], base_solution[j]] + distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n            )\n            swapped_cost = (\n                distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[(i+1)%n]] +\n                distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[(i+1)%n]] +\n                distance_matrix_3[base_solution[i-1], base_solution[j]] + distance_matrix_3[base_solution[j], base_solution[(i+1)%n]] +\n                distance_matrix_1[base_solution[j-1], base_solution[i]] + distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n                distance_matrix_2[base_solution[j-1], base_solution[i]] + distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] +\n                distance_matrix_3[base_solution[j-1], base_solution[i]] + distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n            )\n            if swapped_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        normalized_objectives.append(sum(normalized_obj))\n\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure valid TSP tour by reversing segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Objective-aware edge selection: prefer edges with lower combined distance\n    for _ in range(2):  # Perform two objective-aware swaps\n        # Find edges with the highest combined distance\n        max_dist_idx = -1\n        max_dist = -1\n        for idx in range(n):\n            node1 = new_solution[idx]\n            node2 = new_solution[(idx + 1) % n]\n            total_dist = (distance_matrix_1[node1, node2] +\n                          distance_matrix_2[node1, node2] +\n                          distance_matrix_3[node1, node2])\n            if total_dist > max_dist:\n                max_dist = total_dist\n                max_dist_idx = idx\n\n        if max_dist_idx != -1:\n            # Swap with a random edge to improve balance\n            swap_idx = np.random.choice(n)\n            new_solution[max_dist_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[max_dist_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6857043456212123,
            2.184230589866638
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / distance_matrix_1.max(), obj[1] / distance_matrix_2.max(), obj[2] / distance_matrix_3.max())\n        normalized_objectives.append(sum(normalized_obj))\n\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure valid TSP tour by reversing segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Objective-aware edge selection: prefer edges with lower combined distance\n    for _ in range(2):  # Perform two objective-aware swaps\n        # Find edges with the highest combined distance\n        max_dist_idx = -1\n        max_dist = -1\n        for idx in range(n):\n            node1 = new_solution[idx]\n            node2 = new_solution[(idx + 1) % n]\n            total_dist = (distance_matrix_1[node1, node2] +\n                          distance_matrix_2[node1, node2] +\n                          distance_matrix_3[node1, node2])\n            if total_dist > max_dist:\n                max_dist = total_dist\n                max_dist_idx = idx\n\n        if max_dist_idx != -1:\n            # Swap with a random edge to improve balance\n            swap_idx = np.random.choice(n)\n            new_solution[max_dist_idx], new_solution[swap_idx] = new_solution[swap_idx], new_solution[max_dist_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the range of each objective to identify solutions with diverse trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n\n    # Weight solutions based on their objective diversity\n    weights = np.sum(objectives / (obj_ranges + 1e-8), axis=1)\n    weights = weights / np.sum(weights)\n\n    # Select a solution with probability proportional to its weight\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with adaptive objective weighting\n    n = len(base_solution)\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Randomly select a segment to perturb\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    # Evaluate the current segment cost\n    current_cost = (\n        distance_matrix_1[base_solution[i-1], base_solution[i]] +\n        distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n        distance_matrix_2[base_solution[i-1], base_solution[i]] +\n        distance_matrix_2[base_solution[j], base_solution[(j+1)%n]] +\n        distance_matrix_3[base_solution[i-1], base_solution[i]] +\n        distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n    )\n\n    # Evaluate the reversed segment cost\n    reversed_cost = (\n        distance_matrix_1[base_solution[i-1], base_solution[j]] +\n        distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n        distance_matrix_2[base_solution[i-1], base_solution[j]] +\n        distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] +\n        distance_matrix_3[base_solution[i-1], base_solution[j]] +\n        distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n    )\n\n    # Calculate improvement\n    improvement = current_cost - reversed_cost\n\n    if improvement > 0:\n        # Apply 2-opt move\n        new_solution[i:j+1] = np.flip(base_solution[i:j+1])\n    else:\n        # Apply a random swap if no improvement\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7728366278228561,
            1.500989305973053
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the range of each objective to identify solutions with diverse trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    obj_ranges = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n\n    # Weight solutions based on their objective diversity\n    weights = np.sum(objectives / (obj_ranges + 1e-8), axis=1)\n    weights = weights / np.sum(weights)\n\n    # Select a solution with probability proportional to its weight\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with adaptive objective weighting\n    n = len(base_solution)\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Randomly select a segment to perturb\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n\n    # Evaluate the current segment cost\n    current_cost = (\n        distance_matrix_1[base_solution[i-1], base_solution[i]] +\n        distance_matrix_1[base_solution[j], base_solution[(j+1)%n]] +\n        distance_matrix_2[base_solution[i-1], base_solution[i]] +\n        distance_matrix_2[base_solution[j], base_solution[(j+1)%n]] +\n        distance_matrix_3[base_solution[i-1], base_solution[i]] +\n        distance_matrix_3[base_solution[j], base_solution[(j+1)%n]]\n    )\n\n    # Evaluate the reversed segment cost\n    reversed_cost = (\n        distance_matrix_1[base_solution[i-1], base_solution[j]] +\n        distance_matrix_1[base_solution[i], base_solution[(j+1)%n]] +\n        distance_matrix_2[base_solution[i-1], base_solution[j]] +\n        distance_matrix_2[base_solution[i], base_solution[(j+1)%n]] +\n        distance_matrix_3[base_solution[i-1], base_solution[j]] +\n        distance_matrix_3[base_solution[i], base_solution[(j+1)%n]]\n    )\n\n    # Calculate improvement\n    improvement = current_cost - reversed_cost\n\n    if improvement > 0:\n        # Apply 2-opt move\n        new_solution[i:j+1] = np.flip(base_solution[i:j+1])\n    else:\n        # Apply a random swap if no improvement\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the edges are non-overlapping and valid\n    while (i == k and j == l) or (i == l and j == k):\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Apply the 2-opt move\n    if i < j and k < l:\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the 2-opt move is invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.721872541676462,
            1.1777515530586242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    normalized_objectives = np.array(objectives) / np.max(np.array(objectives), axis=0)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the edges are non-overlapping and valid\n    while (i == k and j == l) or (i == l and j == k):\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Apply the 2-opt move\n    if i < j and k < l:\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the 2-opt move is invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the variance of objectives across the archive\n        objectives = np.array([obj for _, obj in archive])\n        obj_variances = np.var(objectives, axis=0)\n        # Select the solution with the highest variance in any objective\n        selected_idx = np.argmax(np.max(obj_variances))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    # Evaluate the current solution's total distance across all objectives\n    def total_distance(sol):\n        dist1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        dist2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        dist3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return dist1, dist2, dist3\n\n    current_dist = total_distance(new_solution)\n\n    # Perform a limited 2-opt search with objective-aware edge selection\n    for _ in range(min(10, n)):  # Limit iterations to prevent excessive computation\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n        # Evaluate the candidate\n        candidate_dist = total_distance(candidate)\n\n        # Calculate the improvement across all objectives\n        improvement = sum((current_dist[k] - candidate_dist[k]) for k in range(3))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_i, best_j = i, j\n\n    if best_i != -1:\n        new_solution[best_i:best_j+1] = new_solution[best_j:best_i-1 if best_i > 0 else None:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5493860248506306,
            3.5233298420906065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the variance of objectives across the archive\n        objectives = np.array([obj for _, obj in archive])\n        obj_variances = np.var(objectives, axis=0)\n        # Select the solution with the highest variance in any objective\n        selected_idx = np.argmax(np.max(obj_variances))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    # Evaluate the current solution's total distance across all objectives\n    def total_distance(sol):\n        dist1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        dist2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        dist3 = sum(distance_matrix_3[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return dist1, dist2, dist3\n\n    current_dist = total_distance(new_solution)\n\n    # Perform a limited 2-opt search with objective-aware edge selection\n    for _ in range(min(10, n)):  # Limit iterations to prevent excessive computation\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[j:i-1 if i > 0 else None:-1]\n\n        # Evaluate the candidate\n        candidate_dist = total_distance(candidate)\n\n        # Calculate the improvement across all objectives\n        improvement = sum((current_dist[k] - candidate_dist[k]) for k in range(3))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_i, best_j = i, j\n\n    if best_i != -1:\n        new_solution[best_i:best_j+1] = new_solution[best_j:best_i-1 if best_i > 0 else None:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Find edges with high potential for improvement in any of the three objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the change in total distance for each objective\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # If any objective improves, perform the 2-opt move\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6624412856692714,
            1.5976014137268066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Find edges with high potential for improvement in any of the three objectives\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the change in total distance for each objective\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] + distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] + distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # If any objective improves, perform the 2-opt move\n            if delta1 < 0 or delta2 < 0 or delta3 < 0:\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to perform a 3-opt move\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Reverse the middle segment to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objectives(solution, distance_matrix):\n        total = 0\n        for idx in range(len(solution)):\n            u = solution[idx]\n            v = solution[(idx + 1) % len(solution)]\n            total += distance_matrix[u, v]\n        return total\n\n    obj1 = calculate_objectives(new_solution, distance_matrix_1)\n    obj2 = calculate_objectives(new_solution, distance_matrix_2)\n    obj3 = calculate_objectives(new_solution, distance_matrix_3)\n\n    # If the new solution dominates the original or is better in at least one objective, keep it\n    if (obj1 <= archive[0][1][0] and obj2 <= archive[0][1][1] and obj3 <= archive[0][1][2]) and \\\n       (obj1 < archive[0][1][0] or obj2 < archive[0][1][1] or obj3 < archive[0][1][2]):\n        return new_solution\n    else:\n        return selected_solution\n\n",
        "score": [
            -0.6702980176116597,
            0.9133258938789368
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest objective values)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to perform a 3-opt move\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Reverse the middle segment to create a new tour\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the new solution's objectives\n    def calculate_objectives(solution, distance_matrix):\n        total = 0\n        for idx in range(len(solution)):\n            u = solution[idx]\n            v = solution[(idx + 1) % len(solution)]\n            total += distance_matrix[u, v]\n        return total\n\n    obj1 = calculate_objectives(new_solution, distance_matrix_1)\n    obj2 = calculate_objectives(new_solution, distance_matrix_2)\n    obj3 = calculate_objectives(new_solution, distance_matrix_3)\n\n    # If the new solution dominates the original or is better in at least one objective, keep it\n    if (obj1 <= archive[0][1][0] and obj2 <= archive[0][1][1] and obj3 <= archive[0][1][2]) and \\\n       (obj1 < archive[0][1][0] or obj2 < archive[0][1][1] or obj3 < archive[0][1][2]):\n        return new_solution\n    else:\n        return selected_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = [obj for (_, obj) in archive]\n\n    # Step 2: Perform a hybrid local search operator\n    # We combine 3-opt with a novel objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Determine the best edge reversal for the three selected edges\n    # We consider all possible reversals and select the one that improves the most objective\n    candidates = []\n\n    # Original segment costs\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[k]]\n    ]\n\n    # Generate all possible 3-opt neighbors\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a != b:\n                temp_solution = new_solution.copy()\n                temp_solution[a:b] = temp_solution[a:b][::-1]\n\n                # Calculate new costs\n                new_costs = [\n                    sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                    sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                    sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n                ]\n\n                # Calculate improvement in all objectives\n                improvement = sum(new_costs[m] < original_costs[m] for m in range(3))\n                candidates.append((temp_solution, improvement))\n\n    # Select the best candidate based on objective improvement\n    if candidates:\n        candidates.sort(key=lambda x: -x[1])\n        new_solution = candidates[0][0]\n\n    # Step 3: Ensure the solution is valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution generated\"\n    assert len(new_solution) == len(instance), \"Solution length mismatch\"\n\n    return new_solution\n\n",
        "score": [
            -0.8181156057747975,
            1.7480932831764222
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    objectives = [obj for (_, obj) in archive]\n\n    # Step 2: Perform a hybrid local search operator\n    # We combine 3-opt with a novel objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Determine the best edge reversal for the three selected edges\n    # We consider all possible reversals and select the one that improves the most objective\n    candidates = []\n\n    # Original segment costs\n    original_costs = [\n        distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]],\n        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]],\n        distance_matrix_3[new_solution[i-1], new_solution[i]] + distance_matrix_3[new_solution[j-1], new_solution[j]] + distance_matrix_3[new_solution[k-1], new_solution[k]]\n    ]\n\n    # Generate all possible 3-opt neighbors\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a != b:\n                temp_solution = new_solution.copy()\n                temp_solution[a:b] = temp_solution[a:b][::-1]\n\n                # Calculate new costs\n                new_costs = [\n                    sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]],\n                    sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]],\n                    sum(distance_matrix_3[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_3[temp_solution[-1], temp_solution[0]]\n                ]\n\n                # Calculate improvement in all objectives\n                improvement = sum(new_costs[m] < original_costs[m] for m in range(3))\n                candidates.append((temp_solution, improvement))\n\n    # Select the best candidate based on objective improvement\n    if candidates:\n        candidates.sort(key=lambda x: -x[1])\n        new_solution = candidates[0][0]\n\n    # Step 3: Ensure the solution is valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid solution generated\"\n    assert len(new_solution) == len(instance), \"Solution length mismatch\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    potential_scores = np.mean(normalized_objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge costs across all objectives\n    edge_costs = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_costs[i, j] = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                                    distance_matrix_2[new_solution[i], new_solution[j]] +\n                                    distance_matrix_3[new_solution[i], new_solution[j]]) / 3\n\n    # Find the worst edges to potentially improve\n    worst_edges = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        worst_edges.append((edge_costs[a, b], i, (i+1)%n))\n\n    worst_edges.sort(reverse=True, key=lambda x: x[0])\n    top_k = min(3, len(worst_edges))  # Consider top 3 worst edges\n\n    # Apply 2-opt on the worst edges\n    for _, i, j in worst_edges[:top_k]:\n        # Find the best possible swap\n        best_improvement = 0\n        best_swap = None\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n            # Calculate improvement for swap between i and k\n            a, b = new_solution[i], new_solution[k]\n            c, d = new_solution[(i+1)%n], new_solution[(k+1)%n]\n            improvement = (edge_costs[a, b] + edge_costs[c, d] -\n                           (edge_costs[a, c] + edge_costs[b, d]))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, k)\n\n        if best_swap:\n            i, k = best_swap\n            # Perform the swap\n            if i < k:\n                new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n            else:\n                new_solution[k+1:i+1] = new_solution[k+1:i+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6915350550303302,
            3.904309070110321
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    potential_scores = np.mean(normalized_objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge costs across all objectives\n    edge_costs = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_costs[i, j] = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                                    distance_matrix_2[new_solution[i], new_solution[j]] +\n                                    distance_matrix_3[new_solution[i], new_solution[j]]) / 3\n\n    # Find the worst edges to potentially improve\n    worst_edges = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        worst_edges.append((edge_costs[a, b], i, (i+1)%n))\n\n    worst_edges.sort(reverse=True, key=lambda x: x[0])\n    top_k = min(3, len(worst_edges))  # Consider top 3 worst edges\n\n    # Apply 2-opt on the worst edges\n    for _, i, j in worst_edges[:top_k]:\n        # Find the best possible swap\n        best_improvement = 0\n        best_swap = None\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n            # Calculate improvement for swap between i and k\n            a, b = new_solution[i], new_solution[k]\n            c, d = new_solution[(i+1)%n], new_solution[(k+1)%n]\n            improvement = (edge_costs[a, b] + edge_costs[c, d] -\n                           (edge_costs[a, c] + edge_costs[b, d]))\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (i, k)\n\n        if best_swap:\n            i, k = best_swap\n            # Perform the swap\n            if i < k:\n                new_solution[i+1:k+1] = new_solution[i+1:k+1][::-1]\n            else:\n                new_solution[k+1:i+1] = new_solution[k+1:i+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_costs = np.mean([obj for (sol, obj) in archive], axis=0)\n    candidates = [sol for (sol, obj) in archive if any(o > avg_costs[i] for i, o in enumerate(obj))]\n\n    if not candidates:\n        candidates = [sol for (sol, _) in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective edge evaluation\n    for _ in range(10):  # Perform multiple iterations\n        i, j = sorted(random.sample(range(1, n), 2))  # Ensure i < j\n\n        # Evaluate the current and potential edges in all three objectives\n        current_edges = [\n            (base_solution[i-1], base_solution[i]),\n            (base_solution[j-1], base_solution[j])\n        ]\n        new_edges = [\n            (base_solution[i-1], base_solution[j]),\n            (base_solution[i], base_solution[j-1])\n        ]\n\n        current_costs = [\n            sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] + distance_matrix_3[a][b] for a, b in current_edges),\n            sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] + distance_matrix_3[a][b] for a, b in new_edges)\n        ]\n\n        # Perform the swap if it improves any objective\n        if current_costs[1] < current_costs[0]:\n            new_solution[i:j] = base_solution[j-1:i-1:-1]\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7836935838773649,
            3.8045464038848875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    avg_costs = np.mean([obj for (sol, obj) in archive], axis=0)\n    candidates = [sol for (sol, obj) in archive if any(o > avg_costs[i] for i, o in enumerate(obj))]\n\n    if not candidates:\n        candidates = [sol for (sol, _) in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt with multi-objective edge evaluation\n    for _ in range(10):  # Perform multiple iterations\n        i, j = sorted(random.sample(range(1, n), 2))  # Ensure i < j\n\n        # Evaluate the current and potential edges in all three objectives\n        current_edges = [\n            (base_solution[i-1], base_solution[i]),\n            (base_solution[j-1], base_solution[j])\n        ]\n        new_edges = [\n            (base_solution[i-1], base_solution[j]),\n            (base_solution[i], base_solution[j-1])\n        ]\n\n        current_costs = [\n            sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] + distance_matrix_3[a][b] for a, b in current_edges),\n            sum(distance_matrix_1[a][b] + distance_matrix_2[a][b] + distance_matrix_3[a][b] for a, b in new_edges)\n        ]\n\n        # Perform the swap if it improves any objective\n        if current_costs[1] < current_costs[0]:\n            new_solution[i:j] = base_solution[j-1:i-1:-1]\n            base_solution = new_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    # Evaluate all possible 2-opt moves and select the one with the highest combined improvement\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Use a weighted sum of improvements to guide the search\n            improvement = - (delta1 + delta2 + delta3)  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the best 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7292780617157565,
            4.236443221569061
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    # Evaluate all possible 2-opt moves and select the one with the highest combined improvement\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the change in all three objectives\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Use a weighted sum of improvements to guide the search\n            improvement = - (delta1 + delta2 + delta3)  # Negative because we want to minimize\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the best 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Find edges with high potential for improvement across all objectives\n    best_gain = -float('inf')\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the gain in all three objectives\n            gain1 = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]])\n\n            gain2 = (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]])\n\n            gain3 = (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_3[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]])\n\n            total_gain = gain1 + gain2 + gain3\n\n            if total_gain > best_gain:\n                best_gain = total_gain\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Perform the 2-opt move if it improves at least one objective\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Additional: Apply a small perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6109305309869945,
            4.100384402275085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Find edges with high potential for improvement across all objectives\n    best_gain = -float('inf')\n    best_i, best_j = -1, -1\n\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the gain in all three objectives\n            gain1 = (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]])\n\n            gain2 = (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_2[new_solution[i], new_solution[j]] +\n                     distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]])\n\n            gain3 = (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]) - \\\n                    (distance_matrix_3[new_solution[i], new_solution[j]] +\n                     distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]])\n\n            total_gain = gain1 + gain2 + gain3\n\n            if total_gain > best_gain:\n                best_gain = total_gain\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Perform the 2-opt move if it improves at least one objective\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    # Additional: Apply a small perturbation to escape local optima\n    if np.random.rand() < 0.3:  # 30% chance\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{The heuristic function employs a multi-objective local search strategy that combines random solution selection with a novel hybrid operator, which intelligently selects segments of the tour to reverse or swap while considering the trade-offs across all three objectives to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Randomly select a solution, but prioritize those with lower objectives (assuming minimization)\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        obj_scores = np.sum(normalized_obj, axis=1)\n        probs = np.exp(-obj_scores) / np.sum(np.exp(-obj_scores))\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between segment reversal or swap\n    if np.random.rand() < 0.5:\n        # Segment reversal\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Swap two segments\n        start1 = np.random.randint(0, n - 1)\n        end1 = np.random.randint(start1 + 1, n)\n        start2 = np.random.randint(0, n - (end1 - start1))\n        end2 = start2 + (end1 - start1)\n        segment1 = new_solution[start1:end1+1]\n        segment2 = new_solution[start2:end2+1]\n        new_solution[start1:end1+1] = segment2\n        new_solution[start2:end2+1] = segment1\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the hybrid operator fails\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.662073517008426,
            0.99992436170578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Randomly select a solution, but prioritize those with lower objectives (assuming minimization)\n        objectives = np.array([obj for _, obj in archive])\n        min_obj = np.min(objectives, axis=0)\n        max_obj = np.max(objectives, axis=0)\n        normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        obj_scores = np.sum(normalized_obj, axis=1)\n        probs = np.exp(-obj_scores) / np.sum(np.exp(-obj_scores))\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between segment reversal or swap\n    if np.random.rand() < 0.5:\n        # Segment reversal\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n    else:\n        # Swap two segments\n        start1 = np.random.randint(0, n - 1)\n        end1 = np.random.randint(start1 + 1, n)\n        start2 = np.random.randint(0, n - (end1 - start1))\n        end2 = start2 + (end1 - start1)\n        segment1 = new_solution[start1:end1+1]\n        segment2 = new_solution[start2:end2+1]\n        new_solution[start1:end1+1] = segment2\n        new_solution[start2:end2+1] = segment1\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the hybrid operator fails\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{A heuristic function that intelligently selects a non-dominated solution from the archive, then applies a hybrid local search combining 2-opt swaps and objective-aware edge insertion to generate a neighbor solution, ensuring feasibility and potential multi-objective improvement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a \"diversity\" score based on objective values\n        diversity = sum(obj) / len(obj)\n        candidates.append((sol, diversity))\n\n    # Sort by diversity (higher diversity first) and select top 3 candidates\n    candidates.sort(key=lambda x: -x[1])\n    selected_sol = random.choice(candidates[:min(3, len(candidates))])[0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the worst objective\n    objectives = [np.sum([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n                  np.sum([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n                  np.sum([distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])]\n\n    worst_obj = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj]\n\n    # Find the worst edge in the worst objective\n    max_edge_cost = -1\n    i_max, j_max = -1, -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        cost = distance_matrix[u, v]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            i_max, j_max = i, (i+1)%n\n\n    if i_max != -1:\n        # Try to replace the worst edge with a better one\n        u = new_solution[i_max]\n        v = new_solution[j_max]\n\n        # Find the best possible replacement edge\n        min_cost = float('inf')\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(n):\n                if i != j and (i != i_max or j != j_max):\n                    cost = distance_matrix[new_solution[i], new_solution[j]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            # Perform the swap\n            new_solution[i_max] = new_solution[best_i]\n            new_solution[j_max] = new_solution[best_j]\n\n    return new_solution\n\n",
        "score": [
            -0.6620921514466714,
            0.8895568490028382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for sol, obj in archive:\n        # Calculate a \"diversity\" score based on objective values\n        diversity = sum(obj) / len(obj)\n        candidates.append((sol, diversity))\n\n    # Sort by diversity (higher diversity first) and select top 3 candidates\n    candidates.sort(key=lambda x: -x[1])\n    selected_sol = random.choice(candidates[:min(3, len(candidates))])[0].copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the worst objective\n    objectives = [np.sum([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n                  np.sum([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]),\n                  np.sum([distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])]\n\n    worst_obj = np.argmax(objectives)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][worst_obj]\n\n    # Find the worst edge in the worst objective\n    max_edge_cost = -1\n    i_max, j_max = -1, -1\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i+1)%n]\n        cost = distance_matrix[u, v]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            i_max, j_max = i, (i+1)%n\n\n    if i_max != -1:\n        # Try to replace the worst edge with a better one\n        u = new_solution[i_max]\n        v = new_solution[j_max]\n\n        # Find the best possible replacement edge\n        min_cost = float('inf')\n        best_i, best_j = -1, -1\n        for i in range(n):\n            for j in range(n):\n                if i != j and (i != i_max or j != j_max):\n                    cost = distance_matrix[new_solution[i], new_solution[j]]\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_i, best_j = i, j\n\n        if best_i != -1 and best_j != -1:\n            # Perform the swap\n            new_solution[i_max] = new_solution[best_i]\n            new_solution[j_max] = new_solution[best_j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives to identify solutions with the highest potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = normalized_objectives.sum(axis=1)\n    selected_index = np.argmax(potential_scores)\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: 2-opt with edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge insertion to further improve the solution\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Generated solution is not valid.\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution contains duplicates.\"\n\n    return new_solution\n\n",
        "score": [
            -0.67170707724545,
            1.5955502390861511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Normalize objectives to identify solutions with the highest potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = normalized_objectives.sum(axis=1)\n    selected_index = np.argmax(potential_scores)\n    base_solution = archive[selected_index][0].copy()\n\n    # Hybrid local search: 2-opt with edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge insertion to further improve the solution\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution), \"Generated solution is not valid.\"\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution contains duplicates.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective focus\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select segments to improve\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swaps in segments to improve multiple objectives\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Evaluate the impact on all three objectives\n    def evaluate_swap(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    # Try reversing segments and keep the best improvement\n    temp_sol = new_solution.copy()\n    temp_sol[i:j] = segment1[::-1]\n    temp_sol[k:l] = segment2[::-1]\n\n    if evaluate_swap(temp_sol) < evaluate_swap(new_solution):\n        new_solution = temp_sol\n\n    # Path relinking: blend with another solution from the archive\n    if len(archive) > 1:\n        other_solution = random.choice(archive)[0].copy()\n        crossover_point = random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n    # Ensure the solution is valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fix by reinserting missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.6266423957037327,
            0.6967532992362976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective focus\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select segments to improve\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swaps in segments to improve multiple objectives\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Evaluate the impact on all three objectives\n    def evaluate_swap(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost3 = sum(distance_matrix_3[sol[i], sol[(i+1)%n]] for i in range(n))\n        return (cost1, cost2, cost3)\n\n    # Try reversing segments and keep the best improvement\n    temp_sol = new_solution.copy()\n    temp_sol[i:j] = segment1[::-1]\n    temp_sol[k:l] = segment2[::-1]\n\n    if evaluate_swap(temp_sol) < evaluate_swap(new_solution):\n        new_solution = temp_sol\n\n    # Path relinking: blend with another solution from the archive\n    if len(archive) > 1:\n        other_solution = random.choice(archive)[0].copy()\n        crossover_point = random.randint(1, n-1)\n        new_solution[crossover_point:] = other_solution[crossover_point:]\n\n    # Ensure the solution is valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fix by reinserting missing nodes\n        missing_nodes = [node for node in range(n) if node not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] not in unique_nodes:\n                new_solution[i] = missing_nodes.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / max(distance_matrix_1.max(), 1e-6),\n                          obj[1] / max(distance_matrix_2.max(), 1e-6),\n                          obj[2] / max(distance_matrix_3.max(), 1e-6))\n        normalized_objectives.append((sol, normalized_obj))\n\n    # Sort by sum of normalized objectives (descending)\n    normalized_objectives.sort(key=lambda x: -(x[1][0] + x[1][1] + x[1][2]))\n    base_solution = normalized_objectives[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high contribution to objectives\n    edge_contributions = []\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i + 1) % n]\n        contrib = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n        edge_contributions.append(contrib)\n\n    # Select two edges to swap (2-opt)\n    sorted_edges = sorted(range(n), key=lambda x: -edge_contributions[x])\n    i, j = sorted_edges[0], sorted_edges[1]\n\n    # Perform 2-opt swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.576094545371141,
            3.3840713620185854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, obj in archive:\n        normalized_obj = (obj[0] / max(distance_matrix_1.max(), 1e-6),\n                          obj[1] / max(distance_matrix_2.max(), 1e-6),\n                          obj[2] / max(distance_matrix_3.max(), 1e-6))\n        normalized_objectives.append((sol, normalized_obj))\n\n    # Sort by sum of normalized objectives (descending)\n    normalized_objectives.sort(key=lambda x: -(x[1][0] + x[1][1] + x[1][2]))\n    base_solution = normalized_objectives[0][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify edges with high contribution to objectives\n    edge_contributions = []\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i + 1) % n]\n        contrib = (distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]) / 3\n        edge_contributions.append(contrib)\n\n    # Select two edges to swap (2-opt)\n    sorted_edges = sorted(range(n), key=lambda x: -edge_contributions[x])\n    i, j = sorted_edges[0], sorted_edges[1]\n\n    # Perform 2-opt swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7363969841593813,
            1.2727041363716125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware node selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two edges to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Perform the swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{A novel hybrid local search strategy is designed by intelligently selecting a solution from the archive based on objective diversity and applying a multi-objective 2-opt move that optimizes across all three objectives simultaneously, while ensuring feasibility by dynamically adjusting the move based on the trade-off between objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a multi-objective 2-opt move\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate the move across all three objectives\n    def evaluate_move(sol):\n        total_cost = 0.0\n        for k in range(n):\n            u = sol[k]\n            v = sol[(k + 1) % n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        return total_cost\n\n    current_cost = evaluate_move(base_solution)\n    candidate_solution = new_solution.copy()\n    candidate_solution[i:j+1] = candidate_solution[i:j+1][::-1]\n    candidate_cost = evaluate_move(candidate_solution)\n\n    # Accept the move if it improves the total cost across all objectives\n    if candidate_cost < current_cost:\n        new_solution = candidate_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7611082271639111,
            1.3113532543182373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest diversity in objectives (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a multi-objective 2-opt move\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Evaluate the move across all three objectives\n    def evaluate_move(sol):\n        total_cost = 0.0\n        for k in range(n):\n            u = sol[k]\n            v = sol[(k + 1) % n]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v] + distance_matrix_3[u, v]\n        return total_cost\n\n    current_cost = evaluate_move(base_solution)\n    candidate_solution = new_solution.copy()\n    candidate_solution[i:j+1] = candidate_solution[i:j+1][::-1]\n    candidate_cost = evaluate_move(candidate_solution)\n\n    # Accept the move if it improves the total cost across all objectives\n    if candidate_cost < current_cost:\n        new_solution = candidate_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    obj_vars = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(obj_vars)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a novel 3-objective-aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-objective-aware swap: choose nodes based on their impact on all three objectives\n    # Calculate the change in each objective if we swap two nodes\n    def objective_change(a, b):\n        # Current edges: (a-1, a), (a, a+1), (b-1, b), (b, b+1)\n        # New edges: (a-1, b), (b, a+1), (b-1, a), (a, b+1)\n        a_prev = new_solution[a-1] if a > 0 else new_solution[-1]\n        a_next = new_solution[(a+1)%n]\n        b_prev = new_solution[b-1] if b > 0 else new_solution[-1]\n        b_next = new_solution[(b+1)%n]\n\n        # Calculate changes in each objective\n        change1 = (distance_matrix_1[a_prev, b] + distance_matrix_1[b, a_next] +\n                  distance_matrix_1[b_prev, a] + distance_matrix_1[a, b_next] -\n                  distance_matrix_1[a_prev, a] - distance_matrix_1[a, a_next] -\n                  distance_matrix_1[b_prev, b] - distance_matrix_1[b, b_next])\n\n        change2 = (distance_matrix_2[a_prev, b] + distance_matrix_2[b, a_next] +\n                  distance_matrix_2[b_prev, a] + distance_matrix_2[a, b_next] -\n                  distance_matrix_2[a_prev, a] - distance_matrix_2[a, a_next] -\n                  distance_matrix_2[b_prev, b] - distance_matrix_2[b, b_next])\n\n        change3 = (distance_matrix_3[a_prev, b] + distance_matrix_3[b, a_next] +\n                  distance_matrix_3[b_prev, a] + distance_matrix_3[a, b_next] -\n                  distance_matrix_3[a_prev, a] - distance_matrix_3[a, a_next] -\n                  distance_matrix_3[b_prev, b] - distance_matrix_3[b, b_next])\n\n        return (change1, change2, change3)\n\n    # Find a pair of nodes that improves at least one objective\n    improved = False\n    for _ in range(10):  # Try a few random swaps\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        change1, change2, change3 = objective_change(a, b)\n\n        # Accept if it improves at least one objective\n        if change1 < 0 or change2 < 0 or change3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement found, perform a random 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n\n    return new_solution\n\n",
        "score": [
            -0.45451711442618087,
            4.044345211982727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    obj_vars = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(obj_vars)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a novel 3-objective-aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a 3-objective-aware swap: choose nodes based on their impact on all three objectives\n    # Calculate the change in each objective if we swap two nodes\n    def objective_change(a, b):\n        # Current edges: (a-1, a), (a, a+1), (b-1, b), (b, b+1)\n        # New edges: (a-1, b), (b, a+1), (b-1, a), (a, b+1)\n        a_prev = new_solution[a-1] if a > 0 else new_solution[-1]\n        a_next = new_solution[(a+1)%n]\n        b_prev = new_solution[b-1] if b > 0 else new_solution[-1]\n        b_next = new_solution[(b+1)%n]\n\n        # Calculate changes in each objective\n        change1 = (distance_matrix_1[a_prev, b] + distance_matrix_1[b, a_next] +\n                  distance_matrix_1[b_prev, a] + distance_matrix_1[a, b_next] -\n                  distance_matrix_1[a_prev, a] - distance_matrix_1[a, a_next] -\n                  distance_matrix_1[b_prev, b] - distance_matrix_1[b, b_next])\n\n        change2 = (distance_matrix_2[a_prev, b] + distance_matrix_2[b, a_next] +\n                  distance_matrix_2[b_prev, a] + distance_matrix_2[a, b_next] -\n                  distance_matrix_2[a_prev, a] - distance_matrix_2[a, a_next] -\n                  distance_matrix_2[b_prev, b] - distance_matrix_2[b, b_next])\n\n        change3 = (distance_matrix_3[a_prev, b] + distance_matrix_3[b, a_next] +\n                  distance_matrix_3[b_prev, a] + distance_matrix_3[a, b_next] -\n                  distance_matrix_3[a_prev, a] - distance_matrix_3[a, a_next] -\n                  distance_matrix_3[b_prev, b] - distance_matrix_3[b, b_next])\n\n        return (change1, change2, change3)\n\n    # Find a pair of nodes that improves at least one objective\n    improved = False\n    for _ in range(10):  # Try a few random swaps\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        change1, change2, change3 = objective_change(a, b)\n\n        # Accept if it improves at least one objective\n        if change1 < 0 or change2 < 0 or change3 < 0:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement found, perform a random 3-opt move\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = np.concatenate([segment[:k-i], segment[k-i:][::-1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reconnect edges in a way that improves at least one objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    # Current cost of edges being broken\n    cost_i_j = edge_cost(new_solution[i], new_solution[j])\n    cost_k_l = edge_cost(new_solution[k], new_solution[l])\n\n    # Proposed new edges\n    new_edges = [(new_solution[i], new_solution[k]), (new_solution[j], new_solution[l])]\n    new_costs = [edge_cost(a, b) for a, b in new_edges]\n\n    # Check if the new edges improve at least one objective\n    improved = False\n    for m in range(3):\n        if (new_costs[0][m] + new_costs[1][m]) < (cost_i_j[m] + cost_k_l[m]):\n            improved = True\n            break\n\n    if improved:\n        # Perform the swap if it improves at least one objective\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.5901073180887684,
            1.3741928100585938
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reconnect edges in a way that improves at least one objective\n    def edge_cost(a, b):\n        return (distance_matrix_1[a, b], distance_matrix_2[a, b], distance_matrix_3[a, b])\n\n    # Current cost of edges being broken\n    cost_i_j = edge_cost(new_solution[i], new_solution[j])\n    cost_k_l = edge_cost(new_solution[k], new_solution[l])\n\n    # Proposed new edges\n    new_edges = [(new_solution[i], new_solution[k]), (new_solution[j], new_solution[l])]\n    new_costs = [edge_cost(a, b) for a, b in new_edges]\n\n    # Check if the new edges improve at least one objective\n    improved = False\n    for m in range(3):\n        if (new_costs[0][m] + new_costs[1][m]) < (cost_i_j[m] + cost_k_l[m]):\n            improved = True\n            break\n\n    if improved:\n        # Perform the swap if it improves at least one objective\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n        new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 3-opt + node swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly swap two nodes to diversify the search\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7535559346289,
            0.9291270494461059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Perform a hybrid local search: 3-opt + node swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Randomly swap two nodes to diversify the search\n    a, b = random.sample(range(n), 2)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest total distance in any objective)\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]))\n\n    # Perform a hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: randomly select one of the three objectives and apply a small perturbation\n    obj_to_perturb = random.randint(0, 2)\n    if obj_to_perturb == 0:\n        # Perturb in the first objective space\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    elif obj_to_perturb == 1:\n        # Perturb in the second objective space\n        m, n = sorted(random.sample(range(n), 2))\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n    else:\n        # Perturb in the third objective space\n        p, q = sorted(random.sample(range(n), 2))\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.5416367802350759,
            0.9766262888908386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with the highest total distance in any objective)\n    selected_solution, _ = max(archive, key=lambda x: max(x[1]))\n\n    # Perform a hybrid local search: combine 2-opt with a multi-objective aware perturbation\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to swap (2-opt move)\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective perturbation: randomly select one of the three objectives and apply a small perturbation\n    obj_to_perturb = random.randint(0, 2)\n    if obj_to_perturb == 0:\n        # Perturb in the first objective space\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n    elif obj_to_perturb == 1:\n        # Perturb in the second objective space\n        m, n = sorted(random.sample(range(n), 2))\n        new_solution[m], new_solution[n] = new_solution[n], new_solution[m]\n    else:\n        # Perturb in the third objective space\n        p, q = sorted(random.sample(range(n), 2))\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: edge swap + segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions to swap edges\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to reverse\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.5783856433479897,
            0.9942438483238221
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n\n    # Hybrid local search operator: edge swap + segment reversal\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions to swap edges\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Randomly select a segment to reverse\n    k, l = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Revert if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: choose a segment to swap based on worst objective\n    objectives = []\n    for i in range(n-1):\n        obj1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        obj2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        obj3 = distance_matrix_3[new_solution[i], new_solution[i+1]]\n        objectives.append((obj1, obj2, obj3))\n\n    worst_obj = max(objectives, key=lambda x: sum(x))\n    worst_idx = objectives.index(worst_obj)\n\n    # Swap nodes to improve the worst objective\n    if worst_idx + 1 < n:\n        new_solution[worst_idx], new_solution[worst_idx+1] = new_solution[worst_idx+1], new_solution[worst_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6673679339249391,
            1.49331533908844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Hybrid local search strategy: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: choose a segment to swap based on worst objective\n    objectives = []\n    for i in range(n-1):\n        obj1 = distance_matrix_1[new_solution[i], new_solution[i+1]]\n        obj2 = distance_matrix_2[new_solution[i], new_solution[i+1]]\n        obj3 = distance_matrix_3[new_solution[i], new_solution[i+1]]\n        objectives.append((obj1, obj2, obj3))\n\n    worst_obj = max(objectives, key=lambda x: sum(x))\n    worst_idx = objectives.index(worst_obj)\n\n    # Swap nodes to improve the worst objective\n    if worst_idx + 1 < n:\n        new_solution[worst_idx], new_solution[worst_idx+1] = new_solution[worst_idx+1], new_solution[worst_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Evaluate edges based on their contribution to all three objectives\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Calculate the change in all three objectives for the 2-opt move\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Use a weighted sum of improvements to select the best move\n            improvement = delta1 + delta2 + delta3\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement < 0:\n        # Reverse the segment between best_i+1 and best_j\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6525492564521116,
            4.329511082172393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Evaluate edges based on their contribution to all three objectives\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            # Calculate the change in all three objectives for the 2-opt move\n            delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                      distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                      distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            delta3 = (distance_matrix_3[new_solution[i], new_solution[j]] +\n                      distance_matrix_3[new_solution[i+1], new_solution[(j+1)%n]]) - \\\n                     (distance_matrix_3[new_solution[i], new_solution[i+1]] +\n                      distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n            # Use a weighted sum of improvements to select the best move\n            improvement = delta1 + delta2 + delta3\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_improvement < 0:\n        # Reverse the segment between best_i+1 and best_j\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for each objective\n        crowding_distances = []\n        for i in range(3):\n            objectives = np.array([obj[i] for _, obj in archive])\n            sorted_indices = np.argsort(objectives)\n            sorted_objectives = objectives[sorted_indices]\n\n            # Calculate crowding distance\n            crowding = np.zeros(len(archive))\n            crowding[0] = np.inf\n            crowding[-1] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_indices[j]] = sorted_objectives[j+1] - sorted_objectives[j-1]\n\n            crowding_distances.append(crowding)\n\n        # Combine crowding distances (average)\n        combined_crowding = np.mean(crowding_distances, axis=0)\n        # Select the solution with highest crowding distance\n        selected_index = np.argmax(combined_crowding)\n    else:\n        selected_index = 0\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: alternating edge swaps across objectives\n    n = len(base_solution)\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct edges to swap\n        i1, i2 = np.random.choice(n, size=2, replace=False)\n        j1, j2 = np.random.choice(n, size=2, replace=False)\n\n        # Ensure we're not swapping the same edges\n        if i1 == j1 or i2 == j2:\n            continue\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[i1], candidate[j1] = candidate[j1], candidate[i1]\n        candidate[i2], candidate[j2] = candidate[j2], candidate[i2]\n\n        # Calculate the change in each objective\n        delta1 = (distance_matrix_1[new_solution[i1-1], new_solution[j1]] +\n                  distance_matrix_1[new_solution[j1], new_solution[i1]] -\n                  distance_matrix_1[new_solution[i1-1], new_solution[i1]] -\n                  distance_matrix_1[new_solution[j1-1], new_solution[j1]])\n\n        delta2 = (distance_matrix_2[new_solution[i1-1], new_solution[j1]] +\n                  distance_matrix_2[new_solution[j1], new_solution[i1]] -\n                  distance_matrix_2[new_solution[i1-1], new_solution[i1]] -\n                  distance_matrix_2[new_solution[j1-1], new_solution[j1]])\n\n        delta3 = (distance_matrix_3[new_solution[i1-1], new_solution[j1]] +\n                  distance_matrix_3[new_solution[j1], new_solution[i1]] -\n                  distance_matrix_3[new_solution[i1-1], new_solution[i1]] -\n                  distance_matrix_3[new_solution[j1-1], new_solution[j1]])\n\n        # Accept if improvement in at least one objective\n        if (delta1 < 0) or (delta2 < 0) or (delta3 < 0):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7097762582093587,
            2.0272788643836974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances for each objective\n        crowding_distances = []\n        for i in range(3):\n            objectives = np.array([obj[i] for _, obj in archive])\n            sorted_indices = np.argsort(objectives)\n            sorted_objectives = objectives[sorted_indices]\n\n            # Calculate crowding distance\n            crowding = np.zeros(len(archive))\n            crowding[0] = np.inf\n            crowding[-1] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_indices[j]] = sorted_objectives[j+1] - sorted_objectives[j-1]\n\n            crowding_distances.append(crowding)\n\n        # Combine crowding distances (average)\n        combined_crowding = np.mean(crowding_distances, axis=0)\n        # Select the solution with highest crowding distance\n        selected_index = np.argmax(combined_crowding)\n    else:\n        selected_index = 0\n\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: alternating edge swaps across objectives\n    n = len(base_solution)\n    obj_weights = np.array([1.0, 1.0, 1.0])  # Equal weights for all objectives\n\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct edges to swap\n        i1, i2 = np.random.choice(n, size=2, replace=False)\n        j1, j2 = np.random.choice(n, size=2, replace=False)\n\n        # Ensure we're not swapping the same edges\n        if i1 == j1 or i2 == j2:\n            continue\n\n        # Create a candidate solution\n        candidate = new_solution.copy()\n        candidate[i1], candidate[j1] = candidate[j1], candidate[i1]\n        candidate[i2], candidate[j2] = candidate[j2], candidate[i2]\n\n        # Calculate the change in each objective\n        delta1 = (distance_matrix_1[new_solution[i1-1], new_solution[j1]] +\n                  distance_matrix_1[new_solution[j1], new_solution[i1]] -\n                  distance_matrix_1[new_solution[i1-1], new_solution[i1]] -\n                  distance_matrix_1[new_solution[j1-1], new_solution[j1]])\n\n        delta2 = (distance_matrix_2[new_solution[i1-1], new_solution[j1]] +\n                  distance_matrix_2[new_solution[j1], new_solution[i1]] -\n                  distance_matrix_2[new_solution[i1-1], new_solution[i1]] -\n                  distance_matrix_2[new_solution[j1-1], new_solution[j1]])\n\n        delta3 = (distance_matrix_3[new_solution[i1-1], new_solution[j1]] +\n                  distance_matrix_3[new_solution[j1], new_solution[i1]] -\n                  distance_matrix_3[new_solution[i1-1], new_solution[i1]] -\n                  distance_matrix_3[new_solution[j1-1], new_solution[j1]])\n\n        # Accept if improvement in at least one objective\n        if (delta1 < 0) or (delta2 < 0) or (delta3 < 0):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates (though unlikely with random swap)\n    if len(np.unique(new_solution)) != n:\n        # If duplicate exists, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6936617970544873,
            0.8368643283843994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates (though unlikely with random swap)\n    if len(np.unique(new_solution)) != n:\n        # If duplicate exists, revert to original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid 2-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate edge costs in all three objectives\n        cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < cost1) or (new_cost2 < cost2) or (new_cost3 < cost3):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6708438966607224,
            1.3210575103759765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid 2-opt local search with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate edge costs in all three objectives\n        cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        cost3 = (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                 distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n        new_cost3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_3[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < cost1) or (new_cost2 < cost2) or (new_cost3 < cost3):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance\n    obj_idx = np.argmax(objective_variance)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_idx]\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are distant in the other two objectives\n    other_obj_indices = [k for k in range(3) if k != obj_idx]\n    for obj_idx_2 in other_obj_indices:\n        distance_matrix_2 = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_idx_2]\n        # Find the worst edge in this objective\n        worst_edge = -1\n        max_dist = -1\n        for k in range(n):\n            node_a = new_solution[k]\n            node_b = new_solution[(k+1)%n]\n            dist = distance_matrix_2[node_a, node_b]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = k\n        # Swap with a random node that improves the other objective\n        if worst_edge != -1:\n            candidate = random.randint(0, n-1)\n            if candidate != worst_edge and candidate != (worst_edge+1)%n:\n                # Try swapping the worst edge with a random segment\n                new_solution[worst_edge], new_solution[candidate] = new_solution[candidate], new_solution[worst_edge]\n\n    return new_solution\n\n",
        "score": [
            -0.6169395453921243,
            1.5275187611579895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on the objective with the highest variance\n    obj_idx = np.argmax(objective_variance)\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_idx]\n\n    # Randomly select two edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Objective-aware swap: swap nodes that are distant in the other two objectives\n    other_obj_indices = [k for k in range(3) if k != obj_idx]\n    for obj_idx_2 in other_obj_indices:\n        distance_matrix_2 = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_idx_2]\n        # Find the worst edge in this objective\n        worst_edge = -1\n        max_dist = -1\n        for k in range(n):\n            node_a = new_solution[k]\n            node_b = new_solution[(k+1)%n]\n            dist = distance_matrix_2[node_a, node_b]\n            if dist > max_dist:\n                max_dist = dist\n                worst_edge = k\n        # Swap with a random node that improves the other objective\n        if worst_edge != -1:\n            candidate = random.randint(0, n-1)\n            if candidate != worst_edge and candidate != (worst_edge+1)%n:\n                # Try swapping the worst edge with a random segment\n                new_solution[worst_edge], new_solution[candidate] = new_solution[candidate], new_solution[worst_edge]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This algorithm selects a promising solution from the archive based on the diversity of its objectives, then applies a hybrid local search that combines 2-opt with a novel 3-objective-aware edge insertion heuristic to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # 2-opt move\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Check feasibility and improvement\n        if len(np.unique(candidate)) == n:\n            # Calculate new objectives\n            obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if at least one objective improves\n            old_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (obj1 < old_obj1) or (obj2 < old_obj2) or (obj3 < old_obj3):\n                new_solution = candidate\n\n        # 3-objective aware edge insertion\n        if np.random.rand() < 0.3:  # 30% chance for this operation\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n\n            candidate = new_solution.copy()\n            candidate[k:l] = candidate[k:l][::-1]\n\n            # Check feasibility\n            if len(np.unique(candidate)) == n:\n                # Calculate new objectives\n                obj1 = sum(distance_matrix_1[candidate[m], candidate[(m+1)%n]] for m in range(n))\n                obj2 = sum(distance_matrix_2[candidate[m], candidate[(m+1)%n]] for m in range(n))\n                obj3 = sum(distance_matrix_3[candidate[m], candidate[(m+1)%n]] for m in range(n))\n\n                # Accept if at least one objective improves\n                old_obj1 = sum(distance_matrix_1[new_solution[m], new_solution[(m+1)%n]] for m in range(n))\n                old_obj2 = sum(distance_matrix_2[new_solution[m], new_solution[(m+1)%n]] for m in range(n))\n                old_obj3 = sum(distance_matrix_3[new_solution[m], new_solution[(m+1)%n]] for m in range(n))\n\n                if (obj1 < old_obj1) or (obj2 < old_obj2) or (obj3 < old_obj3):\n                    new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7026994278080814,
            4.320848762989044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    diversity_scores = []\n    for sol, obj in archive:\n        diversity = (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(base_solution)\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # 2-opt move\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]\n\n        # Check feasibility and improvement\n        if len(np.unique(candidate)) == n:\n            # Calculate new objectives\n            obj1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            obj2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            obj3 = sum(distance_matrix_3[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Accept if at least one objective improves\n            old_obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            old_obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            if (obj1 < old_obj1) or (obj2 < old_obj2) or (obj3 < old_obj3):\n                new_solution = candidate\n\n        # 3-objective aware edge insertion\n        if np.random.rand() < 0.3:  # 30% chance for this operation\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n\n            candidate = new_solution.copy()\n            candidate[k:l] = candidate[k:l][::-1]\n\n            # Check feasibility\n            if len(np.unique(candidate)) == n:\n                # Calculate new objectives\n                obj1 = sum(distance_matrix_1[candidate[m], candidate[(m+1)%n]] for m in range(n))\n                obj2 = sum(distance_matrix_2[candidate[m], candidate[(m+1)%n]] for m in range(n))\n                obj3 = sum(distance_matrix_3[candidate[m], candidate[(m+1)%n]] for m in range(n))\n\n                # Accept if at least one objective improves\n                old_obj1 = sum(distance_matrix_1[new_solution[m], new_solution[(m+1)%n]] for m in range(n))\n                old_obj2 = sum(distance_matrix_2[new_solution[m], new_solution[(m+1)%n]] for m in range(n))\n                old_obj3 = sum(distance_matrix_3[new_solution[m], new_solution[(m+1)%n]] for m in range(n))\n\n                if (obj1 < old_obj1) or (obj2 < old_obj2) or (obj3 < old_obj3):\n                    new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt + 3-opt with objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt on the segment\n    if len(segment) > 1:\n        segment = np.flip(segment)\n\n    # Apply 3-opt on the segment if it has enough nodes\n    if len(segment) >= 3:\n        k = np.random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[:k], segment[k:][::-1]])\n\n    # Reinsert the perturbed segment\n    new_solution[i:j+1] = segment\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if not (np.array_equal(np.sort(new_solution), np.sort(base_solution)) and len(np.unique(new_solution)) == n):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7113371763357101,
            1.2947088360786438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt + 3-opt with objective-aware perturbations\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt on the segment\n    if len(segment) > 1:\n        segment = np.flip(segment)\n\n    # Apply 3-opt on the segment if it has enough nodes\n    if len(segment) >= 3:\n        k = np.random.randint(1, len(segment)-1)\n        segment = np.concatenate([segment[:k], segment[k:][::-1]])\n\n    # Reinsert the perturbed segment\n    new_solution[i:j+1] = segment\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    if not (np.array_equal(np.sort(new_solution), np.sort(base_solution)) and len(np.unique(new_solution)) == n):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(base_solution)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Evaluate all possible 3-opt moves across objectives\n    candidates = []\n    for a, b, c in [(i, j, k), (i, k, j)]:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n        candidate[b:c] = candidate[b:c][::-1]\n\n        # Compute objective values\n        obj1 = sum(distance_matrix_1[candidate[i], candidate[i-1]] for i in range(n))\n        obj2 = sum(distance_matrix_2[candidate[i], candidate[i-1]] for i in range(n))\n        obj3 = sum(distance_matrix_3[candidate[i], candidate[i-1]] for i in range(n))\n\n        candidates.append((obj1 + obj2 + obj3, candidate))\n\n    # Select the candidate with best combined objective improvement\n    best_improvement, best_solution = min(candidates, key=lambda x: x[0])\n\n    return best_solution\n\n",
        "score": [
            -0.6858195372222777,
            1.2822023987770081
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    n = len(base_solution)\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Evaluate all possible 3-opt moves across objectives\n    candidates = []\n    for a, b, c in [(i, j, k), (i, k, j)]:\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n        candidate[b:c] = candidate[b:c][::-1]\n\n        # Compute objective values\n        obj1 = sum(distance_matrix_1[candidate[i], candidate[i-1]] for i in range(n))\n        obj2 = sum(distance_matrix_2[candidate[i], candidate[i-1]] for i in range(n))\n        obj3 = sum(distance_matrix_3[candidate[i], candidate[i-1]] for i in range(n))\n\n        candidates.append((obj1 + obj2 + obj3, candidate))\n\n    # Select the candidate with best combined objective improvement\n    best_improvement, best_solution = min(candidates, key=lambda x: x[0])\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (2-opt)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the solution's objectives\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Perform a multi-objective aware swap to improve the worst objective\n    worst_obj = np.argmax([obj1, obj2, obj3])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate the change in the worst objective\n            old_dist = dist_matrix[new_solution[a-1], new_solution[a]] + dist_matrix[new_solution[b-1], new_solution[b]]\n            new_dist = dist_matrix[new_solution[a-1], new_solution[b]] + dist_matrix[new_solution[b-1], new_solution[a]]\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6130228044133318,
            2.6797725677490236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: combine 2-opt with a multi-objective aware swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (2-opt)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Evaluate the solution's objectives\n    obj1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    obj3 = sum(distance_matrix_3[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n    # Perform a multi-objective aware swap to improve the worst objective\n    worst_obj = np.argmax([obj1, obj2, obj3])\n    if worst_obj == 0:\n        dist_matrix = distance_matrix_1\n    elif worst_obj == 1:\n        dist_matrix = distance_matrix_2\n    else:\n        dist_matrix = distance_matrix_3\n\n    # Find the best swap to improve the worst objective\n    best_improvement = 0\n    best_swap = None\n    for a in range(n):\n        for b in range(a+1, n):\n            # Calculate the change in the worst objective\n            old_dist = dist_matrix[new_solution[a-1], new_solution[a]] + dist_matrix[new_solution[b-1], new_solution[b]]\n            new_dist = dist_matrix[new_solution[a-1], new_solution[b]] + dist_matrix[new_solution[b-1], new_solution[a]]\n            improvement = old_dist - new_dist\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_swap = (a, b)\n\n    if best_swap:\n        a, b = best_swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]) / 3)[0]\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt for two objectives and insertion for the third\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two distinct segments for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        # Apply 2-opt to the first two objectives\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply insertion for the third objective\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6523852254286401,
            1.3161072731018066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]) / 3)[0]\n    new_solution = best_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt for two objectives and insertion for the third\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Randomly select two distinct segments for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        # Apply 2-opt to the first two objectives\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Apply insertion for the third objective\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        l = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, l, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)[0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective awareness\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i, j = sorted(random.sample(range(1, N - 1), 2))\n    if i != j:\n        # Evaluate the impact on all three objectives\n        old_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Accept if at least one objective improves or if it's a balanced improvement\n        if any(new < old for new, old in zip(new_costs, old_costs)) or \\\n           (sum(new_costs) < sum(old_costs) and\n            all(new <= old * 1.1 for new, old in zip(new_costs, old_costs))):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6455220109473859,
            0.9300882339477539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1] + x[1][2]) / 3)[0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective awareness\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i, j = sorted(random.sample(range(1, N - 1), 2))\n    if i != j:\n        # Evaluate the impact on all three objectives\n        old_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]],\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]],\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        ]\n\n        new_costs = [\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]],\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]],\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        ]\n\n        # Accept if at least one objective improves or if it's a balanced improvement\n        if any(new < old for new, old in zip(new_costs, old_costs)) or \\\n           (sum(new_costs) < sum(old_costs) and\n            all(new <= old * 1.1 for new, old in zip(new_costs, old_costs))):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Determine the best segment to reverse based on objective improvement\n    def calculate_improvement(sol):\n        total_cost = 0\n        for m in range(n):\n            total_cost += distance_matrix_1[sol[m], sol[(m+1)%n]]\n            total_cost += distance_matrix_2[sol[m], sol[(m+1)%n]]\n            total_cost += distance_matrix_3[sol[m], sol[(m+1)%n]]\n        return total_cost\n\n    current_cost = calculate_improvement(new_solution)\n    best_cost = current_cost\n    best_solution = new_solution.copy()\n\n    # Try different segment reversals between the selected edges\n    for a in [i, j, k, l]:\n        for b in [i, j, k, l]:\n            if a != b:\n                temp_sol = new_solution.copy()\n                temp_sol[a:b] = temp_sol[a:b][::-1]\n                temp_cost = calculate_improvement(temp_sol)\n                if temp_cost < best_cost:\n                    best_cost = temp_cost\n                    best_solution = temp_sol.copy()\n\n    # If no improvement, perform a random 2-opt\n    if best_cost == current_cost:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[a:b] = best_solution[a:b][::-1]\n\n    return best_solution\n\n",
        "score": [
            -0.8132788230401751,
            2.674673628807068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on the sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Determine the best segment to reverse based on objective improvement\n    def calculate_improvement(sol):\n        total_cost = 0\n        for m in range(n):\n            total_cost += distance_matrix_1[sol[m], sol[(m+1)%n]]\n            total_cost += distance_matrix_2[sol[m], sol[(m+1)%n]]\n            total_cost += distance_matrix_3[sol[m], sol[(m+1)%n]]\n        return total_cost\n\n    current_cost = calculate_improvement(new_solution)\n    best_cost = current_cost\n    best_solution = new_solution.copy()\n\n    # Try different segment reversals between the selected edges\n    for a in [i, j, k, l]:\n        for b in [i, j, k, l]:\n            if a != b:\n                temp_sol = new_solution.copy()\n                temp_sol[a:b] = temp_sol[a:b][::-1]\n                temp_cost = calculate_improvement(temp_sol)\n                if temp_cost < best_cost:\n                    best_cost = temp_cost\n                    best_solution = temp_sol.copy()\n\n    # If no improvement, perform a random 2-opt\n    if best_cost == current_cost:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        best_solution[a:b] = best_solution[a:b][::-1]\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This algorithm intelligently selects a promising solution from the archive based on objective diversity and applies a hybrid local search combining 2-opt, relocate, and swap operations tailored to multi-objective optimization, ensuring feasibility and potential for further improvement across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (promising for improvement)\n    def objective_diversity(obj):\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    archive_with_diversity = [(sol, obj, objective_diversity(obj)) for sol, obj in archive]\n    archive_with_diversity.sort(key=lambda x: -x[2])  # Sort by diversity in descending order\n\n    # Select top 10% of solutions with highest diversity\n    top_k = max(1, len(archive_with_diversity) // 10)\n    selected_solutions = archive_with_diversity[:top_k]\n\n    # Randomly select one solution from the top candidates\n    selected = random.choice(selected_solutions)\n    base_solution = selected[0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three local search operators\n    operator = random.choice(['2opt', 'relocate', 'swap'])\n\n    if operator == '2opt':\n        # 2-opt: Reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'relocate':\n        # Relocate: Move a random node to another position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'swap':\n        # Swap: Swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.48187795537928546,
            1.001346266269684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity (promising for improvement)\n    def objective_diversity(obj):\n        return (obj[0] - obj[1])**2 + (obj[1] - obj[2])**2 + (obj[2] - obj[0])**2\n\n    archive_with_diversity = [(sol, obj, objective_diversity(obj)) for sol, obj in archive]\n    archive_with_diversity.sort(key=lambda x: -x[2])  # Sort by diversity in descending order\n\n    # Select top 10% of solutions with highest diversity\n    top_k = max(1, len(archive_with_diversity) // 10)\n    selected_solutions = archive_with_diversity[:top_k]\n\n    # Randomly select one solution from the top candidates\n    selected = random.choice(selected_solutions)\n    base_solution = selected[0].copy()\n\n    # Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose one of the three local search operators\n    operator = random.choice(['2opt', 'relocate', 'swap'])\n\n    if operator == '2opt':\n        # 2-opt: Reverse a random segment\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif operator == 'relocate':\n        # Relocate: Move a random node to another position\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    elif operator == 'swap':\n        # Swap: Swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on its potential for improvement across all three objectives, then applies a hybrid local search operator that combines 2-opt with a novel multi-objective edge exchange strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator combining 2-opt with multi-objective edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap on the first pair\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a multi-objective edge exchange on the second pair\n    # This is a novel strategy that considers all three objectives\n    if k != i and k != j and l != i and l != j:\n        # Calculate the cost of the current edges in all three objectives\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_3[new_solution[k-1], new_solution[k]]) + \\\n                       (distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        # Calculate the cost of the new edges in all three objectives\n        new_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                    distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                    distance_matrix_3[new_solution[k-1], new_solution[l]]) + \\\n                   (distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] +\n                    distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] +\n                    distance_matrix_3[new_solution[k], new_solution[(l+1)%n]])\n\n        # If the new edges are better in at least one objective, perform the exchange\n        if new_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7477827476781621,
            0.9406260490417481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator combining 2-opt with multi-objective edge exchange\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Perform 2-opt swap on the first pair\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform a multi-objective edge exchange on the second pair\n    # This is a novel strategy that considers all three objectives\n    if k != i and k != j and l != i and l != j:\n        # Calculate the cost of the current edges in all three objectives\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_3[new_solution[k-1], new_solution[k]]) + \\\n                       (distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        # Calculate the cost of the new edges in all three objectives\n        new_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                    distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                    distance_matrix_3[new_solution[k-1], new_solution[l]]) + \\\n                   (distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] +\n                    distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] +\n                    distance_matrix_3[new_solution[k], new_solution[(l+1)%n]])\n\n        # If the new edges are better in at least one objective, perform the exchange\n        if new_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify worst edge in any objective and swap it\n    def compute_total_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = compute_total_cost(base_solution)\n    new_cost = compute_total_cost(new_solution)\n\n    # Find the worst objective in the current solution\n    worst_obj = np.argmax(current_cost)\n\n    # Find the worst edge in the worst objective\n    worst_edge = -1\n    worst_edge_cost = -1\n    for k in range(n):\n        edge_cost = 0\n        if worst_obj == 0:\n            edge_cost = distance_matrix_1[base_solution[k], base_solution[(k+1)%n]]\n        elif worst_obj == 1:\n            edge_cost = distance_matrix_2[base_solution[k], base_solution[(k+1)%n]]\n        else:\n            edge_cost = distance_matrix_3[base_solution[k], base_solution[(k+1)%n]]\n        if edge_cost > worst_edge_cost:\n            worst_edge_cost = edge_cost\n            worst_edge = k\n\n    # Swap the worst edge with another random edge\n    if worst_edge != -1:\n        l = np.random.randint(0, n)\n        if l != worst_edge and l != (worst_edge + 1) % n:\n            new_solution[worst_edge], new_solution[l] = new_solution[l], new_solution[worst_edge]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7361379966940993,
            1.6274011135101318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware swaps\n    n = len(base_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Objective-aware swap: identify worst edge in any objective and swap it\n    def compute_total_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[sol[k], sol[(k+1)%n]] for k in range(n))\n        cost3 = sum(distance_matrix_3[sol[k], sol[(k+1)%n]] for k in range(n))\n        return (cost1, cost2, cost3)\n\n    current_cost = compute_total_cost(base_solution)\n    new_cost = compute_total_cost(new_solution)\n\n    # Find the worst objective in the current solution\n    worst_obj = np.argmax(current_cost)\n\n    # Find the worst edge in the worst objective\n    worst_edge = -1\n    worst_edge_cost = -1\n    for k in range(n):\n        edge_cost = 0\n        if worst_obj == 0:\n            edge_cost = distance_matrix_1[base_solution[k], base_solution[(k+1)%n]]\n        elif worst_obj == 1:\n            edge_cost = distance_matrix_2[base_solution[k], base_solution[(k+1)%n]]\n        else:\n            edge_cost = distance_matrix_3[base_solution[k], base_solution[(k+1)%n]]\n        if edge_cost > worst_edge_cost:\n            worst_edge_cost = edge_cost\n            worst_edge = k\n\n    # Swap the worst edge with another random edge\n    if worst_edge != -1:\n        l = np.random.randint(0, n)\n        if l != worst_edge and l != (worst_edge + 1) % n:\n            new_solution[worst_edge], new_solution[l] = new_solution[l], new_solution[worst_edge]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high crowding distance or low objective values)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n        # Apply 2-opt if it improves the total distance in any objective\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Apply node insertion if it improves the total distance in any objective\n        if i != k and j != k:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, i, node)\n\n        # Ensure the solution remains valid (no duplicates or missing nodes)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6450571984885307,
            1.9872390508651734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., high crowding distance or low objective values)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: apply a combination of 2-opt and node insertion\n    n = len(new_solution)\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n        # Apply 2-opt if it improves the total distance in any objective\n        if i != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Apply node insertion if it improves the total distance in any objective\n        if i != k and j != k:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, i, node)\n\n        # Ensure the solution remains valid (no duplicates or missing nodes)\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This heuristic selects a non-dominated solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining 2-opt and 3-opt moves, with a probability of 70% for 2-opt and 30% for 3-opt, to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([sum(obj) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert weights to favor solutions with lower total cost\n    weights = weights / np.sum(weights)\n    idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for 3-opt\n        # Perform 3-opt\n        n = len(new_solution)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.8082404816394988,
            1.181343400478363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([sum(obj) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert weights to favor solutions with lower total cost\n    weights = weights / np.sum(weights)\n    idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    if random.random() < 0.7:  # 70% chance for 2-opt\n        # Perform 2-opt\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for 3-opt\n        # Perform 3-opt\n        n = len(new_solution)\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(np.std(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for single objective, path relinking for multi-objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    if i + 1 <= j - 1:\n        segment = new_solution[i+1:j].copy()\n        new_solution[i+1:j] = segment[::-1]\n\n    # Path relinking: combine with another solution's segment\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Find common segments between solutions\n        for k in range(n):\n            if new_solution[k] == other_solution[k]:\n                continue\n            # Find matching node in other solution\n            for l in range(k, n):\n                if new_solution[k] == other_solution[l]:\n                    # Swap segments to create a new path\n                    temp = new_solution[k:l+1].copy()\n                    new_solution[k:l+1] = other_solution[k:l+1]\n                    # Ensure feasibility\n                    if len(np.unique(new_solution)) == n:\n                        break\n                    else:\n                        new_solution[k:l+1] = temp\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.6491330387578904,
            3.869413375854492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0).sum()\n    selected_idx = np.argmax(np.std(objectives, axis=0))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 2-opt for single objective, path relinking for multi-objective\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt to the selected segment\n    if i + 1 <= j - 1:\n        segment = new_solution[i+1:j].copy()\n        new_solution[i+1:j] = segment[::-1]\n\n    # Path relinking: combine with another solution's segment\n    if len(archive) > 1:\n        other_idx = np.random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        # Find common segments between solutions\n        for k in range(n):\n            if new_solution[k] == other_solution[k]:\n                continue\n            # Find matching node in other solution\n            for l in range(k, n):\n                if new_solution[k] == other_solution[l]:\n                    # Swap segments to create a new path\n                    temp = new_solution[k:l+1].copy()\n                    new_solution[k:l+1] = other_solution[k:l+1]\n                    # Ensure feasibility\n                    if len(np.unique(new_solution)) == n:\n                        break\n                    else:\n                        new_solution[k:l+1] = temp\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Select the worst solution in the archive\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion based on objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Reverse the segment (2-opt like move)\n    new_solution[a:b] = segment[::-1]\n\n    # Insert the segment at a new random position (edge insertion)\n    if len(segment) > 1:\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to the original segment\n        new_solution[a:b] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.7218397454736247,
            0.4035254120826721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: sum(x[1]))  # Select the worst solution in the archive\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: combine 2-opt and edge insertion based on objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Reverse the segment (2-opt like move)\n    new_solution[a:b] = segment[::-1]\n\n    # Insert the segment at a new random position (edge insertion)\n    if len(segment) > 1:\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, revert to the original segment\n        new_solution[a:b] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel hybrid local search algorithm that intelligently selects a solution from the archive with high potential for improvement, then applies a combination of 2-opt and 3-opt moves tailored to the tri-objective space to generate a neighbor solution that balances improvements across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt tailored to tri-objective space\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select segments for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate current and potential 2-opt move across all objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_1[new_solution[i], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[j]] +\n                           distance_matrix_3[new_solution[i], new_solution[j]])\n\n        if potential_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Randomly select segments for 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i == j or j == k:\n            continue\n\n        # Evaluate current and potential 3-opt move across all objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        # Try all possible 3-opt configurations\n        for config in [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]:\n            a, b, c = config\n            potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                              distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                              distance_matrix_3[new_solution[a-1], new_solution[b-1]] +\n                              distance_matrix_1[new_solution[b-1], new_solution[c-1]] +\n                              distance_matrix_2[new_solution[b-1], new_solution[c-1]] +\n                              distance_matrix_3[new_solution[b-1], new_solution[c-1]] +\n                              distance_matrix_1[new_solution[c-1], new_solution[a]] +\n                              distance_matrix_2[new_solution[c-1], new_solution[a]] +\n                              distance_matrix_3[new_solution[c-1], new_solution[a]])\n\n            if potential_cost < current_cost:\n                # Apply the best configuration\n                new_solution[a:b] = new_solution[a:b][::-1]\n                new_solution[b:c] = new_solution[b:c][::-1]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.7903248133788023,
            2.310243844985962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (obj[0] + obj[1] + obj[2] + 1e-6) for (sol, obj) in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: 2-opt and 3-opt tailored to tri-objective space\n    n = len(new_solution)\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select segments for 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate current and potential 2-opt move across all objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_3[new_solution[i-1], new_solution[j-1]] +\n                           distance_matrix_1[new_solution[i], new_solution[j]] +\n                           distance_matrix_2[new_solution[i], new_solution[j]] +\n                           distance_matrix_3[new_solution[i], new_solution[j]])\n\n        if potential_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Randomly select segments for 3-opt\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i == j or j == k:\n            continue\n\n        # Evaluate current and potential 3-opt move across all objectives\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_3[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_3[new_solution[k-1], new_solution[k]])\n\n        # Try all possible 3-opt configurations\n        for config in [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]:\n            a, b, c = config\n            potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b-1]] +\n                              distance_matrix_2[new_solution[a-1], new_solution[b-1]] +\n                              distance_matrix_3[new_solution[a-1], new_solution[b-1]] +\n                              distance_matrix_1[new_solution[b-1], new_solution[c-1]] +\n                              distance_matrix_2[new_solution[b-1], new_solution[c-1]] +\n                              distance_matrix_3[new_solution[b-1], new_solution[c-1]] +\n                              distance_matrix_1[new_solution[c-1], new_solution[a]] +\n                              distance_matrix_2[new_solution[c-1], new_solution[a]] +\n                              distance_matrix_3[new_solution[c-1], new_solution[a]])\n\n            if potential_cost < current_cost:\n                # Apply the best configuration\n                new_solution[a:b] = new_solution[a:b][::-1]\n                new_solution[b:c] = new_solution[b:c][::-1]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{The heuristic function 'select_neighbor' intelligently selects a promising solution from the archive based on objective diversity and applies a hybrid local search operator that combines 2-opt moves across all three objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt across all three objectives\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt with the objective that has the highest variance in the archive\n    obj_idx = np.argmax(np.std(objectives, axis=0))\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_idx]\n\n    # Randomly select two edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform the 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5736105851518245,
            1.6443894624710083
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity in objectives\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt across all three objectives\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt with the objective that has the highest variance in the archive\n    obj_idx = np.argmax(np.std(objectives, axis=0))\n    distance_matrix = [distance_matrix_1, distance_matrix_2, distance_matrix_3][obj_idx]\n\n    # Randomly select two edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform the 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.std(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt for one objective, followed by a swap for another\n    new_solution = selected_solution.copy()\n\n    # 2-opt for the first objective\n    i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Swap two nodes for the second objective\n    k, l = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == len(set(new_solution)) == len(instance)\n\n    return new_solution\n\n",
        "score": [
            -0.48580516449242783,
            3.4596787691116333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.std(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt for one objective, followed by a swap for another\n    new_solution = selected_solution.copy()\n\n    # 2-opt for the first objective\n    i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Swap two nodes for the second objective\n    k, l = sorted(np.random.choice(len(new_solution), 2, replace=False))\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    assert len(new_solution) == len(set(new_solution)) == len(instance)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the range of objectives for each solution\n    ranges = []\n    for sol, obj in archive:\n        obj1, obj2, obj3 = obj\n        range_val = max(obj1, obj2, obj3) - min(obj1, obj2, obj3)\n        ranges.append((range_val, sol))\n\n    # Select the solution with the largest range (most potential for improvement)\n    ranges.sort(reverse=True, key=lambda x: x[0])\n    base_solution = ranges[0][1].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains feasibility\n    if i != k and j != l:\n        # Perform the 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4857179398877024,
            1.1185192584991455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the range of objectives for each solution\n    ranges = []\n    for sol, obj in archive:\n        obj1, obj2, obj3 = obj\n        range_val = max(obj1, obj2, obj3) - min(obj1, obj2, obj3)\n        ranges.append((range_val, sol))\n\n    # Select the solution with the largest range (most potential for improvement)\n    ranges.sort(reverse=True, key=lambda x: x[0])\n    base_solution = ranges[0][1].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains feasibility\n    if i != k and j != l:\n        # Perform the 2-opt swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution is still a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations for local search\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7071801894316581,
            1.1950974941253663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations for local search\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Calculate the change in all three objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        delta3 = (distance_matrix_3[new_solution[i-1], new_solution[j]] +\n                  distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_3[new_solution[i-1], new_solution[i]] +\n                  distance_matrix_3[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept if at least one objective improves\n        if delta1 < 0 or delta2 < 0 or delta3 < 0:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt + edge insertion + objective-aware swaps\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Randomly select a segment for 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Edge insertion: move a random edge to a new position\n        k = np.random.randint(0, n)\n        edge = new_solution[[k, (k+1)%n]]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, edge)\n\n        # Objective-aware swap: swap nodes that improve the worst objective\n        for _ in range(3):  # Try a few swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n            new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n            # Calculate old and new costs for all three objectives\n            old_costs = [\n                sum(distance_matrix_1[u, v] for u, v in old_edges),\n                sum(distance_matrix_2[u, v] for u, v in old_edges),\n                sum(distance_matrix_3[u, v] for u, v in old_edges)\n            ]\n            new_costs = [\n                sum(distance_matrix_1[u, v] for u, v in new_edges),\n                sum(distance_matrix_2[u, v] for u, v in new_edges),\n                sum(distance_matrix_3[u, v] for u, v in new_edges)\n            ]\n\n            # Accept if at least one objective improves\n            if any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6820504761335996,
            3.8531112670898438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 2-opt + edge insertion + objective-aware swaps\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Randomly select a segment for 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Edge insertion: move a random edge to a new position\n        k = np.random.randint(0, n)\n        edge = new_solution[[k, (k+1)%n]]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+2:]])\n        insert_pos = np.random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, edge)\n\n        # Objective-aware swap: swap nodes that improve the worst objective\n        for _ in range(3):  # Try a few swaps\n            a, b = np.random.choice(n, 2, replace=False)\n            old_edges = [(new_solution[a-1], new_solution[a]), (new_solution[b-1], new_solution[b])]\n            new_edges = [(new_solution[a-1], new_solution[b]), (new_solution[b-1], new_solution[a])]\n\n            # Calculate old and new costs for all three objectives\n            old_costs = [\n                sum(distance_matrix_1[u, v] for u, v in old_edges),\n                sum(distance_matrix_2[u, v] for u, v in old_edges),\n                sum(distance_matrix_3[u, v] for u, v in old_edges)\n            ]\n            new_costs = [\n                sum(distance_matrix_1[u, v] for u, v in new_edges),\n                sum(distance_matrix_2[u, v] for u, v in new_edges),\n                sum(distance_matrix_3[u, v] for u, v in new_edges)\n            ]\n\n            # Accept if at least one objective improves\n            if any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined objective value (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = np.random.choice(n, size=2, replace=False)\n    k, l = np.random.choice(n, size=2, replace=False)\n\n    # Ensure i < j and k < l for valid edge selection\n    i, j = min(i, j), max(i, j)\n    k, l = min(k, l), max(k, l)\n\n    # Perform edge swap to create a new tour\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Verify the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6840761730472183,
            1.2801200032234192
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined objective value (promising for improvement)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to break and reconnect\n    i, j = np.random.choice(n, size=2, replace=False)\n    k, l = np.random.choice(n, size=2, replace=False)\n\n    # Ensure i < j and k < l for valid edge selection\n    i, j = min(i, j), max(i, j)\n    k, l = min(k, l), max(k, l)\n\n    # Perform edge swap to create a new tour\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Verify the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    def crowding_distance(solutions):\n        objectives = [obj for (_, obj) in solutions]\n        num_obj = len(objectives[0])\n        num_sol = len(objectives)\n\n        distances = np.zeros(num_sol)\n        for m in range(num_obj):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            min_val = objectives[sorted_idx[0]][m]\n            max_val = objectives[sorted_idx[-1]][m]\n\n            if min_val == max_val:\n                continue\n\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, num_sol - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max_val - min_val)\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt local search with probability 0.7\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge insertion: select edges with high potential improvement across objectives\n    else:\n        # Calculate edge improvement potential\n        def edge_potential(i, j):\n            # Current edges\n            a = new_solution[i-1]\n            b = new_solution[i]\n            c = new_solution[j]\n            d = new_solution[(j+1)%n]\n\n            # Potential new edges\n            new_edges = [(a, c), (b, d)]\n            old_edges = [(a, b), (c, d)]\n\n            # Calculate improvement in all three objectives\n            improvement = 0\n            for old, new in zip(old_edges, new_edges):\n                improvement += (distance_matrix_1[old[0], old[1]] - distance_matrix_1[new[0], new[1]]) / distance_matrix_1[old[0], old[1]]\n                improvement += (distance_matrix_2[old[0], old[1]] - distance_matrix_2[new[0], new[1]]) / distance_matrix_2[old[0], old[1]]\n                improvement += (distance_matrix_3[old[0], old[1]] - distance_matrix_3[new[0], new[1]]) / distance_matrix_3[old[0], old[1]]\n\n            return improvement\n\n        # Find best edge swap\n        best_improvement = -np.inf\n        best_i, best_j = -1, -1\n\n        for i in range(1, n-1):\n            for j in range(i+1, n):\n                improvement = edge_potential(i, j)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5149322500274867,
            3.6302240610122682
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for each solution in the archive\n    def crowding_distance(solutions):\n        objectives = [obj for (_, obj) in solutions]\n        num_obj = len(objectives[0])\n        num_sol = len(objectives)\n\n        distances = np.zeros(num_sol)\n        for m in range(num_obj):\n            sorted_idx = np.argsort([obj[m] for obj in objectives])\n            min_val = objectives[sorted_idx[0]][m]\n            max_val = objectives[sorted_idx[-1]][m]\n\n            if min_val == max_val:\n                continue\n\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, num_sol - 1):\n                distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m]) / (max_val - min_val)\n\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel multi-objective edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 2-opt local search with probability 0.7\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge insertion: select edges with high potential improvement across objectives\n    else:\n        # Calculate edge improvement potential\n        def edge_potential(i, j):\n            # Current edges\n            a = new_solution[i-1]\n            b = new_solution[i]\n            c = new_solution[j]\n            d = new_solution[(j+1)%n]\n\n            # Potential new edges\n            new_edges = [(a, c), (b, d)]\n            old_edges = [(a, b), (c, d)]\n\n            # Calculate improvement in all three objectives\n            improvement = 0\n            for old, new in zip(old_edges, new_edges):\n                improvement += (distance_matrix_1[old[0], old[1]] - distance_matrix_1[new[0], new[1]]) / distance_matrix_1[old[0], old[1]]\n                improvement += (distance_matrix_2[old[0], old[1]] - distance_matrix_2[new[0], new[1]]) / distance_matrix_2[old[0], old[1]]\n                improvement += (distance_matrix_3[old[0], old[1]] - distance_matrix_3[new[0], new[1]]) / distance_matrix_3[old[0], old[1]]\n\n            return improvement\n\n        # Find best edge swap\n        best_improvement = -np.inf\n        best_i, best_j = -1, -1\n\n        for i in range(1, n-1):\n            for j in range(i+1, n):\n                improvement = edge_potential(i, j)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(obj[0] / np.max(distance_matrix_1), obj[1] / np.max(distance_matrix_2), obj[2] / np.max(distance_matrix_3)) for _, obj in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n\n    # Evaluate the new segment's contribution to all three objectives\n    def evaluate_segment(sol, start, end):\n        total_cost = 0\n        for k in range(start, end):\n            total_cost += distance_matrix_1[sol[k], sol[k+1]] + distance_matrix_2[sol[k], sol[k+1]] + distance_matrix_3[sol[k], sol[k+1]]\n        return total_cost\n\n    original_cost = evaluate_segment(new_solution, i-1 if i > 0 else n-1, j+1 if j < n-1 else 0)\n    reversed_cost = evaluate_segment(np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]]), i-1 if i > 0 else n-1, j+1 if j < n-1 else 0)\n\n    # Accept the move if it improves the sum of all objectives\n    if reversed_cost < original_cost:\n        new_solution[i:j+1] = reversed_segment\n\n    # Apply a node swap to further diversify\n    a, b = np.random.choice(n, 2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5839739101328452,
            4.103190648555755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = np.array([(obj[0] / np.max(distance_matrix_1), obj[1] / np.max(distance_matrix_2), obj[2] / np.max(distance_matrix_3)) for _, obj in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select a random segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (2-opt move)\n    reversed_segment = segment[::-1]\n\n    # Evaluate the new segment's contribution to all three objectives\n    def evaluate_segment(sol, start, end):\n        total_cost = 0\n        for k in range(start, end):\n            total_cost += distance_matrix_1[sol[k], sol[k+1]] + distance_matrix_2[sol[k], sol[k+1]] + distance_matrix_3[sol[k], sol[k+1]]\n        return total_cost\n\n    original_cost = evaluate_segment(new_solution, i-1 if i > 0 else n-1, j+1 if j < n-1 else 0)\n    reversed_cost = evaluate_segment(np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]]), i-1 if i > 0 else n-1, j+1 if j < n-1 else 0)\n\n    # Accept the move if it improves the sum of all objectives\n    if reversed_cost < original_cost:\n        new_solution[i:j+1] = reversed_segment\n\n    # Apply a node swap to further diversify\n    a, b = np.random.choice(n, 2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Evaluate all possible 2-opt moves considering all three objectives\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the change in all three objectives\n            a, b, c, d = selected_solution[i], selected_solution[i+1], selected_solution[j], selected_solution[(j+1)%n]\n            delta1 = distance_matrix_1[a][d] + distance_matrix_1[b][c] - distance_matrix_1[a][b] - distance_matrix_1[c][d]\n            delta2 = distance_matrix_2[a][d] + distance_matrix_2[b][c] - distance_matrix_2[a][b] - distance_matrix_2[c][d]\n            delta3 = distance_matrix_3[a][d] + distance_matrix_3[b][c] - distance_matrix_3[a][b] - distance_matrix_3[c][d]\n\n            # Combine improvements using a weighted sum (equal weights for simplicity)\n            total_improvement = -delta1 - delta2 - delta3\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Apply the best 2-opt move\n        new_solution = selected_solution.copy()\n        new_solution[best_i+1:best_j+1] = np.flip(selected_solution[best_i+1:best_j+1])\n        return new_solution\n\n    # If no improvement found, perform a random 2-opt move to maintain diversity\n    i = np.random.randint(0, n-1)\n    j = np.random.randint(i+2, n)\n    new_solution = selected_solution.copy()\n    new_solution[i+1:j+1] = np.flip(selected_solution[i+1:j+1])\n    return new_solution\n\n",
        "score": [
            -0.6766610346915432,
            3.518510067462921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    best_improvement = 0\n    best_i, best_j = 0, 0\n\n    # Evaluate all possible 2-opt moves considering all three objectives\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the change in all three objectives\n            a, b, c, d = selected_solution[i], selected_solution[i+1], selected_solution[j], selected_solution[(j+1)%n]\n            delta1 = distance_matrix_1[a][d] + distance_matrix_1[b][c] - distance_matrix_1[a][b] - distance_matrix_1[c][d]\n            delta2 = distance_matrix_2[a][d] + distance_matrix_2[b][c] - distance_matrix_2[a][b] - distance_matrix_2[c][d]\n            delta3 = distance_matrix_3[a][d] + distance_matrix_3[b][c] - distance_matrix_3[a][b] - distance_matrix_3[c][d]\n\n            # Combine improvements using a weighted sum (equal weights for simplicity)\n            total_improvement = -delta1 - delta2 - delta3\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_i, best_j = i, j\n\n    if best_improvement > 0:\n        # Apply the best 2-opt move\n        new_solution = selected_solution.copy()\n        new_solution[best_i+1:best_j+1] = np.flip(selected_solution[best_i+1:best_j+1])\n        return new_solution\n\n    # If no improvement found, perform a random 2-opt move to maintain diversity\n    i = np.random.randint(0, n-1)\n    j = np.random.randint(i+2, n)\n    new_solution = selected_solution.copy()\n    new_solution[i+1:j+1] = np.flip(selected_solution[i+1:j+1])\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., with the best trade-off across objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Determine which objective to prioritize for the swap\n    obj1_diff = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[i]] - distance_matrix_1[selected_solution[i-1], selected_solution[i]] - distance_matrix_1[selected_solution[i], selected_solution[j]]\n    obj2_diff = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[i]] - distance_matrix_2[selected_solution[i-1], selected_solution[i]] - distance_matrix_2[selected_solution[i], selected_solution[j]]\n    obj3_diff = distance_matrix_3[selected_solution[i-1], selected_solution[j]] + distance_matrix_3[selected_solution[j], selected_solution[i]] - distance_matrix_3[selected_solution[i-1], selected_solution[i]] - distance_matrix_3[selected_solution[i], selected_solution[j]]\n\n    # Prioritize the objective with the largest improvement\n    if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n        return new_solution\n    else:\n        # If no improvement, perform a random 2-opt\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.7177517706131991,
            1.4441930055618286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., with the best trade-off across objectives)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(selected_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Determine which objective to prioritize for the swap\n    obj1_diff = distance_matrix_1[selected_solution[i-1], selected_solution[j]] + distance_matrix_1[selected_solution[j], selected_solution[i]] - distance_matrix_1[selected_solution[i-1], selected_solution[i]] - distance_matrix_1[selected_solution[i], selected_solution[j]]\n    obj2_diff = distance_matrix_2[selected_solution[i-1], selected_solution[j]] + distance_matrix_2[selected_solution[j], selected_solution[i]] - distance_matrix_2[selected_solution[i-1], selected_solution[i]] - distance_matrix_2[selected_solution[i], selected_solution[j]]\n    obj3_diff = distance_matrix_3[selected_solution[i-1], selected_solution[j]] + distance_matrix_3[selected_solution[j], selected_solution[i]] - distance_matrix_3[selected_solution[i-1], selected_solution[i]] - distance_matrix_3[selected_solution[i], selected_solution[j]]\n\n    # Prioritize the objective with the largest improvement\n    if obj1_diff < 0 or obj2_diff < 0 or obj3_diff < 0:\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n        return new_solution\n    else:\n        # If no improvement, perform a random 2-opt\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{\"The heuristic function 'select_neighbor' intelligently selects a solution from the archive with high potential for improvement, then applies a hybrid local search strategy combining 2-opt and edge insertion moves across all three objective spaces to generate a neighbor solution while ensuring feasibility.\"}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply hybrid local search: 2-opt with edge insertion across all objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Apply edge insertion in each objective space\n    for _ in range(2):  # Number of insertion attempts\n        # Randomly select an edge to insert\n        k = random.randint(0, n-1)\n        if i <= k <= j:\n            continue  # Skip if selected edge is in the segment\n\n        # Insert the segment at position k\n        new_solution = np.concatenate([\n            new_solution[:k],\n            segment,\n            new_solution[k:]\n        ])\n\n        # Ensure no duplicates (feasibility)\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) < n:\n            # If duplicates exist, revert and try another position\n            new_solution = selected_solution.copy()\n            continue\n\n        # Check if the new solution is better in at least one objective\n        old_costs = archive[0][1]\n        new_costs = (\n            sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        )\n\n        if any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            break  # Accept if improvement in at least one objective\n        else:\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n",
        "score": [
            -0.7068828700448984,
            0.8995528936386108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply hybrid local search: 2-opt with edge insertion across all objectives\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Apply edge insertion in each objective space\n    for _ in range(2):  # Number of insertion attempts\n        # Randomly select an edge to insert\n        k = random.randint(0, n-1)\n        if i <= k <= j:\n            continue  # Skip if selected edge is in the segment\n\n        # Insert the segment at position k\n        new_solution = np.concatenate([\n            new_solution[:k],\n            segment,\n            new_solution[k:]\n        ])\n\n        # Ensure no duplicates (feasibility)\n        unique, counts = np.unique(new_solution, return_counts=True)\n        if len(unique) < n:\n            # If duplicates exist, revert and try another position\n            new_solution = selected_solution.copy()\n            continue\n\n        # Check if the new solution is better in at least one objective\n        old_costs = archive[0][1]\n        new_costs = (\n            sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]],\n            sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n        )\n\n        if any(new_cost < old_cost for new_cost, old_cost in zip(new_costs, old_costs)):\n            break  # Accept if improvement in at least one objective\n        else:\n            new_solution = selected_solution.copy()  # Revert if no improvement\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of 2-opt and segment inversion)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    while (i <= k <= j and j <= l) or (i <= l <= j and j <= k):\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply segment inversion to the first segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 2-opt to the second segment\n    if k < l:\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7901723563963285,
            1.4993461489677429
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = archive[np.random.choice(len(archive))][0].copy()\n\n    # Step 2: Apply a hybrid local search operator (combination of 2-opt and segment inversion)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are distinct and non-overlapping\n    while (i <= k <= j and j <= l) or (i <= l <= j and j <= k):\n        k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply segment inversion to the first segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply 2-opt to the second segment\n    if k < l:\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and node swap to optimize across objectives\n    N = len(base_solution)\n    if N < 2:\n        return new_solution\n\n    # Randomly select segments for 2-opt\n    i, j = sorted(random.sample(range(N), 2))\n    k, l = sorted(random.sample(range(N), 2))\n\n    # Apply 2-opt to improve the tour structure\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply node swap to optimize across objectives\n    swap_pos1, swap_pos2 = random.sample(range(N), 2)\n    new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != N:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5635098585488901,
            0.8994805574417114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Apply a combination of 2-opt and node swap to optimize across objectives\n    N = len(base_solution)\n    if N < 2:\n        return new_solution\n\n    # Randomly select segments for 2-opt\n    i, j = sorted(random.sample(range(N), 2))\n    k, l = sorted(random.sample(range(N), 2))\n\n    # Apply 2-opt to improve the tour structure\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply node swap to optimize across objectives\n    swap_pos1, swap_pos2 = random.sample(range(N), 2)\n    new_solution[swap_pos1], new_solution[swap_pos2] = new_solution[swap_pos2], new_solution[swap_pos1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(set(new_solution)) != N:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swap to create a neighbor\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[k:l] = np.flip(new_solution[k:l])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6901108273283214,
            0.8876442074775696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: 2-opt with multi-objective edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply 2-opt swap to create a neighbor\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[k:l] = np.flip(new_solution[k:l])\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives to prioritize diverse exploration\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(np.argsort(scores)[-3:])  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 or j == n-1:\n            continue  # Avoid invalid swaps\n\n        # Calculate edge costs in all three objectives\n        cost_before = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        cost_after = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if cost_after < cost_before:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional objective-aware edge swaps\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate edge costs in all three objectives\n        cost_before = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        cost_after = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7377746633866095,
            2.4241122603416443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest sum of normalized objectives to prioritize diverse exploration\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.random.choice(np.argsort(scores)[-3:])  # Select among top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with objective-aware edge swaps\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt with objective-aware edge selection\n    for _ in range(10):  # Limit iterations for efficiency\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == 0 or j == n-1:\n            continue  # Avoid invalid swaps\n\n        # Calculate edge costs in all three objectives\n        cost_before = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j], new_solution[(j+1)%n]]\n        )\n\n        cost_after = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i], new_solution[(j+1)%n]]\n        )\n\n        if cost_after < cost_before:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional objective-aware edge swaps\n    for _ in range(5):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate edge costs in all three objectives\n        cost_before = (\n            distance_matrix_1[new_solution[i-1], new_solution[i]] +\n            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n            distance_matrix_2[new_solution[i-1], new_solution[i]] +\n            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n            distance_matrix_3[new_solution[i-1], new_solution[i]] +\n            distance_matrix_3[new_solution[j-1], new_solution[j]]\n        )\n\n        cost_after = (\n            distance_matrix_1[new_solution[i-1], new_solution[j]] +\n            distance_matrix_1[new_solution[j-1], new_solution[i]] +\n            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n            distance_matrix_2[new_solution[j-1], new_solution[i]] +\n            distance_matrix_3[new_solution[i-1], new_solution[j]] +\n            distance_matrix_3[new_solution[j-1], new_solution[i]]\n        )\n\n        if cost_after < cost_before:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply 2-opt within the segment\n    if b - a > 1:\n        segment = new_solution[a:b+1]\n        segment = segment[::-1]  # Reverse the segment\n        new_solution[a:b+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        node_to_insert = np.random.choice(new_solution[a:b+1])\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.6741627278988799,
            1.5227498888969422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to modify\n    a = np.random.randint(0, n)\n    b = np.random.randint(0, n)\n    if a > b:\n        a, b = b, a\n\n    # Apply 2-opt within the segment\n    if b - a > 1:\n        segment = new_solution[a:b+1]\n        segment = segment[::-1]  # Reverse the segment\n        new_solution[a:b+1] = segment\n\n    # Randomly insert a node from the segment elsewhere\n    if n > 2:\n        node_to_insert = np.random.choice(new_solution[a:b+1])\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest sum (most promising for improvement)\n    selected_idx = np.argmin(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion moves\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    # Perform insertion move to further improve\n    k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n    if k != l:\n        # Remove node at k and insert it after l\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = (l + 1) % n\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6816186777244518,
            1.0327186465263367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in archive_objectives]\n\n    # Select the solution with the lowest sum (most promising for improvement)\n    selected_idx = np.argmin(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt and insertion moves\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Check feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original\n        new_solution = base_solution.copy()\n\n    # Perform insertion move to further improve\n    k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n    if k != l:\n        # Remove node at k and insert it after l\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        insert_pos = (l + 1) % n\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_objectives = [max(obj) for _, obj in archive]\n    selected_idx = np.argmax(worst_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply 2-opt and 3-opt moves to improve the worst objective\n    n = len(base_solution)\n    improved = False\n\n    # First, try 2-opt moves to improve the worst objective\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the change in all three objectives\n            delta_obj1 = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                          distance_matrix_1[base_solution[i+1], base_solution[(j+1)%n]]) - \\\n                         (distance_matrix_1[base_solution[i], base_solution[i+1]] +\n                          distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n\n            delta_obj2 = (distance_matrix_2[base_solution[i], base_solution[j]] +\n                          distance_matrix_2[base_solution[i+1], base_solution[(j+1)%n]]) - \\\n                         (distance_matrix_2[base_solution[i], base_solution[i+1]] +\n                          distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n            delta_obj3 = (distance_matrix_3[base_solution[i], base_solution[j]] +\n                          distance_matrix_3[base_solution[i+1], base_solution[(j+1)%n]]) - \\\n                         (distance_matrix_3[base_solution[i], base_solution[i+1]] +\n                          distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n\n            # If any objective improves, apply the move\n            if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                new_solution[i+1:j+1] = base_solution[i+1:j+1][::-1]\n                improved = True\n                break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try 3-opt moves\n    if not improved:\n        for i in range(n - 2):\n            for j in range(i + 2, n - 1):\n                for k in range(j + 2, n):\n                    # Calculate the change in all three objectives\n                    # This is a simplified version; a full 3-opt implementation would be more complex\n                    delta_obj1 = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                  distance_matrix_1[base_solution[j], base_solution[k]] +\n                                  distance_matrix_1[base_solution[k], base_solution[i+1]]) - \\\n                                 (distance_matrix_1[base_solution[i], base_solution[i+1]] +\n                                  distance_matrix_1[base_solution[j], base_solution[j+1]] +\n                                  distance_matrix_1[base_solution[k], base_solution[(k+1)%n]])\n\n                    delta_obj2 = (distance_matrix_2[base_solution[i], base_solution[j]] +\n                                  distance_matrix_2[base_solution[j], base_solution[k]] +\n                                  distance_matrix_2[base_solution[k], base_solution[i+1]]) - \\\n                                 (distance_matrix_2[base_solution[i], base_solution[i+1]] +\n                                  distance_matrix_2[base_solution[j], base_solution[j+1]] +\n                                  distance_matrix_2[base_solution[k], base_solution[(k+1)%n]])\n\n                    delta_obj3 = (distance_matrix_3[base_solution[i], base_solution[j]] +\n                                  distance_matrix_3[base_solution[j], base_solution[k]] +\n                                  distance_matrix_3[base_solution[k], base_solution[i+1]]) - \\\n                                 (distance_matrix_3[base_solution[i], base_solution[i+1]] +\n                                  distance_matrix_3[base_solution[j], base_solution[j+1]] +\n                                  distance_matrix_3[base_solution[k], base_solution[(k+1)%n]])\n\n                    # If any objective improves, apply the move\n                    if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                        # Apply the 3-opt move (simplified)\n                        new_solution[i+1:j+1] = base_solution[i+1:j+1][::-1]\n                        new_solution[j+1:k+1] = base_solution[j+1:k+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6895936128299509,
            1.4177662253379821
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    worst_objectives = [max(obj) for _, obj in archive]\n    selected_idx = np.argmax(worst_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply 2-opt and 3-opt moves to improve the worst objective\n    n = len(base_solution)\n    improved = False\n\n    # First, try 2-opt moves to improve the worst objective\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            # Calculate the change in all three objectives\n            delta_obj1 = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                          distance_matrix_1[base_solution[i+1], base_solution[(j+1)%n]]) - \\\n                         (distance_matrix_1[base_solution[i], base_solution[i+1]] +\n                          distance_matrix_1[base_solution[j], base_solution[(j+1)%n]])\n\n            delta_obj2 = (distance_matrix_2[base_solution[i], base_solution[j]] +\n                          distance_matrix_2[base_solution[i+1], base_solution[(j+1)%n]]) - \\\n                         (distance_matrix_2[base_solution[i], base_solution[i+1]] +\n                          distance_matrix_2[base_solution[j], base_solution[(j+1)%n]])\n\n            delta_obj3 = (distance_matrix_3[base_solution[i], base_solution[j]] +\n                          distance_matrix_3[base_solution[i+1], base_solution[(j+1)%n]]) - \\\n                         (distance_matrix_3[base_solution[i], base_solution[i+1]] +\n                          distance_matrix_3[base_solution[j], base_solution[(j+1)%n]])\n\n            # If any objective improves, apply the move\n            if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                new_solution[i+1:j+1] = base_solution[i+1:j+1][::-1]\n                improved = True\n                break\n        if improved:\n            break\n\n    # If no improvement with 2-opt, try 3-opt moves\n    if not improved:\n        for i in range(n - 2):\n            for j in range(i + 2, n - 1):\n                for k in range(j + 2, n):\n                    # Calculate the change in all three objectives\n                    # This is a simplified version; a full 3-opt implementation would be more complex\n                    delta_obj1 = (distance_matrix_1[base_solution[i], base_solution[j]] +\n                                  distance_matrix_1[base_solution[j], base_solution[k]] +\n                                  distance_matrix_1[base_solution[k], base_solution[i+1]]) - \\\n                                 (distance_matrix_1[base_solution[i], base_solution[i+1]] +\n                                  distance_matrix_1[base_solution[j], base_solution[j+1]] +\n                                  distance_matrix_1[base_solution[k], base_solution[(k+1)%n]])\n\n                    delta_obj2 = (distance_matrix_2[base_solution[i], base_solution[j]] +\n                                  distance_matrix_2[base_solution[j], base_solution[k]] +\n                                  distance_matrix_2[base_solution[k], base_solution[i+1]]) - \\\n                                 (distance_matrix_2[base_solution[i], base_solution[i+1]] +\n                                  distance_matrix_2[base_solution[j], base_solution[j+1]] +\n                                  distance_matrix_2[base_solution[k], base_solution[(k+1)%n]])\n\n                    delta_obj3 = (distance_matrix_3[base_solution[i], base_solution[j]] +\n                                  distance_matrix_3[base_solution[j], base_solution[k]] +\n                                  distance_matrix_3[base_solution[k], base_solution[i+1]]) - \\\n                                 (distance_matrix_3[base_solution[i], base_solution[i+1]] +\n                                  distance_matrix_3[base_solution[j], base_solution[j+1]] +\n                                  distance_matrix_3[base_solution[k], base_solution[(k+1)%n]])\n\n                    # If any objective improves, apply the move\n                    if delta_obj1 < 0 or delta_obj2 < 0 or delta_obj3 < 0:\n                        # Apply the 3-opt move (simplified)\n                        new_solution[i+1:j+1] = base_solution[i+1:j+1][::-1]\n                        new_solution[j+1:k+1] = base_solution[j+1:k+1][::-1]\n                        improved = True\n                        break\n                if improved:\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across objectives using a weighted sum\n    def tradeoff_score(objective):\n        return sum(objective)  # Simple sum for initial selection\n\n    best_solution, _ = min(archive, key=lambda x: tradeoff_score(x[1]))\n    base_solution = best_solution.copy()\n\n    # Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node to relocate\n    k = np.random.randint(0, len(new_solution))\n    node = new_solution[k]\n\n    # Remove the node and insert it in a random position\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    new_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6770500640753684,
            1.1471740126609802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off across objectives using a weighted sum\n    def tradeoff_score(objective):\n        return sum(objective)  # Simple sum for initial selection\n\n    best_solution, _ = min(archive, key=lambda x: tradeoff_score(x[1]))\n    base_solution = best_solution.copy()\n\n    # Apply a hybrid local search combining 2-opt and node insertion\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions for 2-opt\n    i, j = np.random.choice(len(new_solution), 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Perform 2-opt\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Randomly select a node to relocate\n    k = np.random.randint(0, len(new_solution))\n    node = new_solution[k]\n\n    # Remove the node and insert it in a random position\n    new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n    new_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-specific edge swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Determine which objective to prioritize for edge swaps\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Perform objective-specific edge swaps\n    if worst_obj_idx == 0:\n        # Swap edges in the first objective space\n        for k in range(i, j):\n            if distance_matrix_1[new_solution[k], new_solution[k+1]] > distance_matrix_1[new_solution[k], new_solution[(k+2)%n]]:\n                new_solution[k], new_solution[(k+2)%n] = new_solution[(k+2)%n], new_solution[k]\n    elif worst_obj_idx == 1:\n        # Swap edges in the second objective space\n        for k in range(i, j):\n            if distance_matrix_2[new_solution[k], new_solution[k+1]] > distance_matrix_2[new_solution[k], new_solution[(k+2)%n]]:\n                new_solution[k], new_solution[(k+2)%n] = new_solution[(k+2)%n], new_solution[k]\n    else:\n        # Swap edges in the third objective space\n        for k in range(i, j):\n            if distance_matrix_3[new_solution[k], new_solution[k+1]] > distance_matrix_3[new_solution[k], new_solution[(k+2)%n]]:\n                new_solution[k], new_solution[(k+2)%n] = new_solution[(k+2)%n], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7422714115924456,
            1.3361886739730835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt with objective-specific edge swaps\n    n = len(base_solution)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Perform 2-opt swap\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Determine which objective to prioritize for edge swaps\n    objectives = archive[selected_idx][1]\n    worst_obj_idx = np.argmax(objectives)\n\n    # Perform objective-specific edge swaps\n    if worst_obj_idx == 0:\n        # Swap edges in the first objective space\n        for k in range(i, j):\n            if distance_matrix_1[new_solution[k], new_solution[k+1]] > distance_matrix_1[new_solution[k], new_solution[(k+2)%n]]:\n                new_solution[k], new_solution[(k+2)%n] = new_solution[(k+2)%n], new_solution[k]\n    elif worst_obj_idx == 1:\n        # Swap edges in the second objective space\n        for k in range(i, j):\n            if distance_matrix_2[new_solution[k], new_solution[k+1]] > distance_matrix_2[new_solution[k], new_solution[(k+2)%n]]:\n                new_solution[k], new_solution[(k+2)%n] = new_solution[(k+2)%n], new_solution[k]\n    else:\n        # Swap edges in the third objective space\n        for k in range(i, j):\n            if distance_matrix_3[new_solution[k], new_solution[k+1]] > distance_matrix_3[new_solution[k], new_solution[(k+2)%n]]:\n                new_solution[k], new_solution[(k+2)%n] = new_solution[(k+2)%n], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(base_solution)\n    for _ in range(3):  # Perform 3 iterations of the operator\n        # Randomly select three distinct edges to reconnect\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Evaluate the three possible 3-opt moves across all objectives\n        moves = [\n            (base_solution[[i, j, k]], base_solution[[i, k, j]]),\n            (base_solution[[i, j, k]], base_solution[[j, i, k]]),\n            (base_solution[[i, j, k]], base_solution[[j, k, i]])\n        ]\n\n        best_move = None\n        best_improvement = 0\n\n        for move in moves:\n            original_segment = move[0]\n            new_segment = move[1]\n\n            # Calculate the change in total distance for each objective\n            delta_obj1 = (distance_matrix_1[original_segment[0], original_segment[1]] +\n                          distance_matrix_1[original_segment[1], original_segment[2]] +\n                          distance_matrix_1[original_segment[2], original_segment[0]]) - \\\n                         (distance_matrix_1[new_segment[0], new_segment[1]] +\n                          distance_matrix_1[new_segment[1], new_segment[2]] +\n                          distance_matrix_1[new_segment[2], new_segment[0]])\n\n            delta_obj2 = (distance_matrix_2[original_segment[0], original_segment[1]] +\n                          distance_matrix_2[original_segment[1], original_segment[2]] +\n                          distance_matrix_2[original_segment[2], original_segment[0]]) - \\\n                         (distance_matrix_2[new_segment[0], new_segment[1]] +\n                          distance_matrix_2[new_segment[1], new_segment[2]] +\n                          distance_matrix_2[new_segment[2], new_segment[0]])\n\n            delta_obj3 = (distance_matrix_3[original_segment[0], original_segment[1]] +\n                          distance_matrix_3[original_segment[1], original_segment[2]] +\n                          distance_matrix_3[original_segment[2], original_segment[0]]) - \\\n                         (distance_matrix_3[new_segment[0], new_segment[1]] +\n                          distance_matrix_3[new_segment[1], new_segment[2]] +\n                          distance_matrix_3[new_segment[2], new_segment[0]])\n\n            # Combine improvements across all objectives\n            total_improvement = -delta_obj1 - delta_obj2 - delta_obj3\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_move = new_segment\n\n        if best_move is not None:\n            # Apply the best move\n            new_solution[i], new_solution[j], new_solution[k] = best_move\n\n    return new_solution\n\n",
        "score": [
            -0.7244793316908783,
            1.6845168590545654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(base_solution)\n    for _ in range(3):  # Perform 3 iterations of the operator\n        # Randomly select three distinct edges to reconnect\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Evaluate the three possible 3-opt moves across all objectives\n        moves = [\n            (base_solution[[i, j, k]], base_solution[[i, k, j]]),\n            (base_solution[[i, j, k]], base_solution[[j, i, k]]),\n            (base_solution[[i, j, k]], base_solution[[j, k, i]])\n        ]\n\n        best_move = None\n        best_improvement = 0\n\n        for move in moves:\n            original_segment = move[0]\n            new_segment = move[1]\n\n            # Calculate the change in total distance for each objective\n            delta_obj1 = (distance_matrix_1[original_segment[0], original_segment[1]] +\n                          distance_matrix_1[original_segment[1], original_segment[2]] +\n                          distance_matrix_1[original_segment[2], original_segment[0]]) - \\\n                         (distance_matrix_1[new_segment[0], new_segment[1]] +\n                          distance_matrix_1[new_segment[1], new_segment[2]] +\n                          distance_matrix_1[new_segment[2], new_segment[0]])\n\n            delta_obj2 = (distance_matrix_2[original_segment[0], original_segment[1]] +\n                          distance_matrix_2[original_segment[1], original_segment[2]] +\n                          distance_matrix_2[original_segment[2], original_segment[0]]) - \\\n                         (distance_matrix_2[new_segment[0], new_segment[1]] +\n                          distance_matrix_2[new_segment[1], new_segment[2]] +\n                          distance_matrix_2[new_segment[2], new_segment[0]])\n\n            delta_obj3 = (distance_matrix_3[original_segment[0], original_segment[1]] +\n                          distance_matrix_3[original_segment[1], original_segment[2]] +\n                          distance_matrix_3[original_segment[2], original_segment[0]]) - \\\n                         (distance_matrix_3[new_segment[0], new_segment[1]] +\n                          distance_matrix_3[new_segment[1], new_segment[2]] +\n                          distance_matrix_3[new_segment[2], new_segment[0]])\n\n            # Combine improvements across all objectives\n            total_improvement = -delta_obj1 - delta_obj2 - delta_obj3\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_move = new_segment\n\n        if best_move is not None:\n            # Apply the best move\n            new_solution[i], new_solution[j], new_solution[k] = best_move\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or least dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering objective-aware edge swaps\n    for _ in range(3):  # Limit iterations for efficiency\n        # Select a random segment to potentially improve\n        k = np.random.randint(0, n)\n        l = (k + np.random.randint(1, n)) % n\n\n        if k > l:\n            k, l = l, k\n\n        # Evaluate the current and potential new segment\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        potential_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] +\n                          distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] +\n                          distance_matrix_3[new_solution[k], new_solution[(l+1)%n]])\n\n        if potential_cost < current_cost:\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8464505998441471,
            0.9732101559638977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., highest crowding distance or least dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Perform 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Further refine by considering objective-aware edge swaps\n    for _ in range(3):  # Limit iterations for efficiency\n        # Select a random segment to potentially improve\n        k = np.random.randint(0, n)\n        l = (k + np.random.randint(1, n)) % n\n\n        if k > l:\n            k, l = l, k\n\n        # Evaluate the current and potential new segment\n        current_cost = (distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_3[new_solution[k-1], new_solution[k]] +\n                        distance_matrix_1[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_2[new_solution[l], new_solution[(l+1)%n]] +\n                        distance_matrix_3[new_solution[l], new_solution[(l+1)%n]])\n\n        potential_cost = (distance_matrix_1[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_3[new_solution[k-1], new_solution[l]] +\n                          distance_matrix_1[new_solution[k], new_solution[(l+1)%n]] +\n                          distance_matrix_2[new_solution[k], new_solution[(l+1)%n]] +\n                          distance_matrix_3[new_solution[k], new_solution[(l+1)%n]])\n\n        if potential_cost < current_cost:\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest average objective value)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective improvements\n    for _ in range(3):  # Limit iterations to maintain efficiency\n        # Select a random segment and reverse it if it improves the total cost\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n\n        # Calculate new costs\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        if (cost1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n           (cost2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]) or \\\n           (cost3 < sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7287353213724951,
            1.7571903586387634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest average objective value)\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap (2-opt)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Further refine by considering objective improvements\n    for _ in range(3):  # Limit iterations to maintain efficiency\n        # Select a random segment and reverse it if it improves the total cost\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n\n        # Calculate new costs\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n\n        # Accept if at least one objective improves\n        if (cost1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]) or \\\n           (cost2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]) or \\\n           (cost3 < sum(distance_matrix_3[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge insertion to explore the search space\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion move\n    if j < n - 1:\n        k = np.random.randint(j+1, n)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:j+1], [node], new_solution[j+1:k], new_solution[k+1:]])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid neighbor solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.711839355162506,
            0.8476316213607789
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge insertion to explore the search space\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Edge insertion move\n    if j < n - 1:\n        k = np.random.randint(j+1, n)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:j+1], [node], new_solution[j+1:k], new_solution[k+1:]])\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == len(new_solution), \"Invalid neighbor solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            objectives_sorted = objectives[sorted_indices, i]\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[j]] += (objectives_sorted[j + 1] - objectives_sorted[j - 1])\n\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt + node insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select a segment to perturb\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, n)\n\n        # Perform 2-opt on the selected segment\n        segment = new_solution[start:end]\n        reversed_segment = segment[::-1]\n        new_solution[start:end] = reversed_segment\n\n        # Insert a randomly selected node elsewhere\n        node_to_insert = np.random.choice(new_solution)\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Ensure no duplicates by removing the original occurrence\n        mask = np.ones_like(new_solution, dtype=bool)\n        mask[np.where(new_solution == node_to_insert)[0][0]] = False\n        new_solution = new_solution[mask]\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6137339767081447,
            1.9265305757522584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        crowding_distances = np.zeros(len(archive))\n\n        for i in range(3):  # For each objective\n            sorted_indices = np.argsort(objectives[:, i])\n            objectives_sorted = objectives[sorted_indices, i]\n            crowding_distances[sorted_indices[0]] = np.inf\n            crowding_distances[sorted_indices[-1]] = np.inf\n            for j in range(1, len(archive) - 1):\n                crowding_distances[sorted_indices[j]] += (objectives_sorted[j + 1] - objectives_sorted[j - 1])\n\n        selected_idx = np.argmax(crowding_distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 2-opt + node insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select a segment to perturb\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 2, n)\n\n        # Perform 2-opt on the selected segment\n        segment = new_solution[start:end]\n        reversed_segment = segment[::-1]\n        new_solution[start:end] = reversed_segment\n\n        # Insert a randomly selected node elsewhere\n        node_to_insert = np.random.choice(new_solution)\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n        # Ensure no duplicates by removing the original occurrence\n        mask = np.ones_like(new_solution, dtype=bool)\n        mask[np.where(new_solution == node_to_insert)[0][0]] = False\n        new_solution = new_solution[mask]\n\n    # Ensure the solution is a valid tour\n    if len(new_solution) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj) / len(obj) for obj in objectives]\n    sorted_indices = np.argsort(avg_objectives)\n    selected_idx = np.random.choice(sorted_indices[:max(2, len(sorted_indices) // 2)])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform a multi-objective edge swap\n    # Select two edges and swap their endpoints, choosing the best swap for the worst objective\n    if n > 3:\n        a, b, c, d = np.random.choice(range(n), 4, replace=False)\n        # Current edges: (a, b), (c, d)\n        # Proposed edges: (a, c), (b, d)\n        # Calculate the cost change across all three objectives\n        cost_change = [\n            distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]] -\n            distance_matrix_1[new_solution[a], new_solution[b]] - distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]] -\n            distance_matrix_2[new_solution[a], new_solution[b]] - distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[c]] + distance_matrix_3[new_solution[b], new_solution[d]] -\n            distance_matrix_3[new_solution[a], new_solution[b]] - distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n        # If the worst objective improves, accept the swap\n        worst_current = max(archive[selected_idx][1])\n        worst_new = max([archive[selected_idx][1][k] + cost_change[k] for k in range(3)])\n        if worst_new < worst_current:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.6852579261170952,
            0.993691623210907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    avg_objectives = [sum(obj) / len(obj) for obj in objectives]\n    sorted_indices = np.argsort(avg_objectives)\n    selected_idx = np.random.choice(sorted_indices[:max(2, len(sorted_indices) // 2)])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Combine 2-opt with a novel multi-objective edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt for the first objective\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform a multi-objective edge swap\n    # Select two edges and swap their endpoints, choosing the best swap for the worst objective\n    if n > 3:\n        a, b, c, d = np.random.choice(range(n), 4, replace=False)\n        # Current edges: (a, b), (c, d)\n        # Proposed edges: (a, c), (b, d)\n        # Calculate the cost change across all three objectives\n        cost_change = [\n            distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]] -\n            distance_matrix_1[new_solution[a], new_solution[b]] - distance_matrix_1[new_solution[c], new_solution[d]],\n            distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]] -\n            distance_matrix_2[new_solution[a], new_solution[b]] - distance_matrix_2[new_solution[c], new_solution[d]],\n            distance_matrix_3[new_solution[a], new_solution[c]] + distance_matrix_3[new_solution[b], new_solution[d]] -\n            distance_matrix_3[new_solution[a], new_solution[b]] - distance_matrix_3[new_solution[c], new_solution[d]]\n        ]\n        # If the worst objective improves, accept the swap\n        worst_current = max(archive[selected_idx][1])\n        worst_new = max([archive[selected_idx][1][k] + cost_change[k] for k in range(3)])\n        if worst_new < worst_current:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{A novel hybrid local search strategy intelligently selects a solution from the archive, prioritizing those with high potential for improvement, and applies a multi-objective edge-swap operator that dynamically balances improvements across all three objective spaces to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 5))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid edge-swap operator for multi-objective optimization\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n\n    # Ensure the swap is feasible (no revisits or skips)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the neighbor's quality across all objectives\n    def evaluate_solution(sol):\n        total_cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total_cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total_cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total_cost1, total_cost2, total_cost3)\n\n    original_costs = evaluate_solution(base_solution)\n    new_costs = evaluate_solution(new_solution)\n\n    # Accept the neighbor if it improves at least one objective\n    if any(new_cost < orig_cost for new_cost, orig_cost in zip(new_costs, original_costs)):\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.7159106591921607,
            3.1173977613449098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        selected_idx = np.random.randint(0, max(1, len(sorted_archive) // 5))\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid edge-swap operator for multi-objective optimization\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n\n    # Ensure the swap is feasible (no revisits or skips)\n    if i > j:\n        i, j = j, i\n\n    # Perform the swap\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Evaluate the neighbor's quality across all objectives\n    def evaluate_solution(sol):\n        total_cost1 = sum(distance_matrix_1[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n        total_cost2 = sum(distance_matrix_2[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n        total_cost3 = sum(distance_matrix_3[sol[k], sol[k+1]] for k in range(n-1)) + distance_matrix_3[sol[-1], sol[0]]\n        return (total_cost1, total_cost2, total_cost3)\n\n    original_costs = evaluate_solution(base_solution)\n    new_costs = evaluate_solution(new_solution)\n\n    # Accept the neighbor if it improves at least one objective\n    if any(new_cost < orig_cost for new_cost, orig_cost in zip(new_costs, original_costs)):\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranks = np.array([i for i in range(len(archive))])  # Assign ranks based on order in archive (lower index = better)\n    probs = np.exp(-ranks)  # Exponential decay to favor higher-ranked solutions\n    probs /= probs.sum()  # Normalize probabilities\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges (i, i+1), (j, j+1), (k, k+1) with i < j < k\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Determine the best reconnection based on the three objectives\n    # Evaluate all possible reconnections (3-opt moves) and select the one that improves the most in the aggregate\n    candidates = []\n    for a in [i, i+1]:\n        for b in [j, j+1]:\n            for c in [k, k+1]:\n                if a == b or b == c or a == c:\n                    continue  # Skip invalid reconnections\n                # Create a candidate solution by reversing the segment between a and b, then between b and c\n                candidate = new_solution.copy()\n                candidate[a:b] = candidate[a:b][::-1]\n                candidate[b:c] = candidate[b:c][::-1]\n                # Calculate the total cost for the candidate\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n                candidates.append((cost1, cost2, cost3, candidate))\n\n    # Select the candidate with the best aggregate improvement across all objectives\n    if candidates:\n        # Normalize costs to avoid bias towards objectives with larger scales\n        costs = np.array([(c1, c2, c3) for c1, c2, c3, _ in candidates])\n        costs = (costs - costs.mean(axis=0)) / costs.std(axis=0)  # Standardize\n        aggregate_costs = costs.sum(axis=1)\n        best_idx = np.argmin(aggregate_costs)\n        new_solution = candidates[best_idx][3]\n\n    return new_solution\n\n",
        "score": [
            -0.6334943538174244,
            2.6157043814659118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranks = np.array([i for i in range(len(archive))])  # Assign ranks based on order in archive (lower index = better)\n    probs = np.exp(-ranks)  # Exponential decay to favor higher-ranked solutions\n    probs /= probs.sum()  # Normalize probabilities\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges (i, i+1), (j, j+1), (k, k+1) with i < j < k\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Determine the best reconnection based on the three objectives\n    # Evaluate all possible reconnections (3-opt moves) and select the one that improves the most in the aggregate\n    candidates = []\n    for a in [i, i+1]:\n        for b in [j, j+1]:\n            for c in [k, k+1]:\n                if a == b or b == c or a == c:\n                    continue  # Skip invalid reconnections\n                # Create a candidate solution by reversing the segment between a and b, then between b and c\n                candidate = new_solution.copy()\n                candidate[a:b] = candidate[a:b][::-1]\n                candidate[b:c] = candidate[b:c][::-1]\n                # Calculate the total cost for the candidate\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n                cost3 = sum(distance_matrix_3[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_3[candidate[-1], candidate[0]]\n                candidates.append((cost1, cost2, cost3, candidate))\n\n    # Select the candidate with the best aggregate improvement across all objectives\n    if candidates:\n        # Normalize costs to avoid bias towards objectives with larger scales\n        costs = np.array([(c1, c2, c3) for c1, c2, c3, _ in candidates])\n        costs = (costs - costs.mean(axis=0)) / costs.std(axis=0)  # Standardize\n        aggregate_costs = costs.sum(axis=1)\n        best_idx = np.argmin(aggregate_costs)\n        new_solution = candidates[best_idx][3]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.mean(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-specific swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-specific swaps to further improve the solution\n    for _ in range(3):  # Perform 3 random objective-specific swaps\n        obj = np.random.choice([0, 1, 2])  # Randomly select an objective\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Evaluate the swap in the selected objective\n        if obj == 0:\n            current_cost = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n            new_cost = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        elif obj == 1:\n            current_cost = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n            new_cost = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n        else:\n            current_cost = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            new_cost = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]\n\n        # Perform the swap if it improves the selected objective\n        if new_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6367919439475667,
            3.0909531116485596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: np.mean(x[1]))[0].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-specific swaps\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to apply 2-opt\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply objective-specific swaps to further improve the solution\n    for _ in range(3):  # Perform 3 random objective-specific swaps\n        obj = np.random.choice([0, 1, 2])  # Randomly select an objective\n        k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n        # Evaluate the swap in the selected objective\n        if obj == 0:\n            current_cost = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l], new_solution[(l+1)%n]]\n            new_cost = distance_matrix_1[new_solution[k-1], new_solution[l]] + distance_matrix_1[new_solution[k], new_solution[(l+1)%n]]\n        elif obj == 1:\n            current_cost = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l], new_solution[(l+1)%n]]\n            new_cost = distance_matrix_2[new_solution[k-1], new_solution[l]] + distance_matrix_2[new_solution[k], new_solution[(l+1)%n]]\n        else:\n            current_cost = distance_matrix_3[new_solution[k-1], new_solution[k]] + distance_matrix_3[new_solution[l], new_solution[(l+1)%n]]\n            new_cost = distance_matrix_3[new_solution[k-1], new_solution[l]] + distance_matrix_3[new_solution[k], new_solution[(l+1)%n]]\n\n        # Perform the swap if it improves the selected objective\n        if new_cost < current_cost:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge scores based on the three objectives\n    def edge_score(i, j):\n        # Current edges in the solution\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        # Potential new edges\n        new_edges = [(a, d), (c, b)]\n\n        # Calculate total cost for the three objectives\n        cost1 = (distance_matrix_1[a, d] + distance_matrix_1[c, b] -\n                 distance_matrix_1[a, b] - distance_matrix_1[c, d])\n        cost2 = (distance_matrix_2[a, d] + distance_matrix_2[c, b] -\n                 distance_matrix_2[a, b] - distance_matrix_2[c, d])\n        cost3 = (distance_matrix_3[a, d] + distance_matrix_3[c, b] -\n                 distance_matrix_3[a, b] - distance_matrix_3[c, d])\n\n        # Weighted score based on improvement potential\n        return (cost1 + cost2 + cost3) / 3\n\n    # Perform 2-opt with the best improvement\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n):\n        for j in range(i+2, n):\n            improvement = edge_score(i, j)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7077452570911126,
            2.793178045749664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate edge scores based on the three objectives\n    def edge_score(i, j):\n        # Current edges in the solution\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        # Potential new edges\n        new_edges = [(a, d), (c, b)]\n\n        # Calculate total cost for the three objectives\n        cost1 = (distance_matrix_1[a, d] + distance_matrix_1[c, b] -\n                 distance_matrix_1[a, b] - distance_matrix_1[c, d])\n        cost2 = (distance_matrix_2[a, d] + distance_matrix_2[c, b] -\n                 distance_matrix_2[a, b] - distance_matrix_2[c, d])\n        cost3 = (distance_matrix_3[a, d] + distance_matrix_3[c, b] -\n                 distance_matrix_3[a, b] - distance_matrix_3[c, d])\n\n        # Weighted score based on improvement potential\n        return (cost1 + cost2 + cost3) / 3\n\n    # Perform 2-opt with the best improvement\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n):\n        for j in range(i+2, n):\n            improvement = edge_score(i, j)\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_i, best_j = i, j\n\n    if best_i != -1:\n        # Apply the 2-opt move\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{The algorithm selects a solution with the highest potential for improvement by combining a multi-objective ranking criterion with a randomized selection, then applies a hybrid local search that performs 2-opt moves in each objective space while ensuring feasibility and non-dominated solutions, followed by a dynamic edge exchange operator to further optimize across all objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomized selection)\n    selected_idx = np.random.choice(len(archive), p=np.ones(len(archive)) / len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt local search in each objective space\n    for _ in range(10):  # Number of iterations\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution = new_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check feasibility and dominance\n        if len(np.unique(new_solution)) == len(base_solution):\n            # Evaluate the new solution\n            cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            cost3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # Check if the new solution is non-dominated compared to the original\n            original_costs = archive[selected_idx][1]\n            if not (cost1 > original_costs[0] and cost2 > original_costs[1] and cost3 > original_costs[2]):\n                base_solution = new_solution.copy()\n\n    # Perform dynamic edge exchange to optimize across all objectives\n    for _ in range(5):  # Number of iterations\n        i, j = sorted(np.random.choice(len(base_solution), 2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == len(base_solution):\n            base_solution = new_solution.copy()\n\n    return base_solution\n\n",
        "score": [
            -0.7492784831550237,
            3.477803957462311
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomized selection)\n    selected_idx = np.random.choice(len(archive), p=np.ones(len(archive)) / len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform 2-opt local search in each objective space\n    for _ in range(10):  # Number of iterations\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n        new_solution = new_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check feasibility and dominance\n        if len(np.unique(new_solution)) == len(base_solution):\n            # Evaluate the new solution\n            cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            cost3 = sum(distance_matrix_3[new_solution[k], new_solution[k+1]] for k in range(len(new_solution)-1)) + distance_matrix_3[new_solution[-1], new_solution[0]]\n\n            # Check if the new solution is non-dominated compared to the original\n            original_costs = archive[selected_idx][1]\n            if not (cost1 > original_costs[0] and cost2 > original_costs[1] and cost3 > original_costs[2]):\n                base_solution = new_solution.copy()\n\n    # Perform dynamic edge exchange to optimize across all objectives\n    for _ in range(5):  # Number of iterations\n        i, j = sorted(np.random.choice(len(base_solution), 2, replace=False))\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if len(np.unique(new_solution)) == len(base_solution):\n            base_solution = new_solution.copy()\n\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance for each objective\n    crowding_distances = []\n    for i in range(3):\n        sorted_obj = sorted([obj[i] for obj in objectives])\n        crowding = [0.0] * len(sorted_obj)\n        if len(sorted_obj) > 2:\n            min_obj, max_obj = sorted_obj[0], sorted_obj[-1]\n            for j in range(1, len(sorted_obj)-1):\n                crowding[j] = (sorted_obj[j+1] - sorted_obj[j-1]) / (max_obj - min_obj)\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances and select the solution with the highest total\n    total_crowding = [sum(crowding_distances[i][j] for i in range(3)) for j in range(len(objectives))]\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to swap, biased towards those with high distance in any objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the change in total distance for each objective\n    def calculate_delta(sol, i, j, k, l):\n        delta1 = (distance_matrix_1[sol[i], sol[k]] + distance_matrix_1[sol[j], sol[l]]\n                 - distance_matrix_1[sol[i], sol[j]] - distance_matrix_1[sol[k], sol[l]])\n        delta2 = (distance_matrix_2[sol[i], sol[k]] + distance_matrix_2[sol[j], sol[l]]\n                 - distance_matrix_2[sol[i], sol[j]] - distance_matrix_2[sol[k], sol[l]])\n        delta3 = (distance_matrix_3[sol[i], sol[k]] + distance_matrix_3[sol[j], sol[l]]\n                 - distance_matrix_3[sol[i], sol[j]] - distance_matrix_3[sol[k], sol[l]])\n        return delta1, delta2, delta3\n\n    delta1, delta2, delta3 = calculate_delta(new_solution, i, j, k, l)\n\n    # If the swap improves any objective, apply it\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a second 2-opt move to further improve the solution\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7123758615471714,
            1.8725727558135987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance for each objective\n    crowding_distances = []\n    for i in range(3):\n        sorted_obj = sorted([obj[i] for obj in objectives])\n        crowding = [0.0] * len(sorted_obj)\n        if len(sorted_obj) > 2:\n            min_obj, max_obj = sorted_obj[0], sorted_obj[-1]\n            for j in range(1, len(sorted_obj)-1):\n                crowding[j] = (sorted_obj[j+1] - sorted_obj[j-1]) / (max_obj - min_obj)\n        crowding_distances.append(crowding)\n\n    # Combine crowding distances and select the solution with the highest total\n    total_crowding = [sum(crowding_distances[i][j] for i in range(3)) for j in range(len(objectives))]\n    selected_idx = np.argmax(total_crowding)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Apply a hybrid local search: 2-opt with objective-aware edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to swap, biased towards those with high distance in any objective\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Calculate the change in total distance for each objective\n    def calculate_delta(sol, i, j, k, l):\n        delta1 = (distance_matrix_1[sol[i], sol[k]] + distance_matrix_1[sol[j], sol[l]]\n                 - distance_matrix_1[sol[i], sol[j]] - distance_matrix_1[sol[k], sol[l]])\n        delta2 = (distance_matrix_2[sol[i], sol[k]] + distance_matrix_2[sol[j], sol[l]]\n                 - distance_matrix_2[sol[i], sol[j]] - distance_matrix_2[sol[k], sol[l]])\n        delta3 = (distance_matrix_3[sol[i], sol[k]] + distance_matrix_3[sol[j], sol[l]]\n                 - distance_matrix_3[sol[i], sol[j]] - distance_matrix_3[sol[k], sol[l]])\n        return delta1, delta2, delta3\n\n    delta1, delta2, delta3 = calculate_delta(new_solution, i, j, k, l)\n\n    # If the swap improves any objective, apply it\n    if delta1 < 0 or delta2 < 0 or delta3 < 0:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply a second 2-opt move to further improve the solution\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and reinsert it (edge insertion)\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if insertion causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.4664918231198486,
            1.3779245734214782
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = max(archive, key=lambda x: max(x[1]) - min(x[1]))\n    base_solution = selected[0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select a node and reinsert it (edge insertion)\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    l = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if insertion causes duplicates\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap is feasible and improves at least one objective\n    if i != k and j != l:\n        # Perform the swap\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n        new_solution[k:l+1] = selected_solution[k:l+1][::-1]\n\n        # Check if the new solution is valid (visits all nodes exactly once)\n        if len(set(new_solution)) == n:\n            return new_solution\n\n    # If the hybrid operator fails, fall back to a simple 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7526481192499499,
            0.877941632270813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 2-opt with multi-objective edge swaps\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct edges to swap\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap is feasible and improves at least one objective\n    if i != k and j != l:\n        # Perform the swap\n        new_solution[i:j+1] = selected_solution[i:j+1][::-1]\n        new_solution[k:l+1] = selected_solution[k:l+1][::-1]\n\n        # Check if the new solution is valid (visits all nodes exactly once)\n        if len(set(new_solution)) == n:\n            return new_solution\n\n    # If the hybrid operator fails, fall back to a simple 2-opt\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combined metric of objective values (e.g., sum of normalized objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]) / len(x[1]))\n        # Select among the top 30% of solutions with some randomness\n        selected_index = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n        selected_solution = archive_sorted[selected_index][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Select edges to swap based on their contribution to the worst objective\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Identify edges that significantly contribute to the worst objective\n        max_obj = max(obj1, obj2, obj3)\n        if max_obj == obj1:\n            matrix = distance_matrix_1\n        elif max_obj == obj2:\n            matrix = distance_matrix_2\n        else:\n            matrix = distance_matrix_3\n\n        # Find the two edges with highest contribution to the worst objective\n        edge_contributions = [matrix[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        sorted_edges = sorted(range(n), key=lambda i: -edge_contributions[i])\n        i, j = sorted_edges[0], sorted_edges[1]\n\n        # Ensure i < j for 2-opt\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt move\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.697411650033521,
            4.283273673057556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combined metric of objective values (e.g., sum of normalized objectives)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]) / len(x[1]))\n        # Select among the top 30% of solutions with some randomness\n        selected_index = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n        selected_solution = archive_sorted[selected_index][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Apply a hybrid local search operator: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations\n        # Select edges to swap based on their contribution to the worst objective\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        obj3 = sum(distance_matrix_3[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # Identify edges that significantly contribute to the worst objective\n        max_obj = max(obj1, obj2, obj3)\n        if max_obj == obj1:\n            matrix = distance_matrix_1\n        elif max_obj == obj2:\n            matrix = distance_matrix_2\n        else:\n            matrix = distance_matrix_3\n\n        # Find the two edges with highest contribution to the worst objective\n        edge_contributions = [matrix[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        sorted_edges = sorted(range(n), key=lambda i: -edge_contributions[i])\n        i, j = sorted_edges[0], sorted_edges[1]\n\n        # Ensure i < j for 2-opt\n        if i > j:\n            i, j = j, i\n\n        # Apply 2-opt move\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{The algorithm intelligently selects a promising solution from the archive by evaluating the diversity and potential for local improvement, then applies a hybrid local search operator combining 2-opt and edge exchange to generate a neighbor solution while ensuring feasibility across all three objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange to further improve the solution\n    k, l = random.sample(range(n), 2)\n    if k > l:\n        k, l = l, k\n\n    # Ensure the exchange maintains feasibility\n    temp = new_solution[k].copy()\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7438958661970415,
            0.7827395319938659
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Apply a hybrid local search operator\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct positions\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Apply 2-opt move\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply edge exchange to further improve the solution\n    k, l = random.sample(range(n), 2)\n    if k > l:\n        k, l = l, k\n\n    # Ensure the exchange maintains feasibility\n    temp = new_solution[k].copy()\n    new_solution[k] = new_solution[l]\n    new_solution[l] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge exchange to explore the solution space\n    # while considering all three objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment for the first objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n        if distance_matrix_1[segment[k-1]][segment[k]] + distance_matrix_1[segment[l-1]][segment[l]] > \\\n           distance_matrix_1[segment[k-1]][segment[l-1]] + distance_matrix_1[segment[k]][segment[l]]:\n            segment[k:l] = segment[k:l][::-1]\n\n    # Apply edge exchange considering the second and third objectives\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]] + \\\n           distance_matrix_3[new_solution[a-1]][new_solution[a]] + distance_matrix_3[new_solution[b-1]][new_solution[b]] > \\\n           distance_matrix_2[new_solution[a-1]][new_solution[b]] + distance_matrix_2[new_solution[b-1]][new_solution[a]] + \\\n           distance_matrix_3[new_solution[a-1]][new_solution[b]] + distance_matrix_3[new_solution[b-1]][new_solution[a]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Reconstruct the solution with the modified segment\n    new_solution[i:j+1] = segment\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6787966286636835,
            2.542803716659546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # We use a combination of 2-opt and edge exchange to explore the solution space\n    # while considering all three objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Apply 2-opt within the segment for the first objective\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        k, l = sorted(np.random.choice(len(segment), 2, replace=False))\n        if distance_matrix_1[segment[k-1]][segment[k]] + distance_matrix_1[segment[l-1]][segment[l]] > \\\n           distance_matrix_1[segment[k-1]][segment[l-1]] + distance_matrix_1[segment[k]][segment[l]]:\n            segment[k:l] = segment[k:l][::-1]\n\n    # Apply edge exchange considering the second and third objectives\n    for _ in range(5):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        if distance_matrix_2[new_solution[a-1]][new_solution[a]] + distance_matrix_2[new_solution[b-1]][new_solution[b]] + \\\n           distance_matrix_3[new_solution[a-1]][new_solution[a]] + distance_matrix_3[new_solution[b-1]][new_solution[b]] > \\\n           distance_matrix_2[new_solution[a-1]][new_solution[b]] + distance_matrix_2[new_solution[b-1]][new_solution[a]] + \\\n           distance_matrix_3[new_solution[a-1]][new_solution[b]] + distance_matrix_3[new_solution[b-1]][new_solution[a]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Reconstruct the solution with the modified segment\n    new_solution[i:j+1] = segment\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a 3-opt local search to the selected solution\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to perform the 3-opt move\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create three possible new tours by reversing segments between the selected edges\n    option1 = new_solution.copy()\n    option1[i:j] = new_solution[i:j][::-1]\n\n    option2 = new_solution.copy()\n    option2[j:k] = new_solution[j:k][::-1]\n\n    option3 = new_solution.copy()\n    option3[i:k] = new_solution[i:k][::-1]\n    option3[j:k] = option3[j:k][::-1]\n\n    # Evaluate all options based on the sum of objectives in all three spaces\n    def evaluate(solution):\n        total_cost = 0\n        for space, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            cost = sum(dist_matrix[solution[i], solution[i+1]] for i in range(len(solution)-1))\n            cost += dist_matrix[solution[-1], solution[0]]  # Return to start\n            total_cost += cost\n        return total_cost\n\n    options = [option1, option2, option3]\n    best_option = min(options, key=evaluate)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(best_option)) == n:\n        new_solution = best_option\n\n    return new_solution\n\n",
        "score": [
            -0.6577395803584746,
            1.4847872972488403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a 3-opt local search to the selected solution\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to perform the 3-opt move\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Create three possible new tours by reversing segments between the selected edges\n    option1 = new_solution.copy()\n    option1[i:j] = new_solution[i:j][::-1]\n\n    option2 = new_solution.copy()\n    option2[j:k] = new_solution[j:k][::-1]\n\n    option3 = new_solution.copy()\n    option3[i:k] = new_solution[i:k][::-1]\n    option3[j:k] = option3[j:k][::-1]\n\n    # Evaluate all options based on the sum of objectives in all three spaces\n    def evaluate(solution):\n        total_cost = 0\n        for space, dist_matrix in enumerate([distance_matrix_1, distance_matrix_2, distance_matrix_3]):\n            cost = sum(dist_matrix[solution[i], solution[i+1]] for i in range(len(solution)-1))\n            cost += dist_matrix[solution[-1], solution[0]]  # Return to start\n            total_cost += cost\n        return total_cost\n\n    options = [option1, option2, option3]\n    best_option = min(options, key=evaluate)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(best_option)) == n:\n        new_solution = best_option\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the sum of normalized objectives for each solution\n    normalized_objectives = []\n    for sol, obj in archive:\n        # Normalize objectives (assuming all objectives are positive)\n        norm_obj = (obj[0] / distance_matrix_1.sum(), obj[1] / distance_matrix_2.sum(), obj[2] / distance_matrix_3.sum())\n        normalized_objectives.append((sol, norm_obj))\n\n    # Select the solution with the best trade-off (minimizing the sum of normalized objectives)\n    selected = min(normalized_objectives, key=lambda x: sum(x[1]))[0]\n    base_solution = selected.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions to swap\n    i, j = random.sample(range(len(new_solution)), 2)\n\n    # Perform a 2-opt move (swap two edges)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.5957935608028342,
            3.3179760456085203
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the sum of normalized objectives for each solution\n    normalized_objectives = []\n    for sol, obj in archive:\n        # Normalize objectives (assuming all objectives are positive)\n        norm_obj = (obj[0] / distance_matrix_1.sum(), obj[1] / distance_matrix_2.sum(), obj[2] / distance_matrix_3.sum())\n        normalized_objectives.append((sol, norm_obj))\n\n    # Select the solution with the best trade-off (minimizing the sum of normalized objectives)\n    selected = min(normalized_objectives, key=lambda x: sum(x[1]))[0]\n    base_solution = selected.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct positions to swap\n    i, j = random.sample(range(len(new_solution)), 2)\n\n    # Perform a 2-opt move (swap two edges)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Step 2: Hybrid local search operator combining 2-opt and multi-objective edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb (2-opt like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swapping: identify edges that are critical in any objective\n    for _ in range(3):  # Perform limited number of swaps to balance exploration and exploitation\n        # Find edges with high contribution to any objective\n        edge_contributions = []\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            contrib = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n            edge_contributions.append((contrib, k))\n\n        # Sort edges by contribution and select the worst ones to swap\n        edge_contributions.sort(reverse=True)\n        _, worst_edge = edge_contributions[0]\n\n        # Perform a 2-opt swap on the selected edge\n        a, b = worst_edge, (worst_edge + 1) % n\n        c, d = (worst_edge + 2) % n, (worst_edge + 3) % n\n        if np.random.rand() < 0.5:\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5435167167268379,
            1.4243967056274414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n\n    # Step 2: Hybrid local search operator combining 2-opt and multi-objective edge swapping\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to perturb (2-opt like move)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Multi-objective edge swapping: identify edges that are critical in any objective\n    for _ in range(3):  # Perform limited number of swaps to balance exploration and exploitation\n        # Find edges with high contribution to any objective\n        edge_contributions = []\n        for k in range(n):\n            a, b = new_solution[k], new_solution[(k+1)%n]\n            contrib = (distance_matrix_1[a, b] + distance_matrix_2[a, b] + distance_matrix_3[a, b]) / 3\n            edge_contributions.append((contrib, k))\n\n        # Sort edges by contribution and select the worst ones to swap\n        edge_contributions.sort(reverse=True)\n        _, worst_edge = edge_contributions[0]\n\n        # Perform a 2-opt swap on the selected edge\n        a, b = worst_edge, (worst_edge + 1) % n\n        c, d = (worst_edge + 2) % n, (worst_edge + 3) % n\n        if np.random.rand() < 0.5:\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Tri-objective Travelling Salesman Problem (bi-TSP), where each node has three different 2D coordinates: (x1, y1), (x2, y2) and (x3, y3), representing its position in three objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing three objectives simultaneously: the total tour length in each coordinate space. Given an archive of non-dominated solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of three values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited. Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement.Using a creative local search strategy of your own design, specifically tailored to effectively optimize across three objectives, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity (sum of standard deviations of objectives)\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0).sum()\n        # Select the solution with highest diversity\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate edge weights based on all three objectives\n    edge_weights = (\n        distance_matrix_1[new_solution[i], new_solution[j]] +\n        distance_matrix_2[new_solution[i], new_solution[j]] +\n        distance_matrix_3[new_solution[i], new_solution[j]]\n    )\n\n    # Apply 2-opt with probability inversely proportional to edge weight\n    if np.random.rand() < 1 / (1 + edge_weights):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation: swap two random nodes (maintains feasibility)\n    k, l = np.random.choice(n, 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6578104858535825,
            1.0528956770896911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray, distance_matrix_3: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of three float values.\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n    distance_matrix_3: Distance matrix in the third objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity (sum of standard deviations of objectives)\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.std(objectives, axis=0).sum()\n        # Select the solution with highest diversity\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 2-opt with objective-aware edge selection\n    n = len(new_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Calculate edge weights based on all three objectives\n    edge_weights = (\n        distance_matrix_1[new_solution[i], new_solution[j]] +\n        distance_matrix_2[new_solution[i], new_solution[j]] +\n        distance_matrix_3[new_solution[i], new_solution[j]]\n    )\n\n    # Apply 2-opt with probability inversely proportional to edge weight\n    if np.random.rand() < 1 / (1 + edge_weights):\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation: swap two random nodes (maintains feasibility)\n    k, l = np.random.choice(n, 2, replace=False)\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    }
]