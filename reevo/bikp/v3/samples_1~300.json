[
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not extreme in both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity_scores = np.max(normalized, axis=1) - np.min(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (intensification)\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Remove items that violate capacity (diversification)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Step 3: Add promising items not in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidate_items)\n    for item in candidate_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Step 4: Local search to improve both objectives\n    improved = True\n    while improved:\n        improved = False\n        for item in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = np.sum(value1_lst[temp_solution == 1])\n                temp_value2 = np.sum(value2_lst[temp_solution == 1])\n\n                # Check if adding improves at least one objective\n                if (temp_value1 > np.sum(value1_lst[new_solution == 1]) or\n                    temp_value2 > np.sum(value2_lst[new_solution == 1])):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    improved = True\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4848577595923328,
            8.071510642766953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not extreme in both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity_scores = np.max(normalized, axis=1) - np.min(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (intensification)\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Remove items that violate capacity (diversification)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Step 3: Add promising items not in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidate_items)\n    for item in candidate_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Step 4: Local search to improve both objectives\n    improved = True\n    while improved:\n        improved = False\n        for item in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = np.sum(value1_lst[temp_solution == 1])\n                temp_value2 = np.sum(value2_lst[temp_solution == 1])\n\n                # Check if adding improves at least one objective\n                if (temp_value1 > np.sum(value1_lst[new_solution == 1]) or\n                    temp_value2 > np.sum(value2_lst[new_solution == 1])):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    improved = True\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not extreme in both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity_scores = np.max(normalized, axis=1) - np.min(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (intensification)\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Remove items that violate capacity (diversification)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Step 3: Add promising items not in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidate_items)\n    for item in candidate_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Step 4: Local search to improve both objectives\n    improved = True\n    while improved:\n        improved = False\n        for item in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = np.sum(value1_lst[temp_solution == 1])\n                temp_value2 = np.sum(value2_lst[temp_solution == 1])\n\n                # Check if adding improves at least one objective\n                if (temp_value1 > np.sum(value1_lst[new_solution == 1]) or\n                    temp_value2 > np.sum(value2_lst[new_solution == 1])):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    improved = True\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4848577595923328,
            8.071510642766953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not extreme in both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity_scores = np.max(normalized, axis=1) - np.min(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (intensification)\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Remove items that violate capacity (diversification)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Step 3: Add promising items not in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidate_items)\n    for item in candidate_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Step 4: Local search to improve both objectives\n    improved = True\n    while improved:\n        improved = False\n        for item in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = np.sum(value1_lst[temp_solution == 1])\n                temp_value2 = np.sum(value2_lst[temp_solution == 1])\n\n                # Check if adding improves at least one objective\n                if (temp_value1 > np.sum(value1_lst[new_solution == 1]) or\n                    temp_value2 > np.sum(value2_lst[new_solution == 1])):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    improved = True\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not extreme in both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity_scores = np.max(normalized, axis=1) - np.min(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (intensification)\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Remove items that violate capacity (diversification)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Step 3: Add promising items not in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidate_items)\n    for item in candidate_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Step 4: Local search to improve both objectives\n    improved = True\n    while improved:\n        improved = False\n        for item in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = np.sum(value1_lst[temp_solution == 1])\n                temp_value2 = np.sum(value2_lst[temp_solution == 1])\n\n                # Check if adding improves at least one objective\n                if (temp_value1 > np.sum(value1_lst[new_solution == 1]) or\n                    temp_value2 > np.sum(value2_lst[new_solution == 1])):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    improved = True\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.4848577595923328,
            8.071510642766953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not extreme in both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    diversity_scores = np.max(normalized, axis=1) - np.min(normalized, axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (intensification)\n    flip_mask = np.random.rand(n_items) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Remove items that violate capacity (diversification)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = np.random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Step 3: Add promising items not in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(candidate_items)\n    for item in candidate_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    # Step 4: Local search to improve both objectives\n    improved = True\n    while improved:\n        improved = False\n        for item in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[item] <= capacity:\n                temp_solution = new_solution.copy()\n                temp_solution[item] = 1\n                temp_weight = current_weight + weight_lst[item]\n                temp_value1 = np.sum(value1_lst[temp_solution == 1])\n                temp_value2 = np.sum(value2_lst[temp_solution == 1])\n\n                # Check if adding improves at least one objective\n                if (temp_value1 > np.sum(value1_lst[new_solution == 1]) or\n                    temp_value2 > np.sum(value2_lst[new_solution == 1])):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    improved = True\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip some items (exploration)\n    # 2. Use value-to-weight ratio to flip items that improve both objectives (exploitation)\n\n    # Random flips (exploration)\n    flip_mask = np.random.rand(len(base_solution)) < 0.2  # 20% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility after random flips\n    temp_weight = np.sum(weight_lst * new_solution)\n    if temp_weight > capacity:\n        # Remove items randomly until feasible\n        excess_mask = new_solution.copy()\n        while temp_weight > capacity and np.any(excess_mask):\n            excess_items = np.where(excess_mask)[0]\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            temp_weight -= weight_lst[remove_idx]\n            excess_mask[remove_idx] = 0\n\n    # Value-to-weight ratio heuristic (exploitation)\n    # Calculate normalized value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Add small epsilon to avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combined ratio (harmonic mean to balance both objectives)\n    combined_ratio = 2 * (ratio1 * ratio2) / (ratio1 + ratio2 + 1e-10)\n\n    # Sort items by combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Try to add items with highest combined ratio if there's remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    for idx in sorted_indices:\n        if remaining_capacity >= weight_lst[idx] and not new_solution[idx]:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Try to remove items with lowest combined ratio if over capacity\n    if np.sum(weight_lst * new_solution) > capacity:\n        current_weight = np.sum(weight_lst * new_solution)\n        sorted_indices = np.argsort(combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4028751584550092,
            2.997727006673813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip some items (exploration)\n    # 2. Use value-to-weight ratio to flip items that improve both objectives (exploitation)\n\n    # Random flips (exploration)\n    flip_mask = np.random.rand(len(base_solution)) < 0.2  # 20% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility after random flips\n    temp_weight = np.sum(weight_lst * new_solution)\n    if temp_weight > capacity:\n        # Remove items randomly until feasible\n        excess_mask = new_solution.copy()\n        while temp_weight > capacity and np.any(excess_mask):\n            excess_items = np.where(excess_mask)[0]\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            temp_weight -= weight_lst[remove_idx]\n            excess_mask[remove_idx] = 0\n\n    # Value-to-weight ratio heuristic (exploitation)\n    # Calculate normalized value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Add small epsilon to avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combined ratio (harmonic mean to balance both objectives)\n    combined_ratio = 2 * (ratio1 * ratio2) / (ratio1 + ratio2 + 1e-10)\n\n    # Sort items by combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Try to add items with highest combined ratio if there's remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    for idx in sorted_indices:\n        if remaining_capacity >= weight_lst[idx] and not new_solution[idx]:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Try to remove items with lowest combined ratio if over capacity\n    if np.sum(weight_lst * new_solution) > capacity:\n        current_weight = np.sum(weight_lst * new_solution)\n        sorted_indices = np.argsort(combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip some items (exploration)\n    # 2. Use value-to-weight ratio to flip items that improve both objectives (exploitation)\n\n    # Random flips (exploration)\n    flip_mask = np.random.rand(len(base_solution)) < 0.2  # 20% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility after random flips\n    temp_weight = np.sum(weight_lst * new_solution)\n    if temp_weight > capacity:\n        # Remove items randomly until feasible\n        excess_mask = new_solution.copy()\n        while temp_weight > capacity and np.any(excess_mask):\n            excess_items = np.where(excess_mask)[0]\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            temp_weight -= weight_lst[remove_idx]\n            excess_mask[remove_idx] = 0\n\n    # Value-to-weight ratio heuristic (exploitation)\n    # Calculate normalized value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Add small epsilon to avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combined ratio (harmonic mean to balance both objectives)\n    combined_ratio = 2 * (ratio1 * ratio2) / (ratio1 + ratio2 + 1e-10)\n\n    # Sort items by combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Try to add items with highest combined ratio if there's remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    for idx in sorted_indices:\n        if remaining_capacity >= weight_lst[idx] and not new_solution[idx]:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Try to remove items with lowest combined ratio if over capacity\n    if np.sum(weight_lst * new_solution) > capacity:\n        current_weight = np.sum(weight_lst * new_solution)\n        sorted_indices = np.argsort(combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4028751584550092,
            2.997727006673813
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip some items (exploration)\n    # 2. Use value-to-weight ratio to flip items that improve both objectives (exploitation)\n\n    # Random flips (exploration)\n    flip_mask = np.random.rand(len(base_solution)) < 0.2  # 20% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility after random flips\n    temp_weight = np.sum(weight_lst * new_solution)\n    if temp_weight > capacity:\n        # Remove items randomly until feasible\n        excess_mask = new_solution.copy()\n        while temp_weight > capacity and np.any(excess_mask):\n            excess_items = np.where(excess_mask)[0]\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            temp_weight -= weight_lst[remove_idx]\n            excess_mask[remove_idx] = 0\n\n    # Value-to-weight ratio heuristic (exploitation)\n    # Calculate normalized value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Add small epsilon to avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combined ratio (harmonic mean to balance both objectives)\n    combined_ratio = 2 * (ratio1 * ratio2) / (ratio1 + ratio2 + 1e-10)\n\n    # Sort items by combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    # Try to add items with highest combined ratio if there's remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    for idx in sorted_indices:\n        if remaining_capacity >= weight_lst[idx] and not new_solution[idx]:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Try to remove items with lowest combined ratio if over capacity\n    if np.sum(weight_lst * new_solution) > capacity:\n        current_weight = np.sum(weight_lst * new_solution)\n        sorted_indices = np.argsort(combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Solutions with higher value ratios are more likely to be selected\n    solution_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            remaining_capacity = 0\n        # Score based on potential to improve both objectives\n        score = (obj[0] + obj[1]) * (1 + remaining_capacity / capacity)\n        solution_scores.append(score)\n\n    # Normalize scores to probabilities\n    solution_probs = np.array(solution_scores) / np.sum(solution_scores)\n    selected_idx = np.random.choice(len(archive), p=solution_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with value-weighted swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify candidate items to swap (either 0->1 or 1->0)\n    # Prefer items that are not in the solution but have high value ratios\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Calculate value ratios for zero items\n    if len(zero_indices) > 0:\n        zero_value_ratios = (value1_lst[zero_indices] + value2_lst[zero_indices]) / weight_lst[zero_indices]\n        zero_probs = zero_value_ratios / np.sum(zero_value_ratios)\n        selected_zero = np.random.choice(zero_indices, p=zero_probs)\n\n        # If adding this item doesn't exceed capacity, do it\n        if weight_lst[selected_zero] <= remaining_capacity:\n            new_solution[selected_zero] = 1\n            current_weight += weight_lst[selected_zero]\n            remaining_capacity = capacity - current_weight\n\n    # Also consider removing low-value items\n    if len(one_indices) > 0:\n        one_value_ratios = (value1_lst[one_indices] + value2_lst[one_indices]) / weight_lst[one_indices]\n        one_probs = 1 / (one_value_ratios + 1e-6)  # Prefer removing low-value items\n        one_probs = one_probs / np.sum(one_probs)\n        selected_one = np.random.choice(one_indices, p=one_probs)\n\n        # Remove this item to free up capacity\n        new_solution[selected_one] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, remove random items until feasible\n        while total_weight > capacity:\n            one_indices = np.where(new_solution == 1)[0]\n            if len(one_indices) == 0:\n                break\n            selected_one = np.random.choice(one_indices)\n            new_solution[selected_one] = 0\n            total_weight -= weight_lst[selected_one]\n\n    return new_solution\n\n",
        "score": [
            -0.8722710722830964,
            2.7215125262737274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Solutions with higher value ratios are more likely to be selected\n    solution_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            remaining_capacity = 0\n        # Score based on potential to improve both objectives\n        score = (obj[0] + obj[1]) * (1 + remaining_capacity / capacity)\n        solution_scores.append(score)\n\n    # Normalize scores to probabilities\n    solution_probs = np.array(solution_scores) / np.sum(solution_scores)\n    selected_idx = np.random.choice(len(archive), p=solution_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with value-weighted swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify candidate items to swap (either 0->1 or 1->0)\n    # Prefer items that are not in the solution but have high value ratios\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Calculate value ratios for zero items\n    if len(zero_indices) > 0:\n        zero_value_ratios = (value1_lst[zero_indices] + value2_lst[zero_indices]) / weight_lst[zero_indices]\n        zero_probs = zero_value_ratios / np.sum(zero_value_ratios)\n        selected_zero = np.random.choice(zero_indices, p=zero_probs)\n\n        # If adding this item doesn't exceed capacity, do it\n        if weight_lst[selected_zero] <= remaining_capacity:\n            new_solution[selected_zero] = 1\n            current_weight += weight_lst[selected_zero]\n            remaining_capacity = capacity - current_weight\n\n    # Also consider removing low-value items\n    if len(one_indices) > 0:\n        one_value_ratios = (value1_lst[one_indices] + value2_lst[one_indices]) / weight_lst[one_indices]\n        one_probs = 1 / (one_value_ratios + 1e-6)  # Prefer removing low-value items\n        one_probs = one_probs / np.sum(one_probs)\n        selected_one = np.random.choice(one_indices, p=one_probs)\n\n        # Remove this item to free up capacity\n        new_solution[selected_one] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, remove random items until feasible\n        while total_weight > capacity:\n            one_indices = np.where(new_solution == 1)[0]\n            if len(one_indices) == 0:\n                break\n            selected_one = np.random.choice(one_indices)\n            new_solution[selected_one] = 0\n            total_weight -= weight_lst[selected_one]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Solutions with higher value ratios are more likely to be selected\n    solution_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            remaining_capacity = 0\n        # Score based on potential to improve both objectives\n        score = (obj[0] + obj[1]) * (1 + remaining_capacity / capacity)\n        solution_scores.append(score)\n\n    # Normalize scores to probabilities\n    solution_probs = np.array(solution_scores) / np.sum(solution_scores)\n    selected_idx = np.random.choice(len(archive), p=solution_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with value-weighted swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify candidate items to swap (either 0->1 or 1->0)\n    # Prefer items that are not in the solution but have high value ratios\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Calculate value ratios for zero items\n    if len(zero_indices) > 0:\n        zero_value_ratios = (value1_lst[zero_indices] + value2_lst[zero_indices]) / weight_lst[zero_indices]\n        zero_probs = zero_value_ratios / np.sum(zero_value_ratios)\n        selected_zero = np.random.choice(zero_indices, p=zero_probs)\n\n        # If adding this item doesn't exceed capacity, do it\n        if weight_lst[selected_zero] <= remaining_capacity:\n            new_solution[selected_zero] = 1\n            current_weight += weight_lst[selected_zero]\n            remaining_capacity = capacity - current_weight\n\n    # Also consider removing low-value items\n    if len(one_indices) > 0:\n        one_value_ratios = (value1_lst[one_indices] + value2_lst[one_indices]) / weight_lst[one_indices]\n        one_probs = 1 / (one_value_ratios + 1e-6)  # Prefer removing low-value items\n        one_probs = one_probs / np.sum(one_probs)\n        selected_one = np.random.choice(one_indices, p=one_probs)\n\n        # Remove this item to free up capacity\n        new_solution[selected_one] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, remove random items until feasible\n        while total_weight > capacity:\n            one_indices = np.where(new_solution == 1)[0]\n            if len(one_indices) == 0:\n                break\n            selected_one = np.random.choice(one_indices)\n            new_solution[selected_one] = 0\n            total_weight -= weight_lst[selected_one]\n\n    return new_solution\n\n",
        "score": [
            -0.8722710722830964,
            2.7215125262737274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Solutions with higher value ratios are more likely to be selected\n    solution_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            remaining_capacity = 0\n        # Score based on potential to improve both objectives\n        score = (obj[0] + obj[1]) * (1 + remaining_capacity / capacity)\n        solution_scores.append(score)\n\n    # Normalize scores to probabilities\n    solution_probs = np.array(solution_scores) / np.sum(solution_scores)\n    selected_idx = np.random.choice(len(archive), p=solution_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with value-weighted swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify candidate items to swap (either 0->1 or 1->0)\n    # Prefer items that are not in the solution but have high value ratios\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Calculate value ratios for zero items\n    if len(zero_indices) > 0:\n        zero_value_ratios = (value1_lst[zero_indices] + value2_lst[zero_indices]) / weight_lst[zero_indices]\n        zero_probs = zero_value_ratios / np.sum(zero_value_ratios)\n        selected_zero = np.random.choice(zero_indices, p=zero_probs)\n\n        # If adding this item doesn't exceed capacity, do it\n        if weight_lst[selected_zero] <= remaining_capacity:\n            new_solution[selected_zero] = 1\n            current_weight += weight_lst[selected_zero]\n            remaining_capacity = capacity - current_weight\n\n    # Also consider removing low-value items\n    if len(one_indices) > 0:\n        one_value_ratios = (value1_lst[one_indices] + value2_lst[one_indices]) / weight_lst[one_indices]\n        one_probs = 1 / (one_value_ratios + 1e-6)  # Prefer removing low-value items\n        one_probs = one_probs / np.sum(one_probs)\n        selected_one = np.random.choice(one_indices, p=one_probs)\n\n        # Remove this item to free up capacity\n        new_solution[selected_one] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, remove random items until feasible\n        while total_weight > capacity:\n            one_indices = np.where(new_solution == 1)[0]\n            if len(one_indices) == 0:\n                break\n            selected_one = np.random.choice(one_indices)\n            new_solution[selected_one] = 0\n            total_weight -= weight_lst[selected_one]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Solutions with higher value ratios are more likely to be selected\n    solution_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            remaining_capacity = 0\n        # Score based on potential to improve both objectives\n        score = (obj[0] + obj[1]) * (1 + remaining_capacity / capacity)\n        solution_scores.append(score)\n\n    # Normalize scores to probabilities\n    solution_probs = np.array(solution_scores) / np.sum(solution_scores)\n    selected_idx = np.random.choice(len(archive), p=solution_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with value-weighted swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify candidate items to swap (either 0->1 or 1->0)\n    # Prefer items that are not in the solution but have high value ratios\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Calculate value ratios for zero items\n    if len(zero_indices) > 0:\n        zero_value_ratios = (value1_lst[zero_indices] + value2_lst[zero_indices]) / weight_lst[zero_indices]\n        zero_probs = zero_value_ratios / np.sum(zero_value_ratios)\n        selected_zero = np.random.choice(zero_indices, p=zero_probs)\n\n        # If adding this item doesn't exceed capacity, do it\n        if weight_lst[selected_zero] <= remaining_capacity:\n            new_solution[selected_zero] = 1\n            current_weight += weight_lst[selected_zero]\n            remaining_capacity = capacity - current_weight\n\n    # Also consider removing low-value items\n    if len(one_indices) > 0:\n        one_value_ratios = (value1_lst[one_indices] + value2_lst[one_indices]) / weight_lst[one_indices]\n        one_probs = 1 / (one_value_ratios + 1e-6)  # Prefer removing low-value items\n        one_probs = one_probs / np.sum(one_probs)\n        selected_one = np.random.choice(one_indices, p=one_probs)\n\n        # Remove this item to free up capacity\n        new_solution[selected_one] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, remove random items until feasible\n        while total_weight > capacity:\n            one_indices = np.where(new_solution == 1)[0]\n            if len(one_indices) == 0:\n                break\n            selected_one = np.random.choice(one_indices)\n            new_solution[selected_one] = 0\n            total_weight -= weight_lst[selected_one]\n\n    return new_solution\n\n",
        "score": [
            -0.8722710722830964,
            2.7215125262737274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Solutions with higher value ratios are more likely to be selected\n    solution_scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity <= 0:\n            remaining_capacity = 0\n        # Score based on potential to improve both objectives\n        score = (obj[0] + obj[1]) * (1 + remaining_capacity / capacity)\n        solution_scores.append(score)\n\n    # Normalize scores to probabilities\n    solution_probs = np.array(solution_scores) / np.sum(solution_scores)\n    selected_idx = np.random.choice(len(archive), p=solution_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with value-weighted swaps\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify candidate items to swap (either 0->1 or 1->0)\n    # Prefer items that are not in the solution but have high value ratios\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    # Calculate value ratios for zero items\n    if len(zero_indices) > 0:\n        zero_value_ratios = (value1_lst[zero_indices] + value2_lst[zero_indices]) / weight_lst[zero_indices]\n        zero_probs = zero_value_ratios / np.sum(zero_value_ratios)\n        selected_zero = np.random.choice(zero_indices, p=zero_probs)\n\n        # If adding this item doesn't exceed capacity, do it\n        if weight_lst[selected_zero] <= remaining_capacity:\n            new_solution[selected_zero] = 1\n            current_weight += weight_lst[selected_zero]\n            remaining_capacity = capacity - current_weight\n\n    # Also consider removing low-value items\n    if len(one_indices) > 0:\n        one_value_ratios = (value1_lst[one_indices] + value2_lst[one_indices]) / weight_lst[one_indices]\n        one_probs = 1 / (one_value_ratios + 1e-6)  # Prefer removing low-value items\n        one_probs = one_probs / np.sum(one_probs)\n        selected_one = np.random.choice(one_indices, p=one_probs)\n\n        # Remove this item to free up capacity\n        new_solution[selected_one] = 0\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, remove random items until feasible\n        while total_weight > capacity:\n            one_indices = np.where(new_solution == 1)[0]\n            if len(one_indices) == 0:\n                break\n            selected_one = np.random.choice(one_indices)\n            new_solution[selected_one] = 0\n            total_weight -= weight_lst[selected_one]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = np.sum(value1_lst * selected_solution)\n    current_value2 = np.sum(value2_lst * selected_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for swapping\n    num_items = len(selected_solution)\n    subset_size = max(1, int(np.sqrt(num_items)))  # Adjust subset size dynamically\n    candidate_indices = random.sample(range(num_items), subset_size)\n\n    # 2. Evaluate each candidate item for potential swap\n    for idx in candidate_indices:\n        if selected_solution[idx] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 3. Apply value-density-based heuristic to further improve the solution\n    # Calculate value densities for all items not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        densities1 = value1_lst[remaining_items] / weight_lst[remaining_items]\n        densities2 = value2_lst[remaining_items] / weight_lst[remaining_items]\n\n        # Select top-k items based on combined density\n        k = min(3, len(remaining_items))  # Consider top 3 items\n        combined_density = densities1 + densities2\n        top_indices = np.argsort(combined_density)[-k:]\n\n        for idx in remaining_items[top_indices]:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.38041671468745136,
            1.1823432445526123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = np.sum(value1_lst * selected_solution)\n    current_value2 = np.sum(value2_lst * selected_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for swapping\n    num_items = len(selected_solution)\n    subset_size = max(1, int(np.sqrt(num_items)))  # Adjust subset size dynamically\n    candidate_indices = random.sample(range(num_items), subset_size)\n\n    # 2. Evaluate each candidate item for potential swap\n    for idx in candidate_indices:\n        if selected_solution[idx] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 3. Apply value-density-based heuristic to further improve the solution\n    # Calculate value densities for all items not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        densities1 = value1_lst[remaining_items] / weight_lst[remaining_items]\n        densities2 = value2_lst[remaining_items] / weight_lst[remaining_items]\n\n        # Select top-k items based on combined density\n        k = min(3, len(remaining_items))  # Consider top 3 items\n        combined_density = densities1 + densities2\n        top_indices = np.argsort(combined_density)[-k:]\n\n        for idx in remaining_items[top_indices]:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = np.sum(value1_lst * selected_solution)\n    current_value2 = np.sum(value2_lst * selected_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for swapping\n    num_items = len(selected_solution)\n    subset_size = max(1, int(np.sqrt(num_items)))  # Adjust subset size dynamically\n    candidate_indices = random.sample(range(num_items), subset_size)\n\n    # 2. Evaluate each candidate item for potential swap\n    for idx in candidate_indices:\n        if selected_solution[idx] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 3. Apply value-density-based heuristic to further improve the solution\n    # Calculate value densities for all items not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        densities1 = value1_lst[remaining_items] / weight_lst[remaining_items]\n        densities2 = value2_lst[remaining_items] / weight_lst[remaining_items]\n\n        # Select top-k items based on combined density\n        k = min(3, len(remaining_items))  # Consider top 3 items\n        combined_density = densities1 + densities2\n        top_indices = np.argsort(combined_density)[-k:]\n\n        for idx in remaining_items[top_indices]:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.38041671468745136,
            1.1823432445526123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others in the archive)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = np.sum(value1_lst * selected_solution)\n    current_value2 = np.sum(value2_lst * selected_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for swapping\n    num_items = len(selected_solution)\n    subset_size = max(1, int(np.sqrt(num_items)))  # Adjust subset size dynamically\n    candidate_indices = random.sample(range(num_items), subset_size)\n\n    # 2. Evaluate each candidate item for potential swap\n    for idx in candidate_indices:\n        if selected_solution[idx] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 3. Apply value-density-based heuristic to further improve the solution\n    # Calculate value densities for all items not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        densities1 = value1_lst[remaining_items] / weight_lst[remaining_items]\n        densities2 = value2_lst[remaining_items] / weight_lst[remaining_items]\n\n        # Select top-k items based on combined density\n        k = min(3, len(remaining_items))  # Consider top 3 items\n        combined_density = densities1 + densities2\n        top_indices = np.argsort(combined_density)[-k:]\n\n        for idx in remaining_items[top_indices]:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select a solution that is not dominated by others in the archive\n    selected_solution = None\n    for sol, _ in archive:\n        is_dominated = False\n        for _, obj in archive:\n            if obj[0] > sol[0] and obj[1] > sol[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (exploration)\n    # 2. Greedily add items that improve both objectives (exploitation)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Random flips (exploration)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove excess items randomly\n        excess = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        while excess > 0 and len(excess_items) > 0:\n            idx = np.random.choice(excess_items)\n            new_solution[idx] = 0\n            excess -= weight_lst[idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy addition (exploitation)\n    # Find items not in the solution that can be added without violating capacity\n    candidate_items = np.where(new_solution == 0)[0]\n    for idx in candidate_items:\n        if weight_lst[idx] <= (capacity - np.sum(weight_lst * new_solution)):\n            # Check if adding this item improves both objectives\n            new_value1 = np.sum(value1_lst * new_solution) + value1_lst[idx]\n            new_value2 = np.sum(value2_lst * new_solution) + value2_lst[idx]\n            # Only add if it improves both objectives\n            if new_value1 > np.sum(value1_lst * new_solution) and new_value2 > np.sum(value2_lst * new_solution):\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.277932024360228,
            6.958067983388901
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select a solution that is not dominated by others in the archive\n    selected_solution = None\n    for sol, _ in archive:\n        is_dominated = False\n        for _, obj in archive:\n            if obj[0] > sol[0] and obj[1] > sol[1]:\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (exploration)\n    # 2. Greedily add items that improve both objectives (exploitation)\n    new_solution = selected_solution.copy()\n\n    # Step 1: Random flips (exploration)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove excess items randomly\n        excess = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        while excess > 0 and len(excess_items) > 0:\n            idx = np.random.choice(excess_items)\n            new_solution[idx] = 0\n            excess -= weight_lst[idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy addition (exploitation)\n    # Find items not in the solution that can be added without violating capacity\n    candidate_items = np.where(new_solution == 0)[0]\n    for idx in candidate_items:\n        if weight_lst[idx] <= (capacity - np.sum(weight_lst * new_solution)):\n            # Check if adding this item improves both objectives\n            new_value1 = np.sum(value1_lst * new_solution) + value1_lst[idx]\n            new_value2 = np.sum(value2_lst * new_solution) + value2_lst[idx]\n            # Only add if it improves both objectives\n            if new_value1 > np.sum(value1_lst * new_solution) and new_value2 > np.sum(value2_lst * new_solution):\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values in descending order\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% solutions with the highest combined values\n        top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        # Randomly select one from the top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: flip items based on their marginal contribution\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal contributions with randomness\n    combined_marginal = marginal_value1 + marginal_value2 + np.random.rand(len(weight_lst)) * 0.1\n\n    # Sort items by combined marginal contribution\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Try to flip top 20% of items\n    flip_count = max(1, len(sorted_indices) // 5)\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Additional random flip to escape local optima\n    if random.random() < 0.2:\n        random_idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[random_idx] == 1:\n            new_weight = current_weight - weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7676373147204237,
            1.3923526108264923
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values in descending order\n        sorted_archive = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% solutions with the highest combined values\n        top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n        # Randomly select one from the top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: flip items based on their marginal contribution\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal contributions with randomness\n    combined_marginal = marginal_value1 + marginal_value2 + np.random.rand(len(weight_lst)) * 0.1\n\n    # Sort items by combined marginal contribution\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    # Try to flip top 20% of items\n    flip_count = max(1, len(sorted_indices) // 5)\n    for idx in sorted_indices[:flip_count]:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    # Additional random flip to escape local optima\n    if random.random() < 0.2:\n        random_idx = random.randint(0, len(weight_lst) - 1)\n        if new_solution[random_idx] == 1:\n            new_weight = current_weight - weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            new_weight = current_weight + weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy: combination of random flip and greedy improvement\n    # Step 1: Random flip with probability inversely proportional to current weight\n    flip_prob = max(0.1, 1 - current_weight / capacity)\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 1:\n                # Try to remove item if it doesn't make weight infeasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item if it doesn't exceed capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    # Calculate marginal values for all items\n    marginal_val1 = value1_lst / (weight_lst + 1e-6)\n    marginal_val2 = value2_lst / (weight_lst + 1e-6)\n\n    # Sort items by combined marginal value (weighted sum)\n    combined_marginal = marginal_val1 + marginal_val2\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Step 3: Remove items that don't contribute to either objective\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1 and value1_lst[i] == 0 and value2_lst[i] == 0:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3473907171572834,
            2.837221771478653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy: combination of random flip and greedy improvement\n    # Step 1: Random flip with probability inversely proportional to current weight\n    flip_prob = max(0.1, 1 - current_weight / capacity)\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 1:\n                # Try to remove item if it doesn't make weight infeasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item if it doesn't exceed capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    # Calculate marginal values for all items\n    marginal_val1 = value1_lst / (weight_lst + 1e-6)\n    marginal_val2 = value2_lst / (weight_lst + 1e-6)\n\n    # Sort items by combined marginal value (weighted sum)\n    combined_marginal = marginal_val1 + marginal_val2\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n\n    # Step 3: Remove items that don't contribute to either objective\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1 and value1_lst[i] == 0 and value2_lst[i] == 0:\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: Flip a random bit and adjust to maintain feasibility\n    while True:\n        # Randomly select an item to flip\n        flip_idx = np.random.randint(0, len(new_solution))\n\n        if new_solution[flip_idx] == 1:\n            # Try to remove the item\n            new_weight = current_weight - weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight = new_weight\n                break\n        else:\n            # Try to add the item\n            new_weight = current_weight + weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight = new_weight\n                break\n\n    # Additional local search: Try to swap items to improve both objectives\n    for _ in range(5):\n        # Select two random items\n        idx1, idx2 = np.random.choice(len(new_solution), size=2, replace=False)\n\n        if new_solution[idx1] == new_solution[idx2]:\n            continue\n\n        # Calculate potential change in weight\n        delta_weight = weight_lst[idx2] - weight_lst[idx1]\n\n        if abs(delta_weight) > 0:\n            new_weight = current_weight + delta_weight\n            if new_weight <= capacity:\n                # Calculate potential change in both objectives\n                delta_value1 = value1_lst[idx2] - value1_lst[idx1]\n                delta_value2 = value2_lst[idx2] - value2_lst[idx1]\n\n                # Accept if at least one objective improves\n                if delta_value1 > 0 or delta_value2 > 0:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4605641745243485,
            2.3492214381694794
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: Flip a random bit and adjust to maintain feasibility\n    while True:\n        # Randomly select an item to flip\n        flip_idx = np.random.randint(0, len(new_solution))\n\n        if new_solution[flip_idx] == 1:\n            # Try to remove the item\n            new_weight = current_weight - weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight = new_weight\n                break\n        else:\n            # Try to add the item\n            new_weight = current_weight + weight_lst[flip_idx]\n            if new_weight <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight = new_weight\n                break\n\n    # Additional local search: Try to swap items to improve both objectives\n    for _ in range(5):\n        # Select two random items\n        idx1, idx2 = np.random.choice(len(new_solution), size=2, replace=False)\n\n        if new_solution[idx1] == new_solution[idx2]:\n            continue\n\n        # Calculate potential change in weight\n        delta_weight = weight_lst[idx2] - weight_lst[idx1]\n\n        if abs(delta_weight) > 0:\n            new_weight = current_weight + delta_weight\n            if new_weight <= capacity:\n                # Calculate potential change in both objectives\n                delta_value1 = value1_lst[idx2] - value1_lst[idx1]\n                delta_value2 = value2_lst[idx2] - value2_lst[idx1]\n\n                # Accept if at least one objective improves\n                if delta_value1 > 0 or delta_value2 > 0:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance to identify solutions with potential for improvement\n    crowding_distances = np.zeros(len(archive_objectives))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive_objectives) - 1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] - archive_objectives[sorted_indices[j-1]][i])\n\n    # Select a solution with low crowding distance (less crowded, more potential for improvement)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (exploration)\n    num_flips = random.randint(1, min(5, num_items))  # Flip between 1 and 5 items\n    flip_indices = random.sample(range(num_items), num_flips)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip 0 to 1 or 1 to 0\n\n    # Ensure feasibility: if flipping makes the solution infeasible, undo the flip\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        for idx in flip_indices:\n            new_solution[idx] = base_solution[idx]  # Revert the flip\n\n    # Step 2: Perform a targeted swap to improve both objectives (exploitation)\n    # Find items that are currently not in the knapsack but could be added without exceeding capacity\n    not_in_knapsack = np.where(new_solution == 0)[0]\n    can_add = [i for i in not_in_knapsack if (total_weight + weight_lst[i]) <= capacity]\n\n    if can_add:\n        # Select an item to add that maximizes the sum of normalized value improvements\n        normalized_value1 = value1_lst / np.max(value1_lst) if np.max(value1_lst) != 0 else value1_lst\n        normalized_value2 = value2_lst / np.max(value2_lst) if np.max(value2_lst) != 0 else value2_lst\n        combined_value = normalized_value1 + normalized_value2\n\n        best_add_idx = max(can_add, key=lambda i: combined_value[i])\n        new_solution[best_add_idx] = 1\n\n    # Step 3: Randomly remove an item if the knapsack is overfull (edge case handling)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items one by one until feasible\n        while total_weight > capacity:\n            in_knapsack = np.where(new_solution == 1)[0]\n            if not in_knapsack.size:\n                break  # No items to remove (should not happen due to earlier checks)\n            remove_idx = random.choice(in_knapsack)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8284273311296997,
            2.0981943607330322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance to identify solutions with potential for improvement\n    crowding_distances = np.zeros(len(archive_objectives))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive_objectives) - 1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] - archive_objectives[sorted_indices[j-1]][i])\n\n    # Select a solution with low crowding distance (less crowded, more potential for improvement)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly flip a subset of items (exploration)\n    num_flips = random.randint(1, min(5, num_items))  # Flip between 1 and 5 items\n    flip_indices = random.sample(range(num_items), num_flips)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip 0 to 1 or 1 to 0\n\n    # Ensure feasibility: if flipping makes the solution infeasible, undo the flip\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        for idx in flip_indices:\n            new_solution[idx] = base_solution[idx]  # Revert the flip\n\n    # Step 2: Perform a targeted swap to improve both objectives (exploitation)\n    # Find items that are currently not in the knapsack but could be added without exceeding capacity\n    not_in_knapsack = np.where(new_solution == 0)[0]\n    can_add = [i for i in not_in_knapsack if (total_weight + weight_lst[i]) <= capacity]\n\n    if can_add:\n        # Select an item to add that maximizes the sum of normalized value improvements\n        normalized_value1 = value1_lst / np.max(value1_lst) if np.max(value1_lst) != 0 else value1_lst\n        normalized_value2 = value2_lst / np.max(value2_lst) if np.max(value2_lst) != 0 else value2_lst\n        combined_value = normalized_value1 + normalized_value2\n\n        best_add_idx = max(can_add, key=lambda i: combined_value[i])\n        new_solution[best_add_idx] = 1\n\n    # Step 3: Randomly remove an item if the knapsack is overfull (edge case handling)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items one by one until feasible\n        while total_weight > capacity:\n            in_knapsack = np.where(new_solution == 1)[0]\n            if not in_knapsack.size:\n                break  # No items to remove (should not happen due to earlier checks)\n            remove_idx = random.choice(in_knapsack)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we prioritize solutions with high total value (sum of both objectives)\n    archive_with_scores = [(sol, obj, sum(obj)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: -x[2])  # Sort by total value descending\n    selected = archive_with_scores[0][0].copy()\n\n    # Generate a neighbor using a hybrid strategy:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Perform a value-based swap to improve both objectives\n    new_solution = selected.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random perturbation (flip 10% of items)\n    flip_indices = np.random.choice(n_items, size=max(1, n_items // 10), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove excess items randomly\n        excess_weight = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        while excess_weight > 0 and len(excess_items) > 0:\n            idx = np.random.choice(excess_items)\n            excess_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Value-based swap\n    # Identify items not in the solution with high potential to improve both objectives\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Calculate potential improvement for each candidate item\n        candidate_values = []\n        for idx in not_in_solution:\n            if weight_lst[idx] <= capacity - current_weight:\n                # Potential improvement in both objectives\n                improvement = (value1_lst[idx], value2_lst[idx])\n                candidate_values.append((idx, improvement))\n\n        if candidate_values:\n            # Select the item with the highest combined improvement\n            best_candidate = max(candidate_values, key=lambda x: sum(x[1]))\n            new_solution[best_candidate[0]] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3945378156608163,
            2.9270828664302826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we prioritize solutions with high total value (sum of both objectives)\n    archive_with_scores = [(sol, obj, sum(obj)) for sol, obj in archive]\n    archive_with_scores.sort(key=lambda x: -x[2])  # Sort by total value descending\n    selected = archive_with_scores[0][0].copy()\n\n    # Generate a neighbor using a hybrid strategy:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Perform a value-based swap to improve both objectives\n    new_solution = selected.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Random perturbation (flip 10% of items)\n    flip_indices = np.random.choice(n_items, size=max(1, n_items // 10), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after perturbation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove excess items randomly\n        excess_weight = current_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        while excess_weight > 0 and len(excess_items) > 0:\n            idx = np.random.choice(excess_items)\n            excess_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Value-based swap\n    # Identify items not in the solution with high potential to improve both objectives\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Calculate potential improvement for each candidate item\n        candidate_values = []\n        for idx in not_in_solution:\n            if weight_lst[idx] <= capacity - current_weight:\n                # Potential improvement in both objectives\n                improvement = (value1_lst[idx], value2_lst[idx])\n                candidate_values.append((idx, improvement))\n\n        if candidate_values:\n            # Select the item with the highest combined improvement\n            best_candidate = max(candidate_values, key=lambda x: sum(x[1]))\n            new_solution[best_candidate[0]] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    # Prioritize solutions that are not highly dominated or have room for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            # Calculate the percentage of capacity used and the sum of normalized objectives\n            capacity_used = total_weight / capacity\n            normalized_obj1 = obj[0] / np.sum(value1_lst) if np.sum(value1_lst) > 0 else 0\n            normalized_obj2 = obj[1] / np.sum(value2_lst) if np.sum(value2_lst) > 0 else 0\n            score = (1 - capacity_used) * (normalized_obj1 + normalized_obj2)  # Higher score means more potential\n            candidates.append((sol, score))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive.\")\n\n    # Select the solution with the highest score\n    best_candidate = max(candidates, key=lambda x: x[1])\n    base_solution = best_candidate[0].copy()\n\n    # Hybrid local search: Random perturbation followed by greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Random perturbation - flip a few items randomly\n    num_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(n_items, num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flip\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity and np.any(new_solution):\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) > 0:\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)  # Randomize order to explore different options\n\n    for idx in remaining_items:\n        if total_weight + weight_lst[idx] <= capacity:\n            # Evaluate the potential improvement\n            new_value1 = np.sum(value1_lst * new_solution) + value1_lst[idx]\n            new_value2 = np.sum(value2_lst * new_solution) + value2_lst[idx]\n            current_value1, current_value2 = np.sum(value1_lst * new_solution), np.sum(value2_lst * new_solution)\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n               (new_value1 > current_value1 * 1.1 and new_value2 >= current_value2) or \\\n               (new_value2 > current_value2 * 1.1 and new_value1 >= current_value1):\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3755651825691009,
            3.9640210270881653
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with potential for improvement\n    # Prioritize solutions that are not highly dominated or have room for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            # Calculate the percentage of capacity used and the sum of normalized objectives\n            capacity_used = total_weight / capacity\n            normalized_obj1 = obj[0] / np.sum(value1_lst) if np.sum(value1_lst) > 0 else 0\n            normalized_obj2 = obj[1] / np.sum(value2_lst) if np.sum(value2_lst) > 0 else 0\n            score = (1 - capacity_used) * (normalized_obj1 + normalized_obj2)  # Higher score means more potential\n            candidates.append((sol, score))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive.\")\n\n    # Select the solution with the highest score\n    best_candidate = max(candidates, key=lambda x: x[1])\n    base_solution = best_candidate[0].copy()\n\n    # Hybrid local search: Random perturbation followed by greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Step 1: Random perturbation - flip a few items randomly\n    num_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(n_items, num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flip\n    total_weight = np.sum(weight_lst * new_solution)\n    while total_weight > capacity and np.any(new_solution):\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) > 0:\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)  # Randomize order to explore different options\n\n    for idx in remaining_items:\n        if total_weight + weight_lst[idx] <= capacity:\n            # Evaluate the potential improvement\n            new_value1 = np.sum(value1_lst * new_solution) + value1_lst[idx]\n            new_value2 = np.sum(value2_lst * new_solution) + value2_lst[idx]\n            current_value1, current_value2 = np.sum(value1_lst * new_solution), np.sum(value2_lst * new_solution)\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n               (new_value1 > current_value1 * 1.1 and new_value2 >= current_value2) or \\\n               (new_value2 > current_value2 * 1.1 and new_value1 >= current_value1):\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher combined value-to-weight ratios\n    weights = np.array([sum(s[0] * weight_lst) for s in archive])\n    values1 = np.array([s[1][0] for s in archive])\n    values2 = np.array([s[1][1] for s in archive])\n\n    # Calculate normalized value-to-weight ratios for both objectives\n    ratio1 = values1 / (weights + 1e-6)\n    ratio2 = values2 / (weights + 1e-6)\n    combined_ratio = ratio1 + ratio2\n\n    # Select top 20% of solutions based on combined ratio\n    top_indices = np.argsort(combined_ratio)[-max(1, len(archive) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping items with high marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate current weight and values\n    current_weight = np.sum(new_solution * weight_lst)\n    current_value1 = np.sum(new_solution * value1_lst)\n    current_value2 = np.sum(new_solution * value2_lst)\n\n    # Identify items to consider for flip\n    candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Check if removing improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1))  # -1 means remove\n        else:\n            # Check if adding is feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 means add\n\n    if not candidates:\n        # No feasible flips, return a random flip that maintains feasibility\n        feasible_flips = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    feasible_flips.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_flips.append(i)\n        if feasible_flips:\n            flip_idx = random.choice(feasible_flips)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Select flip with highest combined marginal value-to-weight ratio\n    best_flip = None\n    best_score = -float('inf')\n\n    for i, delta in candidates:\n        if delta == 1:  # Adding item\n            marginal_ratio1 = value1_lst[i] / weight_lst[i]\n            marginal_ratio2 = value2_lst[i] / weight_lst[i]\n        else:  # Removing item\n            marginal_ratio1 = -value1_lst[i] / weight_lst[i]\n            marginal_ratio2 = -value2_lst[i] / weight_lst[i]\n\n        combined_marginal = marginal_ratio1 + marginal_ratio2\n        if combined_marginal > best_score:\n            best_score = combined_marginal\n            best_flip = (i, delta)\n\n    if best_flip:\n        i, delta = best_flip\n        new_solution[i] = 1 if delta == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8733329831319614,
            5.530104219913483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher combined value-to-weight ratios\n    weights = np.array([sum(s[0] * weight_lst) for s in archive])\n    values1 = np.array([s[1][0] for s in archive])\n    values2 = np.array([s[1][1] for s in archive])\n\n    # Calculate normalized value-to-weight ratios for both objectives\n    ratio1 = values1 / (weights + 1e-6)\n    ratio2 = values2 / (weights + 1e-6)\n    combined_ratio = ratio1 + ratio2\n\n    # Select top 20% of solutions based on combined ratio\n    top_indices = np.argsort(combined_ratio)[-max(1, len(archive) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping items with high marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate current weight and values\n    current_weight = np.sum(new_solution * weight_lst)\n    current_value1 = np.sum(new_solution * value1_lst)\n    current_value2 = np.sum(new_solution * value2_lst)\n\n    # Identify items to consider for flip\n    candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Check if removing improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1))  # -1 means remove\n        else:\n            # Check if adding is feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 means add\n\n    if not candidates:\n        # No feasible flips, return a random flip that maintains feasibility\n        feasible_flips = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    feasible_flips.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_flips.append(i)\n        if feasible_flips:\n            flip_idx = random.choice(feasible_flips)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Select flip with highest combined marginal value-to-weight ratio\n    best_flip = None\n    best_score = -float('inf')\n\n    for i, delta in candidates:\n        if delta == 1:  # Adding item\n            marginal_ratio1 = value1_lst[i] / weight_lst[i]\n            marginal_ratio2 = value2_lst[i] / weight_lst[i]\n        else:  # Removing item\n            marginal_ratio1 = -value1_lst[i] / weight_lst[i]\n            marginal_ratio2 = -value2_lst[i] / weight_lst[i]\n\n        combined_marginal = marginal_ratio1 + marginal_ratio2\n        if combined_marginal > best_score:\n            best_score = combined_marginal\n            best_flip = (i, delta)\n\n    if best_flip:\n        i, delta = best_flip\n        new_solution[i] = 1 if delta == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher combined value-to-weight ratios\n    weights = np.array([sum(s[0] * weight_lst) for s in archive])\n    values1 = np.array([s[1][0] for s in archive])\n    values2 = np.array([s[1][1] for s in archive])\n\n    # Calculate normalized value-to-weight ratios for both objectives\n    ratio1 = values1 / (weights + 1e-6)\n    ratio2 = values2 / (weights + 1e-6)\n    combined_ratio = ratio1 + ratio2\n\n    # Select top 20% of solutions based on combined ratio\n    top_indices = np.argsort(combined_ratio)[-max(1, len(archive) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping items with high marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate current weight and values\n    current_weight = np.sum(new_solution * weight_lst)\n    current_value1 = np.sum(new_solution * value1_lst)\n    current_value2 = np.sum(new_solution * value2_lst)\n\n    # Identify items to consider for flip\n    candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Check if removing improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1))  # -1 means remove\n        else:\n            # Check if adding is feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 means add\n\n    if not candidates:\n        # No feasible flips, return a random flip that maintains feasibility\n        feasible_flips = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    feasible_flips.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_flips.append(i)\n        if feasible_flips:\n            flip_idx = random.choice(feasible_flips)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Select flip with highest combined marginal value-to-weight ratio\n    best_flip = None\n    best_score = -float('inf')\n\n    for i, delta in candidates:\n        if delta == 1:  # Adding item\n            marginal_ratio1 = value1_lst[i] / weight_lst[i]\n            marginal_ratio2 = value2_lst[i] / weight_lst[i]\n        else:  # Removing item\n            marginal_ratio1 = -value1_lst[i] / weight_lst[i]\n            marginal_ratio2 = -value2_lst[i] / weight_lst[i]\n\n        combined_marginal = marginal_ratio1 + marginal_ratio2\n        if combined_marginal > best_score:\n            best_score = combined_marginal\n            best_flip = (i, delta)\n\n    if best_flip:\n        i, delta = best_flip\n        new_solution[i] = 1 if delta == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8733329831319614,
            5.530104219913483
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher combined value-to-weight ratios\n    weights = np.array([sum(s[0] * weight_lst) for s in archive])\n    values1 = np.array([s[1][0] for s in archive])\n    values2 = np.array([s[1][1] for s in archive])\n\n    # Calculate normalized value-to-weight ratios for both objectives\n    ratio1 = values1 / (weights + 1e-6)\n    ratio2 = values2 / (weights + 1e-6)\n    combined_ratio = ratio1 + ratio2\n\n    # Select top 20% of solutions based on combined ratio\n    top_indices = np.argsort(combined_ratio)[-max(1, len(archive) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor by flipping items with high marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate current weight and values\n    current_weight = np.sum(new_solution * weight_lst)\n    current_value1 = np.sum(new_solution * value1_lst)\n    current_value2 = np.sum(new_solution * value2_lst)\n\n    # Identify items to consider for flip\n    candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Check if removing improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidates.append((i, -1))  # -1 means remove\n        else:\n            # Check if adding is feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 means add\n\n    if not candidates:\n        # No feasible flips, return a random flip that maintains feasibility\n        feasible_flips = []\n        for i in range(n_items):\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    feasible_flips.append(i)\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    feasible_flips.append(i)\n        if feasible_flips:\n            flip_idx = random.choice(feasible_flips)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Select flip with highest combined marginal value-to-weight ratio\n    best_flip = None\n    best_score = -float('inf')\n\n    for i, delta in candidates:\n        if delta == 1:  # Adding item\n            marginal_ratio1 = value1_lst[i] / weight_lst[i]\n            marginal_ratio2 = value2_lst[i] / weight_lst[i]\n        else:  # Removing item\n            marginal_ratio1 = -value1_lst[i] / weight_lst[i]\n            marginal_ratio2 = -value2_lst[i] / weight_lst[i]\n\n        combined_marginal = marginal_ratio1 + marginal_ratio2\n        if combined_marginal > best_score:\n            best_score = combined_marginal\n            best_flip = (i, delta)\n\n    if best_flip:\n        i, delta = best_flip\n        new_solution[i] = 1 if delta == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with higher combined value\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    probabilities = combined_values / np.sum(combined_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a candidate set of items to flip\n    candidate_items = np.where(base_solution == 1)[0] if np.random.rand() < 0.7 else np.where(base_solution == 0)[0]\n\n    if len(candidate_items) == 0:\n        return base_solution\n\n    # Calculate value-to-weight ratios for candidate items\n    ratios1 = value1_lst[candidate_items] / weight_lst[candidate_items]\n    ratios2 = value2_lst[candidate_items] / weight_lst[candidate_items]\n    combined_ratios = ratios1 + ratios2\n\n    # Sort candidates by combined ratio (descending) to prioritize high-value items\n    sorted_indices = np.argsort(-combined_ratios)\n    sorted_candidates = candidate_items[sorted_indices]\n\n    # Try flipping items in order of priority\n    new_solution = base_solution.copy()\n    for item in sorted_candidates:\n        # Calculate the effect of flipping this item\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n        else:\n            new_weight = current_weight + weight_lst[item]\n\n        # Ensure feasibility\n        if new_weight <= capacity:\n            new_solution[item] = 1 - new_solution[item]\n            current_weight = new_weight\n            # Randomly decide whether to continue flipping\n            if np.random.rand() < 0.3:\n                break\n\n    # Apply a small number of random flips to escape local optima\n    num_random_flips = min(3, len(candidate_items))\n    for _ in range(num_random_flips):\n        item = np.random.choice(candidate_items)\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n        else:\n            new_weight = current_weight + weight_lst[item]\n\n        if new_weight <= capacity:\n            new_solution[item] = 1 - new_solution[item]\n            current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4406354200433014,
            7.424968183040619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with higher combined value\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    probabilities = combined_values / np.sum(combined_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a candidate set of items to flip\n    candidate_items = np.where(base_solution == 1)[0] if np.random.rand() < 0.7 else np.where(base_solution == 0)[0]\n\n    if len(candidate_items) == 0:\n        return base_solution\n\n    # Calculate value-to-weight ratios for candidate items\n    ratios1 = value1_lst[candidate_items] / weight_lst[candidate_items]\n    ratios2 = value2_lst[candidate_items] / weight_lst[candidate_items]\n    combined_ratios = ratios1 + ratios2\n\n    # Sort candidates by combined ratio (descending) to prioritize high-value items\n    sorted_indices = np.argsort(-combined_ratios)\n    sorted_candidates = candidate_items[sorted_indices]\n\n    # Try flipping items in order of priority\n    new_solution = base_solution.copy()\n    for item in sorted_candidates:\n        # Calculate the effect of flipping this item\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n        else:\n            new_weight = current_weight + weight_lst[item]\n\n        # Ensure feasibility\n        if new_weight <= capacity:\n            new_solution[item] = 1 - new_solution[item]\n            current_weight = new_weight\n            # Randomly decide whether to continue flipping\n            if np.random.rand() < 0.3:\n                break\n\n    # Apply a small number of random flips to escape local optima\n    num_random_flips = min(3, len(candidate_items))\n    for _ in range(num_random_flips):\n        item = np.random.choice(candidate_items)\n        if new_solution[item] == 1:\n            new_weight = current_weight - weight_lst[item]\n        else:\n            new_weight = current_weight + weight_lst[item]\n\n        if new_weight <= capacity:\n            new_solution[item] = 1 - new_solution[item]\n            current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We prioritize solutions that are not fully packed and have high marginal gains\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity:\n            # Calculate marginal gains for items not in the solution\n            marginal_gains = (value1_lst + value2_lst) * (1 - sol)\n            top_items = np.argsort(marginal_gains)[-3:]  # Top 3 items with highest marginal gains\n            candidates.append((sol, obj, top_items))\n\n    if not candidates:\n        # If no candidates with space, select a random solution\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a candidate with probability proportional to its marginal gains\n        weights = [np.sum((value1_lst + value2_lst)[top_items]) for _, _, top_items in candidates]\n        base_solution = random.choices([sol for sol, _, _ in candidates], weights=weights, k=1)[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small subset of items (1-3) to maintain diversity\n    # 2. For the top marginal gain items, decide to include them if they fit\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 0 and np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # If over capacity, remove items with lowest value/weight ratio\n        while current_weight > capacity:\n            ratios = (value1_lst + value2_lst) / weight_lst\n            ratios[new_solution == 0] = np.inf  # Ignore items not in the solution\n            idx_to_remove = np.argmin(ratios)\n            new_solution[idx_to_remove] = 0\n            current_weight -= weight_lst[idx_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.3047110251880162,
            7.240947812795639
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We prioritize solutions that are not fully packed and have high marginal gains\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity:\n            # Calculate marginal gains for items not in the solution\n            marginal_gains = (value1_lst + value2_lst) * (1 - sol)\n            top_items = np.argsort(marginal_gains)[-3:]  # Top 3 items with highest marginal gains\n            candidates.append((sol, obj, top_items))\n\n    if not candidates:\n        # If no candidates with space, select a random solution\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a candidate with probability proportional to its marginal gains\n        weights = [np.sum((value1_lst + value2_lst)[top_items]) for _, _, top_items in candidates]\n        base_solution = random.choices([sol for sol, _, _ in candidates], weights=weights, k=1)[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small subset of items (1-3) to maintain diversity\n    # 2. For the top marginal gain items, decide to include them if they fit\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 0 and np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n        elif new_solution[idx] == 1:\n            new_solution[idx] = 0\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # If over capacity, remove items with lowest value/weight ratio\n        while current_weight > capacity:\n            ratios = (value1_lst + value2_lst) / weight_lst\n            ratios[new_solution == 0] = np.inf  # Ignore items not in the solution\n            idx_to_remove = np.argmin(ratios)\n            new_solution[idx_to_remove] = 0\n            current_weight -= weight_lst[idx_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions that are not too crowded in the archive\n    # This helps in exploring less-explored regions\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to swap (value-based selection)\n    # 2. Adjust the selection to maintain feasibility\n    # 3. Perform a value-based swap to improve both objectives\n\n    # Step 1: Select a subset of items to consider for swapping\n    num_items = len(new_solution)\n    subset_size = min(5, num_items // 2)  # Dynamic subset size\n    candidate_indices = np.random.choice(num_items, size=subset_size, replace=False)\n\n    # Step 2: Evaluate the potential of each candidate item for swapping\n    # We prioritize items that have high marginal value contributions\n    marginal_values = []\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # If item is included, evaluate its marginal contribution\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n        else:\n            # If item is excluded, evaluate its potential contribution\n            if current_weight + weight_lst[idx] <= capacity:\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n            else:\n                marginal_value1 = 0\n                marginal_value2 = 0\n        marginal_values.append((marginal_value1 + marginal_value2, idx))\n\n    # Sort candidates by their marginal value contributions\n    marginal_values.sort(reverse=True, key=lambda x: x[0])\n\n    # Step 3: Perform the swap if it improves both objectives\n    for _, idx in marginal_values:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it's included\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight >= 0:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try to add the item if it's excluded and feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional step: Randomly flip a small number of items to escape local optima\n    flip_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3353593003048719,
            1.0899836122989655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions that are not too crowded in the archive\n    # This helps in exploring less-explored regions\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to swap (value-based selection)\n    # 2. Adjust the selection to maintain feasibility\n    # 3. Perform a value-based swap to improve both objectives\n\n    # Step 1: Select a subset of items to consider for swapping\n    num_items = len(new_solution)\n    subset_size = min(5, num_items // 2)  # Dynamic subset size\n    candidate_indices = np.random.choice(num_items, size=subset_size, replace=False)\n\n    # Step 2: Evaluate the potential of each candidate item for swapping\n    # We prioritize items that have high marginal value contributions\n    marginal_values = []\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # If item is included, evaluate its marginal contribution\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n        else:\n            # If item is excluded, evaluate its potential contribution\n            if current_weight + weight_lst[idx] <= capacity:\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n            else:\n                marginal_value1 = 0\n                marginal_value2 = 0\n        marginal_values.append((marginal_value1 + marginal_value2, idx))\n\n    # Sort candidates by their marginal value contributions\n    marginal_values.sort(reverse=True, key=lambda x: x[0])\n\n    # Step 3: Perform the swap if it improves both objectives\n    for _, idx in marginal_values:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it's included\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight >= 0:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try to add the item if it's excluded and feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional step: Randomly flip a small number of items to escape local optima\n    flip_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions that are not too crowded in the archive\n    # This helps in exploring less-explored regions\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to swap (value-based selection)\n    # 2. Adjust the selection to maintain feasibility\n    # 3. Perform a value-based swap to improve both objectives\n\n    # Step 1: Select a subset of items to consider for swapping\n    num_items = len(new_solution)\n    subset_size = min(5, num_items // 2)  # Dynamic subset size\n    candidate_indices = np.random.choice(num_items, size=subset_size, replace=False)\n\n    # Step 2: Evaluate the potential of each candidate item for swapping\n    # We prioritize items that have high marginal value contributions\n    marginal_values = []\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # If item is included, evaluate its marginal contribution\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n        else:\n            # If item is excluded, evaluate its potential contribution\n            if current_weight + weight_lst[idx] <= capacity:\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n            else:\n                marginal_value1 = 0\n                marginal_value2 = 0\n        marginal_values.append((marginal_value1 + marginal_value2, idx))\n\n    # Sort candidates by their marginal value contributions\n    marginal_values.sort(reverse=True, key=lambda x: x[0])\n\n    # Step 3: Perform the swap if it improves both objectives\n    for _, idx in marginal_values:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it's included\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight >= 0:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try to add the item if it's excluded and feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional step: Randomly flip a small number of items to escape local optima\n    flip_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3353593003048719,
            1.0899836122989655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions that are not too crowded in the archive\n    # This helps in exploring less-explored regions\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to swap (value-based selection)\n    # 2. Adjust the selection to maintain feasibility\n    # 3. Perform a value-based swap to improve both objectives\n\n    # Step 1: Select a subset of items to consider for swapping\n    num_items = len(new_solution)\n    subset_size = min(5, num_items // 2)  # Dynamic subset size\n    candidate_indices = np.random.choice(num_items, size=subset_size, replace=False)\n\n    # Step 2: Evaluate the potential of each candidate item for swapping\n    # We prioritize items that have high marginal value contributions\n    marginal_values = []\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # If item is included, evaluate its marginal contribution\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n        else:\n            # If item is excluded, evaluate its potential contribution\n            if current_weight + weight_lst[idx] <= capacity:\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n            else:\n                marginal_value1 = 0\n                marginal_value2 = 0\n        marginal_values.append((marginal_value1 + marginal_value2, idx))\n\n    # Sort candidates by their marginal value contributions\n    marginal_values.sort(reverse=True, key=lambda x: x[0])\n\n    # Step 3: Perform the swap if it improves both objectives\n    for _, idx in marginal_values:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it's included\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight >= 0:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try to add the item if it's excluded and feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional step: Randomly flip a small number of items to escape local optima\n    flip_indices = np.random.choice(num_items, size=min(2, num_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with the highest combined value (promising for further improvement)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items not in the solution\n    available_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of available items to flip (with some bias towards higher value items)\n    if len(available_items) > 0:\n        num_to_flip = min(3, len(available_items))  # Flip up to 3 items at a time\n        # Select items with higher value (objective 1) first\n        sorted_available = sorted(available_items, key=lambda i: -value1_lst[i])\n        candidates = sorted_available[:num_to_flip]\n\n        for i in candidates:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Randomly remove some items to ensure diversity and feasibility\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        num_to_remove = min(2, len(current_items))\n        items_to_remove = np.random.choice(current_items, num_to_remove, replace=False)\n        new_solution[items_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9369251526520785,
            1.547967940568924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with the highest combined value (promising for further improvement)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items not in the solution\n    available_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of available items to flip (with some bias towards higher value items)\n    if len(available_items) > 0:\n        num_to_flip = min(3, len(available_items))  # Flip up to 3 items at a time\n        # Select items with higher value (objective 1) first\n        sorted_available = sorted(available_items, key=lambda i: -value1_lst[i])\n        candidates = sorted_available[:num_to_flip]\n\n        for i in candidates:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Randomly remove some items to ensure diversity and feasibility\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        num_to_remove = min(2, len(current_items))\n        items_to_remove = np.random.choice(current_items, num_to_remove, replace=False)\n        new_solution[items_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with the highest combined value (promising for further improvement)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items not in the solution\n    available_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of available items to flip (with some bias towards higher value items)\n    if len(available_items) > 0:\n        num_to_flip = min(3, len(available_items))  # Flip up to 3 items at a time\n        # Select items with higher value (objective 1) first\n        sorted_available = sorted(available_items, key=lambda i: -value1_lst[i])\n        candidates = sorted_available[:num_to_flip]\n\n        for i in candidates:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Randomly remove some items to ensure diversity and feasibility\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        num_to_remove = min(2, len(current_items))\n        items_to_remove = np.random.choice(current_items, num_to_remove, replace=False)\n        new_solution[items_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9369251526520785,
            1.547967940568924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with the highest combined value (promising for further improvement)\n    selected = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items not in the solution\n    available_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of available items to flip (with some bias towards higher value items)\n    if len(available_items) > 0:\n        num_to_flip = min(3, len(available_items))  # Flip up to 3 items at a time\n        # Select items with higher value (objective 1) first\n        sorted_available = sorted(available_items, key=lambda i: -value1_lst[i])\n        candidates = sorted_available[:num_to_flip]\n\n        for i in candidates:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Randomly remove some items to ensure diversity and feasibility\n    current_items = np.where(new_solution == 1)[0]\n    if len(current_items) > 0:\n        num_to_remove = min(2, len(current_items))\n        items_to_remove = np.random.choice(current_items, num_to_remove, replace=False)\n        new_solution[items_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to encourage exploration\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine bit-flip and swap operations\n    # Step 1: Randomly select a subset of items to consider for flipping\n    n_items = len(weight_lst)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in flip_indices:\n        # Attempt to flip the bit\n        new_solution[idx] = 1 - new_solution[idx]\n\n        # Check feasibility\n        new_weight = current_weight + (new_solution[idx] - base_solution[idx]) * weight_lst[idx]\n        if new_weight <= capacity:\n            # If feasible, accept the change\n            base_solution = new_solution.copy()\n            current_weight = new_weight\n        else:\n            # Revert if infeasible\n            new_solution[idx] = base_solution[idx]\n\n    # Step 2: Perform a random swap if the solution is still feasible\n    if np.random.rand() < 0.5 and len(np.where(base_solution == 1)[0]) >= 2:\n        # Select two distinct items to swap\n        selected_items = np.random.choice(np.where(base_solution == 1)[0], size=2, replace=False)\n        new_solution[selected_items[0]], new_solution[selected_items[1]] = new_solution[selected_items[1]], new_solution[selected_items[0]]\n\n        # Check feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # Revert if infeasible\n            new_solution[selected_items[0]], new_solution[selected_items[1]] = new_solution[selected_items[1]], new_solution[selected_items[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8627810078614999,
            1.2113247215747833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select the middle solution to encourage exploration\n        base_solution = archive_sorted[len(archive) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine bit-flip and swap operations\n    # Step 1: Randomly select a subset of items to consider for flipping\n    n_items = len(weight_lst)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    for idx in flip_indices:\n        # Attempt to flip the bit\n        new_solution[idx] = 1 - new_solution[idx]\n\n        # Check feasibility\n        new_weight = current_weight + (new_solution[idx] - base_solution[idx]) * weight_lst[idx]\n        if new_weight <= capacity:\n            # If feasible, accept the change\n            base_solution = new_solution.copy()\n            current_weight = new_weight\n        else:\n            # Revert if infeasible\n            new_solution[idx] = base_solution[idx]\n\n    # Step 2: Perform a random swap if the solution is still feasible\n    if np.random.rand() < 0.5 and len(np.where(base_solution == 1)[0]) >= 2:\n        # Select two distinct items to swap\n        selected_items = np.random.choice(np.where(base_solution == 1)[0], size=2, replace=False)\n        new_solution[selected_items[0]], new_solution[selected_items[1]] = new_solution[selected_items[1]], new_solution[selected_items[0]]\n\n        # Check feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # Revert if infeasible\n            new_solution[selected_items[0]], new_solution[selected_items[1]] = new_solution[selected_items[1]], new_solution[selected_items[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution from the archive with a bias towards higher-value solutions\n    def selection_probability(obj):\n        return (obj[0] + obj[1]) ** 2  # Higher values have higher probability\n\n    solutions, objectives = zip(*archive)\n    probs = np.array([selection_probability(obj) for obj in objectives])\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate a neighbor by performing a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap a subset of items\n    swap_indices = random.sample(range(n_items), min(3, n_items))  # Swap up to 3 items\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the item\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    current_weight = np.dot(new_solution, weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Evaluate items not in the solution\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        # Calculate the marginal gain per unit weight for both objectives\n        marginal_gain1 = value1_lst[candidate_indices] / weight_lst[candidate_indices]\n        marginal_gain2 = value2_lst[candidate_indices] / weight_lst[candidate_indices]\n\n        # Combine gains using a simple weighted sum (can be replaced with more sophisticated methods)\n        combined_gain = marginal_gain1 + marginal_gain2\n        sorted_indices = candidate_indices[np.argsort(-combined_gain)]\n\n        for idx in sorted_indices:\n            if weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Ensure feasibility\n    if np.dot(new_solution, weight_lst) > capacity:\n        # If not feasible, remove items with the lowest combined marginal gain\n        included_indices = np.where(new_solution == 1)[0]\n        if len(included_indices) > 0:\n            marginal_gain1 = value1_lst[included_indices] / weight_lst[included_indices]\n            marginal_gain2 = value2_lst[included_indices] / weight_lst[included_indices]\n            combined_gain = marginal_gain1 + marginal_gain2\n            sorted_indices = included_indices[np.argsort(combined_gain)]\n\n            for idx in sorted_indices:\n                new_solution[idx] = 0\n                if np.dot(new_solution, weight_lst) <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.35557483838431664,
            2.52399018406868
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution from the archive with a bias towards higher-value solutions\n    def selection_probability(obj):\n        return (obj[0] + obj[1]) ** 2  # Higher values have higher probability\n\n    solutions, objectives = zip(*archive)\n    probs = np.array([selection_probability(obj) for obj in objectives])\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate a neighbor by performing a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Step 1: Randomly swap a subset of items\n    swap_indices = random.sample(range(n_items), min(3, n_items))  # Swap up to 3 items\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the item\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    current_weight = np.dot(new_solution, weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Evaluate items not in the solution\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        # Calculate the marginal gain per unit weight for both objectives\n        marginal_gain1 = value1_lst[candidate_indices] / weight_lst[candidate_indices]\n        marginal_gain2 = value2_lst[candidate_indices] / weight_lst[candidate_indices]\n\n        # Combine gains using a simple weighted sum (can be replaced with more sophisticated methods)\n        combined_gain = marginal_gain1 + marginal_gain2\n        sorted_indices = candidate_indices[np.argsort(-combined_gain)]\n\n        for idx in sorted_indices:\n            if weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Ensure feasibility\n    if np.dot(new_solution, weight_lst) > capacity:\n        # If not feasible, remove items with the lowest combined marginal gain\n        included_indices = np.where(new_solution == 1)[0]\n        if len(included_indices) > 0:\n            marginal_gain1 = value1_lst[included_indices] / weight_lst[included_indices]\n            marginal_gain2 = value2_lst[included_indices] / weight_lst[included_indices]\n            combined_gain = marginal_gain1 + marginal_gain2\n            sorted_indices = included_indices[np.argsort(combined_gain)]\n\n            for idx in sorted_indices:\n                new_solution[idx] = 0\n                if np.dot(new_solution, weight_lst) <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    improvement_scores = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        available_weight = capacity - current_weight\n        # Potential improvement is based on available weight and item values\n        potential_improvement = np.sum((weight_lst <= available_weight) * (value1_lst + value2_lst))\n        improvement_scores.append(potential_improvement)\n\n    # Select the solution with the highest improvement score\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine flip-based and swap-based moves\n    new_solution = base_solution.copy()\n\n    # Step 1: Flip-based move (try adding or removing items)\n    flip_indices = np.where(new_solution == 1)[0]\n    if len(flip_indices) > 0:\n        # Randomly select an item to flip\n        flip_idx = random.choice(flip_indices)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If infeasible, revert the flip\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 2: Swap-based move (try swapping items)\n    if len(flip_indices) > 1:\n        # Randomly select two items to swap\n        swap_idx1, swap_idx2 = random.sample(list(flip_indices), 2)\n        new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If infeasible, revert the swap\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n    # Step 3: Add a new item if possible\n    zero_indices = np.where(new_solution == 0)[0]\n    if len(zero_indices) > 0:\n        # Select a random item to add\n        add_idx = random.choice(zero_indices)\n        new_solution[add_idx] = 1\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If infeasible, revert the addition\n            new_solution[add_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6654890426296942,
            3.180389314889908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    improvement_scores = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        available_weight = capacity - current_weight\n        # Potential improvement is based on available weight and item values\n        potential_improvement = np.sum((weight_lst <= available_weight) * (value1_lst + value2_lst))\n        improvement_scores.append(potential_improvement)\n\n    # Select the solution with the highest improvement score\n    selected_idx = np.argmax(improvement_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine flip-based and swap-based moves\n    new_solution = base_solution.copy()\n\n    # Step 1: Flip-based move (try adding or removing items)\n    flip_indices = np.where(new_solution == 1)[0]\n    if len(flip_indices) > 0:\n        # Randomly select an item to flip\n        flip_idx = random.choice(flip_indices)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If infeasible, revert the flip\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Step 2: Swap-based move (try swapping items)\n    if len(flip_indices) > 1:\n        # Randomly select two items to swap\n        swap_idx1, swap_idx2 = random.sample(list(flip_indices), 2)\n        new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If infeasible, revert the swap\n            new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n    # Step 3: Add a new item if possible\n    zero_indices = np.where(new_solution == 0)[0]\n    if len(zero_indices) > 0:\n        # Select a random item to add\n        add_idx = random.choice(zero_indices)\n        new_solution[add_idx] = 1\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # If infeasible, revert the addition\n            new_solution[add_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine flip-based and swap-based moves\n    # Step 1: Flip-based move (try to add or remove a random item)\n    flip_candidates = np.where(base_solution == 0)[0] if np.random.rand() < 0.5 else np.where(base_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        if base_solution[flip_idx] == 0:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n        else:\n            # Try to remove item\n            new_solution[flip_idx] = 0\n\n    # Step 2: Swap-based move (try to swap two items)\n    if np.sum(new_solution) > 1:\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = np.random.choice(in_items)\n            out_idx = np.random.choice(out_items)\n\n            # Check if swap maintains feasibility\n            new_weight = current_weight - weight_lst[in_idx] + weight_lst[out_idx]\n            if new_weight <= capacity:\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4088514285266502,
            1.8490056693553925
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine flip-based and swap-based moves\n    # Step 1: Flip-based move (try to add or remove a random item)\n    flip_candidates = np.where(base_solution == 0)[0] if np.random.rand() < 0.5 else np.where(base_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        if base_solution[flip_idx] == 0:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n        else:\n            # Try to remove item\n            new_solution[flip_idx] = 0\n\n    # Step 2: Swap-based move (try to swap two items)\n    if np.sum(new_solution) > 1:\n        # Select two items to swap (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = np.random.choice(in_items)\n            out_idx = np.random.choice(out_items)\n\n            # Check if swap maintains feasibility\n            new_weight = current_weight - weight_lst[in_idx] + weight_lst[out_idx]\n            if new_weight <= capacity:\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flip with value-based swap\n    # Step 1: Randomly flip a subset of items (with a bias towards low-value items)\n    flip_mask = np.random.rand(len(new_solution)) < 0.3  # 30% chance to flip each item\n    flip_candidates = np.where(flip_mask)[0]\n\n    for item in flip_candidates:\n        if new_solution[item] == 1:\n            # If item is in the solution, check if removing it keeps it feasible\n            if np.sum(new_solution * weight_lst) - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            # If item is not in the solution, check if adding it keeps it feasible\n            if np.sum(new_solution * weight_lst) + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    # Step 2: Value-based swap - swap items between high and low value categories\n    # Calculate marginal values\n    current_weight = np.sum(new_solution * weight_lst)\n    marginal_value1 = value1_lst - (new_solution * value1_lst)\n    marginal_value2 = value2_lst - (new_solution * value2_lst)\n\n    # Identify items to potentially swap\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    # Sort by marginal value for each objective\n    in_sorted_value1 = sorted(in_solution, key=lambda x: marginal_value1[x], reverse=True)\n    out_sorted_value1 = sorted(out_solution, key=lambda x: marginal_value1[x])\n\n    in_sorted_value2 = sorted(in_solution, key=lambda x: marginal_value2[x], reverse=True)\n    out_sorted_value2 = sorted(out_solution, key=lambda x: marginal_value2[x])\n\n    # Perform swaps based on both objectives\n    for i in range(min(3, len(in_sorted_value1), len(out_sorted_value1))):\n        item_in = in_sorted_value1[i]\n        item_out = out_sorted_value1[i]\n\n        # Check if swap is feasible\n        if (current_weight - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n    for i in range(min(3, len(in_sorted_value2), len(out_sorted_value2))):\n        item_in = in_sorted_value2[i]\n        item_out = out_sorted_value2[i]\n\n        # Check if swap is feasible\n        if (current_weight - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n    return new_solution\n\n",
        "score": [
            -0.4036691883415311,
            6.26218569278717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flip with value-based swap\n    # Step 1: Randomly flip a subset of items (with a bias towards low-value items)\n    flip_mask = np.random.rand(len(new_solution)) < 0.3  # 30% chance to flip each item\n    flip_candidates = np.where(flip_mask)[0]\n\n    for item in flip_candidates:\n        if new_solution[item] == 1:\n            # If item is in the solution, check if removing it keeps it feasible\n            if np.sum(new_solution * weight_lst) - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            # If item is not in the solution, check if adding it keeps it feasible\n            if np.sum(new_solution * weight_lst) + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n\n    # Step 2: Value-based swap - swap items between high and low value categories\n    # Calculate marginal values\n    current_weight = np.sum(new_solution * weight_lst)\n    marginal_value1 = value1_lst - (new_solution * value1_lst)\n    marginal_value2 = value2_lst - (new_solution * value2_lst)\n\n    # Identify items to potentially swap\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    # Sort by marginal value for each objective\n    in_sorted_value1 = sorted(in_solution, key=lambda x: marginal_value1[x], reverse=True)\n    out_sorted_value1 = sorted(out_solution, key=lambda x: marginal_value1[x])\n\n    in_sorted_value2 = sorted(in_solution, key=lambda x: marginal_value2[x], reverse=True)\n    out_sorted_value2 = sorted(out_solution, key=lambda x: marginal_value2[x])\n\n    # Perform swaps based on both objectives\n    for i in range(min(3, len(in_sorted_value1), len(out_sorted_value1))):\n        item_in = in_sorted_value1[i]\n        item_out = out_sorted_value1[i]\n\n        # Check if swap is feasible\n        if (current_weight - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n    for i in range(min(3, len(in_sorted_value2), len(out_sorted_value2))):\n        item_in = in_sorted_value2[i]\n        item_out = out_sorted_value2[i]\n\n        # Check if swap is feasible\n        if (current_weight - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n            new_solution[item_in] = 0\n            new_solution[item_out] = 1\n            current_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity * 0.9:  # Avoid solutions too close to capacity\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no candidates, select a random solution\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a candidate with high potential (e.g., high objective values)\n        base_solution = max(candidates, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine swap and insertion moves\n    n_items = len(weight_lst)\n    moves_performed = 0\n    max_moves = min(3, n_items)  # Limit the number of moves to avoid excessive computation\n\n    while moves_performed < max_moves:\n        # Randomly select a move type\n        move_type = random.choice(['swap', 'insert', 'remove'])\n\n        if move_type == 'swap':\n            # Swap two items in the knapsack with two items outside\n            in_knapsack = np.where(new_solution == 1)[0]\n            out_knapsack = np.where(new_solution == 0)[0]\n\n            if len(in_knapsack) > 0 and len(out_knapsack) > 0:\n                i = random.choice(in_knapsack)\n                j = random.choice(out_knapsack)\n\n                # Check feasibility\n                current_weight = np.sum(weight_lst * new_solution)\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    moves_performed += 1\n\n        elif move_type == 'insert':\n            # Insert an item into the knapsack\n            out_knapsack = np.where(new_solution == 0)[0]\n\n            if len(out_knapsack) > 0:\n                j = random.choice(out_knapsack)\n\n                # Check feasibility\n                current_weight = np.sum(weight_lst * new_solution)\n                new_weight = current_weight + weight_lst[j]\n\n                if new_weight <= capacity:\n                    new_solution[j] = 1\n                    moves_performed += 1\n\n        elif move_type == 'remove':\n            # Remove an item from the knapsack\n            in_knapsack = np.where(new_solution == 1)[0]\n\n            if len(in_knapsack) > 0:\n                i = random.choice(in_knapsack)\n                new_solution[i] = 0\n                moves_performed += 1\n\n    return new_solution\n\n",
        "score": [
            -0.40223789013255007,
            1.2371284663677216
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity * 0.9:  # Avoid solutions too close to capacity\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no candidates, select a random solution\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a candidate with high potential (e.g., high objective values)\n        base_solution = max(candidates, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine swap and insertion moves\n    n_items = len(weight_lst)\n    moves_performed = 0\n    max_moves = min(3, n_items)  # Limit the number of moves to avoid excessive computation\n\n    while moves_performed < max_moves:\n        # Randomly select a move type\n        move_type = random.choice(['swap', 'insert', 'remove'])\n\n        if move_type == 'swap':\n            # Swap two items in the knapsack with two items outside\n            in_knapsack = np.where(new_solution == 1)[0]\n            out_knapsack = np.where(new_solution == 0)[0]\n\n            if len(in_knapsack) > 0 and len(out_knapsack) > 0:\n                i = random.choice(in_knapsack)\n                j = random.choice(out_knapsack)\n\n                # Check feasibility\n                current_weight = np.sum(weight_lst * new_solution)\n                new_weight = current_weight - weight_lst[i] + weight_lst[j]\n\n                if new_weight <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    moves_performed += 1\n\n        elif move_type == 'insert':\n            # Insert an item into the knapsack\n            out_knapsack = np.where(new_solution == 0)[0]\n\n            if len(out_knapsack) > 0:\n                j = random.choice(out_knapsack)\n\n                # Check feasibility\n                current_weight = np.sum(weight_lst * new_solution)\n                new_weight = current_weight + weight_lst[j]\n\n                if new_weight <= capacity:\n                    new_solution[j] = 1\n                    moves_performed += 1\n\n        elif move_type == 'remove':\n            # Remove an item from the knapsack\n            in_knapsack = np.where(new_solution == 1)[0]\n\n            if len(in_knapsack) > 0:\n                i = random.choice(in_knapsack)\n                new_solution[i] = 0\n                moves_performed += 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search strategy: combination of flip and swap\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip with weight constraint\n    if remaining_capacity > 0:\n        # Select items to flip (remove or add)\n        flip_candidates = np.where(base_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            flip_idx = np.random.choice(flip_candidates)\n            new_solution[flip_idx] = 0\n            remaining_capacity += weight_lst[flip_idx]\n\n            # Add a new item if possible\n            add_candidates = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n            if len(add_candidates) > 0:\n                add_idx = np.random.choice(add_candidates)\n                new_solution[add_idx] = 1\n\n    # Step 2: Random swap with weight constraint\n    swap_candidates = np.where(base_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        swap1, swap2 = np.random.choice(swap_candidates, 2, replace=False)\n        weight_diff = weight_lst[swap2] - weight_lst[swap1]\n\n        if remaining_capacity >= weight_diff:\n            new_solution[swap1], new_solution[swap2] = new_solution[swap2], new_solution[swap1]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        while total_weight > capacity:\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break\n            remove_idx = np.random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5758116356438686,
            1.6508080065250397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.array([])\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search strategy: combination of flip and swap\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip with weight constraint\n    if remaining_capacity > 0:\n        # Select items to flip (remove or add)\n        flip_candidates = np.where(base_solution == 1)[0]\n        if len(flip_candidates) > 0:\n            flip_idx = np.random.choice(flip_candidates)\n            new_solution[flip_idx] = 0\n            remaining_capacity += weight_lst[flip_idx]\n\n            # Add a new item if possible\n            add_candidates = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n            if len(add_candidates) > 0:\n                add_idx = np.random.choice(add_candidates)\n                new_solution[add_idx] = 1\n\n    # Step 2: Random swap with weight constraint\n    swap_candidates = np.where(base_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        swap1, swap2 = np.random.choice(swap_candidates, 2, replace=False)\n        weight_diff = weight_lst[swap2] - weight_lst[swap1]\n\n        if remaining_capacity >= weight_diff:\n            new_solution[swap1], new_solution[swap2] = new_solution[swap2], new_solution[swap1]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        while total_weight > capacity:\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break\n            remove_idx = np.random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_values = np.array([sol_obj[1] for sol_obj in archive])\n\n    # Calculate the crowding distance to identify less crowded solutions\n    crowding_dist = np.zeros(len(archive))\n    for obj_idx in range(2):\n        sorted_idx = np.argsort(archive_values[:, obj_idx])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_idx[i]] += (archive_values[sorted_idx[i+1], obj_idx] - archive_values[sorted_idx[i-1], obj_idx])\n\n    # Prefer solutions with lower crowding distance (less explored)\n    selected_idx = np.argmin(crowding_dist)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: random flip + greedy improvement\n    new_solution = base_solution.copy()\n\n    # Random flip: flip a random subset of items\n    flip_mask = np.random.rand(len(new_solution)) < 0.1  # 10% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility: remove items if weight exceeds capacity\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        excess_weight = total_weight - capacity\n        # Remove items with the smallest ratio of (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices[::-1]:  # Remove items with lowest ratio first\n            if new_solution[idx] == 1 and excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    # Greedy improvement: add the most valuable items not in the solution\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n\n    # Prioritize items with the highest combined value-to-weight ratio\n    item_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_items = np.argsort(item_ratios[available_items])[::-1]\n\n    for idx in sorted_items:\n        if weight_lst[available_items[idx]] <= remaining_weight:\n            new_solution[available_items[idx]] = 1\n            remaining_weight -= weight_lst[available_items[idx]]\n\n    return new_solution\n\n",
        "score": [
            -0.3154984909137406,
            2.046384245157242
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_values = np.array([sol_obj[1] for sol_obj in archive])\n\n    # Calculate the crowding distance to identify less crowded solutions\n    crowding_dist = np.zeros(len(archive))\n    for obj_idx in range(2):\n        sorted_idx = np.argsort(archive_values[:, obj_idx])\n        crowding_dist[sorted_idx[0]] = np.inf\n        crowding_dist[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_dist[sorted_idx[i]] += (archive_values[sorted_idx[i+1], obj_idx] - archive_values[sorted_idx[i-1], obj_idx])\n\n    # Prefer solutions with lower crowding distance (less explored)\n    selected_idx = np.argmin(crowding_dist)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: random flip + greedy improvement\n    new_solution = base_solution.copy()\n\n    # Random flip: flip a random subset of items\n    flip_mask = np.random.rand(len(new_solution)) < 0.1  # 10% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility: remove items if weight exceeds capacity\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        excess_weight = total_weight - capacity\n        # Remove items with the smallest ratio of (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices[::-1]:  # Remove items with lowest ratio first\n            if new_solution[idx] == 1 and excess_weight <= 0:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n    # Greedy improvement: add the most valuable items not in the solution\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    available_items = np.where(new_solution == 0)[0]\n\n    # Prioritize items with the highest combined value-to-weight ratio\n    item_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_items = np.argsort(item_ratios[available_items])[::-1]\n\n    for idx in sorted_items:\n        if weight_lst[available_items[idx]] <= remaining_weight:\n            new_solution[available_items[idx]] = 1\n            remaining_weight -= weight_lst[available_items[idx]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Random flip with objective-aware probability\n    # 2. Capacity-aware swap\n    # 3. Objective-driven adjustment\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip with objective-aware probability\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                # Remove item if it doesn't violate capacity\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Add item if it doesn't violate capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Capacity-aware swap (try to improve both objectives)\n    if current_weight < capacity:\n        # Find items not in solution that could be added\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            # Select item with highest combined value density\n            value_density1 = value1_lst[candidates] / weight_lst[candidates]\n            value_density2 = value2_lst[candidates] / weight_lst[candidates]\n            combined_density = value_density1 + value_density2\n            best_candidate = candidates[np.argmax(combined_density)]\n\n            if current_weight + weight_lst[best_candidate] <= capacity:\n                new_solution[best_candidate] = 1\n\n    # Step 3: Objective-driven adjustment (try to improve one objective at a time)\n    if random.random() < 0.5:  # 50% chance to focus on objective 1\n        # Find item in solution with lowest value1/weight ratio to remove\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            value_density1 = value1_lst[in_solution] / weight_lst[in_solution]\n            worst_item = in_solution[np.argmin(value_density1)]\n            new_solution[worst_item] = 0\n    else:  # focus on objective 2\n        # Find item in solution with lowest value2/weight ratio to remove\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            value_density2 = value2_lst[in_solution] / weight_lst[in_solution]\n            worst_item = in_solution[np.argmin(value_density2)]\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.37868041513445994,
            1.2470553517341614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Random flip with objective-aware probability\n    # 2. Capacity-aware swap\n    # 3. Objective-driven adjustment\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Random flip with objective-aware probability\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                # Remove item if it doesn't violate capacity\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Add item if it doesn't violate capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Capacity-aware swap (try to improve both objectives)\n    if current_weight < capacity:\n        # Find items not in solution that could be added\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            # Select item with highest combined value density\n            value_density1 = value1_lst[candidates] / weight_lst[candidates]\n            value_density2 = value2_lst[candidates] / weight_lst[candidates]\n            combined_density = value_density1 + value_density2\n            best_candidate = candidates[np.argmax(combined_density)]\n\n            if current_weight + weight_lst[best_candidate] <= capacity:\n                new_solution[best_candidate] = 1\n\n    # Step 3: Objective-driven adjustment (try to improve one objective at a time)\n    if random.random() < 0.5:  # 50% chance to focus on objective 1\n        # Find item in solution with lowest value1/weight ratio to remove\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            value_density1 = value1_lst[in_solution] / weight_lst[in_solution]\n            worst_item = in_solution[np.argmin(value_density1)]\n            new_solution[worst_item] = 0\n    else:  # focus on objective 2\n        # Find item in solution with lowest value2/weight ratio to remove\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            value_density2 = value2_lst[in_solution] / weight_lst[in_solution]\n            worst_item = in_solution[np.argmin(value_density2)]\n            new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    candidate_indices = []\n    for idx, (solution, _) in enumerate(archive):\n        current_weight = np.dot(solution, weight_lst)\n        if current_weight < capacity:\n            candidate_indices.append(idx)\n\n    if not candidate_indices:\n        return archive[0][0].copy()  # Fallback to first solution if no candidates\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swap followed by greedy improvement\n    n_items = len(new_solution)\n    if n_items < 2:\n        return new_solution  # No possible swaps\n\n    # Random swap\n    i, j = random.sample(range(n_items), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    current_weight = np.dot(new_solution, weight_lst)\n    if current_weight > capacity:\n        # If infeasible, greedily remove the heaviest item not in the original solution\n        for item in range(n_items):\n            if new_solution[item] == 1 and base_solution[item] == 0:\n                new_solution[item] = 0\n                current_weight = np.dot(new_solution, weight_lst)\n                if current_weight <= capacity:\n                    break\n\n    # Greedy improvement: try to add the most valuable item not in the solution\n    remaining_weight = capacity - np.dot(new_solution, weight_lst)\n    if remaining_weight > 0:\n        # Calculate marginal gains for both objectives\n        marginal_gain1 = value1_lst - np.dot(new_solution, value1_lst)\n        marginal_gain2 = value2_lst - np.dot(new_solution, value2_lst)\n        # Normalize gains to balance objectives\n        normalized_gain = marginal_gain1 + marginal_gain2\n        # Select the best candidate item to add\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_weight))[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(normalized_gain[candidate_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.30261012621620864,
            7.161549121141434
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    candidate_indices = []\n    for idx, (solution, _) in enumerate(archive):\n        current_weight = np.dot(solution, weight_lst)\n        if current_weight < capacity:\n            candidate_indices.append(idx)\n\n    if not candidate_indices:\n        return archive[0][0].copy()  # Fallback to first solution if no candidates\n\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swap followed by greedy improvement\n    n_items = len(new_solution)\n    if n_items < 2:\n        return new_solution  # No possible swaps\n\n    # Random swap\n    i, j = random.sample(range(n_items), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    current_weight = np.dot(new_solution, weight_lst)\n    if current_weight > capacity:\n        # If infeasible, greedily remove the heaviest item not in the original solution\n        for item in range(n_items):\n            if new_solution[item] == 1 and base_solution[item] == 0:\n                new_solution[item] = 0\n                current_weight = np.dot(new_solution, weight_lst)\n                if current_weight <= capacity:\n                    break\n\n    # Greedy improvement: try to add the most valuable item not in the solution\n    remaining_weight = capacity - np.dot(new_solution, weight_lst)\n    if remaining_weight > 0:\n        # Calculate marginal gains for both objectives\n        marginal_gain1 = value1_lst - np.dot(new_solution, value1_lst)\n        marginal_gain2 = value2_lst - np.dot(new_solution, value2_lst)\n        # Normalize gains to balance objectives\n        normalized_gain = marginal_gain1 + marginal_gain2\n        # Select the best candidate item to add\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_weight))[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(normalized_gain[candidate_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we select the solution with the highest sum of normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for flipping\n    n_items = len(base_solution)\n    subset_size = max(1, int(0.3 * n_items))  # Consider 30% of items\n    subset_indices = np.random.choice(n_items, subset_size, replace=False)\n\n    # 2. For each item in the subset, decide whether to flip it based on:\n    #    a) The item's contribution to both objectives\n    #    b) The current solution's total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    for idx in subset_indices:\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it if it's not critical\n            if np.random.rand() < 0.5 or current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, consider adding it if it improves both objectives\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate potential improvement for both objectives\n                obj1_improvement = value1_lst[idx]\n                obj2_improvement = value2_lst[idx]\n                if (obj1_improvement > 0 and obj2_improvement > 0) or np.random.rand() < 0.3:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # If infeasible, remove items randomly until feasible\n        excess = new_weight - capacity\n        while excess > 0 and np.any(new_solution == 1):\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.863400884287736,
            1.5373681485652924
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we select the solution with the highest sum of normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for flipping\n    n_items = len(base_solution)\n    subset_size = max(1, int(0.3 * n_items))  # Consider 30% of items\n    subset_indices = np.random.choice(n_items, subset_size, replace=False)\n\n    # 2. For each item in the subset, decide whether to flip it based on:\n    #    a) The item's contribution to both objectives\n    #    b) The current solution's total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    for idx in subset_indices:\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it if it's not critical\n            if np.random.rand() < 0.5 or current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, consider adding it if it improves both objectives\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate potential improvement for both objectives\n                obj1_improvement = value1_lst[idx]\n                obj2_improvement = value2_lst[idx]\n                if (obj1_improvement > 0 and obj2_improvement > 0) or np.random.rand() < 0.3:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # If infeasible, remove items randomly until feasible\n        excess = new_weight - capacity\n        while excess > 0 and np.any(new_solution == 1):\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Intelligently select a promising solution from the archive\n    # Prefer solutions that are not too close to the boundary (to allow room for improvement)\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < 0.9 * capacity:  # Avoid solutions too close to capacity\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if no candidates\n\n    # Randomly select a base solution with probability proportional to its potential improvement\n    base_solution = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search strategy\n    # Strategy: Randomly swap items between high-value and low-value items, then flip bits based on weighted objectives\n    n_items = len(weight_lst)\n    if n_items == 0:\n        return new_solution\n\n    # Identify high-value and low-value items based on both objectives\n    combined_value = value1_lst + value2_lst\n    high_value_items = np.argsort(combined_value)[-n_items//2:]  # Top 50% items\n    low_value_items = np.argsort(combined_value)[:n_items//2]    # Bottom 50% items\n\n    # Randomly swap items between high and low value categories\n    for _ in range(3):  # Perform 3 random swaps\n        if len(high_value_items) > 0 and len(low_value_items) > 0:\n            hi = random.choice(high_value_items)\n            lo = random.choice(low_value_items)\n            new_solution[hi], new_solution[lo] = new_solution[lo], new_solution[hi]\n\n    # Randomly flip bits based on weighted objectives\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip each bit\n            new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing excess items if capacity is exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with the smallest combined value per weight\n        item_efficiency = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(item_efficiency)\n        for i in sorted_indices:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3732944561185102,
            1.9313380718231201
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Intelligently select a promising solution from the archive\n    # Prefer solutions that are not too close to the boundary (to allow room for improvement)\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < 0.9 * capacity:  # Avoid solutions too close to capacity\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if no candidates\n\n    # Randomly select a base solution with probability proportional to its potential improvement\n    base_solution = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search strategy\n    # Strategy: Randomly swap items between high-value and low-value items, then flip bits based on weighted objectives\n    n_items = len(weight_lst)\n    if n_items == 0:\n        return new_solution\n\n    # Identify high-value and low-value items based on both objectives\n    combined_value = value1_lst + value2_lst\n    high_value_items = np.argsort(combined_value)[-n_items//2:]  # Top 50% items\n    low_value_items = np.argsort(combined_value)[:n_items//2]    # Bottom 50% items\n\n    # Randomly swap items between high and low value categories\n    for _ in range(3):  # Perform 3 random swaps\n        if len(high_value_items) > 0 and len(low_value_items) > 0:\n            hi = random.choice(high_value_items)\n            lo = random.choice(low_value_items)\n            new_solution[hi], new_solution[lo] = new_solution[lo], new_solution[hi]\n\n    # Randomly flip bits based on weighted objectives\n    for i in range(n_items):\n        if random.random() < 0.2:  # 20% chance to flip each bit\n            new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing excess items if capacity is exceeded\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with the smallest combined value per weight\n        item_efficiency = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(item_efficiency)\n        for i in sorted_indices:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards higher value solutions\n    weights = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = weights / np.sum(weights)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for flip (items that can be toggled without violating capacity)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item would still keep the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append(i)\n        else:\n            # Check if adding the item would keep the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append(i)\n\n    if not candidate_items:\n        # If no candidates, perform a random flip among all items (may require multiple flips to return to feasibility)\n        candidate_items = list(range(len(base_solution)))\n\n    # Select a subset of candidate items to flip (hybrid approach)\n    num_flips = min(3, len(candidate_items))  # Limit to 3 flips for computational efficiency\n    flip_indices = random.sample(candidate_items, num_flips)\n\n    # Create new solution by flipping selected items\n    new_solution = base_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility (in case of multiple flips)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If still infeasible, perform a greedy repair\n        # Sort items by (value1 + value2)/weight in descending order and remove items until feasible\n        items_sorted = sorted(range(len(new_solution)), key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i], reverse=True)\n        for i in items_sorted:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8222828855324602,
            1.5905657708644867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards higher value solutions\n    weights = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = weights / np.sum(weights)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate candidate items for flip (items that can be toggled without violating capacity)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item would still keep the solution feasible\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append(i)\n        else:\n            # Check if adding the item would keep the solution feasible\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                candidate_items.append(i)\n\n    if not candidate_items:\n        # If no candidates, perform a random flip among all items (may require multiple flips to return to feasibility)\n        candidate_items = list(range(len(base_solution)))\n\n    # Select a subset of candidate items to flip (hybrid approach)\n    num_flips = min(3, len(candidate_items))  # Limit to 3 flips for computational efficiency\n    flip_indices = random.sample(candidate_items, num_flips)\n\n    # Create new solution by flipping selected items\n    new_solution = base_solution.copy()\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility (in case of multiple flips)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If still infeasible, perform a greedy repair\n        # Sort items by (value1 + value2)/weight in descending order and remove items until feasible\n        items_sorted = sorted(range(len(new_solution)), key=lambda i: (value1_lst[i] + value2_lst[i]) / weight_lst[i], reverse=True)\n        for i in items_sorted:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                total_weight -= weight_lst[i]\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol[0] for sol in archive]\n    archive_values = [sol[1] for sol in archive]\n\n    # Calculate the \"improvement potential\" for each solution\n    potential = []\n    for sol, (v1, v2) in zip(archive_solutions, archive_values):\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Potential is based on the ratio of remaining capacity to total capacity\n        # and the current values (higher values indicate higher potential)\n        potential.append((v1 + v2) * remaining_capacity / capacity)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly select a subset of items to flip (swap 0 and 1)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, check if removing it keeps the solution feasible\n            if np.sum(weight_lst * new_solution) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If the item is excluded, check if adding it keeps the solution feasible\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Strategy 2: Add the most valuable item not in the solution (for each objective)\n    if np.sum(new_solution) < n_items:\n        # For objective 1\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            best_idx = candidate_indices[np.argmax(value1_lst[candidate_indices])]\n            if np.sum(weight_lst * new_solution) + weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 1\n\n    # Strategy 3: Remove the least valuable item in the solution (for both objectives)\n    if np.sum(new_solution) > 0:\n        included_indices = np.where(new_solution == 1)[0]\n        # Calculate the combined value (normalized) for each included item\n        combined_value = (value1_lst[included_indices] + value2_lst[included_indices]) / (weight_lst[included_indices] + 1e-6)\n        worst_idx = included_indices[np.argmin(combined_value)]\n        if np.sum(weight_lst * new_solution) - weight_lst[worst_idx] <= capacity:\n            new_solution[worst_idx] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the least valuable item until feasible\n        included_indices = np.where(new_solution == 1)[0]\n        if len(included_indices) == 0:\n            break\n        combined_value = (value1_lst[included_indices] + value2_lst[included_indices]) / (weight_lst[included_indices] + 1e-6)\n        worst_idx = included_indices[np.argmin(combined_value)]\n        new_solution[worst_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5129270398488939,
            2.8161074221134186
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol[0] for sol in archive]\n    archive_values = [sol[1] for sol in archive]\n\n    # Calculate the \"improvement potential\" for each solution\n    potential = []\n    for sol, (v1, v2) in zip(archive_solutions, archive_values):\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Potential is based on the ratio of remaining capacity to total capacity\n        # and the current values (higher values indicate higher potential)\n        potential.append((v1 + v2) * remaining_capacity / capacity)\n\n    # Select the solution with the highest potential\n    selected_idx = np.argmax(potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly select a subset of items to flip (swap 0 and 1)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, check if removing it keeps the solution feasible\n            if np.sum(weight_lst * new_solution) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If the item is excluded, check if adding it keeps the solution feasible\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Strategy 2: Add the most valuable item not in the solution (for each objective)\n    if np.sum(new_solution) < n_items:\n        # For objective 1\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            best_idx = candidate_indices[np.argmax(value1_lst[candidate_indices])]\n            if np.sum(weight_lst * new_solution) + weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 1\n\n    # Strategy 3: Remove the least valuable item in the solution (for both objectives)\n    if np.sum(new_solution) > 0:\n        included_indices = np.where(new_solution == 1)[0]\n        # Calculate the combined value (normalized) for each included item\n        combined_value = (value1_lst[included_indices] + value2_lst[included_indices]) / (weight_lst[included_indices] + 1e-6)\n        worst_idx = included_indices[np.argmin(combined_value)]\n        if np.sum(weight_lst * new_solution) - weight_lst[worst_idx] <= capacity:\n            new_solution[worst_idx] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the least valuable item until feasible\n        included_indices = np.where(new_solution == 1)[0]\n        if len(included_indices) == 0:\n            break\n        combined_value = (value1_lst[included_indices] + value2_lst[included_indices]) / (weight_lst[included_indices] + 1e-6)\n        worst_idx = included_indices[np.argmin(combined_value)]\n        new_solution[worst_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not too close to the boundary\n    # This avoids selecting solutions that are already near capacity\n    base_solution, _ = max(archive, key=lambda x: np.sum(weight_lst * x[0]) / capacity)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Determine the number of items to swap (between 1 and min(10, N//2))\n    num_swaps = np.random.randint(1, min(10, len(weight_lst) // 2) + 1)\n\n    # Get indices of items currently in the solution\n    included_indices = np.where(new_solution == 1)[0]\n    excluded_indices = np.where(new_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for excluded items to prioritize high-value items\n    if len(excluded_indices) > 0:\n        excluded_values1 = value1_lst[excluded_indices]\n        excluded_values2 = value2_lst[excluded_indices]\n        excluded_weights = weight_lst[excluded_indices]\n\n        # Normalize the objectives to avoid bias towards one objective\n        norm_values1 = (excluded_values1 - np.min(excluded_values1)) / (np.max(excluded_values1) - np.min(excluded_values1) + 1e-10)\n        norm_values2 = (excluded_values2 - np.min(excluded_values2)) / (np.max(excluded_values2) - np.min(excluded_values2) + 1e-10)\n        combined_values = norm_values1 + norm_values2\n\n        # Sort excluded items by combined normalized value and weight ratio\n        excluded_items_sorted = sorted(zip(excluded_indices, combined_values / (excluded_weights + 1e-10)),\n                                      key=lambda x: -x[1])\n\n        # Select top items to consider for addition\n        top_items = [item[0] for item in excluded_items_sorted[:min(10, len(excluded_items_sorted))]]\n\n        # Randomly select items to swap in\n        swap_in = np.random.choice(top_items, size=min(num_swaps, len(top_items)), replace=False)\n\n        # Calculate the total weight of the items to be added\n        total_add_weight = np.sum(weight_lst[swap_in])\n\n        # If adding items exceeds capacity, remove some items first\n        if current_weight + total_add_weight > capacity:\n            # Calculate the excess weight\n            excess_weight = current_weight + total_add_weight - capacity\n\n            # Calculate value-to-weight ratios for included items to prioritize low-value items for removal\n            if len(included_indices) > 0:\n                included_values1 = value1_lst[included_indices]\n                included_values2 = value2_lst[included_indices]\n                included_weights = weight_lst[included_indices]\n\n                norm_included_values1 = (included_values1 - np.min(included_values1)) / (np.max(included_values1) - np.min(included_values1) + 1e-10)\n                norm_included_values2 = (included_values2 - np.min(included_values2)) / (np.max(included_values2) - np.min(included_values2) + 1e-10)\n                combined_included_values = norm_included_values1 + norm_included_values2\n\n                # Sort included items by combined normalized value and weight ratio (ascending)\n                included_items_sorted = sorted(zip(included_indices, combined_included_values / (included_weights + 1e-10)),\n                                             key=lambda x: x[1])\n\n                # Remove items until the excess weight is covered\n                removed_weight = 0\n                swap_out = []\n                for item in included_items_sorted:\n                    if removed_weight >= excess_weight:\n                        break\n                    swap_out.append(item[0])\n                    removed_weight += weight_lst[item[0]]\n\n                # If still not enough, randomly select more items to remove\n                if removed_weight < excess_weight:\n                    remaining_excess = excess_weight - removed_weight\n                    remaining_included = [i for i in included_indices if i not in swap_out]\n                    if remaining_included:\n                        remaining_weights = weight_lst[remaining_included]\n                        remaining_items = sorted(zip(remaining_included, remaining_weights),\n                                               key=lambda x: x[1])\n                        for item in remaining_items:\n                            if removed_weight >= excess_weight:\n                                break\n                            swap_out.append(item[0])\n                            removed_weight += item[1]\n\n                # Remove the selected items\n                new_solution[swap_out] = 0\n\n        # Add the selected items\n        new_solution[swap_in] = 1\n\n    # Ensure the solution is feasible\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If still not feasible, remove the least valuable items until feasible\n        included_indices = np.where(new_solution == 1)[0]\n        if len(included_indices) > 0:\n            included_values1 = value1_lst[included_indices]\n            included_values2 = value2_lst[included_indices]\n            included_weights = weight_lst[included_indices]\n\n            norm_included_values1 = (included_values1 - np.min(included_values1)) / (np.max(included_values1) - np.min(included_values1) + 1e-10)\n            norm_included_values2 = (included_values2 - np.min(included_values2)) / (np.max(included_values2) - np.min(included_values2) + 1e-10)\n            combined_included_values = norm_included_values1 + norm_included_values2\n\n            included_items_sorted = sorted(zip(included_indices, combined_included_values / (included_weights + 1e-10)),\n                                         key=lambda x: x[1])\n\n            current_weight = np.sum(weight_lst * new_solution)\n            for item in included_items_sorted:\n                if current_weight <= capacity:\n                    break\n                new_solution[item[0]] = 0\n                current_weight -= weight_lst[item[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.32588015011262594,
            4.416639178991318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not too close to the boundary\n    # This avoids selecting solutions that are already near capacity\n    base_solution, _ = max(archive, key=lambda x: np.sum(weight_lst * x[0]) / capacity)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Determine the number of items to swap (between 1 and min(10, N//2))\n    num_swaps = np.random.randint(1, min(10, len(weight_lst) // 2) + 1)\n\n    # Get indices of items currently in the solution\n    included_indices = np.where(new_solution == 1)[0]\n    excluded_indices = np.where(new_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for excluded items to prioritize high-value items\n    if len(excluded_indices) > 0:\n        excluded_values1 = value1_lst[excluded_indices]\n        excluded_values2 = value2_lst[excluded_indices]\n        excluded_weights = weight_lst[excluded_indices]\n\n        # Normalize the objectives to avoid bias towards one objective\n        norm_values1 = (excluded_values1 - np.min(excluded_values1)) / (np.max(excluded_values1) - np.min(excluded_values1) + 1e-10)\n        norm_values2 = (excluded_values2 - np.min(excluded_values2)) / (np.max(excluded_values2) - np.min(excluded_values2) + 1e-10)\n        combined_values = norm_values1 + norm_values2\n\n        # Sort excluded items by combined normalized value and weight ratio\n        excluded_items_sorted = sorted(zip(excluded_indices, combined_values / (excluded_weights + 1e-10)),\n                                      key=lambda x: -x[1])\n\n        # Select top items to consider for addition\n        top_items = [item[0] for item in excluded_items_sorted[:min(10, len(excluded_items_sorted))]]\n\n        # Randomly select items to swap in\n        swap_in = np.random.choice(top_items, size=min(num_swaps, len(top_items)), replace=False)\n\n        # Calculate the total weight of the items to be added\n        total_add_weight = np.sum(weight_lst[swap_in])\n\n        # If adding items exceeds capacity, remove some items first\n        if current_weight + total_add_weight > capacity:\n            # Calculate the excess weight\n            excess_weight = current_weight + total_add_weight - capacity\n\n            # Calculate value-to-weight ratios for included items to prioritize low-value items for removal\n            if len(included_indices) > 0:\n                included_values1 = value1_lst[included_indices]\n                included_values2 = value2_lst[included_indices]\n                included_weights = weight_lst[included_indices]\n\n                norm_included_values1 = (included_values1 - np.min(included_values1)) / (np.max(included_values1) - np.min(included_values1) + 1e-10)\n                norm_included_values2 = (included_values2 - np.min(included_values2)) / (np.max(included_values2) - np.min(included_values2) + 1e-10)\n                combined_included_values = norm_included_values1 + norm_included_values2\n\n                # Sort included items by combined normalized value and weight ratio (ascending)\n                included_items_sorted = sorted(zip(included_indices, combined_included_values / (included_weights + 1e-10)),\n                                             key=lambda x: x[1])\n\n                # Remove items until the excess weight is covered\n                removed_weight = 0\n                swap_out = []\n                for item in included_items_sorted:\n                    if removed_weight >= excess_weight:\n                        break\n                    swap_out.append(item[0])\n                    removed_weight += weight_lst[item[0]]\n\n                # If still not enough, randomly select more items to remove\n                if removed_weight < excess_weight:\n                    remaining_excess = excess_weight - removed_weight\n                    remaining_included = [i for i in included_indices if i not in swap_out]\n                    if remaining_included:\n                        remaining_weights = weight_lst[remaining_included]\n                        remaining_items = sorted(zip(remaining_included, remaining_weights),\n                                               key=lambda x: x[1])\n                        for item in remaining_items:\n                            if removed_weight >= excess_weight:\n                                break\n                            swap_out.append(item[0])\n                            removed_weight += item[1]\n\n                # Remove the selected items\n                new_solution[swap_out] = 0\n\n        # Add the selected items\n        new_solution[swap_in] = 1\n\n    # Ensure the solution is feasible\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If still not feasible, remove the least valuable items until feasible\n        included_indices = np.where(new_solution == 1)[0]\n        if len(included_indices) > 0:\n            included_values1 = value1_lst[included_indices]\n            included_values2 = value2_lst[included_indices]\n            included_weights = weight_lst[included_indices]\n\n            norm_included_values1 = (included_values1 - np.min(included_values1)) / (np.max(included_values1) - np.min(included_values1) + 1e-10)\n            norm_included_values2 = (included_values2 - np.min(included_values2)) / (np.max(included_values2) - np.min(included_values2) + 1e-10)\n            combined_included_values = norm_included_values1 + norm_included_values2\n\n            included_items_sorted = sorted(zip(included_indices, combined_included_values / (included_weights + 1e-10)),\n                                         key=lambda x: x[1])\n\n            current_weight = np.sum(weight_lst * new_solution)\n            for item in included_items_sorted:\n                if current_weight <= capacity:\n                    break\n                new_solution[item[0]] = 0\n                current_weight -= weight_lst[item[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = max(archive, key=lambda x: np.sum(x[0]))[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Hybrid local search strategy: combination of random flip, swap, and greedy addition\n    new_solution = selected_solution.copy()\n\n    # Step 1: Random flip with probability based on solution density\n    flip_prob = 0.3 if np.sum(new_solution) / len(new_solution) > 0.5 else 0.7\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Greedy addition of items with high marginal utility\n    for i in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[i] <= capacity:\n            marginal_value1 = value1_lst[i]\n            marginal_value2 = value2_lst[i]\n            # Prefer items that improve both objectives\n            if marginal_value1 > 0 and marginal_value2 > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Random swap between objectives to diversify\n    if np.random.rand() < 0.5:\n        obj1_items = np.where(new_solution == 1)[0]\n        obj2_items = np.where(new_solution == 0)[0]\n        if len(obj1_items) > 0 and len(obj2_items) > 0:\n            swap_idx1 = np.random.choice(obj1_items)\n            swap_idx2 = np.random.choice(obj2_items)\n            if current_weight - weight_lst[swap_idx1] + weight_lst[swap_idx2] <= capacity:\n                new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.47059320931775606,
            2.8861342668533325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = max(archive, key=lambda x: np.sum(x[0]))[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Hybrid local search strategy: combination of random flip, swap, and greedy addition\n    new_solution = selected_solution.copy()\n\n    # Step 1: Random flip with probability based on solution density\n    flip_prob = 0.3 if np.sum(new_solution) / len(new_solution) > 0.5 else 0.7\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 1:\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Greedy addition of items with high marginal utility\n    for i in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[i] <= capacity:\n            marginal_value1 = value1_lst[i]\n            marginal_value2 = value2_lst[i]\n            # Prefer items that improve both objectives\n            if marginal_value1 > 0 and marginal_value2 > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Step 3: Random swap between objectives to diversify\n    if np.random.rand() < 0.5:\n        obj1_items = np.where(new_solution == 1)[0]\n        obj2_items = np.where(new_solution == 0)[0]\n        if len(obj1_items) > 0 and len(obj2_items) > 0:\n            swap_idx1 = np.random.choice(obj1_items)\n            swap_idx2 = np.random.choice(obj2_items)\n            if current_weight - weight_lst[swap_idx1] + weight_lst[swap_idx2] <= capacity:\n                new_solution[swap_idx1], new_solution[swap_idx2] = new_solution[swap_idx2], new_solution[swap_idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random swaps followed by a greedy improvement\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swaps (exploration)\n    for _ in range(min(3, num_items)):  # Limit swaps to avoid excessive exploration\n        i, j = random.sample(range(num_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility of swap\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Greedy improvement (exploitation)\n    for i in range(num_items):\n        if new_solution[i]:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                # Greedily add the item that improves both objectives the most\n                marginal_value1 = value1_lst[i]\n                marginal_value2 = value2_lst[i]\n                if marginal_value1 > 0 or marginal_value2 > 0:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.44534802545347607,
            1.8466373085975647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random swaps followed by a greedy improvement\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swaps (exploration)\n    for _ in range(min(3, num_items)):  # Limit swaps to avoid excessive exploration\n        i, j = random.sample(range(num_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility of swap\n            delta_weight = (weight_lst[j] - weight_lst[i]) if new_solution[i] else (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n    # Greedy improvement (exploitation)\n    for i in range(num_items):\n        if new_solution[i]:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                # Greedily add the item that improves both objectives the most\n                marginal_value1 = value1_lst[i]\n                marginal_value2 = value2_lst[i]\n                if marginal_value1 > 0 or marginal_value2 > 0:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_weights = np.array([np.sum(weight_lst * sol) for sol in archive_solutions])\n    archive_values1 = np.array([np.sum(value1_lst * sol) for sol in archive_solutions])\n    archive_values2 = np.array([np.sum(value2_lst * sol) for sol in archive_solutions])\n\n    # Calculate potential improvement scores (combination of value ratios and weight slack)\n    value_ratios = archive_values1 / (archive_values2 + 1e-10)\n    weight_slacks = capacity - archive_weights\n    improvement_scores = value_ratios * (1 + weight_slacks / (capacity + 1e-10))\n\n    # Select top 3 solutions with highest improvement potential\n    top_indices = np.argsort(improvement_scores)[-min(3, len(archive)):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # First phase: Randomly flip items with high value ratio\n    value_ratio = value1_lst / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(value_ratio)[::-1]  # Highest value ratio first\n\n    for i in sorted_indices[:max(1, n_items // 10)]:\n        if np.random.rand() < 0.7:  # 70% chance to consider flipping\n            candidate = new_solution.copy()\n            candidate[i] = 1 - candidate[i]  # Flip the bit\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst * new_solution)\n            candidate_weight = current_weight - weight_lst[i] * new_solution[i] + weight_lst[i] * candidate[i]\n\n            if candidate_weight <= capacity:\n                new_solution = candidate\n\n    # Second phase: Value-based item swaps\n    for _ in range(3):  # Perform 3 random swaps\n        if np.sum(new_solution) < 2:\n            break\n\n        # Select two items to swap\n        item1, item2 = np.random.choice(np.where(new_solution == 1)[0], 2, replace=False)\n\n        # Check if swap is feasible\n        current_weight = np.sum(weight_lst * new_solution)\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n\n        if current_weight + delta_weight <= capacity:\n            # Perform swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n",
        "score": [
            -0.6683727417475488,
            4.725875616073608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_weights = np.array([np.sum(weight_lst * sol) for sol in archive_solutions])\n    archive_values1 = np.array([np.sum(value1_lst * sol) for sol in archive_solutions])\n    archive_values2 = np.array([np.sum(value2_lst * sol) for sol in archive_solutions])\n\n    # Calculate potential improvement scores (combination of value ratios and weight slack)\n    value_ratios = archive_values1 / (archive_values2 + 1e-10)\n    weight_slacks = capacity - archive_weights\n    improvement_scores = value_ratios * (1 + weight_slacks / (capacity + 1e-10))\n\n    # Select top 3 solutions with highest improvement potential\n    top_indices = np.argsort(improvement_scores)[-min(3, len(archive)):]\n    selected_idx = np.random.choice(top_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # First phase: Randomly flip items with high value ratio\n    value_ratio = value1_lst / (value2_lst + 1e-10)\n    sorted_indices = np.argsort(value_ratio)[::-1]  # Highest value ratio first\n\n    for i in sorted_indices[:max(1, n_items // 10)]:\n        if np.random.rand() < 0.7:  # 70% chance to consider flipping\n            candidate = new_solution.copy()\n            candidate[i] = 1 - candidate[i]  # Flip the bit\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst * new_solution)\n            candidate_weight = current_weight - weight_lst[i] * new_solution[i] + weight_lst[i] * candidate[i]\n\n            if candidate_weight <= capacity:\n                new_solution = candidate\n\n    # Second phase: Value-based item swaps\n    for _ in range(3):  # Perform 3 random swaps\n        if np.sum(new_solution) < 2:\n            break\n\n        # Select two items to swap\n        item1, item2 = np.random.choice(np.where(new_solution == 1)[0], 2, replace=False)\n\n        # Check if swap is feasible\n        current_weight = np.sum(weight_lst * new_solution)\n        delta_weight = weight_lst[item2] - weight_lst[item1]\n\n        if current_weight + delta_weight <= capacity:\n            # Perform swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential (e.g., not already explored)\n    # Here we select a random solution with probability inversely proportional to its dominance\n    # This encourages exploration of less-explored regions\n    weights = np.array([1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Bit-flip operation (flip a random bit)\n    # 2. If feasible, consider swapping two items\n    # 3. If both operations are infeasible, try a different bit-flip\n\n    # Step 1: Bit-flip operation\n    flip_pos = np.random.randint(0, len(new_solution))\n    new_solution[flip_pos] = 1 - new_solution[flip_pos]\n\n    # Check feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight <= capacity:\n        return new_solution\n\n    # If bit-flip is infeasible, try swap operation\n    if len(new_solution) >= 2:\n        # Select two distinct positions to swap\n        pos1, pos2 = np.random.choice(len(new_solution), size=2, replace=False)\n\n        # Calculate change in weight\n        weight_diff = weight_lst[pos1] - weight_lst[pos2]\n        new_weight = total_weight + weight_diff\n\n        if new_weight <= capacity:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n            return new_solution\n\n    # If both operations are infeasible, try a different bit-flip\n    for _ in range(10):  # Try up to 10 times\n        flip_pos = np.random.randint(0, len(new_solution))\n        new_solution[flip_pos] = 1 - new_solution[flip_pos]\n        if np.sum(weight_lst * new_solution) <= capacity:\n            return new_solution\n\n    # If all else fails, return the original solution\n    return base_solution.copy()\n\n",
        "score": [
            -0.3349426956731353,
            2.4600725769996643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential (e.g., not already explored)\n    # Here we select a random solution with probability inversely proportional to its dominance\n    # This encourages exploration of less-explored regions\n    weights = np.array([1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # 1. Bit-flip operation (flip a random bit)\n    # 2. If feasible, consider swapping two items\n    # 3. If both operations are infeasible, try a different bit-flip\n\n    # Step 1: Bit-flip operation\n    flip_pos = np.random.randint(0, len(new_solution))\n    new_solution[flip_pos] = 1 - new_solution[flip_pos]\n\n    # Check feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight <= capacity:\n        return new_solution\n\n    # If bit-flip is infeasible, try swap operation\n    if len(new_solution) >= 2:\n        # Select two distinct positions to swap\n        pos1, pos2 = np.random.choice(len(new_solution), size=2, replace=False)\n\n        # Calculate change in weight\n        weight_diff = weight_lst[pos1] - weight_lst[pos2]\n        new_weight = total_weight + weight_diff\n\n        if new_weight <= capacity:\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n            return new_solution\n\n    # If both operations are infeasible, try a different bit-flip\n    for _ in range(10):  # Try up to 10 times\n        flip_pos = np.random.randint(0, len(new_solution))\n        new_solution[flip_pos] = 1 - new_solution[flip_pos]\n        if np.sum(weight_lst * new_solution) <= capacity:\n            return new_solution\n\n    # If all else fails, return the original solution\n    return base_solution.copy()\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to flip (1 to 5)\n    flip_indices = np.random.choice(len(weight_lst), size=np.random.randint(1, min(6, len(weight_lst))), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility and repair if necessary\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible, prioritizing those with lower marginal utility\n        marginal_utilities = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(marginal_utilities)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                if total_weight <= capacity:\n                    break\n\n    # Greedy improvement step: add items with highest marginal utility\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    if remaining_capacity > 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            marginal_utilities = (value1_lst + value2_lst) / weight_lst\n            sorted_indices = np.argsort(marginal_utilities)[::-1]\n            for idx in sorted_indices:\n                if weight_lst[idx] <= remaining_capacity:\n                    new_solution[idx] = 1\n                    remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.36614068549665024,
            2.5115804970264435
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to flip (1 to 5)\n    flip_indices = np.random.choice(len(weight_lst), size=np.random.randint(1, min(6, len(weight_lst))), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility and repair if necessary\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items until feasible, prioritizing those with lower marginal utility\n        marginal_utilities = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(marginal_utilities)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                if total_weight <= capacity:\n                    break\n\n    # Greedy improvement step: add items with highest marginal utility\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    if remaining_capacity > 0:\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            marginal_utilities = (value1_lst + value2_lst) / weight_lst\n            sorted_indices = np.argsort(marginal_utilities)[::-1]\n            for idx in sorted_indices:\n                if weight_lst[idx] <= remaining_capacity:\n                    new_solution[idx] = 1\n                    remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the edge of the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Generate candidate items for possible swap or flip\n    candidate_items = np.where(selected_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search: combination of flip and swap operations\n    neighbor = selected_solution.copy()\n\n    # Flip operation: randomly flip a subset of items\n    flip_indices = np.random.choice(candidate_items, size=min(3, len(candidate_items)), replace=False)\n    for idx in flip_indices:\n        if neighbor[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                neighbor[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                neighbor[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Swap operation: randomly swap two items if feasible\n    if len(candidate_items) >= 2:\n        swap_indices = np.random.choice(candidate_items, size=2, replace=False)\n        i, j = swap_indices\n        if neighbor[i] == 1 and neighbor[j] == 0:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]\n\n    return neighbor\n\n",
        "score": [
            -0.9347279145717422,
            0.7527242302894592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the edge of the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Generate candidate items for possible swap or flip\n    candidate_items = np.where(selected_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search: combination of flip and swap operations\n    neighbor = selected_solution.copy()\n\n    # Flip operation: randomly flip a subset of items\n    flip_indices = np.random.choice(candidate_items, size=min(3, len(candidate_items)), replace=False)\n    for idx in flip_indices:\n        if neighbor[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                neighbor[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                neighbor[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Swap operation: randomly swap two items if feasible\n    if len(candidate_items) >= 2:\n        swap_indices = np.random.choice(candidate_items, size=2, replace=False)\n        i, j = swap_indices\n        if neighbor[i] == 1 and neighbor[j] == 0:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]\n\n    return neighbor\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the edge of the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Generate candidate items for possible swap or flip\n    candidate_items = np.where(selected_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search: combination of flip and swap operations\n    neighbor = selected_solution.copy()\n\n    # Flip operation: randomly flip a subset of items\n    flip_indices = np.random.choice(candidate_items, size=min(3, len(candidate_items)), replace=False)\n    for idx in flip_indices:\n        if neighbor[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                neighbor[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                neighbor[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Swap operation: randomly swap two items if feasible\n    if len(candidate_items) >= 2:\n        swap_indices = np.random.choice(candidate_items, size=2, replace=False)\n        i, j = swap_indices\n        if neighbor[i] == 1 and neighbor[j] == 0:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]\n\n    return neighbor\n\n",
        "score": [
            -0.9347279145717422,
            0.7527242302894592
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the edge of the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Generate candidate items for possible swap or flip\n    candidate_items = np.where(selected_solution == 1)[0]\n    if len(candidate_items) == 0:\n        candidate_items = np.arange(len(weight_lst))\n\n    # Hybrid local search: combination of flip and swap operations\n    neighbor = selected_solution.copy()\n\n    # Flip operation: randomly flip a subset of items\n    flip_indices = np.random.choice(candidate_items, size=min(3, len(candidate_items)), replace=False)\n    for idx in flip_indices:\n        if neighbor[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                neighbor[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                neighbor[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Swap operation: randomly swap two items if feasible\n    if len(candidate_items) >= 2:\n        swap_indices = np.random.choice(candidate_items, size=2, replace=False)\n        i, j = swap_indices\n        if neighbor[i] == 1 and neighbor[j] == 0:\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                neighbor[i], neighbor[j] = neighbor[j], neighbor[i]\n\n    return neighbor\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    # 1. Randomly flip a subset of items (value-based selection)\n    flip_indices = np.where(np.random.rand(len(new_solution)) < 0.2)[0]  # 20% chance per item\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:  # Ensure feasibility\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:  # Ensure feasibility\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # 2. Add items with high marginal value-to-weight ratio for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # 3. Remove low-value items to free up capacity\n    for idx in sorted_indices[::-1]:  # Start with lowest marginal value\n        if new_solution[idx] == 1 and (current_weight - weight_lst[idx] >= 0):\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7764555152464754,
            2.8483905494213104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    # 1. Randomly flip a subset of items (value-based selection)\n    flip_indices = np.where(np.random.rand(len(new_solution)) < 0.2)[0]  # 20% chance per item\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:  # Ensure feasibility\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:  # Ensure feasibility\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # 2. Add items with high marginal value-to-weight ratio for both objectives\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value (descending)\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # 3. Remove low-value items to free up capacity\n    for idx in sorted_indices[::-1]:  # Start with lowest marginal value\n        if new_solution[idx] == 1 and (current_weight - weight_lst[idx] >= 0):\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 3: Generate candidate moves\n    new_solution = base_solution.copy()\n\n    # Try flip-based moves (add/remove one item)\n    for _ in range(10):  # Try a few random flips\n        item_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[item_idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                break\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                break\n\n    # If no flip worked, try swap-based moves (swap two items)\n    if np.array_equal(new_solution, base_solution):\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) >= 2:\n            i, j = random.sample(list(candidates), 2)\n            if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n                current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # If no improvement, return the original solution\n    if np.array_equal(new_solution, base_solution):\n        return base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3435565810360518,
            1.3340036869049072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (highest sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Step 3: Generate candidate moves\n    new_solution = base_solution.copy()\n\n    # Try flip-based moves (add/remove one item)\n    for _ in range(10):  # Try a few random flips\n        item_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[item_idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                break\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 1\n                break\n\n    # If no flip worked, try swap-based moves (swap two items)\n    if np.array_equal(new_solution, base_solution):\n        candidates = np.where(base_solution == 1)[0]\n        if len(candidates) >= 2:\n            i, j = random.sample(list(candidates), 2)\n            if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n                current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # If no improvement, return the original solution\n    if np.array_equal(new_solution, base_solution):\n        return base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.dot(sol, weight_lst)\n        potential_gain = np.dot(1 - sol, value1_lst) + np.dot(1 - sol, value2_lst)\n        candidates.append((sol, obj, current_weight, potential_gain))\n\n    # Sort by potential gain and select top 30% or at least 1\n    candidates.sort(key=lambda x: -x[3])\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected = random.choice(top_candidates)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of swap and flip with weight adjustment\n    n_items = len(weight_lst)\n    current_weight = selected[2]\n\n    # First, try to swap two items (if possible)\n    if n_items >= 2:\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices\n\n        # Check if swapping is feasible\n        delta_weight = (weight_lst[j] - weight_lst[i]) if base_solution[i] else (weight_lst[i] - weight_lst[j])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            return new_solution\n\n    # If swap didn't work, try to flip a single item\n    for _ in range(10):  # Try up to 10 random flips\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                return new_solution\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                return new_solution\n\n    # If no improvement found, try to add the most valuable item not in the solution\n    remaining_items = np.where(base_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Consider both objectives for selection\n        combined_value = value1_lst + value2_lst\n        best_item = remaining_items[np.argmax(combined_value[remaining_items])]\n        if current_weight + weight_lst[best_item] <= capacity:\n            new_solution[best_item] = 1\n            return new_solution\n\n    # If all else fails, return a slightly modified solution\n    if random.random() < 0.5:\n        # Flip a random item (if feasible)\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n        elif base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.7474381242725464,
            2.3316551744937897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.dot(sol, weight_lst)\n        potential_gain = np.dot(1 - sol, value1_lst) + np.dot(1 - sol, value2_lst)\n        candidates.append((sol, obj, current_weight, potential_gain))\n\n    # Sort by potential gain and select top 30% or at least 1\n    candidates.sort(key=lambda x: -x[3])\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected = random.choice(top_candidates)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of swap and flip with weight adjustment\n    n_items = len(weight_lst)\n    current_weight = selected[2]\n\n    # First, try to swap two items (if possible)\n    if n_items >= 2:\n        swap_indices = random.sample(range(n_items), 2)\n        i, j = swap_indices\n\n        # Check if swapping is feasible\n        delta_weight = (weight_lst[j] - weight_lst[i]) if base_solution[i] else (weight_lst[i] - weight_lst[j])\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            return new_solution\n\n    # If swap didn't work, try to flip a single item\n    for _ in range(10):  # Try up to 10 random flips\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                return new_solution\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                return new_solution\n\n    # If no improvement found, try to add the most valuable item not in the solution\n    remaining_items = np.where(base_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Consider both objectives for selection\n        combined_value = value1_lst + value2_lst\n        best_item = remaining_items[np.argmax(combined_value[remaining_items])]\n        if current_weight + weight_lst[best_item] <= capacity:\n            new_solution[best_item] = 1\n            return new_solution\n\n    # If all else fails, return a slightly modified solution\n    if random.random() < 0.5:\n        # Flip a random item (if feasible)\n        i = random.randint(0, n_items - 1)\n        if base_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n            new_solution[i] = 0\n        elif base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential items to flip\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added without exceeding capacity\n    candidate_items = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # If no items can be added, try removing items to free up space\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 1)[0]\n\n    # If no items can be modified (unlikely but possible), return the base solution\n    if len(candidate_items) == 0:\n        return base_solution\n\n    # Hybrid local search: flip a subset of items based on their marginal contribution\n    # Calculate marginal contributions (value1 + value2) for candidate items\n    marginal_contributions = value1_lst + value2_lst\n    sorted_candidates = candidate_items[np.argsort(marginal_contributions[candidate_items])[::-1]]\n\n    # Select top k items with highest marginal contribution (k = 1 to 3)\n    k = np.random.randint(1, min(4, len(sorted_candidates) + 1))\n    selected_items = sorted_candidates[:k]\n\n    # Flip the selected items\n    for item in selected_items:\n        new_solution[item] = 1 - new_solution[item]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items until feasible\n        excess = new_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        excess_weights = weight_lst[excess_items]\n        sorted_excess = excess_items[np.argsort(excess_weights)[::-1]]\n\n        for item in sorted_excess:\n            if excess <= 0:\n                break\n            new_solution[item] = 0\n            excess -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8163395224467916,
            1.1899732947349548
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential items to flip\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added without exceeding capacity\n    candidate_items = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # If no items can be added, try removing items to free up space\n    if len(candidate_items) == 0:\n        candidate_items = np.where(base_solution == 1)[0]\n\n    # If no items can be modified (unlikely but possible), return the base solution\n    if len(candidate_items) == 0:\n        return base_solution\n\n    # Hybrid local search: flip a subset of items based on their marginal contribution\n    # Calculate marginal contributions (value1 + value2) for candidate items\n    marginal_contributions = value1_lst + value2_lst\n    sorted_candidates = candidate_items[np.argsort(marginal_contributions[candidate_items])[::-1]]\n\n    # Select top k items with highest marginal contribution (k = 1 to 3)\n    k = np.random.randint(1, min(4, len(sorted_candidates) + 1))\n    selected_items = sorted_candidates[:k]\n\n    # Flip the selected items\n    for item in selected_items:\n        new_solution[item] = 1 - new_solution[item]\n\n    # Ensure feasibility by removing items if weight exceeds capacity\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items until feasible\n        excess = new_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        excess_weights = weight_lst[excess_items]\n        sorted_excess = excess_items[np.argsort(excess_weights)[::-1]]\n\n        for item in sorted_excess:\n            if excess <= 0:\n                break\n            new_solution[item] = 0\n            excess -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by combined value (value1 + value2) in descending order\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Randomly select from top 30% of solutions to introduce diversity\n        top_k = max(1, int(0.3 * len(archive_sorted)))\n        selected_pair = random.choice(archive_sorted[:top_k])\n    else:\n        selected_pair = archive[0]\n\n    base_solution, _ = selected_pair\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Phase 1: Random perturbation (flip a small number of bits)\n    num_flips = min(3, len(new_solution))  # Flip at most 3 items\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Phase 2: Greedy improvement step (add items with highest value-to-weight ratio)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate value-to-weight ratios for items not in the solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Use a weighted combination of both objectives for the ratio\n            combined_values = value1_lst + value2_lst\n            value_to_weight_ratio = combined_values[candidate_items] / weight_lst[candidate_items]\n\n            # Sort candidates by ratio in descending order\n            sorted_candidates = candidate_items[np.argsort(value_to_weight_ratio)[::-1]]\n\n            for item in sorted_candidates:\n                if weight_lst[item] <= remaining_capacity:\n                    new_solution[item] = 1\n                    remaining_capacity -= weight_lst[item]\n\n    # Ensure feasibility (shouldn't be necessary due to greedy step, but added for safety)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove the item with the smallest value-to-weight ratio\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            combined_values = value1_lst + value2_lst\n            value_to_weight_ratio = combined_values[included_items] / weight_lst[included_items]\n            item_to_remove = included_items[np.argmin(value_to_weight_ratio)]\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.30682877508022266,
            3.743532210588455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by combined value (value1 + value2) in descending order\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Randomly select from top 30% of solutions to introduce diversity\n        top_k = max(1, int(0.3 * len(archive_sorted)))\n        selected_pair = random.choice(archive_sorted[:top_k])\n    else:\n        selected_pair = archive[0]\n\n    base_solution, _ = selected_pair\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Phase 1: Random perturbation (flip a small number of bits)\n    num_flips = min(3, len(new_solution))  # Flip at most 3 items\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Phase 2: Greedy improvement step (add items with highest value-to-weight ratio)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate value-to-weight ratios for items not in the solution\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            # Use a weighted combination of both objectives for the ratio\n            combined_values = value1_lst + value2_lst\n            value_to_weight_ratio = combined_values[candidate_items] / weight_lst[candidate_items]\n\n            # Sort candidates by ratio in descending order\n            sorted_candidates = candidate_items[np.argsort(value_to_weight_ratio)[::-1]]\n\n            for item in sorted_candidates:\n                if weight_lst[item] <= remaining_capacity:\n                    new_solution[item] = 1\n                    remaining_capacity -= weight_lst[item]\n\n    # Ensure feasibility (shouldn't be necessary due to greedy step, but added for safety)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove the item with the smallest value-to-weight ratio\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            combined_values = value1_lst + value2_lst\n            value_to_weight_ratio = combined_values[included_items] / weight_lst[included_items]\n            item_to_remove = included_items[np.argmin(value_to_weight_ratio)]\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a higher probability for solutions near the Pareto front\n    # Here, we use a simple heuristic: solutions with higher combined value are more likely to be selected\n    combined_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = combined_values / combined_values.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: random swaps followed by a greedy improvement\n    # Step 1: Randomly swap a subset of items (up to 5% of the items)\n    n_items = len(weight_lst)\n    swap_candidates = np.random.choice(n_items, size=min(n_items, max(1, int(0.05 * n_items))), replace=False)\n    for i in swap_candidates:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility after random swaps\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(new_solution * weight_lst)\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement - add items that improve at least one objective\n    remaining_items = np.where(new_solution == 0)[0]\n    current_value1 = np.sum(new_solution * value1_lst)\n    current_value2 = np.sum(new_solution * value2_lst)\n    current_weight = np.sum(new_solution * weight_lst)\n\n    improved = True\n    while improved and len(remaining_items) > 0:\n        improved = False\n        for i in remaining_items:\n            if current_weight + weight_lst[i] <= capacity:\n                # Check if adding item i improves at least one objective\n                new_value1 = current_value1 + value1_lst[i]\n                new_value2 = current_value2 + value2_lst[i]\n                if (new_value1 > current_value1) or (new_value2 > current_value2):\n                    new_solution[i] = 1\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n                    current_weight += weight_lst[i]\n                    improved = True\n                    break\n        remaining_items = np.where(new_solution == 0)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.35808219922152207,
            3.834659159183502
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a higher probability for solutions near the Pareto front\n    # Here, we use a simple heuristic: solutions with higher combined value are more likely to be selected\n    combined_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = combined_values / combined_values.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: random swaps followed by a greedy improvement\n    # Step 1: Randomly swap a subset of items (up to 5% of the items)\n    n_items = len(weight_lst)\n    swap_candidates = np.random.choice(n_items, size=min(n_items, max(1, int(0.05 * n_items))), replace=False)\n    for i in swap_candidates:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility after random swaps\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(new_solution * weight_lst)\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement - add items that improve at least one objective\n    remaining_items = np.where(new_solution == 0)[0]\n    current_value1 = np.sum(new_solution * value1_lst)\n    current_value2 = np.sum(new_solution * value2_lst)\n    current_weight = np.sum(new_solution * weight_lst)\n\n    improved = True\n    while improved and len(remaining_items) > 0:\n        improved = False\n        for i in remaining_items:\n            if current_weight + weight_lst[i] <= capacity:\n                # Check if adding item i improves at least one objective\n                new_value1 = current_value1 + value1_lst[i]\n                new_value2 = current_value2 + value2_lst[i]\n                if (new_value1 > current_value1) or (new_value2 > current_value2):\n                    new_solution[i] = 1\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n                    current_weight += weight_lst[i]\n                    improved = True\n                    break\n        remaining_items = np.where(new_solution == 0)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + np.sum(s[0])) for s in archive],  # Prefer sparser solutions\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of flip, swap, and insertion\n    operation = random.choice(['flip', 'swap', 'insert'])\n\n    if operation == 'flip':\n        # Flip a random bit (0 to 1 or 1 to 0)\n        idx = random.randint(0, len(new_solution) - 1)\n        new_solution[idx] = 1 - new_solution[idx]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[idx] = base_solution[idx]\n\n    elif operation == 'swap':\n        # Swap two items\n        idx1, idx2 = random.sample(range(len(new_solution)), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    elif operation == 'insert':\n        # Remove a random item and insert another\n        if np.sum(new_solution) > 0:\n            # Remove a random item\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            # Insert a random item not in the solution\n            available_items = np.where((new_solution == 0) & (weight_lst <= (capacity - np.sum(weight_lst * new_solution))))[0]\n            if len(available_items) > 0:\n                insert_idx = random.choice(available_items)\n                new_solution[insert_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36980155640136725,
            2.5449065268039703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + np.sum(s[0])) for s in archive],  # Prefer sparser solutions\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of flip, swap, and insertion\n    operation = random.choice(['flip', 'swap', 'insert'])\n\n    if operation == 'flip':\n        # Flip a random bit (0 to 1 or 1 to 0)\n        idx = random.randint(0, len(new_solution) - 1)\n        new_solution[idx] = 1 - new_solution[idx]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[idx] = base_solution[idx]\n\n    elif operation == 'swap':\n        # Swap two items\n        idx1, idx2 = random.sample(range(len(new_solution)), 2)\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n        # Ensure feasibility\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    elif operation == 'insert':\n        # Remove a random item and insert another\n        if np.sum(new_solution) > 0:\n            # Remove a random item\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            # Insert a random item not in the solution\n            available_items = np.where((new_solution == 0) & (weight_lst <= (capacity - np.sum(weight_lst * new_solution))))[0]\n            if len(available_items) > 0:\n                insert_idx = random.choice(available_items)\n                new_solution[insert_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a base solution with potential for improvement\n    # Prioritize solutions that are not fully packed and have high potential for marginal gains\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            # Calculate potential marginal gains for each objective\n            marginal_gain1 = np.sum((1 - sol) * value1_lst) / (np.sum((1 - sol) * weight_lst) + 1e-10)\n            marginal_gain2 = np.sum((1 - sol) * value2_lst) / (np.sum((1 - sol) * weight_lst) + 1e-10)\n            # Combine gains with a simple weighted sum (could be more sophisticated)\n            combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n            candidates.append((combined_gain, sol))\n\n    if not candidates:\n        # If no candidates found, fall back to random selection\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        # Select the solution with highest combined marginal gain\n        candidates.sort(key=lambda x: -x[0])\n        base_solution = candidates[0][1].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip and marginal gain-based flip\n    if np.random.random() < 0.7:  # 70% chance for marginal gain-based flip\n        # Calculate marginal gains for each item not in the solution\n        marginal_gains1 = (1 - new_solution) * value1_lst\n        marginal_gains2 = (1 - new_solution) * value2_lst\n        marginal_weights = (1 - new_solution) * weight_lst\n\n        # Combine gains with a simple weighted sum\n        combined_gains = 0.5 * marginal_gains1 + 0.5 * marginal_gains2\n\n        # Find items that can be added without exceeding capacity\n        current_weight = np.sum(new_solution * weight_lst)\n        possible_items = np.where((marginal_weights > 0) & (current_weight + marginal_weights <= capacity))[0]\n\n        if len(possible_items) > 0:\n            # Select the item with highest combined marginal gain\n            best_item = possible_items[np.argmax(combined_gains[possible_items])]\n            new_solution[best_item] = 1\n    else:  # 30% chance for random flip\n        # Randomly select an item to flip (add or remove)\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 0:\n            # With 50% chance, remove an item; otherwise, try to add\n            if np.random.random() < 0.5:\n                # Remove an item\n                item_to_remove = np.random.choice(items)\n                new_solution[item_to_remove] = 0\n            else:\n                # Try to add an item not in the solution\n                not_in_solution = np.where(new_solution == 0)[0]\n                if len(not_in_solution) > 0:\n                    current_weight = np.sum(new_solution * weight_lst)\n                    possible_adds = not_in_solution[np.where(current_weight + weight_lst[not_in_solution] <= capacity)[0]]\n                    if len(possible_adds) > 0:\n                        item_to_add = np.random.choice(possible_adds)\n                        new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.951747917720948,
            6.487797200679779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a base solution with potential for improvement\n    # Prioritize solutions that are not fully packed and have high potential for marginal gains\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            # Calculate potential marginal gains for each objective\n            marginal_gain1 = np.sum((1 - sol) * value1_lst) / (np.sum((1 - sol) * weight_lst) + 1e-10)\n            marginal_gain2 = np.sum((1 - sol) * value2_lst) / (np.sum((1 - sol) * weight_lst) + 1e-10)\n            # Combine gains with a simple weighted sum (could be more sophisticated)\n            combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n            candidates.append((combined_gain, sol))\n\n    if not candidates:\n        # If no candidates found, fall back to random selection\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        # Select the solution with highest combined marginal gain\n        candidates.sort(key=lambda x: -x[0])\n        base_solution = candidates[0][1].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip and marginal gain-based flip\n    if np.random.random() < 0.7:  # 70% chance for marginal gain-based flip\n        # Calculate marginal gains for each item not in the solution\n        marginal_gains1 = (1 - new_solution) * value1_lst\n        marginal_gains2 = (1 - new_solution) * value2_lst\n        marginal_weights = (1 - new_solution) * weight_lst\n\n        # Combine gains with a simple weighted sum\n        combined_gains = 0.5 * marginal_gains1 + 0.5 * marginal_gains2\n\n        # Find items that can be added without exceeding capacity\n        current_weight = np.sum(new_solution * weight_lst)\n        possible_items = np.where((marginal_weights > 0) & (current_weight + marginal_weights <= capacity))[0]\n\n        if len(possible_items) > 0:\n            # Select the item with highest combined marginal gain\n            best_item = possible_items[np.argmax(combined_gains[possible_items])]\n            new_solution[best_item] = 1\n    else:  # 30% chance for random flip\n        # Randomly select an item to flip (add or remove)\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 0:\n            # With 50% chance, remove an item; otherwise, try to add\n            if np.random.random() < 0.5:\n                # Remove an item\n                item_to_remove = np.random.choice(items)\n                new_solution[item_to_remove] = 0\n            else:\n                # Try to add an item not in the solution\n                not_in_solution = np.where(new_solution == 0)[0]\n                if len(not_in_solution) > 0:\n                    current_weight = np.sum(new_solution * weight_lst)\n                    possible_adds = not_in_solution[np.where(current_weight + weight_lst[not_in_solution] <= capacity)[0]]\n                    if len(possible_adds) > 0:\n                        item_to_add = np.random.choice(possible_adds)\n                        new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a base solution with potential for improvement\n    # Prioritize solutions that are not fully packed and have high potential for marginal gains\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            # Calculate potential marginal gains for each objective\n            marginal_gain1 = np.sum((1 - sol) * value1_lst) / (np.sum((1 - sol) * weight_lst) + 1e-10)\n            marginal_gain2 = np.sum((1 - sol) * value2_lst) / (np.sum((1 - sol) * weight_lst) + 1e-10)\n            # Combine gains with a simple weighted sum (could be more sophisticated)\n            combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n            candidates.append((combined_gain, sol))\n\n    if not candidates:\n        # If no candidates found, fall back to random selection\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        # Select the solution with highest combined marginal gain\n        candidates.sort(key=lambda x: -x[0])\n        base_solution = candidates[0][1].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip and marginal gain-based flip\n    if np.random.random() < 0.7:  # 70% chance for marginal gain-based flip\n        # Calculate marginal gains for each item not in the solution\n        marginal_gains1 = (1 - new_solution) * value1_lst\n        marginal_gains2 = (1 - new_solution) * value2_lst\n        marginal_weights = (1 - new_solution) * weight_lst\n\n        # Combine gains with a simple weighted sum\n        combined_gains = 0.5 * marginal_gains1 + 0.5 * marginal_gains2\n\n        # Find items that can be added without exceeding capacity\n        current_weight = np.sum(new_solution * weight_lst)\n        possible_items = np.where((marginal_weights > 0) & (current_weight + marginal_weights <= capacity))[0]\n\n        if len(possible_items) > 0:\n            # Select the item with highest combined marginal gain\n            best_item = possible_items[np.argmax(combined_gains[possible_items])]\n            new_solution[best_item] = 1\n    else:  # 30% chance for random flip\n        # Randomly select an item to flip (add or remove)\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 0:\n            # With 50% chance, remove an item; otherwise, try to add\n            if np.random.random() < 0.5:\n                # Remove an item\n                item_to_remove = np.random.choice(items)\n                new_solution[item_to_remove] = 0\n            else:\n                # Try to add an item not in the solution\n                not_in_solution = np.where(new_solution == 0)[0]\n                if len(not_in_solution) > 0:\n                    current_weight = np.sum(new_solution * weight_lst)\n                    possible_adds = not_in_solution[np.where(current_weight + weight_lst[not_in_solution] <= capacity)[0]]\n                    if len(possible_adds) > 0:\n                        item_to_add = np.random.choice(possible_adds)\n                        new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.951747917720948,
            6.487797200679779
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligently select a base solution with potential for improvement\n    # Prioritize solutions that are not fully packed and have high potential for marginal gains\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            # Calculate potential marginal gains for each objective\n            marginal_gain1 = np.sum((1 - sol) * value1_lst) / (np.sum((1 - sol) * weight_lst) + 1e-10)\n            marginal_gain2 = np.sum((1 - sol) * value2_lst) / (np.sum((1 - sol) * weight_lst) + 1e-10)\n            # Combine gains with a simple weighted sum (could be more sophisticated)\n            combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n            candidates.append((combined_gain, sol))\n\n    if not candidates:\n        # If no candidates found, fall back to random selection\n        base_solution = archive[np.random.randint(len(archive))][0].copy()\n    else:\n        # Select the solution with highest combined marginal gain\n        candidates.sort(key=lambda x: -x[0])\n        base_solution = candidates[0][1].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip and marginal gain-based flip\n    if np.random.random() < 0.7:  # 70% chance for marginal gain-based flip\n        # Calculate marginal gains for each item not in the solution\n        marginal_gains1 = (1 - new_solution) * value1_lst\n        marginal_gains2 = (1 - new_solution) * value2_lst\n        marginal_weights = (1 - new_solution) * weight_lst\n\n        # Combine gains with a simple weighted sum\n        combined_gains = 0.5 * marginal_gains1 + 0.5 * marginal_gains2\n\n        # Find items that can be added without exceeding capacity\n        current_weight = np.sum(new_solution * weight_lst)\n        possible_items = np.where((marginal_weights > 0) & (current_weight + marginal_weights <= capacity))[0]\n\n        if len(possible_items) > 0:\n            # Select the item with highest combined marginal gain\n            best_item = possible_items[np.argmax(combined_gains[possible_items])]\n            new_solution[best_item] = 1\n    else:  # 30% chance for random flip\n        # Randomly select an item to flip (add or remove)\n        items = np.where(new_solution == 1)[0]\n        if len(items) > 0:\n            # With 50% chance, remove an item; otherwise, try to add\n            if np.random.random() < 0.5:\n                # Remove an item\n                item_to_remove = np.random.choice(items)\n                new_solution[item_to_remove] = 0\n            else:\n                # Try to add an item not in the solution\n                not_in_solution = np.where(new_solution == 0)[0]\n                if len(not_in_solution) > 0:\n                    current_weight = np.sum(new_solution * weight_lst)\n                    possible_adds = not_in_solution[np.where(current_weight + weight_lst[not_in_solution] <= capacity)[0]]\n                    if len(possible_adds) > 0:\n                        item_to_add = np.random.choice(possible_adds)\n                        new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not too crowded in the archive\n    # (assuming the archive is sorted or has some structure)\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify items that can be swapped (either included or excluded)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Hybrid local search: combine random swaps with biased selection\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Randomly select an item to flip (include/exclude)\n        if random.random() < 0.5 and len(included_items) > 0:\n            # Try to remove an item that has high marginal utility\n            candidate_items = included_items\n            if len(candidate_items) > 0:\n                # Sort by marginal utility (value1 + value2) / weight\n                marginal_utilities = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n                item_to_remove = candidate_items[np.argmax(marginal_utilities)]\n                new_solution[item_to_remove] = 0\n                # Check feasibility\n                new_weight = current_weight - weight_lst[item_to_remove]\n                if new_weight <= capacity:\n                    current_weight = new_weight\n                    break\n                else:\n                    new_solution[item_to_remove] = 1  # Revert if infeasible\n        else:\n            # Try to add an item that has high marginal utility\n            candidate_items = excluded_items\n            if len(candidate_items) > 0:\n                # Sort by marginal utility (value1 + value2) / weight\n                marginal_utilities = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n                item_to_add = candidate_items[np.argmax(marginal_utilities)]\n                new_solution[item_to_add] = 1\n                # Check feasibility\n                new_weight = current_weight + weight_lst[item_to_add]\n                if new_weight <= capacity:\n                    current_weight = new_weight\n                    break\n                else:\n                    new_solution[item_to_add] = 0  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.6470545635971137,
            0.9737718403339386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not too crowded in the archive\n    # (assuming the archive is sorted or has some structure)\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Identify items that can be swapped (either included or excluded)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Hybrid local search: combine random swaps with biased selection\n    for _ in range(10):  # Number of attempts to find a better neighbor\n        # Randomly select an item to flip (include/exclude)\n        if random.random() < 0.5 and len(included_items) > 0:\n            # Try to remove an item that has high marginal utility\n            candidate_items = included_items\n            if len(candidate_items) > 0:\n                # Sort by marginal utility (value1 + value2) / weight\n                marginal_utilities = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n                item_to_remove = candidate_items[np.argmax(marginal_utilities)]\n                new_solution[item_to_remove] = 0\n                # Check feasibility\n                new_weight = current_weight - weight_lst[item_to_remove]\n                if new_weight <= capacity:\n                    current_weight = new_weight\n                    break\n                else:\n                    new_solution[item_to_remove] = 1  # Revert if infeasible\n        else:\n            # Try to add an item that has high marginal utility\n            candidate_items = excluded_items\n            if len(candidate_items) > 0:\n                # Sort by marginal utility (value1 + value2) / weight\n                marginal_utilities = (value1_lst[candidate_items] + value2_lst[candidate_items]) / weight_lst[candidate_items]\n                item_to_add = candidate_items[np.argmax(marginal_utilities)]\n                new_solution[item_to_add] = 1\n                # Check feasibility\n                new_weight = current_weight + weight_lst[item_to_add]\n                if new_weight <= capacity:\n                    current_weight = new_weight\n                    break\n                else:\n                    new_solution[item_to_add] = 0  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random bit flips with targeted swaps\n    n_items = len(base_solution)\n\n    # Step 1: Randomly flip a small number of bits (1-3) to introduce diversity\n    flip_indices = np.random.choice(n_items, size=np.random.randint(1, 4), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after flips\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            # Remove the item with the smallest ratio of (value1 + value2) / weight\n            ratios = (value1_lst + value2_lst) / weight_lst\n            ratios[new_solution == 0] = np.inf  # Exclude non-selected items\n            remove_idx = np.argmin(ratios)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    # Step 2: Perform targeted swaps to improve both objectives\n    # Identify items that are in the solution but could be swapped with out-of-solution items\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    if len(in_solution) > 0 and len(out_solution) > 0:\n        # Randomly select a pair to swap\n        swap_in = np.random.choice(in_solution)\n        swap_out = np.random.choice(out_solution)\n\n        # Check if the swap is feasible\n        new_weight = total_weight - weight_lst[swap_in] + weight_lst[swap_out]\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.35427787775263087,
            2.007298558950424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random bit flips with targeted swaps\n    n_items = len(base_solution)\n\n    # Step 1: Randomly flip a small number of bits (1-3) to introduce diversity\n    flip_indices = np.random.choice(n_items, size=np.random.randint(1, 4), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after flips\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            # Remove the item with the smallest ratio of (value1 + value2) / weight\n            ratios = (value1_lst + value2_lst) / weight_lst\n            ratios[new_solution == 0] = np.inf  # Exclude non-selected items\n            remove_idx = np.argmin(ratios)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    # Step 2: Perform targeted swaps to improve both objectives\n    # Identify items that are in the solution but could be swapped with out-of-solution items\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    if len(in_solution) > 0 and len(out_solution) > 0:\n        # Randomly select a pair to swap\n        swap_in = np.random.choice(in_solution)\n        swap_out = np.random.choice(out_solution)\n\n        # Check if the swap is feasible\n        new_weight = total_weight - weight_lst[swap_in] + weight_lst[swap_out]\n        if new_weight <= capacity:\n            new_solution[swap_in] = 0\n            new_solution[swap_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Prefer solutions that are not fully packed (have margin for improvement)\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity * 0.9:  # Prefer solutions with room to improve\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if none have margin\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly swap a subset of items (exploration)\n    # 2. Greedily improve by adding high-value items not in the solution (exploitation)\n    # 3. Ensure feasibility by removing low-value items if capacity is exceeded\n\n    # Step 1: Random swaps (exploration)\n    num_items = len(weight_lst)\n    num_swaps = min(3, num_items)  # Limit swaps to a small number for efficiency\n    swap_indices = random.sample(range(num_items), num_swaps)\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Step 2: Greedy improvement (exploitation)\n    # Add high-value items not in the solution, prioritizing items with good value-to-weight ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-to-weight ratios for items not in the solution\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Prioritize items with high value1 (can be adjusted for multi-objective)\n        value1_ratios = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n        sorted_indices = np.argsort(value1_ratios)[::-1]  # Descending order\n\n        for idx in sorted_indices:\n            item_idx = not_in_solution[idx]\n            if weight_lst[item_idx] <= remaining_capacity:\n                new_solution[item_idx] = 1\n                remaining_capacity -= weight_lst[item_idx]\n\n    # Step 3: Ensure feasibility by removing low-value items if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    while current_weight > capacity:\n        # Remove items with the lowest value1 (can be adjusted for multi-objective)\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) == 0:\n            break  # No items to remove\n\n        # Find the item with the lowest value1\n        min_value_idx = np.argmin(value1_lst[in_solution])\n        item_to_remove = in_solution[min_value_idx]\n        new_solution[item_to_remove] = 0\n        current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.3691043966309494,
            3.709087461233139
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a solution with high potential for improvement\n    # Prefer solutions that are not fully packed (have margin for improvement)\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity * 0.9:  # Prefer solutions with room to improve\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if none have margin\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly swap a subset of items (exploration)\n    # 2. Greedily improve by adding high-value items not in the solution (exploitation)\n    # 3. Ensure feasibility by removing low-value items if capacity is exceeded\n\n    # Step 1: Random swaps (exploration)\n    num_items = len(weight_lst)\n    num_swaps = min(3, num_items)  # Limit swaps to a small number for efficiency\n    swap_indices = random.sample(range(num_items), num_swaps)\n    for idx in swap_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Step 2: Greedy improvement (exploitation)\n    # Add high-value items not in the solution, prioritizing items with good value-to-weight ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-to-weight ratios for items not in the solution\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Prioritize items with high value1 (can be adjusted for multi-objective)\n        value1_ratios = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n        sorted_indices = np.argsort(value1_ratios)[::-1]  # Descending order\n\n        for idx in sorted_indices:\n            item_idx = not_in_solution[idx]\n            if weight_lst[item_idx] <= remaining_capacity:\n                new_solution[item_idx] = 1\n                remaining_capacity -= weight_lst[item_idx]\n\n    # Step 3: Ensure feasibility by removing low-value items if needed\n    current_weight = np.sum(weight_lst * new_solution)\n    while current_weight > capacity:\n        # Remove items with the lowest value1 (can be adjusted for multi-objective)\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) == 0:\n            break  # No items to remove\n\n        # Find the item with the lowest value1\n        min_value_idx = np.argmin(value1_lst[in_solution])\n        item_to_remove = in_solution[min_value_idx]\n        new_solution[item_to_remove] = 0\n        current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement: those with low total weight and high objective values\n    selected_solution = None\n    max_score = -float('inf')\n\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (obj[0] + obj[1]) / (total_weight + 1e-6)  # Balance between objectives and weight\n        if score > max_score:\n            max_score = score\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of swap and flip operations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for flip\n    subset_size = max(1, int(0.2 * n_items))\n    candidates = np.random.choice(n_items, size=subset_size, replace=False)\n\n    for i in candidates:\n        if new_solution[i] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    # Additional swap operation to diversify the solution\n    if len(np.where(new_solution == 1)[0]) >= 2:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.3792227734488971,
            1.7141136229038239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement: those with low total weight and high objective values\n    selected_solution = None\n    max_score = -float('inf')\n\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        score = (obj[0] + obj[1]) / (total_weight + 1e-6)  # Balance between objectives and weight\n        if score > max_score:\n            max_score = score\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combination of swap and flip operations\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for flip\n    subset_size = max(1, int(0.2 * n_items))\n    candidates = np.random.choice(n_items, size=subset_size, replace=False)\n\n    for i in candidates:\n        if new_solution[i] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = new_weight\n\n    # Additional swap operation to diversify the solution\n    if len(np.where(new_solution == 1)[0]) >= 2:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with a bias towards higher objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = normalized.sum(axis=1)\n    base_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Generate candidate flips: items to potentially add or remove\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Remove one item (with replacement chance)\n        remove_idx = np.random.choice(candidate_items)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    # Add items with high marginal contribution to either objective\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Calculate marginal contributions\n        marginal1 = value1_lst / (weight_lst + 1e-10)\n        marginal2 = value2_lst / (weight_lst + 1e-10)\n        combined_marginal = marginal1 + marginal2\n\n        # Select items with high marginal contribution that fit in remaining weight\n        available_items = np.where((new_solution == 0) & (weight_lst <= remaining_weight))[0]\n        if len(available_items) > 0:\n            # Weighted selection based on combined marginal contribution\n            probs = combined_marginal[available_items]\n            probs = probs / probs.sum() if probs.sum() > 0 else np.ones_like(probs) / len(probs)\n            selected_items = np.random.choice(available_items, size=min(2, len(available_items)), p=probs, replace=False)\n            new_solution[selected_items] = 1\n\n    # Ensure feasibility (in case of floating point precision issues)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items until feasible\n        excess = np.sum(weight_lst * new_solution) - capacity\n        while excess > 0 and np.any(new_solution == 1):\n            remove_candidates = np.where(new_solution == 1)[0]\n            remove_idx = np.random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3509497553323062,
            3.7619096636772156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with a bias towards higher objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = normalized.sum(axis=1)\n    base_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Generate candidate flips: items to potentially add or remove\n    candidate_items = np.where(new_solution == 1)[0]\n    if len(candidate_items) > 0:\n        # Remove one item (with replacement chance)\n        remove_idx = np.random.choice(candidate_items)\n        new_solution[remove_idx] = 0\n        current_weight -= weight_lst[remove_idx]\n\n    # Add items with high marginal contribution to either objective\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Calculate marginal contributions\n        marginal1 = value1_lst / (weight_lst + 1e-10)\n        marginal2 = value2_lst / (weight_lst + 1e-10)\n        combined_marginal = marginal1 + marginal2\n\n        # Select items with high marginal contribution that fit in remaining weight\n        available_items = np.where((new_solution == 0) & (weight_lst <= remaining_weight))[0]\n        if len(available_items) > 0:\n            # Weighted selection based on combined marginal contribution\n            probs = combined_marginal[available_items]\n            probs = probs / probs.sum() if probs.sum() > 0 else np.ones_like(probs) / len(probs)\n            selected_items = np.random.choice(available_items, size=min(2, len(available_items)), p=probs, replace=False)\n            new_solution[selected_items] = 1\n\n    # Ensure feasibility (in case of floating point precision issues)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Remove items until feasible\n        excess = np.sum(weight_lst * new_solution) - capacity\n        while excess > 0 and np.any(new_solution == 1):\n            remove_candidates = np.where(new_solution == 1)[0]\n            remove_idx = np.random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too dense or sparse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random flip + Greedy improvement\n    # Step 1: Randomly flip a subset of items (with probability 0.5 per item)\n    flip_mask = np.random.rand(len(new_solution)) < 0.5\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Greedy improvement to ensure feasibility and quality\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible, prioritizing items with the smallest ratio of (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Step 3: Add items that improve both objectives, if space allows\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Calculate potential improvement for each item (normalized by weight)\n        improvement1 = value1_lst / weight_lst\n        improvement2 = value2_lst / weight_lst\n        combined_improvement = improvement1 + improvement2\n        sorted_indices = np.argsort(-combined_improvement)  # Descending order\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.42845685992572735,
            2.2311646938323975
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too dense or sparse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random flip + Greedy improvement\n    # Step 1: Randomly flip a subset of items (with probability 0.5 per item)\n    flip_mask = np.random.rand(len(new_solution)) < 0.5\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Greedy improvement to ensure feasibility and quality\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible, prioritizing items with the smallest ratio of (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and current_weight > capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    # Step 3: Add items that improve both objectives, if space allows\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Calculate potential improvement for each item (normalized by weight)\n        improvement1 = value1_lst / weight_lst\n        improvement2 = value2_lst / weight_lst\n        combined_improvement = improvement1 + improvement2\n        sorted_indices = np.argsort(-combined_improvement)  # Descending order\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the \"potential\" for improvement (e.g., ratio of unused capacity)\n        current_weight = np.sum(sol * weight_lst)\n        unused_capacity = capacity - current_weight\n        if unused_capacity > 0:\n            potential = unused_capacity / capacity\n            candidates.append((sol, obj, potential))\n\n    if not candidates:\n        # All solutions are at full capacity, pick a random one\n        base_solution, _ = random.choice(archive)\n    else:\n        # Select solution with highest potential for improvement\n        candidates.sort(key=lambda x: -x[2])\n        base_solution, _, _ = candidates[0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a few items (exploration)\n    n_flips = min(3, len(new_solution))  # Limit number of flips\n    for _ in range(n_flips):\n        i = random.randint(0, len(new_solution) - 1)\n        if new_solution[i] == 1:\n            # Remove item if it doesn't violate capacity\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Add item if it doesn't exceed capacity\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # 2. Greedily add items that improve both objectives\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Check if adding this item improves both objectives\n            if (value1_lst[i] > 0) and (value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # 3. Randomly remove items that don't contribute to either objective\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1 and (value1_lst[i] == 0 or value2_lst[i] == 0):\n            if random.random() < 0.3:  # 30% chance to remove\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.36852479579915703,
            7.759556293487549
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the \"potential\" for improvement (e.g., ratio of unused capacity)\n        current_weight = np.sum(sol * weight_lst)\n        unused_capacity = capacity - current_weight\n        if unused_capacity > 0:\n            potential = unused_capacity / capacity\n            candidates.append((sol, obj, potential))\n\n    if not candidates:\n        # All solutions are at full capacity, pick a random one\n        base_solution, _ = random.choice(archive)\n    else:\n        # Select solution with highest potential for improvement\n        candidates.sort(key=lambda x: -x[2])\n        base_solution, _, _ = candidates[0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a few items (exploration)\n    n_flips = min(3, len(new_solution))  # Limit number of flips\n    for _ in range(n_flips):\n        i = random.randint(0, len(new_solution) - 1)\n        if new_solution[i] == 1:\n            # Remove item if it doesn't violate capacity\n            if current_weight - weight_lst[i] >= 0:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            # Add item if it doesn't exceed capacity\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # 2. Greedily add items that improve both objectives\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Check if adding this item improves both objectives\n            if (value1_lst[i] > 0) and (value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # 3. Randomly remove items that don't contribute to either objective\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1 and (value1_lst[i] == 0 or value2_lst[i] == 0):\n            if random.random() < 0.3:  # 30% chance to remove\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (higher is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions with a higher probability\n        top_k = max(1, int(0.3 * len(archive_sorted)))\n        selected_solution = random.choice(archive_sorted[:top_k])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random flip with greedy improvement\n    # Step 1: Randomly flip a subset of items (up to 10% of items)\n    n_items = len(weight_lst)\n    flip_indices = random.sample(range(n_items), min(n_items, max(1, int(0.1 * n_items))))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flip\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        items_sorted_by_weight = np.argsort(weight_lst * new_solution)\n        for idx in items_sorted_by_weight:\n            if new_solution[idx] == 1 and excess_weight > 0:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n                if excess_weight <= 0:\n                    break\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate potential improvement for each remaining item\n    potential_improvements = []\n    for idx in remaining_items:\n        if weight_lst[idx] <= remaining_capacity:\n            # Normalized improvement (sum of normalized value1 and value2)\n            norm_value1 = value1_lst[idx] / np.max(value1_lst)\n            norm_value2 = value2_lst[idx] / np.max(value2_lst)\n            improvement = norm_value1 + norm_value2\n            potential_improvements.append((idx, improvement))\n\n    # Sort by improvement and add top 3 items\n    potential_improvements.sort(key=lambda x: x[1], reverse=True)\n    for idx, _ in potential_improvements[:3]:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3506640365649252,
            5.56353834271431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (higher is better)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n        # Select top 30% of solutions with a higher probability\n        top_k = max(1, int(0.3 * len(archive_sorted)))\n        selected_solution = random.choice(archive_sorted[:top_k])[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random flip with greedy improvement\n    # Step 1: Randomly flip a subset of items (up to 10% of items)\n    n_items = len(weight_lst)\n    flip_indices = random.sample(range(n_items), min(n_items, max(1, int(0.1 * n_items))))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flip\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess_weight = current_weight - capacity\n        items_sorted_by_weight = np.argsort(weight_lst * new_solution)\n        for idx in items_sorted_by_weight:\n            if new_solution[idx] == 1 and excess_weight > 0:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n                if excess_weight <= 0:\n                    break\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate potential improvement for each remaining item\n    potential_improvements = []\n    for idx in remaining_items:\n        if weight_lst[idx] <= remaining_capacity:\n            # Normalized improvement (sum of normalized value1 and value2)\n            norm_value1 = value1_lst[idx] / np.max(value1_lst)\n            norm_value2 = value2_lst[idx] / np.max(value2_lst)\n            improvement = norm_value1 + norm_value2\n            potential_improvements.append((idx, improvement))\n\n    # Sort by improvement and add top 3 items\n    potential_improvements.sort(key=lambda x: x[1], reverse=True)\n    for idx, _ in potential_improvements[:3]:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combination of bit-flip and swap\n    new_solution = base_solution.copy()\n\n    # Bit-flip: randomly flip a bit if feasible\n    if random.random() < 0.5:  # 50% chance to perform bit-flip\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Swap: randomly swap two items if feasible\n    else:\n        swap_idx1, swap_idx2 = random.sample(range(len(base_solution)), 2)\n        if base_solution[swap_idx1] != base_solution[swap_idx2]:\n            # Check feasibility of swap\n            if base_solution[swap_idx1] == 1:\n                # Case 1: swap out item1 and swap in item2\n                if current_weight - weight_lst[swap_idx1] + weight_lst[swap_idx2] <= capacity:\n                    new_solution[swap_idx1], new_solution[swap_idx2] = 0, 1\n            else:\n                # Case 2: swap out item2 and swap in item1\n                if current_weight - weight_lst[swap_idx2] + weight_lst[swap_idx1] <= capacity:\n                    new_solution[swap_idx1], new_solution[swap_idx2] = 1, 0\n\n    return new_solution\n\n",
        "score": [
            -0.3153168958582453,
            1.6041224896907806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combination of bit-flip and swap\n    new_solution = base_solution.copy()\n\n    # Bit-flip: randomly flip a bit if feasible\n    if random.random() < 0.5:  # 50% chance to perform bit-flip\n        flip_idx = random.randint(0, len(base_solution) - 1)\n        if base_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Swap: randomly swap two items if feasible\n    else:\n        swap_idx1, swap_idx2 = random.sample(range(len(base_solution)), 2)\n        if base_solution[swap_idx1] != base_solution[swap_idx2]:\n            # Check feasibility of swap\n            if base_solution[swap_idx1] == 1:\n                # Case 1: swap out item1 and swap in item2\n                if current_weight - weight_lst[swap_idx1] + weight_lst[swap_idx2] <= capacity:\n                    new_solution[swap_idx1], new_solution[swap_idx2] = 0, 1\n            else:\n                # Case 2: swap out item2 and swap in item1\n                if current_weight - weight_lst[swap_idx2] + weight_lst[swap_idx1] <= capacity:\n                    new_solution[swap_idx1], new_solution[swap_idx2] = 1, 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with higher total weight utilization\n    weights = np.array([np.dot(sol[0], weight_lst) for sol in archive])\n    probs = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(len(archive)) / len(archive)\n    base_solution = random.choices(archive, weights=probs, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.dot(new_solution, weight_lst)\n\n    # Determine the number of operations to perform (1-3)\n    num_ops = random.randint(1, 3)\n\n    for _ in range(num_ops):\n        operation = random.choice(['swap', 'insert', 'invert'])\n\n        if operation == 'swap':\n            # Randomly select two items and swap their states\n            indices = random.sample(range(len(new_solution)), 2)\n            i, j = indices[0], indices[1]\n            delta_weight = (weight_lst[j] - weight_lst[i]) * (new_solution[j] - new_solution[i])\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n        elif operation == 'insert':\n            # Randomly select an item to flip (insert/remove)\n            i = random.randint(0, len(new_solution) - 1)\n            delta_weight = (1 - 2 * new_solution[i]) * weight_lst[i]\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[i] = 1 - new_solution[i]\n                current_weight += delta_weight\n\n        elif operation == 'invert':\n            # Randomly select a segment and invert it\n            start, end = sorted(random.sample(range(len(new_solution) + 1), 2))\n            segment = new_solution[start:end]\n            delta_weight = np.dot(weight_lst[start:end], (1 - 2 * segment))\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[start:end] = 1 - segment\n                current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.29015802609856345,
            3.8780358731746674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with higher total weight utilization\n    weights = np.array([np.dot(sol[0], weight_lst) for sol in archive])\n    probs = weights / np.sum(weights) if np.sum(weights) > 0 else np.ones(len(archive)) / len(archive)\n    base_solution = random.choices(archive, weights=probs, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.dot(new_solution, weight_lst)\n\n    # Determine the number of operations to perform (1-3)\n    num_ops = random.randint(1, 3)\n\n    for _ in range(num_ops):\n        operation = random.choice(['swap', 'insert', 'invert'])\n\n        if operation == 'swap':\n            # Randomly select two items and swap their states\n            indices = random.sample(range(len(new_solution)), 2)\n            i, j = indices[0], indices[1]\n            delta_weight = (weight_lst[j] - weight_lst[i]) * (new_solution[j] - new_solution[i])\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight += delta_weight\n\n        elif operation == 'insert':\n            # Randomly select an item to flip (insert/remove)\n            i = random.randint(0, len(new_solution) - 1)\n            delta_weight = (1 - 2 * new_solution[i]) * weight_lst[i]\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[i] = 1 - new_solution[i]\n                current_weight += delta_weight\n\n        elif operation == 'invert':\n            # Randomly select a segment and invert it\n            start, end = sorted(random.sample(range(len(new_solution) + 1), 2))\n            segment = new_solution[start:end]\n            delta_weight = np.dot(weight_lst[start:end], (1 - 2 * segment))\n\n            if current_weight + delta_weight <= capacity:\n                new_solution[start:end] = 1 - segment\n                current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a promising solution from the archive\n    # Prefer solutions with higher total value in either objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Random perturbation + Greedy improvement\n    new_solution = selected_solution.copy()\n\n    # Step 1: Random Perturbation - Flip a random subset of items\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items randomly\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy Improvement - Add items with highest marginal utility\n    current_weight = np.sum(new_solution * weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal utility for each item not in the solution\n        marginal_utility1 = value1_lst / weight_lst\n        marginal_utility2 = value2_lst / weight_lst\n        combined_utility = marginal_utility1 + marginal_utility2\n\n        # Sort items by combined marginal utility (descending)\n        sorted_indices = np.argsort(combined_utility)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items with lowest marginal utility until feasible\n        sorted_indices = np.argsort((value1_lst + value2_lst) / weight_lst)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3113021078351351,
            3.6025783121585846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a promising solution from the archive\n    # Prefer solutions with higher total value in either objective\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: Random perturbation + Greedy improvement\n    new_solution = selected_solution.copy()\n\n    # Step 1: Random Perturbation - Flip a random subset of items\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items randomly\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy Improvement - Add items with highest marginal utility\n    current_weight = np.sum(new_solution * weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal utility for each item not in the solution\n        marginal_utility1 = value1_lst / weight_lst\n        marginal_utility2 = value2_lst / weight_lst\n        combined_utility = marginal_utility1 + marginal_utility2\n\n        # Sort items by combined marginal utility (descending)\n        sorted_indices = np.argsort(combined_utility)[::-1]\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Ensure feasibility by removing items if capacity exceeded\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items with lowest marginal utility until feasible\n        sorted_indices = np.argsort((value1_lst + value2_lst) / weight_lst)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability based on its dominance rank (higher rank = more promising)\n    base_solution, _ = random.choices(archive, weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip bits with a probability that decreases as the solution approaches capacity\n    flip_prob = 0.3 * (1 - current_weight / capacity)\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # If removing the item keeps the solution feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If adding the item keeps the solution feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # 2. Perform objective-aware swaps to improve both objectives\n    for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n        # Find items to swap: one in the solution and one not in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        out_solution = np.where(new_solution == 0)[0]\n\n        if len(in_solution) > 0 and len(out_solution) > 0:\n            # Select items with potential to improve both objectives\n            candidate_in = random.choice(in_solution)\n            candidate_out = random.choice(out_solution)\n\n            # Calculate potential new weight and objectives\n            new_weight = current_weight - weight_lst[candidate_in] + weight_lst[candidate_out]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[candidate_in] + value1_lst[candidate_out]\n                new_value2 = current_value2 - value2_lst[candidate_in] + value2_lst[candidate_out]\n\n                # Accept the swap if it improves at least one objective\n                if (new_value1 > current_value1) or (new_value2 > current_value2):\n                    new_solution[candidate_in], new_solution[candidate_out] = 0, 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.4042347193141328,
            2.308917284011841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability based on its dominance rank (higher rank = more promising)\n    base_solution, _ = random.choices(archive, weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip bits with a probability that decreases as the solution approaches capacity\n    flip_prob = 0.3 * (1 - current_weight / capacity)\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # If removing the item keeps the solution feasible\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If adding the item keeps the solution feasible\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # 2. Perform objective-aware swaps to improve both objectives\n    for _ in range(3):  # Limit the number of swaps to avoid excessive computation\n        # Find items to swap: one in the solution and one not in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        out_solution = np.where(new_solution == 0)[0]\n\n        if len(in_solution) > 0 and len(out_solution) > 0:\n            # Select items with potential to improve both objectives\n            candidate_in = random.choice(in_solution)\n            candidate_out = random.choice(out_solution)\n\n            # Calculate potential new weight and objectives\n            new_weight = current_weight - weight_lst[candidate_in] + weight_lst[candidate_out]\n            if new_weight <= capacity:\n                new_value1 = current_value1 - value1_lst[candidate_in] + value1_lst[candidate_out]\n                new_value2 = current_value2 - value2_lst[candidate_in] + value2_lst[candidate_out]\n\n                # Accept the swap if it improves at least one objective\n                if (new_value1 > current_value1) or (new_value2 > current_value2):\n                    new_solution[candidate_in], new_solution[candidate_out] = 0, 1\n                    current_weight = new_weight\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: item swaps and random flips\n    new_solution = base_solution.copy()\n\n    # Step 1: Perform item swaps to improve both objectives\n    for _ in range(2):  # Number of swaps\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        remove_item = random.choice(in_items)\n        add_item = random.choice(out_items)\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[remove_item] + weight_lst[add_item]\n        if new_weight <= capacity:\n            new_solution[remove_item] = 0\n            new_solution[add_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Random flips to escape local optima\n    for _ in range(3):  # Number of flips\n        flip_item = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 0\n                current_weight -= weight_lst[flip_item]\n        else:\n            if current_weight + weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 1\n                current_weight += weight_lst[flip_item]\n\n    return new_solution\n\n",
        "score": [
            -0.8834601253100438,
            0.7840182781219482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: item swaps and random flips\n    new_solution = base_solution.copy()\n\n    # Step 1: Perform item swaps to improve both objectives\n    for _ in range(2):  # Number of swaps\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select a random item to remove and a random item to add\n        remove_item = random.choice(in_items)\n        add_item = random.choice(out_items)\n\n        # Check feasibility\n        new_weight = current_weight - weight_lst[remove_item] + weight_lst[add_item]\n        if new_weight <= capacity:\n            new_solution[remove_item] = 0\n            new_solution[add_item] = 1\n            current_weight = new_weight\n\n    # Step 2: Random flips to escape local optima\n    for _ in range(3):  # Number of flips\n        flip_item = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_item] == 1:\n            if current_weight - weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 0\n                current_weight -= weight_lst[flip_item]\n        else:\n            if current_weight + weight_lst[flip_item] <= capacity:\n                new_solution[flip_item] = 1\n                current_weight += weight_lst[flip_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_probability(solution):\n        current_weight = np.sum(weight_lst[solution == 1])\n        utilization = current_weight / capacity\n        # Higher probability for solutions with lower utilization\n        return 1 - utilization\n\n    solutions, _ = zip(*archive)\n    probabilities = np.array([selection_probability(sol) for sol in solutions])\n    probabilities = probabilities / np.sum(probabilities)\n    base_solution = random.choices(solutions, weights=probabilities, k=1)[0].copy()\n\n    # Hybrid local search strategy: combination of swap and insertion\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Random swap of two items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility and revert if necessary\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight > capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 2: Random insertion of an item not in the solution\n    if np.sum(new_solution) < n_items:\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            item_to_add = random.choice(candidates)\n            new_solution[item_to_add] = 1\n\n            # Check feasibility and revert if necessary\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight > capacity:\n                new_solution[item_to_add] = 0\n\n    # Phase 3: Random removal of an item in the solution\n    if np.sum(new_solution) > 0:\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            item_to_remove = random.choice(candidates)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.478309055873287,
            2.6910276114940643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def selection_probability(solution):\n        current_weight = np.sum(weight_lst[solution == 1])\n        utilization = current_weight / capacity\n        # Higher probability for solutions with lower utilization\n        return 1 - utilization\n\n    solutions, _ = zip(*archive)\n    probabilities = np.array([selection_probability(sol) for sol in solutions])\n    probabilities = probabilities / np.sum(probabilities)\n    base_solution = random.choices(solutions, weights=probabilities, k=1)[0].copy()\n\n    # Hybrid local search strategy: combination of swap and insertion\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Phase 1: Random swap of two items\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility and revert if necessary\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if current_weight > capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Phase 2: Random insertion of an item not in the solution\n    if np.sum(new_solution) < n_items:\n        candidates = np.where(new_solution == 0)[0]\n        if len(candidates) > 0:\n            item_to_add = random.choice(candidates)\n            new_solution[item_to_add] = 1\n\n            # Check feasibility and revert if necessary\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight > capacity:\n                new_solution[item_to_add] = 0\n\n    # Phase 3: Random removal of an item in the solution\n    if np.sum(new_solution) > 0:\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            item_to_remove = random.choice(candidates)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objective values (higher is better)\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(weight_lst[x[0] == 1]) + 1e-10), reverse=True)\n        # Select top 20% of solutions with some randomness\n        candidate_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 5)]\n        selected = random.choice(candidate_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    current_weight = sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search strategy\n    # Option 1: Random flip with value-based selection (70% chance)\n    if random.random() < 0.7:\n        # Calculate value-to-weight ratios\n        ratios1 = value1_lst / (weight_lst + 1e-10)\n        ratios2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios for both objectives\n        combined_ratios = (ratios1 + ratios2) / 2\n\n        # Select items to flip based on high combined ratio and current selection\n        flip_candidates = np.where((combined_ratios > np.percentile(combined_ratios, 75)) &\n                                  (base_solution == 1))[0]\n\n        if len(flip_candidates) > 0:\n            item_to_flip = random.choice(flip_candidates)\n            new_solution[item_to_flip] = 0  # Remove the item\n            current_weight -= weight_lst[item_to_flip]\n\n            # Try to add the best possible item that fits\n            remaining_capacity = capacity - current_weight\n            available_items = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n            if len(available_items) > 0:\n                # Select item with highest combined ratio\n                best_item = available_items[np.argmax(combined_ratios[available_items])]\n                new_solution[best_item] = 1\n    else:\n        # Option 2: Random swap (30% chance)\n        # Select two items to swap (one in, one out)\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            item_out = random.choice(in_items)\n            item_in = random.choice(out_items)\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[item_out] + weight_lst[item_in]\n            if new_weight <= capacity:\n                new_solution[item_out] = 0\n                new_solution[item_in] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4986848756614095,
            2.732124239206314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objective values (higher is better)\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(weight_lst[x[0] == 1]) + 1e-10), reverse=True)\n        # Select top 20% of solutions with some randomness\n        candidate_solutions = sorted_solutions[:max(1, len(sorted_solutions) // 5)]\n        selected = random.choice(candidate_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    current_weight = sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search strategy\n    # Option 1: Random flip with value-based selection (70% chance)\n    if random.random() < 0.7:\n        # Calculate value-to-weight ratios\n        ratios1 = value1_lst / (weight_lst + 1e-10)\n        ratios2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios for both objectives\n        combined_ratios = (ratios1 + ratios2) / 2\n\n        # Select items to flip based on high combined ratio and current selection\n        flip_candidates = np.where((combined_ratios > np.percentile(combined_ratios, 75)) &\n                                  (base_solution == 1))[0]\n\n        if len(flip_candidates) > 0:\n            item_to_flip = random.choice(flip_candidates)\n            new_solution[item_to_flip] = 0  # Remove the item\n            current_weight -= weight_lst[item_to_flip]\n\n            # Try to add the best possible item that fits\n            remaining_capacity = capacity - current_weight\n            available_items = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n            if len(available_items) > 0:\n                # Select item with highest combined ratio\n                best_item = available_items[np.argmax(combined_ratios[available_items])]\n                new_solution[best_item] = 1\n    else:\n        # Option 2: Random swap (30% chance)\n        # Select two items to swap (one in, one out)\n        in_items = np.where(base_solution == 1)[0]\n        out_items = np.where(base_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            item_out = random.choice(in_items)\n            item_in = random.choice(out_items)\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[item_out] + weight_lst[item_in]\n            if new_weight <= capacity:\n                new_solution[item_out] = 0\n                new_solution[item_in] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate total values for each solution in the archive\n    total_values = np.array([sum(sol[1]) for sol in archive])\n    probabilities = total_values / total_values.sum() if total_values.sum() > 0 else np.ones(len(archive)) / len(archive)\n    base_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added without exceeding capacity\n    addable_items = (weight_lst <= remaining_capacity) & (new_solution == 0)\n\n    # Identify items that can be removed without violating feasibility\n    removable_items = new_solution == 1\n\n    # Hybrid local search: flip items with a probability based on their value\n    for i in range(len(new_solution)):\n        if addable_items[i]:\n            # Probability of adding an item is proportional to its normalized value\n            value1_norm = value1_lst[i] / np.max(value1_lst) if np.max(value1_lst) > 0 else 0.5\n            value2_norm = value2_lst[i] / np.max(value2_lst) if np.max(value2_lst) > 0 else 0.5\n            prob = 0.5 * (value1_norm + value2_norm)\n            if random.random() < prob:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                remaining_capacity = capacity - current_weight\n        elif removable_items[i]:\n            # Probability of removing an item is inversely proportional to its normalized value\n            value1_norm = value1_lst[i] / np.max(value1_lst) if np.max(value1_lst) > 0 else 0.5\n            value2_norm = value2_lst[i] / np.max(value2_lst) if np.max(value2_lst) > 0 else 0.5\n            prob = 0.5 * (1 - value1_norm) * (1 - value2_norm)\n            if random.random() < prob:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                remaining_capacity = capacity - current_weight\n\n    # Ensure feasibility by removing items if necessary\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Select a removable item with probability inversely proportional to its value\n        removable_idx = np.where(new_solution == 1)[0]\n        if len(removable_idx) == 0:\n            break\n        value1_removable = value1_lst[removable_idx]\n        value2_removable = value2_lst[removable_idx]\n        value1_norm = value1_removable / np.max(value1_removable) if np.max(value1_removable) > 0 else np.ones_like(value1_removable)\n        value2_norm = value2_removable / np.max(value2_removable) if np.max(value2_removable) > 0 else np.ones_like(value2_removable)\n        prob = 0.5 * (1 - value1_norm) * (1 - value2_norm)\n        prob = prob / prob.sum() if prob.sum() > 0 else np.ones_like(prob) / len(prob)\n        selected_idx = np.random.choice(removable_idx, p=prob)\n        new_solution[selected_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.8507406594880524,
            8.285085529088974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate total values for each solution in the archive\n    total_values = np.array([sum(sol[1]) for sol in archive])\n    probabilities = total_values / total_values.sum() if total_values.sum() > 0 else np.ones(len(archive)) / len(archive)\n    base_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items that can be added without exceeding capacity\n    addable_items = (weight_lst <= remaining_capacity) & (new_solution == 0)\n\n    # Identify items that can be removed without violating feasibility\n    removable_items = new_solution == 1\n\n    # Hybrid local search: flip items with a probability based on their value\n    for i in range(len(new_solution)):\n        if addable_items[i]:\n            # Probability of adding an item is proportional to its normalized value\n            value1_norm = value1_lst[i] / np.max(value1_lst) if np.max(value1_lst) > 0 else 0.5\n            value2_norm = value2_lst[i] / np.max(value2_lst) if np.max(value2_lst) > 0 else 0.5\n            prob = 0.5 * (value1_norm + value2_norm)\n            if random.random() < prob:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                remaining_capacity = capacity - current_weight\n        elif removable_items[i]:\n            # Probability of removing an item is inversely proportional to its normalized value\n            value1_norm = value1_lst[i] / np.max(value1_lst) if np.max(value1_lst) > 0 else 0.5\n            value2_norm = value2_lst[i] / np.max(value2_lst) if np.max(value2_lst) > 0 else 0.5\n            prob = 0.5 * (1 - value1_norm) * (1 - value2_norm)\n            if random.random() < prob:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                remaining_capacity = capacity - current_weight\n\n    # Ensure feasibility by removing items if necessary\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Select a removable item with probability inversely proportional to its value\n        removable_idx = np.where(new_solution == 1)[0]\n        if len(removable_idx) == 0:\n            break\n        value1_removable = value1_lst[removable_idx]\n        value2_removable = value2_lst[removable_idx]\n        value1_norm = value1_removable / np.max(value1_removable) if np.max(value1_removable) > 0 else np.ones_like(value1_removable)\n        value2_norm = value2_removable / np.max(value2_removable) if np.max(value2_removable) > 0 else np.ones_like(value2_removable)\n        prob = 0.5 * (1 - value1_norm) * (1 - value2_norm)\n        prob = prob / prob.sum() if prob.sum() > 0 else np.ones_like(prob) / len(prob)\n        selected_idx = np.random.choice(removable_idx, p=prob)\n        new_solution[selected_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not already at the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flip, greedy addition, and swap\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random flip with probability 0.3\n    if np.random.rand() < 0.3:\n        flip_idx = np.random.choice(n_items)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Greedy addition for items not in the solution\n    else:\n        # Calculate marginal gains for each item not in the solution\n        marginal_gains = []\n        for i in range(n_items):\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((gain1 + gain2, i))  # Combined gain for simplicity\n\n        if marginal_gains:\n            marginal_gains.sort(reverse=True, key=lambda x: x[0])\n            best_item = marginal_gains[0][1]\n            new_solution[best_item] = 1\n\n    # Optional: Perform a swap if no improvement is found\n    if np.random.rand() < 0.2:\n        # Select two items: one in the solution and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = np.random.choice(in_items)\n            out_idx = np.random.choice(out_items)\n\n            # Check if swap is feasible\n            delta_weight = weight_lst[out_idx] - weight_lst[in_idx]\n            if current_weight + delta_weight <= capacity:\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3281053121705099,
            5.281008660793304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not already at the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flip, greedy addition, and swap\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random flip with probability 0.3\n    if np.random.rand() < 0.3:\n        flip_idx = np.random.choice(n_items)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Greedy addition for items not in the solution\n    else:\n        # Calculate marginal gains for each item not in the solution\n        marginal_gains = []\n        for i in range(n_items):\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                gain1 = value1_lst[i]\n                gain2 = value2_lst[i]\n                marginal_gains.append((gain1 + gain2, i))  # Combined gain for simplicity\n\n        if marginal_gains:\n            marginal_gains.sort(reverse=True, key=lambda x: x[0])\n            best_item = marginal_gains[0][1]\n            new_solution[best_item] = 1\n\n    # Optional: Perform a swap if no improvement is found\n    if np.random.rand() < 0.2:\n        # Select two items: one in the solution and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            in_idx = np.random.choice(in_items)\n            out_idx = np.random.choice(out_items)\n\n            # Check if swap is feasible\n            delta_weight = weight_lst[out_idx] - weight_lst[in_idx]\n            if current_weight + delta_weight <= capacity:\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy improvement\n    num_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # First, perform random swaps (exploration)\n    for _ in range(min(5, num_items // 2)):\n        i, j = random.sample(range(num_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility if swapping\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if total_weight + weight_lst[j] - weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight += weight_lst[j] - weight_lst[i]\n            elif new_solution[i] == 0 and new_solution[j] == 1:\n                if total_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight += weight_lst[i] - weight_lst[j]\n\n    # Then, perform greedy improvement (exploitation)\n    for i in range(num_items):\n        if new_solution[i] == 0:\n            if total_weight + weight_lst[i] <= capacity:\n                # Check if adding this item improves both objectives\n                if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n        else:\n            # Check if removing this item doesn't worsen both objectives\n            if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                # Ensure at least one item remains (if needed)\n                if np.sum(new_solution) > 1:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.32103052921424724,
            4.130114048719406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps + greedy improvement\n    num_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # First, perform random swaps (exploration)\n    for _ in range(min(5, num_items // 2)):\n        i, j = random.sample(range(num_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility if swapping\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if total_weight + weight_lst[j] - weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight += weight_lst[j] - weight_lst[i]\n            elif new_solution[i] == 0 and new_solution[j] == 1:\n                if total_weight + weight_lst[i] - weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    total_weight += weight_lst[i] - weight_lst[j]\n\n    # Then, perform greedy improvement (exploitation)\n    for i in range(num_items):\n        if new_solution[i] == 0:\n            if total_weight + weight_lst[i] <= capacity:\n                # Check if adding this item improves both objectives\n                if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                    new_solution[i] = 1\n                    total_weight += weight_lst[i]\n        else:\n            # Check if removing this item doesn't worsen both objectives\n            if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                # Ensure at least one item remains (if needed)\n                if np.sum(new_solution) > 1:\n                    new_solution[i] = 0\n                    total_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high value ratios or diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation followed by greedy improvement\n    # Step 1: Random perturbation - flip a random subset of items\n    n_items = len(weight_lst)\n    n_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(n_items, size=n_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after perturbation\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, remove items randomly until feasible\n        while total_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break  # No items to remove\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)  # Randomize order for exploration\n\n    for idx in remaining_items:\n        if (weight_lst[idx] + total_weight <= capacity):\n            # Evaluate improvement in both objectives\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n               (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * np.mean(value2_lst)) or \\\n               (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * np.mean(value1_lst)):\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n                current_value1, current_value2 = new_value1, new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.40904000261380086,
            1.943048506975174
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with high value ratios or diversity\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation followed by greedy improvement\n    # Step 1: Random perturbation - flip a random subset of items\n    n_items = len(weight_lst)\n    n_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(n_items, size=n_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after perturbation\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, remove items randomly until feasible\n        while total_weight > capacity:\n            excess_items = np.where(new_solution == 1)[0]\n            if len(excess_items) == 0:\n                break  # No items to remove\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)  # Randomize order for exploration\n\n    for idx in remaining_items:\n        if (weight_lst[idx] + total_weight <= capacity):\n            # Evaluate improvement in both objectives\n            new_value1 = current_value1 + value1_lst[idx]\n            new_value2 = current_value2 + value2_lst[idx]\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n               (new_value1 > current_value1 and new_value2 >= current_value2 - 0.1 * np.mean(value2_lst)) or \\\n               (new_value2 > current_value2 and new_value1 >= current_value1 - 0.1 * np.mean(value1_lst)):\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n                current_value1, current_value2 = new_value1, new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Hybrid local search: flip a random item if feasible, otherwise swap with a lighter item\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select an item to flip\n    flip_idx = np.random.randint(0, n_items)\n    if selected_solution[flip_idx] == 1:\n        if current_weight - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n    else:\n        if current_weight + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    # If flipping didn't work, perform a weight-based swap\n    if np.array_equal(new_solution, selected_solution):\n        # Find the heaviest item in the knapsack and the lightest item outside\n        in_knapsack = np.where(selected_solution == 1)[0]\n        out_knapsack = np.where(selected_solution == 0)[0]\n\n        if len(in_knapsack) > 0 and len(out_knapsack) > 0:\n            heaviest_in = in_knapsack[np.argmax(weight_lst[in_knapsack])]\n            lightest_out = out_knapsack[np.argmin(weight_lst[out_knapsack])]\n\n            if (current_weight - weight_lst[heaviest_in] + weight_lst[lightest_out]) <= capacity:\n                new_solution[heaviest_in] = 0\n                new_solution[lightest_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.33893344767346567,
            0.9009908735752106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n\n    # Hybrid local search: flip a random item if feasible, otherwise swap with a lighter item\n    new_solution = selected_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select an item to flip\n    flip_idx = np.random.randint(0, n_items)\n    if selected_solution[flip_idx] == 1:\n        if current_weight - weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 0\n    else:\n        if current_weight + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    # If flipping didn't work, perform a weight-based swap\n    if np.array_equal(new_solution, selected_solution):\n        # Find the heaviest item in the knapsack and the lightest item outside\n        in_knapsack = np.where(selected_solution == 1)[0]\n        out_knapsack = np.where(selected_solution == 0)[0]\n\n        if len(in_knapsack) > 0 and len(out_knapsack) > 0:\n            heaviest_in = in_knapsack[np.argmax(weight_lst[in_knapsack])]\n            lightest_out = out_knapsack[np.argmin(weight_lst[out_knapsack])]\n\n            if (current_weight - weight_lst[heaviest_in] + weight_lst[lightest_out]) <= capacity:\n                new_solution[heaviest_in] = 0\n                new_solution[lightest_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip and greedy improvement\n    # Step 1: Randomly flip a subset of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for item in excess_items:\n            if total_weight <= capacity:\n                break\n            total_weight -= weight_lst[item]\n            new_solution[item] = 0\n\n    # Step 2: Greedy improvement - add items with highest marginal value ratio\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Calculate marginal value ratios for both objectives\n        marginal_ratios1 = value1_lst[remaining_items] / weight_lst[remaining_items]\n        marginal_ratios2 = value2_lst[remaining_items] / weight_lst[remaining_items]\n\n        # Combine ratios using a weighted sum\n        combined_ratios = 0.5 * marginal_ratios1 + 0.5 * marginal_ratios2\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = remaining_items[np.argsort(-combined_ratios)]\n\n        # Add items until capacity is exceeded\n        for item in sorted_indices:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n            else:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.34080681368615207,
            1.893982708454132
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip and greedy improvement\n    # Step 1: Randomly flip a subset of items\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_items)\n        for item in excess_items:\n            if total_weight <= capacity:\n                break\n            total_weight -= weight_lst[item]\n            new_solution[item] = 0\n\n    # Step 2: Greedy improvement - add items with highest marginal value ratio\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Calculate marginal value ratios for both objectives\n        marginal_ratios1 = value1_lst[remaining_items] / weight_lst[remaining_items]\n        marginal_ratios2 = value2_lst[remaining_items] / weight_lst[remaining_items]\n\n        # Combine ratios using a weighted sum\n        combined_ratios = 0.5 * marginal_ratios1 + 0.5 * marginal_ratios2\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = remaining_items[np.argsort(-combined_ratios)]\n\n        # Add items until capacity is exceeded\n        for item in sorted_indices:\n            if total_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                total_weight += weight_lst[item]\n            else:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # Higher-ranked solutions (less dominated) are more likely to be selected\n    ranks = np.argsort([i for i in range(len(archive))])\n    selected_idx = np.random.choice(ranks, p=np.exp(-ranks) / np.sum(np.exp(-ranks)))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Perform a random swap of two items\n    n_items = len(new_solution)\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility\n        total_weight = np.sum(new_solution * weight_lst)\n        if total_weight > capacity:\n            # If infeasible, revert the swap and try a different approach\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Perform a greedy improvement: add the most valuable item not in the solution\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                # Evaluate items by their combined value (normalized)\n                combined_value = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n                best_item = available_items[np.argmax(combined_value[available_items])]\n                if total_weight + weight_lst[best_item] <= capacity:\n                    new_solution[best_item] = 1\n                else:\n                    # If adding the best item is not possible, remove the least valuable item\n                    selected_items = np.where(new_solution == 1)[0]\n                    if len(selected_items) > 0:\n                        worst_item = selected_items[np.argmin(combined_value[selected_items])]\n                        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.5283642863199173,
            1.7048135101795197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance rank\n    # Higher-ranked solutions (less dominated) are more likely to be selected\n    ranks = np.argsort([i for i in range(len(archive))])\n    selected_idx = np.random.choice(ranks, p=np.exp(-ranks) / np.sum(np.exp(-ranks)))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Perform a random swap of two items\n    n_items = len(new_solution)\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility\n        total_weight = np.sum(new_solution * weight_lst)\n        if total_weight > capacity:\n            # If infeasible, revert the swap and try a different approach\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            # Perform a greedy improvement: add the most valuable item not in the solution\n            available_items = np.where(new_solution == 0)[0]\n            if len(available_items) > 0:\n                # Evaluate items by their combined value (normalized)\n                combined_value = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n                best_item = available_items[np.argmax(combined_value[available_items])]\n                if total_weight + weight_lst[best_item] <= capacity:\n                    new_solution[best_item] = 1\n                else:\n                    # If adding the best item is not possible, remove the least valuable item\n                    selected_items = np.where(new_solution == 1)[0]\n                    if len(selected_items) > 0:\n                        worst_item = selected_items[np.argmin(combined_value[selected_items])]\n                        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution from the archive with a bias towards solutions that are not too similar to others\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine flip-based and swap-based moves\n    # First, perform a flip-based move (flip a random item)\n    flip_index = np.random.randint(0, len(new_solution))\n    new_solution[flip_index] = 1 - new_solution[flip_index]\n\n    # Check feasibility after flip\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, undo the flip and try a swap-based move instead\n        new_solution[flip_index] = 1 - new_solution[flip_index]\n        # Select two random items to swap\n        swap_indices = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Ensure the solution remains feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If still infeasible, perform a greedy repair: remove items until feasible\n        while total_weight > capacity:\n            # Identify items that can be removed to reduce weight\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break  # No items left to remove\n            # Remove the item with the smallest total value (value1 + value2)\n            total_values = value1_lst + value2_lst\n            remove_idx = removable_items[np.argmin(total_values[removable_items])]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.40824198931142,
            1.4693808555603027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution from the archive with a bias towards solutions that are not too similar to others\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine flip-based and swap-based moves\n    # First, perform a flip-based move (flip a random item)\n    flip_index = np.random.randint(0, len(new_solution))\n    new_solution[flip_index] = 1 - new_solution[flip_index]\n\n    # Check feasibility after flip\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, undo the flip and try a swap-based move instead\n        new_solution[flip_index] = 1 - new_solution[flip_index]\n        # Select two random items to swap\n        swap_indices = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Ensure the solution remains feasible\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If still infeasible, perform a greedy repair: remove items until feasible\n        while total_weight > capacity:\n            # Identify items that can be removed to reduce weight\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break  # No items left to remove\n            # Remove the item with the smallest total value (value1 + value2)\n            total_values = value1_lst + value2_lst\n            remove_idx = removable_items[np.argmin(total_values[removable_items])]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity or potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        # Calculate the number of items in the solution\n        num_items = np.sum(sol)\n        # Prefer solutions that are neither too sparse nor too dense\n        diversity_score = abs(num_items - len(sol) / 2)\n        candidates.append((sol, diversity_score))\n\n    # Sort candidates by diversity score (higher score means more diverse)\n    candidates.sort(key=lambda x: -x[1])\n    selected_sol = candidates[0][0].copy()\n\n    # Generate a neighbor by flipping a subset of items\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n    max_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n\n    # Randomly select items to flip\n    flip_indices = random.sample(range(n_items), max_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing excess weight\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        # Sort items by value1/weight ratio to prioritize removal of less valuable items\n        item_ratios = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                if total_weight <= capacity:\n                    break\n\n    # Greedy improvement step: add items that improve both objectives\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate potential improvement for each item\n        potential_items = np.where(new_solution == 0)[0]\n        if len(potential_items) > 0:\n            # Sort by combined value improvement\n            combined_value = value1_lst + value2_lst\n            sorted_potential = sorted(potential_items, key=lambda x: -combined_value[x])\n            for idx in sorted_potential:\n                if weight_lst[idx] <= remaining_weight:\n                    new_solution[idx] = 1\n                    remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3501410101597747,
            3.939874142408371
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high diversity or potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        # Calculate the number of items in the solution\n        num_items = np.sum(sol)\n        # Prefer solutions that are neither too sparse nor too dense\n        diversity_score = abs(num_items - len(sol) / 2)\n        candidates.append((sol, diversity_score))\n\n    # Sort candidates by diversity score (higher score means more diverse)\n    candidates.sort(key=lambda x: -x[1])\n    selected_sol = candidates[0][0].copy()\n\n    # Generate a neighbor by flipping a subset of items\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n    max_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n\n    # Randomly select items to flip\n    flip_indices = random.sample(range(n_items), max_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing excess weight\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items until feasible\n        excess = total_weight - capacity\n        # Sort items by value1/weight ratio to prioritize removal of less valuable items\n        item_ratios = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                if total_weight <= capacity:\n                    break\n\n    # Greedy improvement step: add items that improve both objectives\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate potential improvement for each item\n        potential_items = np.where(new_solution == 0)[0]\n        if len(potential_items) > 0:\n            # Sort by combined value improvement\n            combined_value = value1_lst + value2_lst\n            sorted_potential = sorted(potential_items, key=lambda x: -combined_value[x])\n            for idx in sorted_potential:\n                if weight_lst[idx] <= remaining_weight:\n                    new_solution[idx] = 1\n                    remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine item swapping with value-based flipping\n    for _ in range(3):  # Perform up to 3 operations\n        # Option 1: Randomly flip one item (with weight check)\n        flip_candidate = np.random.randint(0, len(weight_lst))\n        if new_solution[flip_candidate] == 1:\n            # Check if removing this item keeps solution feasible\n            if current_weight - weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 0\n                current_weight -= weight_lst[flip_candidate]\n        else:\n            # Check if adding this item keeps solution feasible\n            if current_weight + weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 1\n                current_weight += weight_lst[flip_candidate]\n\n        # Option 2: Swap two items if it improves both objectives\n        if np.random.random() < 0.3:  # 30% chance for swap\n            item1, item2 = np.random.choice(len(weight_lst), size=2, replace=False)\n            if new_solution[item1] != new_solution[item2]:\n                # Calculate potential new weight\n                delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] else (weight_lst[item1] - weight_lst[item2])\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.40711051742701276,
            1.1700668931007385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine item swapping with value-based flipping\n    for _ in range(3):  # Perform up to 3 operations\n        # Option 1: Randomly flip one item (with weight check)\n        flip_candidate = np.random.randint(0, len(weight_lst))\n        if new_solution[flip_candidate] == 1:\n            # Check if removing this item keeps solution feasible\n            if current_weight - weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 0\n                current_weight -= weight_lst[flip_candidate]\n        else:\n            # Check if adding this item keeps solution feasible\n            if current_weight + weight_lst[flip_candidate] <= capacity:\n                new_solution[flip_candidate] = 1\n                current_weight += weight_lst[flip_candidate]\n\n        # Option 2: Swap two items if it improves both objectives\n        if np.random.random() < 0.3:  # 30% chance for swap\n            item1, item2 = np.random.choice(len(weight_lst), size=2, replace=False)\n            if new_solution[item1] != new_solution[item2]:\n                # Calculate potential new weight\n                delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] else (weight_lst[item1] - weight_lst[item2])\n                if current_weight + delta_weight <= capacity:\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias toward higher-value solutions\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Randomly select a subset of items to consider for perturbation\n    n_items = len(new_solution)\n    candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    # Hybrid local search: try to swap or flip items to improve both objectives\n    for i in candidates:\n        # Try flipping the item (add if not in, remove if in)\n        if new_solution[i] == 1:\n            temp_weight = current_weight - weight_lst[i]\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n        else:\n            temp_weight = current_weight + weight_lst[i]\n            temp_value1 = current_value1 + value1_lst[i]\n            temp_value2 = current_value2 + value2_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Additional improvement: try to swap items to balance objectives\n    for i in candidates:\n        for j in candidates:\n            if i != j:\n                if new_solution[i] == 1 and new_solution[j] == 0:\n                    delta_weight = weight_lst[j] - weight_lst[i]\n                    delta_value1 = value1_lst[j] - value1_lst[i]\n                    delta_value2 = value2_lst[j] - value2_lst[i]\n\n                    if (current_weight + delta_weight) <= capacity:\n                        # Check if the swap improves at least one objective\n                        if (delta_value1 > 0 and delta_value2 >= 0) or (delta_value2 > 0 and delta_value1 >= 0):\n                            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                            current_weight += delta_weight\n                            current_value1 += delta_value1\n                            current_value2 += delta_value2\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.3219232263409757,
            1.4313725233078003
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias toward higher-value solutions\n    base_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Randomly select a subset of items to consider for perturbation\n    n_items = len(new_solution)\n    candidates = np.random.choice(n_items, size=min(10, n_items), replace=False)\n\n    # Hybrid local search: try to swap or flip items to improve both objectives\n    for i in candidates:\n        # Try flipping the item (add if not in, remove if in)\n        if new_solution[i] == 1:\n            temp_weight = current_weight - weight_lst[i]\n            temp_value1 = current_value1 - value1_lst[i]\n            temp_value2 = current_value2 - value2_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 0\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n        else:\n            temp_weight = current_weight + weight_lst[i]\n            temp_value1 = current_value1 + value1_lst[i]\n            temp_value2 = current_value2 + value2_lst[i]\n            if temp_weight <= capacity:\n                new_solution[i] = 1\n                current_weight = temp_weight\n                current_value1 = temp_value1\n                current_value2 = temp_value2\n\n    # Additional improvement: try to swap items to balance objectives\n    for i in candidates:\n        for j in candidates:\n            if i != j:\n                if new_solution[i] == 1 and new_solution[j] == 0:\n                    delta_weight = weight_lst[j] - weight_lst[i]\n                    delta_value1 = value1_lst[j] - value1_lst[i]\n                    delta_value2 = value2_lst[j] - value2_lst[i]\n\n                    if (current_weight + delta_weight) <= capacity:\n                        # Check if the swap improves at least one objective\n                        if (delta_value1 > 0 and delta_value2 >= 0) or (delta_value2 > 0 and delta_value1 >= 0):\n                            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                            current_weight += delta_weight\n                            current_value1 += delta_value1\n                            current_value2 += delta_value2\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random flips with targeted improvements\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # First, perform random flips to escape local optima\n    num_flips = min(3, n_items)  # Limit flips to avoid excessive changes\n    flip_indices = random.sample(range(n_items), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Then perform targeted improvements for both objectives\n    # Sort items by their value-to-weight ratio for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine ratios to find items that are good for both objectives\n    combined_ratio = ratio1 + ratio2\n\n    # Sort items by combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0:\n            # Try adding the best item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            # Try removing the worst item (for both objectives)\n            if random.random() < 0.3:  # 30% chance to remove\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4196133665007558,
            1.825424611568451
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random flips with targeted improvements\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # First, perform random flips to escape local optima\n    num_flips = min(3, n_items)  # Limit flips to avoid excessive changes\n    flip_indices = random.sample(range(n_items), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Then perform targeted improvements for both objectives\n    # Sort items by their value-to-weight ratio for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine ratios to find items that are good for both objectives\n    combined_ratio = ratio1 + ratio2\n\n    # Sort items by combined ratio in descending order\n    sorted_indices = np.argsort(-combined_ratio)\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0:\n            # Try adding the best item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n        else:\n            # Try removing the worst item (for both objectives)\n            if random.random() < 0.3:  # 30% chance to remove\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (not just the first one)\n    # Here, we select a solution with the highest sum of normalized values\n    normalized_values = np.array([(v1 + v2) for _, (v1, v2) in archive])\n    if len(normalized_values) > 0:\n        selected_idx = np.argmax(normalized_values)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate a neighbor by flipping a subset of items\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)  # Flip up to 3 items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, try to include it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional improvement: flip items with high marginal value\n    # Calculate marginal values for excluded items\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        marginal_values = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        best_excluded_idx = excluded_items[np.argmax(marginal_values)]\n        if current_weight + weight_lst[best_excluded_idx] <= capacity:\n            new_solution[best_excluded_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.31067469039664175,
            5.175269603729248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (not just the first one)\n    # Here, we select a solution with the highest sum of normalized values\n    normalized_values = np.array([(v1 + v2) for _, (v1, v2) in archive])\n    if len(normalized_values) > 0:\n        selected_idx = np.argmax(normalized_values)\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate a neighbor by flipping a subset of items\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n    flip_indices = np.random.choice(num_items, size=min(3, num_items), replace=False)  # Flip up to 3 items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, try to include it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Additional improvement: flip items with high marginal value\n    # Calculate marginal values for excluded items\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        marginal_values = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n        best_excluded_idx = excluded_items[np.argmax(marginal_values)]\n        if current_weight + weight_lst[best_excluded_idx] <= capacity:\n            new_solution[best_excluded_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards non-dominated solutions\n    # Here, we randomly select a solution from the archive, but in practice, you might use a more sophisticated selection\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of bits (with a bias towards items with high value-to-weight ratio)\n    # 2. Ensure feasibility by adjusting flips to stay within capacity\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine ratios for a more balanced selection\n    combined_ratio = ratio1 + ratio2\n\n    # Select items to flip based on combined ratio (higher ratio = higher chance of being flipped)\n    flip_prob = combined_ratio / (np.sum(combined_ratio) + 1e-10)\n    flip_mask = np.random.rand(len(flip_prob)) < flip_prob\n\n    # Determine the number of flips (between 1 and min(10, number of items))\n    num_flips = min(10, np.sum(flip_mask))\n\n    # Randomly select items to flip from the flip_mask\n    flip_indices = np.where(flip_mask)[0]\n    if len(flip_indices) > num_flips:\n        flip_indices = np.random.choice(flip_indices, size=num_flips, replace=False)\n\n    # Apply flips and ensure feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it's in the solution\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add item if it fits within capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5395256477665313,
            5.592698454856873
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards non-dominated solutions\n    # Here, we randomly select a solution from the archive, but in practice, you might use a more sophisticated selection\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of bits (with a bias towards items with high value-to-weight ratio)\n    # 2. Ensure feasibility by adjusting flips to stay within capacity\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine ratios for a more balanced selection\n    combined_ratio = ratio1 + ratio2\n\n    # Select items to flip based on combined ratio (higher ratio = higher chance of being flipped)\n    flip_prob = combined_ratio / (np.sum(combined_ratio) + 1e-10)\n    flip_mask = np.random.rand(len(flip_prob)) < flip_prob\n\n    # Determine the number of flips (between 1 and min(10, number of items))\n    num_flips = min(10, np.sum(flip_mask))\n\n    # Randomly select items to flip from the flip_mask\n    flip_indices = np.where(flip_mask)[0]\n    if len(flip_indices) > num_flips:\n        flip_indices = np.random.choice(flip_indices, size=num_flips, replace=False)\n\n    # Apply flips and ensure feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove item if it's in the solution\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add item if it fits within capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (non-dominated or with high crowding distance)\n    selected_solution, _ = max(archive, key=lambda x: np.sum(x[0]))  # Simplified selection criterion\n    current_solution = selected_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = current_solution.copy()\n    n_items = len(weight_lst)\n\n    # Determine the number of operations (1 to 3)\n    num_operations = random.randint(1, 3)\n\n    for _ in range(num_operations):\n        # Randomly choose between swap, flip, or hybrid operation\n        operation = random.choice(['swap', 'flip', 'hybrid'])\n\n        if operation == 'swap':\n            # Swap two items\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'flip':\n            # Flip a single item\n            i = random.randint(0, n_items - 1)\n            new_solution[i] = 1 - new_solution[i]\n\n        elif operation == 'hybrid':\n            # Hybrid operation: swap + flip\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            k = random.randint(0, n_items - 1)\n            new_solution[k] = 1 - new_solution[k]\n\n        # Ensure feasibility\n        total_weight = np.sum(new_solution * weight_lst)\n        if total_weight > capacity:\n            # Remove the last operation if it violates capacity\n            new_solution = current_solution.copy()\n            break\n\n    # If no feasible solution found, return the original\n    if np.sum(new_solution * weight_lst) > capacity:\n        return current_solution\n\n    return new_solution\n\n",
        "score": [
            -0.22639763231866067,
            7.048101872205734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (non-dominated or with high crowding distance)\n    selected_solution, _ = max(archive, key=lambda x: np.sum(x[0]))  # Simplified selection criterion\n    current_solution = selected_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = current_solution.copy()\n    n_items = len(weight_lst)\n\n    # Determine the number of operations (1 to 3)\n    num_operations = random.randint(1, 3)\n\n    for _ in range(num_operations):\n        # Randomly choose between swap, flip, or hybrid operation\n        operation = random.choice(['swap', 'flip', 'hybrid'])\n\n        if operation == 'swap':\n            # Swap two items\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operation == 'flip':\n            # Flip a single item\n            i = random.randint(0, n_items - 1)\n            new_solution[i] = 1 - new_solution[i]\n\n        elif operation == 'hybrid':\n            # Hybrid operation: swap + flip\n            i, j = random.sample(range(n_items), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            k = random.randint(0, n_items - 1)\n            new_solution[k] = 1 - new_solution[k]\n\n        # Ensure feasibility\n        total_weight = np.sum(new_solution * weight_lst)\n        if total_weight > capacity:\n            # Remove the last operation if it violates capacity\n            new_solution = current_solution.copy()\n            break\n\n    # If no feasible solution found, return the original\n    if np.sum(new_solution * weight_lst) > capacity:\n        return current_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already at the Pareto front)\n    # Here, we select a solution that is not dominated by others in the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly perturb the solution (flip a few bits)\n    num_perturbations = min(3, len(new_solution) // 2)  # Limit the number of perturbations\n    perturb_indices = random.sample(range(len(new_solution)), num_perturbations)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # 2. Greedily improve the solution by adding items with high marginal utility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal utility for each item not in the solution\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Use a combined utility metric (e.g., weighted sum of value1 and value2)\n        utility = (value1_lst[not_in_solution] + value2_lst[not_in_solution]) / (weight_lst[not_in_solution] + 1e-6)\n        sorted_indices = np.argsort(-utility)  # Sort in descending order\n\n        for idx in sorted_indices:\n            item_idx = not_in_solution[idx]\n            if weight_lst[item_idx] <= remaining_capacity:\n                new_solution[item_idx] = 1\n                remaining_capacity -= weight_lst[item_idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If still infeasible, remove items until feasible\n        in_solution = np.where(new_solution == 1)[0]\n        for idx in in_solution:\n            if current_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.33603588777596105,
            1.548451453447342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already at the Pareto front)\n    # Here, we select a solution that is not dominated by others in the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly perturb the solution (flip a few bits)\n    num_perturbations = min(3, len(new_solution) // 2)  # Limit the number of perturbations\n    perturb_indices = random.sample(range(len(new_solution)), num_perturbations)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # 2. Greedily improve the solution by adding items with high marginal utility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal utility for each item not in the solution\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Use a combined utility metric (e.g., weighted sum of value1 and value2)\n        utility = (value1_lst[not_in_solution] + value2_lst[not_in_solution]) / (weight_lst[not_in_solution] + 1e-6)\n        sorted_indices = np.argsort(-utility)  # Sort in descending order\n\n        for idx in sorted_indices:\n            item_idx = not_in_solution[idx]\n            if weight_lst[item_idx] <= remaining_capacity:\n                new_solution[item_idx] = 1\n                remaining_capacity -= weight_lst[item_idx]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If still infeasible, remove items until feasible\n        in_solution = np.where(new_solution == 1)[0]\n        for idx in in_solution:\n            if current_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    # Calculate potential improvement metric (e.g., average marginal value per weight)\n    potential_scores = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Calculate marginal values for items not in the solution\n        marginal_value1 = value1_lst * (1 - sol)\n        marginal_value2 = value2_lst * (1 - sol)\n        # Normalize by weight to get potential improvement per unit weight\n        marginal_per_weight = (marginal_value1 + marginal_value2) / (weight_lst + 1e-6)\n        # Score is the sum of top 5 marginal improvements\n        top_indices = np.argsort(marginal_per_weight)[-5:]\n        score = np.sum(marginal_per_weight[top_indices])\n        potential_scores.append(score)\n\n    # Select solution with highest potential (weighted by randomness for diversity)\n    weights = np.array(potential_scores) + 1e-6  # Small epsilon to avoid zero weights\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Hybrid local search: Random bit flips + greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Random bit flips (exploration)\n    for _ in range(min(3, n_items // 2)):  # Limit flips to prevent excessive changes\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Greedy improvement (exploitation)\n    # Evaluate all possible single-bit changes\n    best_improvement = 0\n    best_idx = -1\n    best_action = None  # 'add' or 'remove'\n\n    for idx in range(n_items):\n        if new_solution[idx] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight >= 0:\n                # Calculate improvement in both objectives\n                improvement = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-6)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_idx = idx\n                    best_action = 'remove'\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate improvement in both objectives\n                improvement = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-6)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_idx = idx\n                    best_action = 'add'\n\n    # Apply the best improvement if found\n    if best_idx != -1 and best_action == 'remove':\n        new_solution[best_idx] = 0\n    elif best_idx != -1 and best_action == 'add':\n        new_solution[best_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.35646144030504856,
            3.5768997073173523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    # Calculate potential improvement metric (e.g., average marginal value per weight)\n    potential_scores = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Calculate marginal values for items not in the solution\n        marginal_value1 = value1_lst * (1 - sol)\n        marginal_value2 = value2_lst * (1 - sol)\n        # Normalize by weight to get potential improvement per unit weight\n        marginal_per_weight = (marginal_value1 + marginal_value2) / (weight_lst + 1e-6)\n        # Score is the sum of top 5 marginal improvements\n        top_indices = np.argsort(marginal_per_weight)[-5:]\n        score = np.sum(marginal_per_weight[top_indices])\n        potential_scores.append(score)\n\n    # Select solution with highest potential (weighted by randomness for diversity)\n    weights = np.array(potential_scores) + 1e-6  # Small epsilon to avoid zero weights\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    # Hybrid local search: Random bit flips + greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Random bit flips (exploration)\n    for _ in range(min(3, n_items // 2)):  # Limit flips to prevent excessive changes\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            # Try to remove item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Greedy improvement (exploitation)\n    # Evaluate all possible single-bit changes\n    best_improvement = 0\n    best_idx = -1\n    best_action = None  # 'add' or 'remove'\n\n    for idx in range(n_items):\n        if new_solution[idx] == 1:\n            # Consider removing this item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight >= 0:\n                # Calculate improvement in both objectives\n                improvement = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-6)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_idx = idx\n                    best_action = 'remove'\n        else:\n            # Consider adding this item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate improvement in both objectives\n                improvement = (value1_lst[idx] + value2_lst[idx]) / (weight_lst[idx] + 1e-6)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_idx = idx\n                    best_action = 'add'\n\n    # Apply the best improvement if found\n    if best_idx != -1 and best_action == 'remove':\n        new_solution[best_idx] = 0\n    elif best_idx != -1 and best_action == 'add':\n        new_solution[best_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 1: Random perturbation - flip a random number of bits (items)\n    num_flips = min(3, len(weight_lst))  # Limit flips to avoid excessive changes\n    flip_indices = random.sample(range(len(weight_lst)), num_flips)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Ensure feasibility after perturbation\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_weight = total_weight - capacity\n        while excess_weight > 0 and np.sum(new_solution) > 0:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            excess_weight = np.sum(weight_lst * new_solution) - capacity\n\n    # Step 2: Greedy improvement - add or remove items to improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Calculate current total weight and values\n        current_weight = np.sum(weight_lst * new_solution)\n        current_value1 = np.sum(value1_lst * new_solution)\n        current_value2 = np.sum(value2_lst * new_solution)\n\n        # Try adding an item not in the solution\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_weight = current_weight + weight_lst[i]\n                new_value1 = current_value1 + value1_lst[i]\n                new_value2 = current_value2 + value2_lst[i]\n\n                # Accept if both values improve\n                if new_value1 > current_value1 and new_value2 > current_value2:\n                    new_solution[i] = 1\n                    current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n                    break\n\n        # Try removing an item in the solution\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                new_value1 = current_value1 - value1_lst[i]\n                new_value2 = current_value2 - value2_lst[i]\n\n                # Accept if both values improve (or at least one if the other is not worse)\n                if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 >= current_value1 and new_value2 > current_value2):\n                    new_solution[i] = 0\n                    current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3929660974438068,
            7.23009666800499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 1: Random perturbation - flip a random number of bits (items)\n    num_flips = min(3, len(weight_lst))  # Limit flips to avoid excessive changes\n    flip_indices = random.sample(range(len(weight_lst)), num_flips)\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Ensure feasibility after perturbation\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_weight = total_weight - capacity\n        while excess_weight > 0 and np.sum(new_solution) > 0:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            excess_weight = np.sum(weight_lst * new_solution) - capacity\n\n    # Step 2: Greedy improvement - add or remove items to improve both objectives\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Calculate current total weight and values\n        current_weight = np.sum(weight_lst * new_solution)\n        current_value1 = np.sum(value1_lst * new_solution)\n        current_value2 = np.sum(value2_lst * new_solution)\n\n        # Try adding an item not in the solution\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_weight = current_weight + weight_lst[i]\n                new_value1 = current_value1 + value1_lst[i]\n                new_value2 = current_value2 + value2_lst[i]\n\n                # Accept if both values improve\n                if new_value1 > current_value1 and new_value2 > current_value2:\n                    new_solution[i] = 1\n                    current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n                    break\n\n        # Try removing an item in the solution\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                new_weight = current_weight - weight_lst[i]\n                new_value1 = current_value1 - value1_lst[i]\n                new_value2 = current_value2 - value2_lst[i]\n\n                # Accept if both values improve (or at least one if the other is not worse)\n                if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                   (new_value1 >= current_value1 and new_value2 > current_value2):\n                    new_solution[i] = 0\n                    current_weight, current_value1, current_value2 = new_weight, new_value1, new_value2\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items that can be flipped (either added or removed) while maintaining feasibility\n    removable = np.where(new_solution == 1)[0]\n    addable = np.where(new_solution == 0)[0]\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (perturbation)\n    # 2. Apply value-to-weight ratio analysis to prioritize high-value, low-weight items\n    flip_candidates = np.concatenate((removable, addable))\n    if len(flip_candidates) > 0:\n        # Calculate value-to-weight ratios for both objectives\n        ratio1 = value1_lst[flip_candidates] / (weight_lst[flip_candidates] + 1e-10)\n        ratio2 = value2_lst[flip_candidates] / (weight_lst[flip_candidates] + 1e-10)\n        combined_ratio = 0.5 * ratio1 + 0.5 * ratio2  # Equal weighting for both objectives\n\n        # Select top candidates based on combined ratio\n        top_k = min(3, len(flip_candidates))  # Consider top 3 items\n        top_indices = np.argsort(combined_ratio)[-top_k:]\n\n        for idx in top_indices:\n            candidate_item = flip_candidates[idx]\n            if new_solution[candidate_item] == 1:  # Item is currently in the knapsack\n                if current_weight - weight_lst[candidate_item] <= capacity:\n                    new_solution[candidate_item] = 0\n                    current_weight -= weight_lst[candidate_item]\n            else:  # Item is not in the knapsack\n                if current_weight + weight_lst[candidate_item] <= capacity:\n                    new_solution[candidate_item] = 1\n                    current_weight += weight_lst[candidate_item]\n\n    return new_solution\n\n",
        "score": [
            -0.8326718432696549,
            5.376948863267899
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items that can be flipped (either added or removed) while maintaining feasibility\n    removable = np.where(new_solution == 1)[0]\n    addable = np.where(new_solution == 0)[0]\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (perturbation)\n    # 2. Apply value-to-weight ratio analysis to prioritize high-value, low-weight items\n    flip_candidates = np.concatenate((removable, addable))\n    if len(flip_candidates) > 0:\n        # Calculate value-to-weight ratios for both objectives\n        ratio1 = value1_lst[flip_candidates] / (weight_lst[flip_candidates] + 1e-10)\n        ratio2 = value2_lst[flip_candidates] / (weight_lst[flip_candidates] + 1e-10)\n        combined_ratio = 0.5 * ratio1 + 0.5 * ratio2  # Equal weighting for both objectives\n\n        # Select top candidates based on combined ratio\n        top_k = min(3, len(flip_candidates))  # Consider top 3 items\n        top_indices = np.argsort(combined_ratio)[-top_k:]\n\n        for idx in top_indices:\n            candidate_item = flip_candidates[idx]\n            if new_solution[candidate_item] == 1:  # Item is currently in the knapsack\n                if current_weight - weight_lst[candidate_item] <= capacity:\n                    new_solution[candidate_item] = 0\n                    current_weight -= weight_lst[candidate_item]\n            else:  # Item is not in the knapsack\n                if current_weight + weight_lst[candidate_item] <= capacity:\n                    new_solution[candidate_item] = 1\n                    current_weight += weight_lst[candidate_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with potential for improvement (e.g., not already optimal)\n    candidates = [sol for sol, _ in archive if np.sum(weight_lst * sol) < capacity * 0.9]  # Solutions with room to improve\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if none have room\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of random flip and greedy improvement\n    n_items = len(base_solution)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Randomly flip a subset of items (local perturbation)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after flip\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(excess_items) > 0:\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst * new_solution)\n    for item in remaining_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves both objectives\n            new_v1 = np.sum(value1_lst * new_solution) + value1_lst[item]\n            new_v2 = np.sum(value2_lst * new_solution) + value2_lst[item]\n            current_v1 = np.sum(value1_lst * new_solution)\n            current_v2 = np.sum(value2_lst * new_solution)\n\n            if (new_v1 > current_v1 and new_v2 > current_v2) or \\\n               (new_v1 >= current_v1 and new_v2 >= current_v2 and random.random() > 0.5):  # Random tie-breaker\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4511082868685006,
            2.41641366481781
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with potential for improvement (e.g., not already optimal)\n    candidates = [sol for sol, _ in archive if np.sum(weight_lst * sol) < capacity * 0.9]  # Solutions with room to improve\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if none have room\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of random flip and greedy improvement\n    n_items = len(base_solution)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Randomly flip a subset of items (local perturbation)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after flip\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(excess_items) > 0:\n            remove_idx = random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst * new_solution)\n    for item in remaining_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves both objectives\n            new_v1 = np.sum(value1_lst * new_solution) + value1_lst[item]\n            new_v2 = np.sum(value2_lst * new_solution) + value2_lst[item]\n            current_v1 = np.sum(value1_lst * new_solution)\n            current_v2 = np.sum(value2_lst * new_solution)\n\n            if (new_v1 > current_v1 and new_v2 > current_v2) or \\\n               (new_v1 >= current_v1 and new_v2 >= current_v2 and random.random() > 0.5):  # Random tie-breaker\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with a bias towards those with higher total value\n    weights = np.array([sum(w * s for w, s in zip(weight_lst, sol[0])) for sol in archive])\n    values = np.array([sum(v1 * s for v1, s in zip(value1_lst, sol[0])) + sum(v2 * s for v2, s in zip(value2_lst, sol[0])) for sol in archive])\n    scores = values / (weights + 1e-6)  # Avoid division by zero\n\n    # Select top 20% solutions by score, then pick one randomly\n    top_indices = np.argsort(scores)[-max(1, len(scores) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip bits with high potential for improvement\n    # Step 1: Random bit flips (exploration)\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy improvement (exploitation)\n    # Calculate marginal gains for each item\n    current_weight = sum(w * s for w, s in zip(weight_lst, new_solution))\n    marginal_gains = []\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Calculate marginal loss if removed\n            marginal_gain = -(value1_lst[i] + value2_lst[i])\n        else:\n            # Calculate marginal gain if added (only if feasible)\n            if current_weight + weight_lst[i] <= capacity:\n                marginal_gain = value1_lst[i] + value2_lst[i]\n            else:\n                marginal_gain = -float('inf')\n\n        marginal_gains.append((marginal_gain, i))\n\n    # Sort by marginal gain and apply best improvements\n    marginal_gains.sort(reverse=True, key=lambda x: x[0])\n    for gain, idx in marginal_gains[:3]:  # Apply top 3 improvements\n        if gain > 0:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility (in case greedy steps violated capacity)\n    current_weight = sum(w * s for w, s in zip(weight_lst, new_solution))\n    if current_weight > capacity:\n        # Remove items until feasible\n        items = [(i, weight_lst[i], value1_lst[i] + value2_lst[i]) for i in range(len(new_solution)) if new_solution[i] == 1]\n        items.sort(key=lambda x: x[2]/x[1], reverse=True)  # Sort by value-to-weight ratio\n\n        for i, w, _ in items:\n            if current_weight <= capacity:\n                break\n            new_solution[i] = 0\n            current_weight -= w\n\n    return new_solution\n\n",
        "score": [
            -0.33389548470117536,
            10.231304556131363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with a bias towards those with higher total value\n    weights = np.array([sum(w * s for w, s in zip(weight_lst, sol[0])) for sol in archive])\n    values = np.array([sum(v1 * s for v1, s in zip(value1_lst, sol[0])) + sum(v2 * s for v2, s in zip(value2_lst, sol[0])) for sol in archive])\n    scores = values / (weights + 1e-6)  # Avoid division by zero\n\n    # Select top 20% solutions by score, then pick one randomly\n    top_indices = np.argsort(scores)[-max(1, len(scores) // 5):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip bits with high potential for improvement\n    # Step 1: Random bit flips (exploration)\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy improvement (exploitation)\n    # Calculate marginal gains for each item\n    current_weight = sum(w * s for w, s in zip(weight_lst, new_solution))\n    marginal_gains = []\n\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Calculate marginal loss if removed\n            marginal_gain = -(value1_lst[i] + value2_lst[i])\n        else:\n            # Calculate marginal gain if added (only if feasible)\n            if current_weight + weight_lst[i] <= capacity:\n                marginal_gain = value1_lst[i] + value2_lst[i]\n            else:\n                marginal_gain = -float('inf')\n\n        marginal_gains.append((marginal_gain, i))\n\n    # Sort by marginal gain and apply best improvements\n    marginal_gains.sort(reverse=True, key=lambda x: x[0])\n    for gain, idx in marginal_gains[:3]:  # Apply top 3 improvements\n        if gain > 0:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility (in case greedy steps violated capacity)\n    current_weight = sum(w * s for w, s in zip(weight_lst, new_solution))\n    if current_weight > capacity:\n        # Remove items until feasible\n        items = [(i, weight_lst[i], value1_lst[i] + value2_lst[i]) for i in range(len(new_solution)) if new_solution[i] == 1]\n        items.sort(key=lambda x: x[2]/x[1], reverse=True)  # Sort by value-to-weight ratio\n\n        for i, w, _ in items:\n            if current_weight <= capacity:\n                break\n            new_solution[i] = 0\n            current_weight -= w\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions that are not on the Pareto front but have high potential for improvement\n    # Here, we select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search strategy\n    # Strategy: Randomly select a subset of items and flip their inclusion status,\n    # then perform a greedy improvement step to ensure feasibility and quality\n    n_items = len(weight_lst)\n    subset_size = min(5, n_items)  # Limit the subset size for efficiency\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    # Flip the selected subset\n    for idx in subset_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility and perform greedy improvement\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, remove items until feasible\n        items_in_solution = np.where(new_solution == 1)[0]\n        random.shuffle(items_in_solution)\n        for idx in items_in_solution:\n            if total_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    # Step 3: Perform a greedy improvement step to maximize both objectives\n    # Add items that improve both objectives without exceeding capacity\n    items_not_in_solution = np.where(new_solution == 0)[0]\n    for idx in items_not_in_solution:\n        if weight_lst[idx] + total_weight <= capacity:\n            new_value1 = value1_lst[idx]\n            new_value2 = value2_lst[idx]\n            # Check if adding this item improves both objectives\n            if new_value1 > 0 and new_value2 > 0:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.376279414181514,
            1.651360273361206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions that are not on the Pareto front but have high potential for improvement\n    # Here, we select a solution with high diversity and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search strategy\n    # Strategy: Randomly select a subset of items and flip their inclusion status,\n    # then perform a greedy improvement step to ensure feasibility and quality\n    n_items = len(weight_lst)\n    subset_size = min(5, n_items)  # Limit the subset size for efficiency\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    # Flip the selected subset\n    for idx in subset_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility and perform greedy improvement\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, remove items until feasible\n        items_in_solution = np.where(new_solution == 1)[0]\n        random.shuffle(items_in_solution)\n        for idx in items_in_solution:\n            if total_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    # Step 3: Perform a greedy improvement step to maximize both objectives\n    # Add items that improve both objectives without exceeding capacity\n    items_not_in_solution = np.where(new_solution == 0)[0]\n    for idx in items_not_in_solution:\n        if weight_lst[idx] + total_weight <= capacity:\n            new_value1 = value1_lst[idx]\n            new_value2 = value2_lst[idx]\n            # Check if adding this item improves both objectives\n            if new_value1 > 0 and new_value2 > 0:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (non-dominated solutions come first)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] * x[1][1], -x[1][0], -x[1][1]))\n        # Higher probability for non-dominated solutions\n        probabilities = np.linspace(1.0, 0.1, len(archive_sorted))\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive_sorted), p=probabilities)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Randomly flip a subset of items to explore neighborhood\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Greedily add items that improve both objectives\n    for idx in range(len(new_solution)):\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx] <= capacity):\n            # Check if adding the item improves both objectives\n            if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4418457807436493,
            2.744610697031021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (non-dominated solutions come first)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] * x[1][1], -x[1][0], -x[1][1]))\n        # Higher probability for non-dominated solutions\n        probabilities = np.linspace(1.0, 0.1, len(archive_sorted))\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive_sorted), p=probabilities)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Randomly flip a subset of items to explore neighborhood\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Greedily add items that improve both objectives\n    for idx in range(len(new_solution)):\n        if new_solution[idx] == 0 and (current_weight + weight_lst[idx] <= capacity):\n            # Check if adding the item improves both objectives\n            if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if np.sum(weight_lst * sol) < capacity]\n    if not candidates:\n        return archive[0][0].copy()  # Fallback if no feasible candidates\n\n    # Intelligent selection: prioritize solutions with high value-to-weight ratio variance\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n    scores = [np.std(sol * (value_to_weight1 + value_to_weight2)) for sol in candidates]\n    selected_idx = np.argmax(scores)\n    base_solution = candidates[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly flip bits with a bias towards items with high value-to-weight ratio\n    flip_prob = 0.3  # Probability of flipping a bit\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 1:\n                # Remove item if it's in the solution\n                new_solution[i] = 0\n            else:\n                # Add item if it fits within capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Additional refinement: flip the least valuable item if over capacity\n    if current_weight > capacity:\n        # Find items to remove based on marginal value contribution\n        marginal_value = (value1_lst + value2_lst) * new_solution\n        while current_weight > capacity:\n            least_valuable_idx = np.argmin(marginal_value * (new_solution > 0))\n            if new_solution[least_valuable_idx] == 1:\n                new_solution[least_valuable_idx] = 0\n                current_weight -= weight_lst[least_valuable_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9035760204966232,
            6.910187512636185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = [sol for sol, _ in archive if np.sum(weight_lst * sol) < capacity]\n    if not candidates:\n        return archive[0][0].copy()  # Fallback if no feasible candidates\n\n    # Intelligent selection: prioritize solutions with high value-to-weight ratio variance\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n    scores = [np.std(sol * (value_to_weight1 + value_to_weight2)) for sol in candidates]\n    selected_idx = np.argmax(scores)\n    base_solution = candidates[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly flip bits with a bias towards items with high value-to-weight ratio\n    flip_prob = 0.3  # Probability of flipping a bit\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 1:\n                # Remove item if it's in the solution\n                new_solution[i] = 0\n            else:\n                # Add item if it fits within capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Additional refinement: flip the least valuable item if over capacity\n    if current_weight > capacity:\n        # Find items to remove based on marginal value contribution\n        marginal_value = (value1_lst + value2_lst) * new_solution\n        while current_weight > capacity:\n            least_valuable_idx = np.argmin(marginal_value * (new_solution > 0))\n            if new_solution[least_valuable_idx] == 1:\n                new_solution[least_valuable_idx] = 0\n                current_weight -= weight_lst[least_valuable_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: flip a random bit if feasible, otherwise perform a swap\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Random flip\n        flip_idx = np.random.randint(0, len(new_solution))\n        temp_solution = new_solution.copy()\n        temp_solution[flip_idx] = 1 - temp_solution[flip_idx]\n\n        # Check feasibility\n        temp_weight = current_weight + (weight_lst[flip_idx] if temp_solution[flip_idx] else -weight_lst[flip_idx])\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            break\n\n    # If flip failed, perform a swap between items from different objectives\n    else:\n        # Identify items with high marginal contribution for each objective\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n        # Find items not in the current solution with high marginal value\n        not_in_solution = np.where(new_solution == 0)[0]\n        if len(not_in_solution) > 0:\n            # Select items with top marginal value for each objective\n            top_value1_items = np.argsort(-marginal_value1[not_in_solution])[:min(5, len(not_in_solution))]\n            top_value2_items = np.argsort(-marginal_value2[not_in_solution])[:min(5, len(not_in_solution))]\n\n            # Randomly select one item from each top group\n            if len(top_value1_items) > 0 and len(top_value2_items) > 0:\n                item1 = np.random.choice(top_value1_items)\n                item2 = np.random.choice(top_value2_items)\n\n                # Swap the two items if feasible\n                temp_solution = new_solution.copy()\n                temp_solution[not_in_solution[item1]] = 1\n                temp_solution[not_in_solution[item2]] = 1\n\n                # Remove one item if necessary to maintain feasibility\n                if np.sum(weight_lst * temp_solution) > capacity:\n                    # Remove the item with the lowest marginal value\n                    in_solution = np.where(temp_solution == 1)[0]\n                    remove_item = np.argmin(marginal_value1[in_solution] + marginal_value2[in_solution])\n                    temp_solution[in_solution[remove_item]] = 0\n\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.3961552638955036,
            1.0084883570671082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on objective diversity and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: flip a random bit if feasible, otherwise perform a swap\n    for _ in range(10):  # Limit the number of attempts to avoid excessive computation\n        # Random flip\n        flip_idx = np.random.randint(0, len(new_solution))\n        temp_solution = new_solution.copy()\n        temp_solution[flip_idx] = 1 - temp_solution[flip_idx]\n\n        # Check feasibility\n        temp_weight = current_weight + (weight_lst[flip_idx] if temp_solution[flip_idx] else -weight_lst[flip_idx])\n        if temp_weight <= capacity:\n            new_solution = temp_solution\n            break\n\n    # If flip failed, perform a swap between items from different objectives\n    else:\n        # Identify items with high marginal contribution for each objective\n        marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n        # Find items not in the current solution with high marginal value\n        not_in_solution = np.where(new_solution == 0)[0]\n        if len(not_in_solution) > 0:\n            # Select items with top marginal value for each objective\n            top_value1_items = np.argsort(-marginal_value1[not_in_solution])[:min(5, len(not_in_solution))]\n            top_value2_items = np.argsort(-marginal_value2[not_in_solution])[:min(5, len(not_in_solution))]\n\n            # Randomly select one item from each top group\n            if len(top_value1_items) > 0 and len(top_value2_items) > 0:\n                item1 = np.random.choice(top_value1_items)\n                item2 = np.random.choice(top_value2_items)\n\n                # Swap the two items if feasible\n                temp_solution = new_solution.copy()\n                temp_solution[not_in_solution[item1]] = 1\n                temp_solution[not_in_solution[item2]] = 1\n\n                # Remove one item if necessary to maintain feasibility\n                if np.sum(weight_lst * temp_solution) > capacity:\n                    # Remove the item with the lowest marginal value\n                    in_solution = np.where(temp_solution == 1)[0]\n                    remove_item = np.argmin(marginal_value1[in_solution] + marginal_value2[in_solution])\n                    temp_solution[in_solution[remove_item]] = 0\n\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those that are not fully packed\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Random perturbation: flip a subset of items\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility: if the perturbation makes the solution infeasible, undo it\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Undo the flips that caused infeasibility\n        for idx in flip_indices:\n            new_solution[idx] = base_solution[idx]\n\n    # Greedy improvement: try to add items that improve both objectives\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    candidate_indices = np.where(new_solution == 0)[0]\n\n    for idx in candidate_indices:\n        if weight_lst[idx] <= remaining_weight:\n            # Check if adding this item improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    # If no improvement possible, try removing items to free up space\n    if remaining_weight < 0:\n        # Remove items with the least combined value\n        included_indices = np.where(new_solution == 1)[0]\n        combined_values = value1_lst[included_indices] + value2_lst[included_indices]\n        sorted_indices = included_indices[np.argsort(combined_values)]\n        for idx in sorted_indices:\n            if remaining_weight >= 0:\n                break\n            new_solution[idx] = 0\n            remaining_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3821615459697154,
            2.942645490169525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those that are not fully packed\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Random perturbation: flip a subset of items\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility: if the perturbation makes the solution infeasible, undo it\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Undo the flips that caused infeasibility\n        for idx in flip_indices:\n            new_solution[idx] = base_solution[idx]\n\n    # Greedy improvement: try to add items that improve both objectives\n    remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n    candidate_indices = np.where(new_solution == 0)[0]\n\n    for idx in candidate_indices:\n        if weight_lst[idx] <= remaining_weight:\n            # Check if adding this item improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    # If no improvement possible, try removing items to free up space\n    if remaining_weight < 0:\n        # Remove items with the least combined value\n        included_indices = np.where(new_solution == 1)[0]\n        combined_values = value1_lst[included_indices] + value2_lst[included_indices]\n        sorted_indices = included_indices[np.argsort(combined_values)]\n        for idx in sorted_indices:\n            if remaining_weight >= 0:\n                break\n            new_solution[idx] = 0\n            remaining_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the centroid of the objective space\n    centroid_value1 = np.mean([obj[0] for _, obj in archive])\n    centroid_value2 = np.mean([obj[1] for _, obj in archive])\n\n    # Select solutions that are within a certain distance from the centroid\n    # and have a good balance (ratio of value1 to value2 is close to 1)\n    candidates = []\n    for sol, obj in archive:\n        dist_to_centroid = np.sqrt((obj[0] - centroid_value1)**2 + (obj[1] - centroid_value2)**2)\n        balance_ratio = obj[0] / (obj[1] + 1e-10)  # Avoid division by zero\n        candidates.append((sol, dist_to_centroid, balance_ratio))\n\n    # Sort candidates by distance to centroid and balance ratio\n    candidates.sort(key=lambda x: (x[1], abs(x[2] - 1.0)))\n\n    # Select the top 30% of candidates\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    if not top_candidates:\n        top_candidates = candidates\n\n    # Randomly select one from the top candidates\n    selected_sol = random.choice(top_candidates)[0]\n\n    # Step 2: Apply hybrid local search to generate a neighbor\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1->0 or 0->1)\n    # 2. Apply a greedy improvement step to ensure feasibility and potentially better objectives\n    # 3. If the flip makes the solution infeasible, apply a repair mechanism\n\n    # Random flip of a subset of items\n    flip_mask = np.random.randint(0, 2, size=n_items)\n    temp_solution = new_solution ^ flip_mask\n\n    # Check feasibility\n    total_weight = np.sum(weight_lst * temp_solution)\n    if total_weight <= capacity:\n        new_solution = temp_solution\n    else:\n        # Repair mechanism: remove items until feasible\n        # Sort items by their marginal contribution to the objectives (value1/weight + value2/weight)\n        item_scores = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n        sorted_indices = np.argsort(item_scores)\n        excess_weight = total_weight - capacity\n\n        # Remove items with lowest marginal contribution until feasible\n        for idx in sorted_indices:\n            if excess_weight <= 0:\n                break\n            if temp_solution[idx] == 1:\n                temp_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n        new_solution = temp_solution\n\n    # Greedy improvement step: try to add items that improve both objectives\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        # Calculate potential improvement for each item\n        potential_improvement = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n        candidate_items = np.where(new_solution == 0)[0]\n        sorted_candidates = sorted(candidate_items, key=lambda x: -potential_improvement[x])\n\n        for item in sorted_candidates:\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3948819176321602,
            2.6454045474529266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the centroid of the objective space\n    centroid_value1 = np.mean([obj[0] for _, obj in archive])\n    centroid_value2 = np.mean([obj[1] for _, obj in archive])\n\n    # Select solutions that are within a certain distance from the centroid\n    # and have a good balance (ratio of value1 to value2 is close to 1)\n    candidates = []\n    for sol, obj in archive:\n        dist_to_centroid = np.sqrt((obj[0] - centroid_value1)**2 + (obj[1] - centroid_value2)**2)\n        balance_ratio = obj[0] / (obj[1] + 1e-10)  # Avoid division by zero\n        candidates.append((sol, dist_to_centroid, balance_ratio))\n\n    # Sort candidates by distance to centroid and balance ratio\n    candidates.sort(key=lambda x: (x[1], abs(x[2] - 1.0)))\n\n    # Select the top 30% of candidates\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    if not top_candidates:\n        top_candidates = candidates\n\n    # Randomly select one from the top candidates\n    selected_sol = random.choice(top_candidates)[0]\n\n    # Step 2: Apply hybrid local search to generate a neighbor\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1->0 or 0->1)\n    # 2. Apply a greedy improvement step to ensure feasibility and potentially better objectives\n    # 3. If the flip makes the solution infeasible, apply a repair mechanism\n\n    # Random flip of a subset of items\n    flip_mask = np.random.randint(0, 2, size=n_items)\n    temp_solution = new_solution ^ flip_mask\n\n    # Check feasibility\n    total_weight = np.sum(weight_lst * temp_solution)\n    if total_weight <= capacity:\n        new_solution = temp_solution\n    else:\n        # Repair mechanism: remove items until feasible\n        # Sort items by their marginal contribution to the objectives (value1/weight + value2/weight)\n        item_scores = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n        sorted_indices = np.argsort(item_scores)\n        excess_weight = total_weight - capacity\n\n        # Remove items with lowest marginal contribution until feasible\n        for idx in sorted_indices:\n            if excess_weight <= 0:\n                break\n            if temp_solution[idx] == 1:\n                temp_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n\n        new_solution = temp_solution\n\n    # Greedy improvement step: try to add items that improve both objectives\n    remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n    if remaining_capacity > 0:\n        # Calculate potential improvement for each item\n        potential_improvement = (value1_lst / (weight_lst + 1e-10)) + (value2_lst / (weight_lst + 1e-10))\n        candidate_items = np.where(new_solution == 0)[0]\n        sorted_candidates = sorted(candidate_items, key=lambda x: -potential_improvement[x])\n\n        for item in sorted_candidates:\n            if weight_lst[item] <= remaining_capacity:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.max(total_values) == 0:\n        probabilities = np.ones(len(archive)) / len(archive)\n    else:\n        probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (with bias toward lower value/higher weight items)\n    flip_prob = 0.3  # Probability of flipping each item\n    item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_bias = 1 / (item_scores + 1e-6)  # Higher bias for lower value/higher weight items\n    flip_mask = (np.random.rand(len(weight_lst)) < flip_prob) & (np.random.rand(len(weight_lst)) < flip_bias)\n\n    # 2. Flip the selected items (with feasibility check)\n    for i in np.where(flip_mask)[0]:\n        if new_solution[i] == 1:\n            # If item is currently included, try to remove it\n            if np.sum(new_solution * weight_lst) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            # If item is currently excluded, try to add it\n            if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # 3. If no changes were made, perform a more aggressive local search\n    if np.array_equal(new_solution, base_solution):\n        # Find items with negative marginal contribution to at least one objective\n        current_weight = np.sum(new_solution * weight_lst)\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                # Try to remove item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                # Try to add item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.37593957884107987,
            3.0212709605693817
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.max(total_values) == 0:\n        probabilities = np.ones(len(archive)) / len(archive)\n    else:\n        probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (with bias toward lower value/higher weight items)\n    flip_prob = 0.3  # Probability of flipping each item\n    item_scores = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    flip_bias = 1 / (item_scores + 1e-6)  # Higher bias for lower value/higher weight items\n    flip_mask = (np.random.rand(len(weight_lst)) < flip_prob) & (np.random.rand(len(weight_lst)) < flip_bias)\n\n    # 2. Flip the selected items (with feasibility check)\n    for i in np.where(flip_mask)[0]:\n        if new_solution[i] == 1:\n            # If item is currently included, try to remove it\n            if np.sum(new_solution * weight_lst) - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n        else:\n            # If item is currently excluded, try to add it\n            if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # 3. If no changes were made, perform a more aggressive local search\n    if np.array_equal(new_solution, base_solution):\n        # Find items with negative marginal contribution to at least one objective\n        current_weight = np.sum(new_solution * weight_lst)\n        for i in range(len(weight_lst)):\n            if new_solution[i] == 1:\n                # Try to remove item\n                new_weight = current_weight - weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 0\n                    current_weight = new_weight\n            else:\n                # Try to add item\n                new_weight = current_weight + weight_lst[i]\n                if new_weight <= capacity:\n                    new_solution[i] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n    current_value1, current_value2 = sorted_archive[0][1]\n\n    # Generate a neighbor by flipping items with high marginal value-to-weight ratios\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine gains using a weighted sum to balance both objectives\n    combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n\n    # Identify items to flip (either add or remove)\n    candidate_indices = np.where(new_solution == 0)[0]  # Consider adding items not in the solution\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(new_solution == 1)[0]  # Fallback: consider removing items\n\n    # Sort candidates by combined gain (highest first)\n    sorted_candidates = sorted(candidate_indices, key=lambda i: combined_gain[i], reverse=True)\n\n    # Try adding the highest-gain item\n    for idx in sorted_candidates:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            break\n\n    # If no addition was possible, try removing the lowest-gain item\n    if np.all(new_solution == selected_solution):\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            sorted_removals = sorted(remove_candidates, key=lambda i: combined_gain[i])\n            for idx in sorted_removals:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.80775698599286,
            1.89833664894104
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n    current_value1, current_value2 = sorted_archive[0][1]\n\n    # Generate a neighbor by flipping items with high marginal value-to-weight ratios\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine gains using a weighted sum to balance both objectives\n    combined_gain = 0.5 * marginal_gain1 + 0.5 * marginal_gain2\n\n    # Identify items to flip (either add or remove)\n    candidate_indices = np.where(new_solution == 0)[0]  # Consider adding items not in the solution\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(new_solution == 1)[0]  # Fallback: consider removing items\n\n    # Sort candidates by combined gain (highest first)\n    sorted_candidates = sorted(candidate_indices, key=lambda i: combined_gain[i], reverse=True)\n\n    # Try adding the highest-gain item\n    for idx in sorted_candidates:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            break\n\n    # If no addition was possible, try removing the lowest-gain item\n    if np.all(new_solution == selected_solution):\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            sorted_removals = sorted(remove_candidates, key=lambda i: combined_gain[i])\n            for idx in sorted_removals:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not all items are included)\n    candidates = [sol for sol, _ in archive if np.sum(sol) < len(sol)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    # Intelligently select a candidate: prioritize solutions with lower total weight or higher potential\n    selected_idx = random.choices(\n        range(len(candidates)),\n        weights=[1 / (np.sum(weight_lst * sol) + 1) for sol in candidates],\n        k=1\n    )[0]\n    base_solution = candidates[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid strategy: random flip + greedy improvement\n    new_solution = base_solution.copy()\n\n    # Random flip: flip a random subset of items\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing items that exceed capacity\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break  # No items to remove, solution is infeasible\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Greedy improvement: add items that improve at least one objective without violating capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            # Check if adding item i improves at least one objective\n            if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.38288966999689344,
            3.0441131591796875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not all items are included)\n    candidates = [sol for sol, _ in archive if np.sum(sol) < len(sol)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    # Intelligently select a candidate: prioritize solutions with lower total weight or higher potential\n    selected_idx = random.choices(\n        range(len(candidates)),\n        weights=[1 / (np.sum(weight_lst * sol) + 1) for sol in candidates],\n        k=1\n    )[0]\n    base_solution = candidates[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid strategy: random flip + greedy improvement\n    new_solution = base_solution.copy()\n\n    # Random flip: flip a random subset of items\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing items that exceed capacity\n    while np.sum(weight_lst * new_solution) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break  # No items to remove, solution is infeasible\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    # Greedy improvement: add items that improve at least one objective without violating capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            # Check if adding item i improves at least one objective\n            if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate the crowding distance for each solution to identify less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for obj_idx in range(2):\n        sorted_indices = np.argsort([obj[obj_idx] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(sorted_indices) - 1):\n            crowding_distances[sorted_indices[i]] += (archive_objectives[sorted_indices[i+1]][obj_idx] - archive_objectives[sorted_indices[i-1]][obj_idx])\n\n    # Select a solution with low crowding distance (less explored region)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: random swaps + greedy selection\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Greedily improve the solution by adding the most valuable items\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n\n    for idx in remaining_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Evaluate the impact on both objectives\n            value_ratio1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n            value_ratio2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n\n            # Add if it improves at least one objective\n            if value_ratio1 > 0 or value_ratio2 > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3087895439839631,
            2.6193263232707977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate the crowding distance for each solution to identify less crowded regions\n    crowding_distances = np.zeros(len(archive))\n    for obj_idx in range(2):\n        sorted_indices = np.argsort([obj[obj_idx] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for i in range(1, len(sorted_indices) - 1):\n            crowding_distances[sorted_indices[i]] += (archive_objectives[sorted_indices[i+1]][obj_idx] - archive_objectives[sorted_indices[i-1]][obj_idx])\n\n    # Select a solution with low crowding distance (less explored region)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: random swaps + greedy selection\n    n_items = len(base_solution)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Randomly select a subset of items to flip\n    flip_indices = np.random.choice(n_items, size=min(5, n_items), replace=False)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = new_weight\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Greedily improve the solution by adding the most valuable items\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n\n    for idx in remaining_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Evaluate the impact on both objectives\n            value_ratio1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n            value_ratio2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n\n            # Add if it improves at least one objective\n            if value_ratio1 > 0 or value_ratio2 > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    # Prioritize solutions that are not extreme in either objective\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([obj for _, obj in archive])\n\n    # Calculate distances from the Pareto front to identify less explored regions\n    distances = np.linalg.norm(archive_objectives - np.min(archive_objectives, axis=0), axis=1)\n    selected_idx = np.argmax(distances)  # Select the solution farthest from the current front\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Randomly flip a subset of items (with bias towards less valuable items)\n    flip_indices = np.where(new_solution == 1)[0]\n    if len(flip_indices) > 0:\n        # Calculate value-to-weight ratios for included items\n        included_weights = weight_lst[flip_indices]\n        included_values = value1_lst[flip_indices] + value2_lst[flip_indices]\n        ratios = included_values / (included_weights + 1e-6)  # Avoid division by zero\n\n        # Identify items with the lowest ratios (potential candidates for removal)\n        low_ratio_indices = flip_indices[np.argsort(ratios)[:max(1, len(flip_indices) // 3)]]\n\n        # Randomly flip some of these low-ratio items\n        flip_mask = np.random.choice([True, False], size=len(low_ratio_indices), p=[0.7, 0.3])\n        new_solution[low_ratio_indices[flip_mask]] = 0\n\n    # Strategy 2: Add items not in the solution if they fit\n    excluded_indices = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate remaining capacity\n    remaining_capacity = capacity - current_weight\n\n    # Filter items that can be added without exceeding capacity\n    potential_additions = excluded_indices[weight_lst[excluded_indices] <= remaining_capacity]\n\n    if len(potential_additions) > 0:\n        # Select items with highest combined value (value1 + value2)\n        combined_values = value1_lst[potential_additions] + value2_lst[potential_additions]\n        top_additions = potential_additions[np.argsort(combined_values)[-max(1, len(potential_additions) // 2):]]\n\n        # Randomly add some of these top items\n        add_mask = np.random.choice([True, False], size=len(top_additions), p=[0.5, 0.5])\n        new_solution[top_additions[add_mask]] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, remove items with lowest value-to-weight ratio until feasible\n        while total_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            included_weights = weight_lst[included_indices]\n            included_values = value1_lst[included_indices] + value2_lst[included_indices]\n            ratios = included_values / (included_weights + 1e-6)\n            remove_idx = included_indices[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.8685983084367881,
            1.7011485397815704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    # Prioritize solutions that are not extreme in either objective\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = np.array([obj for _, obj in archive])\n\n    # Calculate distances from the Pareto front to identify less explored regions\n    distances = np.linalg.norm(archive_objectives - np.min(archive_objectives, axis=0), axis=1)\n    selected_idx = np.argmax(distances)  # Select the solution farthest from the current front\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Strategy 1: Randomly flip a subset of items (with bias towards less valuable items)\n    flip_indices = np.where(new_solution == 1)[0]\n    if len(flip_indices) > 0:\n        # Calculate value-to-weight ratios for included items\n        included_weights = weight_lst[flip_indices]\n        included_values = value1_lst[flip_indices] + value2_lst[flip_indices]\n        ratios = included_values / (included_weights + 1e-6)  # Avoid division by zero\n\n        # Identify items with the lowest ratios (potential candidates for removal)\n        low_ratio_indices = flip_indices[np.argsort(ratios)[:max(1, len(flip_indices) // 3)]]\n\n        # Randomly flip some of these low-ratio items\n        flip_mask = np.random.choice([True, False], size=len(low_ratio_indices), p=[0.7, 0.3])\n        new_solution[low_ratio_indices[flip_mask]] = 0\n\n    # Strategy 2: Add items not in the solution if they fit\n    excluded_indices = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Calculate remaining capacity\n    remaining_capacity = capacity - current_weight\n\n    # Filter items that can be added without exceeding capacity\n    potential_additions = excluded_indices[weight_lst[excluded_indices] <= remaining_capacity]\n\n    if len(potential_additions) > 0:\n        # Select items with highest combined value (value1 + value2)\n        combined_values = value1_lst[potential_additions] + value2_lst[potential_additions]\n        top_additions = potential_additions[np.argsort(combined_values)[-max(1, len(potential_additions) // 2):]]\n\n        # Randomly add some of these top items\n        add_mask = np.random.choice([True, False], size=len(top_additions), p=[0.5, 0.5])\n        new_solution[top_additions[add_mask]] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, remove items with lowest value-to-weight ratio until feasible\n        while total_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            included_weights = weight_lst[included_indices]\n            included_values = value1_lst[included_indices] + value2_lst[included_indices]\n            ratios = included_values / (included_weights + 1e-6)\n            remove_idx = included_indices[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution):\n        current_weight = np.sum(weight_lst[solution == 1])\n        remaining_capacity = capacity - current_weight\n        # Score based on how much weight can be added without violating capacity\n        return remaining_capacity\n\n    # Sort solutions by potential score (descending) and select top 30% or at least 1\n    archive_sorted = sorted(archive, key=lambda x: -potential_score(x[0]))\n    top_candidates = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    selected_solution, _ = random.choice(top_candidates)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random swaps + value-based greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random swaps (1-3 times)\n    for _ in range(random.randint(1, 3)):\n        # Select two different items to swap\n        idx1, idx2 = random.sample(range(n_items), 2)\n\n        # Calculate new weight if we swap\n        if new_solution[idx1] != new_solution[idx2]:\n            delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] else (weight_lst[idx1] - weight_lst[idx2])\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight += delta_weight\n\n    # Value-based greedy selection for one objective (alternating between objectives)\n    objective_to_optimize = random.choice([value1_lst, value2_lst])\n    for _ in range(random.randint(1, 2)):\n        # Find items that can be added without violating capacity\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n        if len(candidate_items) > 0:\n            # Select item with highest value for the chosen objective\n            best_item = candidate_items[np.argmax(objective_to_optimize[candidate_items])]\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n\n        # Find items that can be removed to free up capacity\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Select item with lowest value for the chosen objective\n            worst_item = candidate_items[np.argmin(objective_to_optimize[candidate_items])]\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.5580628779952819,
            6.569156378507614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    def potential_score(solution):\n        current_weight = np.sum(weight_lst[solution == 1])\n        remaining_capacity = capacity - current_weight\n        # Score based on how much weight can be added without violating capacity\n        return remaining_capacity\n\n    # Sort solutions by potential score (descending) and select top 30% or at least 1\n    archive_sorted = sorted(archive, key=lambda x: -potential_score(x[0]))\n    top_candidates = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    selected_solution, _ = random.choice(top_candidates)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: random swaps + value-based greedy selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random swaps (1-3 times)\n    for _ in range(random.randint(1, 3)):\n        # Select two different items to swap\n        idx1, idx2 = random.sample(range(n_items), 2)\n\n        # Calculate new weight if we swap\n        if new_solution[idx1] != new_solution[idx2]:\n            delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] else (weight_lst[idx1] - weight_lst[idx2])\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight += delta_weight\n\n    # Value-based greedy selection for one objective (alternating between objectives)\n    objective_to_optimize = random.choice([value1_lst, value2_lst])\n    for _ in range(random.randint(1, 2)):\n        # Find items that can be added without violating capacity\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n        if len(candidate_items) > 0:\n            # Select item with highest value for the chosen objective\n            best_item = candidate_items[np.argmax(objective_to_optimize[candidate_items])]\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n\n        # Find items that can be removed to free up capacity\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            # Select item with lowest value for the chosen objective\n            worst_item = candidate_items[np.argmin(objective_to_optimize[candidate_items])]\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = np.argmax([np.sum(weight_lst[archive[i][0].astype(bool)]) for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution.astype(bool)])\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Hybrid local search strategy: flip a subset of items based on their marginal contribution\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    np.random.shuffle(candidates)\n\n    # Flip a random subset of included items to explore different trade-offs\n    flip_count = min(3, len(candidates))  # Limit the number of flips to balance exploration and exploitation\n    for i in range(flip_count):\n        idx = candidates[i]\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                current_weight = new_weight\n            else:\n                new_solution[idx] = 1  # Revert if infeasible\n\n    # Add a new item if possible, prioritizing high marginal contribution\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    for idx in remaining_items:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            new_solution[idx] = 1\n            current_weight = new_weight\n            break  # Add only one item to keep changes manageable\n\n    return new_solution\n\n",
        "score": [
            -0.8313783314581976,
            2.044858694076538
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = np.argmax([np.sum(weight_lst[archive[i][0].astype(bool)]) for i in range(len(archive))])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution.astype(bool)])\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Hybrid local search strategy: flip a subset of items based on their marginal contribution\n    new_solution = base_solution.copy()\n    candidates = np.where(new_solution == 1)[0]\n    np.random.shuffle(candidates)\n\n    # Flip a random subset of included items to explore different trade-offs\n    flip_count = min(3, len(candidates))  # Limit the number of flips to balance exploration and exploitation\n    for i in range(flip_count):\n        idx = candidates[i]\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                current_weight = new_weight\n            else:\n                new_solution[idx] = 1  # Revert if infeasible\n\n    # Add a new item if possible, prioritizing high marginal contribution\n    remaining_items = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_items)\n    for idx in remaining_items:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            new_solution[idx] = 1\n            current_weight = new_weight\n            break  # Add only one item to keep changes manageable\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligent selection of a promising solution\n    # Prefer solutions that are not fully packed (potential for improvement)\n    # and have high objective values\n    selected_idx = 0\n    max_potential = -1\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst * solution)\n        potential = (objective[0] + objective[1]) * (1 - current_weight / capacity)\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Flip-based move: Randomly flip a subset of items\n    # 2. Swap-based move: Randomly swap two items\n    # 3. Ensure feasibility by validating weight constraints\n\n    # Flip-based move\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Validate weight constraint\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # If infeasible, undo the flip and try swap-based move\n        new_solution = base_solution.copy()\n        # Swap-based move\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Final validation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # If still infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5956031158738876,
            4.216908931732178
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligent selection of a promising solution\n    # Prefer solutions that are not fully packed (potential for improvement)\n    # and have high objective values\n    selected_idx = 0\n    max_potential = -1\n    for i, (solution, objective) in enumerate(archive):\n        current_weight = np.sum(weight_lst * solution)\n        potential = (objective[0] + objective[1]) * (1 - current_weight / capacity)\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    # 1. Flip-based move: Randomly flip a subset of items\n    # 2. Swap-based move: Randomly swap two items\n    # 3. Ensure feasibility by validating weight constraints\n\n    # Flip-based move\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Validate weight constraint\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # If infeasible, undo the flip and try swap-based move\n        new_solution = base_solution.copy()\n        # Swap-based move\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Final validation\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # If still infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    # Sort by the sum of normalized objective values to prioritize solutions with higher potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Perform value-based swaps to improve both objectives\n    new_solution = base_solution.copy()\n\n    # Step 1: Random perturbation (flip 10-30% of items)\n    flip_prob = np.random.uniform(0.1, 0.3)\n    flip_mask = np.random.rand(len(new_solution)) < flip_prob\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility after perturbation\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items with lowest value-to-weight ratio until feasible\n        while new_weight > capacity:\n            item_values = (value1_lst * new_solution + value2_lst * new_solution) / weight_lst\n            worst_item = np.argmin(item_values)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n                new_weight -= weight_lst[worst_item]\n            else:\n                break\n\n    # Step 2: Value-based swaps for both objectives\n    # Identify items not in the solution with high marginal value\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Calculate marginal value for each candidate item\n        marginal_value1 = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n        marginal_value2 = value2_lst[not_in_solution] / weight_lst[not_in_solution]\n\n        # Select top 20% candidates based on combined marginal value\n        top_candidates = np.argsort(-(marginal_value1 + marginal_value2))[:max(1, len(not_in_solution) // 5)]\n\n        for candidate in not_in_solution[top_candidates]:\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n\n    # Step 3: Local improvement - remove low-value items\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) > 0:\n        # Calculate value-to-weight ratio for each item in solution\n        value_ratio = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n        worst_items = np.argsort(value_ratio)[:max(1, len(in_solution) // 5)]\n\n        for item in in_solution[worst_items]:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3020276716092324,
            1.6081490814685822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    # Sort by the sum of normalized objective values to prioritize solutions with higher potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    base_solution = archive_sorted[0][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Perform value-based swaps to improve both objectives\n    new_solution = base_solution.copy()\n\n    # Step 1: Random perturbation (flip 10-30% of items)\n    flip_prob = np.random.uniform(0.1, 0.3)\n    flip_mask = np.random.rand(len(new_solution)) < flip_prob\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility after perturbation\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items with lowest value-to-weight ratio until feasible\n        while new_weight > capacity:\n            item_values = (value1_lst * new_solution + value2_lst * new_solution) / weight_lst\n            worst_item = np.argmin(item_values)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n                new_weight -= weight_lst[worst_item]\n            else:\n                break\n\n    # Step 2: Value-based swaps for both objectives\n    # Identify items not in the solution with high marginal value\n    not_in_solution = np.where(new_solution == 0)[0]\n    if len(not_in_solution) > 0:\n        # Calculate marginal value for each candidate item\n        marginal_value1 = value1_lst[not_in_solution] / weight_lst[not_in_solution]\n        marginal_value2 = value2_lst[not_in_solution] / weight_lst[not_in_solution]\n\n        # Select top 20% candidates based on combined marginal value\n        top_candidates = np.argsort(-(marginal_value1 + marginal_value2))[:max(1, len(not_in_solution) // 5)]\n\n        for candidate in not_in_solution[top_candidates]:\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n                current_weight += weight_lst[candidate]\n\n    # Step 3: Local improvement - remove low-value items\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) > 0:\n        # Calculate value-to-weight ratio for each item in solution\n        value_ratio = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n        worst_items = np.argsort(value_ratio)[:max(1, len(in_solution) // 5)]\n\n        for item in in_solution[worst_items]:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the frontier)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a random bit with objective-aware probability\n    flip_prob = 0.3  # Base probability to flip\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 1:\n                # If item is included, decide to remove based on marginal contribution\n                marginal_val1 = value1_lst[i]\n                marginal_val2 = value2_lst[i]\n                if (marginal_val1 / current_val1 < 0.1) or (marginal_val2 / current_val2 < 0.1):\n                    new_solution[i] = 0\n            else:\n                # If item is excluded, decide to include if it fits and improves both objectives\n                if (np.sum(new_solution * weight_lst) + weight_lst[i]) <= capacity:\n                    if (value1_lst[i] > 0) and (value2_lst[i] > 0):\n                        new_solution[i] = 1\n\n    # Objective-aware swap: select two items and swap their inclusion status if it improves both objectives\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Calculate potential new values\n            new_val1 = current_val1 - value1_lst[i] + value1_lst[j] if new_solution[i] else current_val1 + value1_lst[i] - value1_lst[j]\n            new_val2 = current_val2 - value2_lst[i] + value2_lst[j] if new_solution[i] else current_val2 + value2_lst[i] - value2_lst[j]\n            # Check if swap improves both objectives\n            if (new_val1 > current_val1) and (new_val2 > current_val2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Remove the heaviest item that can be removed without reducing both objectives too much\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            break\n        # Select item with smallest ratio of marginal contribution to weight\n        ratios = [(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in candidate_items]\n        remove_idx = candidate_items[np.argmin(ratios)]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.37854498498276096,
            4.172699928283691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the frontier)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a random bit with objective-aware probability\n    flip_prob = 0.3  # Base probability to flip\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            if new_solution[i] == 1:\n                # If item is included, decide to remove based on marginal contribution\n                marginal_val1 = value1_lst[i]\n                marginal_val2 = value2_lst[i]\n                if (marginal_val1 / current_val1 < 0.1) or (marginal_val2 / current_val2 < 0.1):\n                    new_solution[i] = 0\n            else:\n                # If item is excluded, decide to include if it fits and improves both objectives\n                if (np.sum(new_solution * weight_lst) + weight_lst[i]) <= capacity:\n                    if (value1_lst[i] > 0) and (value2_lst[i] > 0):\n                        new_solution[i] = 1\n\n    # Objective-aware swap: select two items and swap their inclusion status if it improves both objectives\n    if len(new_solution) >= 2:\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Calculate potential new values\n            new_val1 = current_val1 - value1_lst[i] + value1_lst[j] if new_solution[i] else current_val1 + value1_lst[i] - value1_lst[j]\n            new_val2 = current_val2 - value2_lst[i] + value2_lst[j] if new_solution[i] else current_val2 + value2_lst[i] - value2_lst[j]\n            # Check if swap improves both objectives\n            if (new_val1 > current_val1) and (new_val2 > current_val2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Remove the heaviest item that can be removed without reducing both objectives too much\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            break\n        # Select item with smallest ratio of marginal contribution to weight\n        ratios = [(value1_lst[i] + value2_lst[i]) / weight_lst[i] for i in candidate_items]\n        remove_idx = candidate_items[np.argmin(ratios)]\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping a random subset of items\n    new_solution = base_solution.copy()\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility: if weight exceeds capacity, remove the heaviest items\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # Get indices of included items sorted by weight (heaviest first)\n        included_indices = np.where(new_solution == 1)[0]\n        sorted_indices = included_indices[np.argsort(weight_lst[included_indices])[::-1]]\n        for idx in sorted_indices:\n            new_solution[idx] = 0\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight <= capacity:\n                break\n\n    # Greedy improvement: try to add items that improve both objectives\n    excluded_indices = np.where(new_solution == 0)[0]\n    if len(excluded_indices) > 0:\n        # Calculate potential improvements\n        potential_weights = weight_lst[excluded_indices]\n        potential_value1 = value1_lst[excluded_indices]\n        potential_value2 = value2_lst[excluded_indices]\n\n        # Filter items that can be added without exceeding capacity\n        feasible_mask = (current_weight + potential_weights <= capacity)\n        feasible_indices = excluded_indices[feasible_mask]\n\n        if len(feasible_indices) > 0:\n            # Select the item that improves both objectives the most (using a weighted sum)\n            weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n            improvements = weights[0] * potential_value1[feasible_mask] + weights[1] * potential_value2[feasible_mask]\n            best_idx = feasible_indices[np.argmax(improvements)]\n            new_solution[best_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3761327031561543,
            1.2591844201087952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping a random subset of items\n    new_solution = base_solution.copy()\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility: if weight exceeds capacity, remove the heaviest items\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # Get indices of included items sorted by weight (heaviest first)\n        included_indices = np.where(new_solution == 1)[0]\n        sorted_indices = included_indices[np.argsort(weight_lst[included_indices])[::-1]]\n        for idx in sorted_indices:\n            new_solution[idx] = 0\n            new_weight = np.sum(weight_lst[new_solution == 1])\n            if new_weight <= capacity:\n                break\n\n    # Greedy improvement: try to add items that improve both objectives\n    excluded_indices = np.where(new_solution == 0)[0]\n    if len(excluded_indices) > 0:\n        # Calculate potential improvements\n        potential_weights = weight_lst[excluded_indices]\n        potential_value1 = value1_lst[excluded_indices]\n        potential_value2 = value2_lst[excluded_indices]\n\n        # Filter items that can be added without exceeding capacity\n        feasible_mask = (current_weight + potential_weights <= capacity)\n        feasible_indices = excluded_indices[feasible_mask]\n\n        if len(feasible_indices) > 0:\n            # Select the item that improves both objectives the most (using a weighted sum)\n            weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n            improvements = weights[0] * potential_value1[feasible_mask] + weights[1] * potential_value2[feasible_mask]\n            best_idx = feasible_indices[np.argmax(improvements)]\n            new_solution[best_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Identify items that could be swapped or flipped to improve both objectives\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: flip a random item if it improves both objectives\n    if len(items_in) > 0:\n        # Randomly select an item to flip out\n        flip_out_idx = random.choice(items_in)\n        new_weight = current_weight - weight_lst[flip_out_idx]\n\n        # Check if flipping out improves both objectives\n        new_val1 = current_val1 - value1_lst[flip_out_idx]\n        new_val2 = current_val2 - value2_lst[flip_out_idx]\n\n        # If flipping out improves both, do it\n        if new_val1 > current_val1 and new_val2 > current_val2:\n            new_solution[flip_out_idx] = 0\n            return new_solution\n\n    # If no improvement, try adding an item that improves both objectives\n    for item in items_out:\n        if current_weight + weight_lst[item] <= capacity:\n            new_val1 = current_val1 + value1_lst[item]\n            new_val2 = current_val2 + value2_lst[item]\n\n            # If adding improves both, do it\n            if new_val1 > current_val1 and new_val2 > current_val2:\n                new_solution[item] = 1\n                return new_solution\n\n    # If no clear improvement, perform a random swap\n    if len(items_in) > 0 and len(items_out) > 0:\n        swap_out = random.choice(items_in)\n        swap_in = random.choice(items_out)\n\n        # Check if the swap is feasible\n        if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n            return new_solution\n\n    # If no improvement, return the original solution\n    return new_solution\n\n",
        "score": [
            -0.3756534032276041,
            3.881193310022354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Identify items that could be swapped or flipped to improve both objectives\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: flip a random item if it improves both objectives\n    if len(items_in) > 0:\n        # Randomly select an item to flip out\n        flip_out_idx = random.choice(items_in)\n        new_weight = current_weight - weight_lst[flip_out_idx]\n\n        # Check if flipping out improves both objectives\n        new_val1 = current_val1 - value1_lst[flip_out_idx]\n        new_val2 = current_val2 - value2_lst[flip_out_idx]\n\n        # If flipping out improves both, do it\n        if new_val1 > current_val1 and new_val2 > current_val2:\n            new_solution[flip_out_idx] = 0\n            return new_solution\n\n    # If no improvement, try adding an item that improves both objectives\n    for item in items_out:\n        if current_weight + weight_lst[item] <= capacity:\n            new_val1 = current_val1 + value1_lst[item]\n            new_val2 = current_val2 + value2_lst[item]\n\n            # If adding improves both, do it\n            if new_val1 > current_val1 and new_val2 > current_val2:\n                new_solution[item] = 1\n                return new_solution\n\n    # If no clear improvement, perform a random swap\n    if len(items_in) > 0 and len(items_out) > 0:\n        swap_out = random.choice(items_in)\n        swap_in = random.choice(items_out)\n\n        # Check if the swap is feasible\n        if current_weight - weight_lst[swap_out] + weight_lst[swap_in] <= capacity:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n            return new_solution\n\n    # If no improvement, return the original solution\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Targeted item swaps to improve both objectives\n\n    # Step 1: Random perturbation (flip 10% of items)\n    flip_indices = np.random.choice(len(new_solution), size=max(1, len(new_solution) // 10), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Targeted swaps to improve both objectives\n    # Identify items that are in the solution but could be swapped with excluded items\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    for i in in_solution:\n        for j in out_solution:\n            if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n                (value1_lst[i] < value1_lst[j] or value2_lst[i] < value2_lst[j])):\n                # Swap if it improves at least one objective\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.4455129014837319,
            4.248534739017487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Targeted item swaps to improve both objectives\n\n    # Step 1: Random perturbation (flip 10% of items)\n    flip_indices = np.random.choice(len(new_solution), size=max(1, len(new_solution) // 10), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Targeted swaps to improve both objectives\n    # Identify items that are in the solution but could be swapped with excluded items\n    in_solution = np.where(new_solution == 1)[0]\n    out_solution = np.where(new_solution == 0)[0]\n\n    for i in in_solution:\n        for j in out_solution:\n            if (current_weight - weight_lst[i] + weight_lst[j] <= capacity and\n                (value1_lst[i] < value1_lst[j] or value2_lst[i] < value2_lst[j])):\n                # Swap if it improves at least one objective\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution (simplified)\n        crowding = []\n        objectives = np.array([obj for _, obj in archive])\n        for i in range(len(archive)):\n            # For each objective, find the nearest neighbors\n            sorted_obj1 = np.sort(objectives[:, 0])\n            sorted_obj2 = np.sort(objectives[:, 1])\n            idx1 = np.where(sorted_obj1 == objectives[i, 0])[0][0]\n            idx2 = np.where(sorted_obj2 == objectives[i, 1])[0][0]\n\n            if idx1 == 0 or idx1 == len(objectives) - 1:\n                dist1 = float('inf')\n            else:\n                dist1 = (sorted_obj1[idx1 + 1] - sorted_obj1[idx1 - 1]) / (sorted_obj1[-1] - sorted_obj1[0] + 1e-10)\n\n            if idx2 == 0 or idx2 == len(objectives) - 1:\n                dist2 = float('inf')\n            else:\n                dist2 = (sorted_obj2[idx2 + 1] - sorted_obj2[idx2 - 1]) / (sorted_obj2[-1] - sorted_obj2[0] + 1e-10)\n\n            crowding.append(min(dist1, dist2))\n\n        # Select solutions with lower crowding (more promising for improvement)\n        selected_idx = np.argmin(crowding)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Strategy 1: Randomly flip a subset of items (with bias towards low-value items)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, decide whether to remove it based on its marginal value\n            marginal_value1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n            marginal_value2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n            if random.random() < 0.7 * (1 - min(marginal_value1, marginal_value2) / (np.max(value1_lst) + np.max(value2_lst) + 1e-10)):\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, decide whether to include it based on its marginal value\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[idx] <= capacity:\n                marginal_value1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n                marginal_value2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n                if random.random() < 0.7 * min(marginal_value1, marginal_value2) / (np.max(value1_lst) + np.max(value2_lst) + 1e-10):\n                    new_solution[idx] = 1\n\n    # Strategy 2: Ensure feasibility (if not already)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal value until feasible\n        while current_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate marginal values for included items\n            marginal_values = []\n            for idx in included_items:\n                marginal_value1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n                marginal_value2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n                marginal_values.append(min(marginal_value1, marginal_value2))\n            # Remove the item with lowest marginal value\n            remove_idx = included_items[np.argmin(marginal_values)]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7666236369137431,
            6.07953879237175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for each solution (simplified)\n        crowding = []\n        objectives = np.array([obj for _, obj in archive])\n        for i in range(len(archive)):\n            # For each objective, find the nearest neighbors\n            sorted_obj1 = np.sort(objectives[:, 0])\n            sorted_obj2 = np.sort(objectives[:, 1])\n            idx1 = np.where(sorted_obj1 == objectives[i, 0])[0][0]\n            idx2 = np.where(sorted_obj2 == objectives[i, 1])[0][0]\n\n            if idx1 == 0 or idx1 == len(objectives) - 1:\n                dist1 = float('inf')\n            else:\n                dist1 = (sorted_obj1[idx1 + 1] - sorted_obj1[idx1 - 1]) / (sorted_obj1[-1] - sorted_obj1[0] + 1e-10)\n\n            if idx2 == 0 or idx2 == len(objectives) - 1:\n                dist2 = float('inf')\n            else:\n                dist2 = (sorted_obj2[idx2 + 1] - sorted_obj2[idx2 - 1]) / (sorted_obj2[-1] - sorted_obj2[0] + 1e-10)\n\n            crowding.append(min(dist1, dist2))\n\n        # Select solutions with lower crowding (more promising for improvement)\n        selected_idx = np.argmin(crowding)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Generate a neighbor solution using a hybrid local search strategy\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Strategy 1: Randomly flip a subset of items (with bias towards low-value items)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, decide whether to remove it based on its marginal value\n            marginal_value1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n            marginal_value2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n            if random.random() < 0.7 * (1 - min(marginal_value1, marginal_value2) / (np.max(value1_lst) + np.max(value2_lst) + 1e-10)):\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, decide whether to include it based on its marginal value\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight + weight_lst[idx] <= capacity:\n                marginal_value1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n                marginal_value2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n                if random.random() < 0.7 * min(marginal_value1, marginal_value2) / (np.max(value1_lst) + np.max(value2_lst) + 1e-10):\n                    new_solution[idx] = 1\n\n    # Strategy 2: Ensure feasibility (if not already)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items in order of lowest marginal value until feasible\n        while current_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate marginal values for included items\n            marginal_values = []\n            for idx in included_items:\n                marginal_value1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n                marginal_value2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n                marginal_values.append(min(marginal_value1, marginal_value2))\n            # Remove the item with lowest marginal value\n            remove_idx = included_items[np.argmin(marginal_values)]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with higher combined value\n    combined_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = combined_values / np.sum(combined_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Determine flip candidates: items not in the solution with high value-to-weight ratio\n    not_in_solution = np.where(base_solution == 0)[0]\n    if len(not_in_solution) == 0:\n        # If no items can be added, try removing low-value items\n        in_solution = np.where(base_solution == 1)[0]\n        if len(in_solution) == 0:\n            return new_solution  # No possible moves\n        # Remove items with lowest combined value\n        combined_values_in = value1_lst[in_solution] + value2_lst[in_solution]\n        item_to_remove = in_solution[np.argmin(combined_values_in)]\n        new_solution[item_to_remove] = 0\n        return new_solution\n\n    # Calculate value-to-weight ratios for not-in-solution items\n    vw_ratios = (value1_lst[not_in_solution] + value2_lst[not_in_solution]) / weight_lst[not_in_solution]\n\n    # Select top k candidates based on value-to-weight ratio\n    k = min(5, len(not_in_solution))\n    top_candidates = not_in_solution[np.argsort(vw_ratios)[-k:]]\n\n    # Randomly select one candidate to flip\n    candidate = random.choice(top_candidates)\n\n    # Check if adding this item keeps the solution feasible\n    if current_weight + weight_lst[candidate] <= capacity:\n        new_solution[candidate] = 1\n    else:\n        # If not feasible, try to remove items to make space\n        in_solution = np.where(base_solution == 1)[0]\n        if len(in_solution) == 0:\n            return new_solution  # No possible moves\n\n        # Calculate how much weight we need to free up\n        needed_weight = weight_lst[candidate] - (capacity - current_weight)\n\n        # Find items to remove that can free up needed_weight\n        removable = []\n        for item in in_solution:\n            if weight_lst[item] <= needed_weight:\n                removable.append(item)\n                needed_weight -= weight_lst[item]\n                if needed_weight <= 0:\n                    break\n\n        if removable:\n            # Remove selected items and add the candidate\n            new_solution[removable] = 0\n            new_solution[candidate] = 1\n        else:\n            # If no items can be removed to make space, try a different candidate\n            other_candidates = [x for x in not_in_solution if x != candidate]\n            if other_candidates:\n                candidate = random.choice(other_candidates)\n                if current_weight + weight_lst[candidate] <= capacity:\n                    new_solution[candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.68451931091097,
            8.647567480802536
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with higher combined value\n    combined_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = combined_values / np.sum(combined_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Determine flip candidates: items not in the solution with high value-to-weight ratio\n    not_in_solution = np.where(base_solution == 0)[0]\n    if len(not_in_solution) == 0:\n        # If no items can be added, try removing low-value items\n        in_solution = np.where(base_solution == 1)[0]\n        if len(in_solution) == 0:\n            return new_solution  # No possible moves\n        # Remove items with lowest combined value\n        combined_values_in = value1_lst[in_solution] + value2_lst[in_solution]\n        item_to_remove = in_solution[np.argmin(combined_values_in)]\n        new_solution[item_to_remove] = 0\n        return new_solution\n\n    # Calculate value-to-weight ratios for not-in-solution items\n    vw_ratios = (value1_lst[not_in_solution] + value2_lst[not_in_solution]) / weight_lst[not_in_solution]\n\n    # Select top k candidates based on value-to-weight ratio\n    k = min(5, len(not_in_solution))\n    top_candidates = not_in_solution[np.argsort(vw_ratios)[-k:]]\n\n    # Randomly select one candidate to flip\n    candidate = random.choice(top_candidates)\n\n    # Check if adding this item keeps the solution feasible\n    if current_weight + weight_lst[candidate] <= capacity:\n        new_solution[candidate] = 1\n    else:\n        # If not feasible, try to remove items to make space\n        in_solution = np.where(base_solution == 1)[0]\n        if len(in_solution) == 0:\n            return new_solution  # No possible moves\n\n        # Calculate how much weight we need to free up\n        needed_weight = weight_lst[candidate] - (capacity - current_weight)\n\n        # Find items to remove that can free up needed_weight\n        removable = []\n        for item in in_solution:\n            if weight_lst[item] <= needed_weight:\n                removable.append(item)\n                needed_weight -= weight_lst[item]\n                if needed_weight <= 0:\n                    break\n\n        if removable:\n            # Remove selected items and add the candidate\n            new_solution[removable] = 0\n            new_solution[candidate] = 1\n        else:\n            # If no items can be removed to make space, try a different candidate\n            other_candidates = [x for x in not_in_solution if x != candidate]\n            if other_candidates:\n                candidate = random.choice(other_candidates)\n                if current_weight + weight_lst[candidate] <= capacity:\n                    new_solution[candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not fully packed)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either included or excluded without violating capacity)\n    feasible_flips = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                feasible_flips.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                feasible_flips.append((i, 1))  # 1 indicates inclusion\n\n    if not feasible_flips:\n        # If no flips are feasible, return the base solution (or apply a different strategy)\n        return base_solution\n\n    # Select a flip with high potential improvement (value-to-weight ratio)\n    flip_candidates = []\n    for i, flip_type in feasible_flips:\n        if flip_type == 1:\n            # Potential improvement for inclusion\n            ratio1 = value1_lst[i] / weight_lst[i]\n            ratio2 = value2_lst[i] / weight_lst[i]\n            improvement = (ratio1 + ratio2) / 2  # Combined improvement metric\n            flip_candidates.append((i, flip_type, improvement))\n        else:\n            # Potential improvement for exclusion (negative impact)\n            ratio1 = -value1_lst[i] / weight_lst[i]\n            ratio2 = -value2_lst[i] / weight_lst[i]\n            improvement = (ratio1 + ratio2) / 2\n            flip_candidates.append((i, flip_type, improvement))\n\n    # Sort by improvement and select the top candidate\n    flip_candidates.sort(key=lambda x: -x[2])\n    best_i, best_flip_type, _ = flip_candidates[0]\n\n    # Apply the flip\n    new_solution[best_i] = 1 if best_flip_type == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8171488090211967,
            2.125443935394287
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not fully packed)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that can be flipped (either included or excluded without violating capacity)\n    feasible_flips = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                feasible_flips.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                feasible_flips.append((i, 1))  # 1 indicates inclusion\n\n    if not feasible_flips:\n        # If no flips are feasible, return the base solution (or apply a different strategy)\n        return base_solution\n\n    # Select a flip with high potential improvement (value-to-weight ratio)\n    flip_candidates = []\n    for i, flip_type in feasible_flips:\n        if flip_type == 1:\n            # Potential improvement for inclusion\n            ratio1 = value1_lst[i] / weight_lst[i]\n            ratio2 = value2_lst[i] / weight_lst[i]\n            improvement = (ratio1 + ratio2) / 2  # Combined improvement metric\n            flip_candidates.append((i, flip_type, improvement))\n        else:\n            # Potential improvement for exclusion (negative impact)\n            ratio1 = -value1_lst[i] / weight_lst[i]\n            ratio2 = -value2_lst[i] / weight_lst[i]\n            improvement = (ratio1 + ratio2) / 2\n            flip_candidates.append((i, flip_type, improvement))\n\n    # Sort by improvement and select the top candidate\n    flip_candidates.sort(key=lambda x: -x[2])\n    best_i, best_flip_type, _ = flip_candidates[0]\n\n    # Apply the flip\n    new_solution[best_i] = 1 if best_flip_type == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a base solution with probability proportional to its non-dominated rank (higher rank = more promising)\n    ranks = np.linspace(1, len(archive), len(archive))\n    probabilities = ranks / np.sum(ranks)\n    base_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random subset flip followed by greedy improvement\n    n_items = len(weight_lst)\n    subset_size = min(5, n_items)  # Flip a small random subset of items\n    flip_indices = random.sample(range(n_items), subset_size)\n\n    # Apply random flip and ensure feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: add items that improve both objectives if feasible\n    for i in range(n_items):\n        if new_solution[i] == 0:\n            if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                # Calculate potential improvement in both objectives\n                delta_v1 = value1_lst[i]\n                delta_v2 = value2_lst[i]\n                if delta_v1 > 0 and delta_v2 > 0:  # Only consider improving moves\n                    new_solution[i] = 1\n\n    # Optional: Remove items if they don't contribute to either objective\n    for i in range(n_items):\n        if new_solution[i] == 1 and value1_lst[i] == 0 and value2_lst[i] == 0:\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4538420337153721,
            7.428462207317352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Select a base solution with probability proportional to its non-dominated rank (higher rank = more promising)\n    ranks = np.linspace(1, len(archive), len(archive))\n    probabilities = ranks / np.sum(ranks)\n    base_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random subset flip followed by greedy improvement\n    n_items = len(weight_lst)\n    subset_size = min(5, n_items)  # Flip a small random subset of items\n    flip_indices = random.sample(range(n_items), subset_size)\n\n    # Apply random flip and ensure feasibility\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: add items that improve both objectives if feasible\n    for i in range(n_items):\n        if new_solution[i] == 0:\n            if np.sum(new_solution * weight_lst) + weight_lst[i] <= capacity:\n                # Calculate potential improvement in both objectives\n                delta_v1 = value1_lst[i]\n                delta_v2 = value2_lst[i]\n                if delta_v1 > 0 and delta_v2 > 0:  # Only consider improving moves\n                    new_solution[i] = 1\n\n    # Optional: Remove items if they don't contribute to either objective\n    for i in range(n_items):\n        if new_solution[i] == 1 and value1_lst[i] == 0 and value2_lst[i] == 0:\n            new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (higher value1 + value2)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        # Select from top 50% of solutions\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 2)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine bit-flip with value-based swaps\n    for _ in range(3):  # Perform up to 3 operations\n        # Option 1: Random bit-flip (with feasibility check)\n        if random.random() < 0.5:\n            idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[idx] == 1:\n                # Try to remove item if it doesn't make the solution worse in both objectives\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n            else:\n                # Try to add item if it doesn't exceed capacity\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Option 2: Value-based swap (try to improve both objectives)\n        else:\n            # Find items currently in and not in the solution\n            in_items = np.where(new_solution == 1)[0]\n            out_items = np.where(new_solution == 0)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                # Select a random item to remove and a random item to add\n                remove_idx = random.choice(in_items)\n                add_idx = random.choice(out_items)\n\n                # Check if swap improves both objectives\n                current_value1 = np.sum(value1_lst[new_solution == 1])\n                current_value2 = np.sum(value2_lst[new_solution == 1])\n\n                temp_solution = new_solution.copy()\n                temp_solution[remove_idx] = 0\n                temp_solution[add_idx] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_value1 = current_value1 - value1_lst[remove_idx] + value1_lst[add_idx]\n                    new_value2 = current_value2 - value2_lst[remove_idx] + value2_lst[add_idx]\n\n                    # Accept if at least one objective improves\n                    if new_value1 > current_value1 or new_value2 > current_value2:\n                        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.31191217303943325,
            2.7775042057037354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (higher value1 + value2)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        # Select from top 50% of solutions\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 2)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine bit-flip with value-based swaps\n    for _ in range(3):  # Perform up to 3 operations\n        # Option 1: Random bit-flip (with feasibility check)\n        if random.random() < 0.5:\n            idx = random.randint(0, len(new_solution) - 1)\n            if new_solution[idx] == 1:\n                # Try to remove item if it doesn't make the solution worse in both objectives\n                temp_solution = new_solution.copy()\n                temp_solution[idx] = 0\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    new_solution = temp_solution\n            else:\n                # Try to add item if it doesn't exceed capacity\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Option 2: Value-based swap (try to improve both objectives)\n        else:\n            # Find items currently in and not in the solution\n            in_items = np.where(new_solution == 1)[0]\n            out_items = np.where(new_solution == 0)[0]\n\n            if len(in_items) > 0 and len(out_items) > 0:\n                # Select a random item to remove and a random item to add\n                remove_idx = random.choice(in_items)\n                add_idx = random.choice(out_items)\n\n                # Check if swap improves both objectives\n                current_value1 = np.sum(value1_lst[new_solution == 1])\n                current_value2 = np.sum(value2_lst[new_solution == 1])\n\n                temp_solution = new_solution.copy()\n                temp_solution[remove_idx] = 0\n                temp_solution[add_idx] = 1\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n\n                if temp_weight <= capacity:\n                    new_value1 = current_value1 - value1_lst[remove_idx] + value1_lst[add_idx]\n                    new_value2 = current_value2 - value2_lst[remove_idx] + value2_lst[add_idx]\n\n                    # Accept if at least one objective improves\n                    if new_value1 > current_value1 or new_value2 > current_value2:\n                        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (higher is better)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select a solution from the top 30% to encourage exploration\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 3 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flip with value-based swap\n    # Step 1: Randomly flip a small number of items (1-3)\n    num_flips = random.randint(1, 3)\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Ensure feasibility by removing the worst items if capacity is exceeded\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Calculate the \"value density\" for each item (value1 + value2) / weight\n        value_density = (value1_lst + value2_lst) / weight_lst\n        # Remove items with the lowest value density until feasible\n        while current_weight > capacity:\n            # Find the item with the lowest value density in the solution\n            selected_items = np.where(new_solution == 1)[0]\n            if len(selected_items) == 0:\n                break  # No items left to remove\n            worst_item = selected_items[np.argmin(value_density[selected_items])]\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    # Step 3: Randomly swap items to explore the neighborhood\n    if len(np.where(new_solution == 1)[0]) > 1:\n        # Select two items to swap\n        swap_indices = random.sample(range(len(new_solution)), 2)\n        # Ensure swapping doesn't violate capacity\n        weight_diff = weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]]\n        if (weight_diff <= 0) or (current_weight + weight_diff <= capacity):\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.3198647710975956,
            1.7725603580474854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (higher is better)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select a solution from the top 30% to encourage exploration\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 3 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flip with value-based swap\n    # Step 1: Randomly flip a small number of items (1-3)\n    num_flips = random.randint(1, 3)\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Ensure feasibility by removing the worst items if capacity is exceeded\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Calculate the \"value density\" for each item (value1 + value2) / weight\n        value_density = (value1_lst + value2_lst) / weight_lst\n        # Remove items with the lowest value density until feasible\n        while current_weight > capacity:\n            # Find the item with the lowest value density in the solution\n            selected_items = np.where(new_solution == 1)[0]\n            if len(selected_items) == 0:\n                break  # No items left to remove\n            worst_item = selected_items[np.argmin(value_density[selected_items])]\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    # Step 3: Randomly swap items to explore the neighborhood\n    if len(np.where(new_solution == 1)[0]) > 1:\n        # Select two items to swap\n        swap_indices = random.sample(range(len(new_solution)), 2)\n        # Ensure swapping doesn't violate capacity\n        weight_diff = weight_lst[swap_indices[0]] - weight_lst[swap_indices[1]]\n        if (weight_diff <= 0) or (current_weight + weight_diff <= capacity):\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    candidates = [sol for sol, obj in archive if obj[0] > 0 and obj[1] > 0]  # Filter non-zero solutions\n    if not candidates:\n        candidates = [sol for sol, obj in archive]  # Fallback to all if no non-zero\n\n    selected = random.choice(candidates) if candidates else archive[0][0]\n    new_solution = selected.copy()\n\n    # Hybrid local search strategy: combination of swap and greedy addition\n    n_items = len(new_solution)\n\n    # First, try to swap two items if it improves both objectives\n    improved = False\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] == new_solution[j]:\n            continue  # Skip if both are same state\n\n        # Create temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check feasibility and improvement\n        temp_weight = np.sum(weight_lst * temp_solution)\n        if temp_weight <= capacity:\n            temp_value1 = np.sum(value1_lst * temp_solution)\n            temp_value2 = np.sum(value2_lst * temp_solution)\n            original_value1 = np.sum(value1_lst * new_solution)\n            original_value2 = np.sum(value2_lst * new_solution)\n\n            if (temp_value1 > original_value1 and temp_value2 > original_value2):\n                new_solution = temp_solution\n                improved = True\n                break\n\n    # If no improvement from swaps, try greedy addition of items\n    if not improved:\n        for _ in range(5):  # Limit iterations\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 1:\n                continue  # Skip if already included\n\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                temp_value1 = np.sum(value1_lst * temp_solution)\n                temp_value2 = np.sum(value2_lst * temp_solution)\n                original_value1 = np.sum(value1_lst * new_solution)\n                original_value2 = np.sum(value2_lst * new_solution)\n\n                if (temp_value1 >= original_value1 and temp_value2 >= original_value2):\n                    new_solution = temp_solution\n                    improved = True\n                    break\n\n    # If still no improvement, try removing the least valuable item\n    if not improved:\n        if np.sum(new_solution) > 0:  # Ensure at least one item is present\n            # Calculate value-to-weight ratios for both objectives\n            ratios1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n            ratios2 = value2_lst / (weight_lst + 1e-10)\n\n            # Find items to remove (lowest ratio in either objective)\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                item_to_remove = candidates[np.argmin(ratios1[candidates] + ratios2[candidates])]\n                new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.2841276270574803,
            1.6718941926956177
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    candidates = [sol for sol, obj in archive if obj[0] > 0 and obj[1] > 0]  # Filter non-zero solutions\n    if not candidates:\n        candidates = [sol for sol, obj in archive]  # Fallback to all if no non-zero\n\n    selected = random.choice(candidates) if candidates else archive[0][0]\n    new_solution = selected.copy()\n\n    # Hybrid local search strategy: combination of swap and greedy addition\n    n_items = len(new_solution)\n\n    # First, try to swap two items if it improves both objectives\n    improved = False\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] == new_solution[j]:\n            continue  # Skip if both are same state\n\n        # Create temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check feasibility and improvement\n        temp_weight = np.sum(weight_lst * temp_solution)\n        if temp_weight <= capacity:\n            temp_value1 = np.sum(value1_lst * temp_solution)\n            temp_value2 = np.sum(value2_lst * temp_solution)\n            original_value1 = np.sum(value1_lst * new_solution)\n            original_value2 = np.sum(value2_lst * new_solution)\n\n            if (temp_value1 > original_value1 and temp_value2 > original_value2):\n                new_solution = temp_solution\n                improved = True\n                break\n\n    # If no improvement from swaps, try greedy addition of items\n    if not improved:\n        for _ in range(5):  # Limit iterations\n            i = random.randint(0, n_items - 1)\n            if new_solution[i] == 1:\n                continue  # Skip if already included\n\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = np.sum(weight_lst * temp_solution)\n\n            if temp_weight <= capacity:\n                temp_value1 = np.sum(value1_lst * temp_solution)\n                temp_value2 = np.sum(value2_lst * temp_solution)\n                original_value1 = np.sum(value1_lst * new_solution)\n                original_value2 = np.sum(value2_lst * new_solution)\n\n                if (temp_value1 >= original_value1 and temp_value2 >= original_value2):\n                    new_solution = temp_solution\n                    improved = True\n                    break\n\n    # If still no improvement, try removing the least valuable item\n    if not improved:\n        if np.sum(new_solution) > 0:  # Ensure at least one item is present\n            # Calculate value-to-weight ratios for both objectives\n            ratios1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n            ratios2 = value2_lst / (weight_lst + 1e-10)\n\n            # Find items to remove (lowest ratio in either objective)\n            candidates = np.where(new_solution == 1)[0]\n            if len(candidates) > 0:\n                item_to_remove = candidates[np.argmin(ratios1[candidates] + ratios2[candidates])]\n                new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a probability weighted by its potential for improvement\n    weights = [1.0 / (1 + i) for i in range(len(archive))]  # Higher probability for earlier solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy: combination of random flip and greedy improvement\n    for _ in range(10):  # Number of iterations for local search\n        # Random flip: flip a random item\n        candidate_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[candidate_idx] = 1 - new_solution[candidate_idx]\n\n        # Check feasibility\n        new_weight = current_weight + (weight_lst[candidate_idx] if new_solution[candidate_idx] else -weight_lst[candidate_idx])\n        if new_weight > capacity:\n            new_solution[candidate_idx] = 1 - new_solution[candidate_idx]  # Revert if infeasible\n            continue\n\n        # Greedy improvement: try to add or remove items that improve both objectives\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                # Try adding item i\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    new_weight = current_weight + weight_lst[i]\n                    new_value1 = current_value1 + value1_lst[i]\n                    new_value2 = current_value2 + value2_lst[i]\n\n                    # Check if this addition is beneficial for both objectives\n                    if new_value1 > current_value1 and new_value2 > current_value2:\n                        current_value1, current_value2 = new_value1, new_value2\n                        current_weight = new_weight\n                        break\n                    else:\n                        new_solution[i] = 0  # Revert if not beneficial\n            else:\n                # Try removing item i\n                new_weight = current_weight - weight_lst[i]\n                new_value1 = current_value1 - value1_lst[i]\n                new_value2 = current_value2 - value2_lst[i]\n\n                # Check if this removal is beneficial for both objectives\n                if new_value1 > current_value1 and new_value2 > current_value2:\n                    new_solution[i] = 0\n                    current_value1, current_value2 = new_value1, new_value2\n                    current_weight = new_weight\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.41880797168478456,
            4.241196364164352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a probability weighted by its potential for improvement\n    weights = [1.0 / (1 + i) for i in range(len(archive))]  # Higher probability for earlier solutions\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy: combination of random flip and greedy improvement\n    for _ in range(10):  # Number of iterations for local search\n        # Random flip: flip a random item\n        candidate_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[candidate_idx] = 1 - new_solution[candidate_idx]\n\n        # Check feasibility\n        new_weight = current_weight + (weight_lst[candidate_idx] if new_solution[candidate_idx] else -weight_lst[candidate_idx])\n        if new_weight > capacity:\n            new_solution[candidate_idx] = 1 - new_solution[candidate_idx]  # Revert if infeasible\n            continue\n\n        # Greedy improvement: try to add or remove items that improve both objectives\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                # Try adding item i\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    new_weight = current_weight + weight_lst[i]\n                    new_value1 = current_value1 + value1_lst[i]\n                    new_value2 = current_value2 + value2_lst[i]\n\n                    # Check if this addition is beneficial for both objectives\n                    if new_value1 > current_value1 and new_value2 > current_value2:\n                        current_value1, current_value2 = new_value1, new_value2\n                        current_weight = new_weight\n                        break\n                    else:\n                        new_solution[i] = 0  # Revert if not beneficial\n            else:\n                # Try removing item i\n                new_weight = current_weight - weight_lst[i]\n                new_value1 = current_value1 - value1_lst[i]\n                new_value2 = current_value2 - value2_lst[i]\n\n                # Check if this removal is beneficial for both objectives\n                if new_value1 > current_value1 and new_value2 > current_value2:\n                    new_solution[i] = 0\n                    current_value1, current_value2 = new_value1, new_value2\n                    current_weight = new_weight\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution: prioritize solutions with high potential for improvement\n    # Potential is estimated by how close the solution is to the Pareto front and its diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 - (obj[0] + obj[1]) / (sum(archive[i][1]) + 1e-6) for i, (sol, obj) in enumerate(archive)], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid approach:\n    # 1. Randomly select a subset of items to consider for flipping\n    # 2. For each item, evaluate its potential contribution to both objectives\n    # 3. Flip items that improve at least one objective while maintaining feasibility\n\n    new_solution = base_solution.copy()\n    items_to_consider = np.random.choice(len(weight_lst), size=min(10, len(weight_lst)), replace=False)\n\n    for item in items_to_consider:\n        if new_solution[item] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Evaluate potential improvement using a weighted sum of objectives\n                weight = random.random()  # Random weight for balancing objectives\n                potential_improvement = weight * value1_lst[item] + (1 - weight) * value2_lst[item]\n                if potential_improvement > 0:\n                    new_solution[item] = 1\n                    current_weight = new_weight\n\n    # Additional local search: try to swap items between objectives\n    for _ in range(3):  # Limit the number of swaps to prevent excessive computation\n        # Select two items, one included and one excluded\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            item_in = random.choice(included_items)\n            item_out = random.choice(excluded_items)\n\n            # Check if swapping would maintain feasibility\n            new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n            if new_weight <= capacity:\n                # Evaluate the swap's potential improvement\n                weight = random.random()\n                improvement = (weight * (value1_lst[item_out] - value1_lst[item_in]) +\n                              (1 - weight) * (value2_lst[item_out] - value2_lst[item_in]))\n                if improvement > 0:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4234883737112437,
            1.4319631457328796
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution: prioritize solutions with high potential for improvement\n    # Potential is estimated by how close the solution is to the Pareto front and its diversity\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 - (obj[0] + obj[1]) / (sum(archive[i][1]) + 1e-6) for i, (sol, obj) in enumerate(archive)], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor solution using a hybrid approach:\n    # 1. Randomly select a subset of items to consider for flipping\n    # 2. For each item, evaluate its potential contribution to both objectives\n    # 3. Flip items that improve at least one objective while maintaining feasibility\n\n    new_solution = base_solution.copy()\n    items_to_consider = np.random.choice(len(weight_lst), size=min(10, len(weight_lst)), replace=False)\n\n    for item in items_to_consider:\n        if new_solution[item] == 1:\n            # Consider removing the item\n            new_weight = current_weight - weight_lst[item]\n            if new_weight <= capacity:\n                new_solution[item] = 0\n                current_weight = new_weight\n        else:\n            # Consider adding the item\n            new_weight = current_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Evaluate potential improvement using a weighted sum of objectives\n                weight = random.random()  # Random weight for balancing objectives\n                potential_improvement = weight * value1_lst[item] + (1 - weight) * value2_lst[item]\n                if potential_improvement > 0:\n                    new_solution[item] = 1\n                    current_weight = new_weight\n\n    # Additional local search: try to swap items between objectives\n    for _ in range(3):  # Limit the number of swaps to prevent excessive computation\n        # Select two items, one included and one excluded\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            item_in = random.choice(included_items)\n            item_out = random.choice(excluded_items)\n\n            # Check if swapping would maintain feasibility\n            new_weight = current_weight - weight_lst[item_in] + weight_lst[item_out]\n            if new_weight <= capacity:\n                # Evaluate the swap's potential improvement\n                weight = random.random()\n                improvement = (weight * (value1_lst[item_out] - value1_lst[item_in]) +\n                              (1 - weight) * (value2_lst[item_out] - value2_lst[item_in]))\n                if improvement > 0:\n                    new_solution[item_in] = 0\n                    new_solution[item_out] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # We prioritize solutions that are on the Pareto front and have high marginal gains\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = current_obj[0]\n    current_value2 = current_obj[1]\n\n    # Step 3: Generate candidate neighbors using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy: Randomly select a subset of items to flip (add/remove) based on their marginal value\n    # We consider both objectives and weight constraints\n    num_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = random.sample(range(n_items), num_flips)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Additional refinement: If no improvement, try a more aggressive flip\n    if np.array_equal(new_solution, base_solution):\n        # Find the item with the highest marginal value for either objective\n        marginal_values = np.zeros(n_items)\n        for i in range(n_items):\n            if base_solution[i] == 1:\n                marginal_values[i] = -(value1_lst[i] + value2_lst[i])  # Negative for removal\n            else:\n                marginal_values[i] = value1_lst[i] + value2_lst[i]    # Positive for addition\n\n        # Select the item with the highest marginal value\n        best_idx = np.argmax(marginal_values)\n        if base_solution[best_idx] == 1:\n            if current_weight - weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 0\n        else:\n            if current_weight + weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.4149841568989034,
            1.230079174041748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # We prioritize solutions that are on the Pareto front and have high marginal gains\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Step 2: Calculate current total weight and values\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = current_obj[0]\n    current_value2 = current_obj[1]\n\n    # Step 3: Generate candidate neighbors using a hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy: Randomly select a subset of items to flip (add/remove) based on their marginal value\n    # We consider both objectives and weight constraints\n    num_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = random.sample(range(n_items), num_flips)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Additional refinement: If no improvement, try a more aggressive flip\n    if np.array_equal(new_solution, base_solution):\n        # Find the item with the highest marginal value for either objective\n        marginal_values = np.zeros(n_items)\n        for i in range(n_items):\n            if base_solution[i] == 1:\n                marginal_values[i] = -(value1_lst[i] + value2_lst[i])  # Negative for removal\n            else:\n                marginal_values[i] = value1_lst[i] + value2_lst[i]    # Positive for addition\n\n        # Select the item with the highest marginal value\n        best_idx = np.argmax(marginal_values)\n        if base_solution[best_idx] == 1:\n            if current_weight - weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 0\n        else:\n            if current_weight + weight_lst[best_idx] <= capacity:\n                new_solution[best_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution based on potential for improvement\n    # We prioritize solutions that are not too close to the boundary in either objective\n    # and have a good balance between the two objectives\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions (shouldn't happen in a proper archive)\n        # Calculate potential improvement score (simplified)\n        potential = (v1 + v2) / (1 + total_weight)  # Higher is better\n        candidates.append((potential, sol))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Sort candidates by potential and select top 30% for random choice\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected_sol = random.choice(top_candidates)[1].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # First, try to add items that have high marginal value\n    # Calculate marginal values\n    marginal_value1 = value1_lst * (1 - selected_sol)\n    marginal_value2 = value2_lst * (1 - selected_sol)\n    marginal_weight = weight_lst * (1 - selected_sol)\n\n    # Normalize marginal values\n    total_weight = np.sum(weight_lst * selected_sol)\n    remaining_capacity = capacity - total_weight\n\n    if remaining_capacity > 0:\n        # Select items with highest combined marginal value-to-weight ratio\n        ratios = (marginal_value1 + marginal_value2) / (marginal_weight + 1e-6)\n        candidate_indices = np.argsort(ratios)[::-1]\n\n        for idx in candidate_indices:\n            if marginal_weight[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= marginal_weight[idx]\n\n    # Then, try to remove items with low marginal contribution\n    # Calculate marginal contribution for items in the solution\n    in_solution = selected_sol == 1\n    if np.any(in_solution):\n        marginal_contrib1 = value1_lst * in_solution\n        marginal_contrib2 = value2_lst * in_solution\n        marginal_contrib_weight = weight_lst * in_solution\n\n        # Select items with lowest combined marginal contribution-to-weight ratio\n        contrib_ratios = (marginal_contrib1 + marginal_contrib2) / (marginal_contrib_weight + 1e-6)\n        candidate_indices = np.argsort(contrib_ratios)\n\n        for idx in candidate_indices:\n            if in_solution[idx]:\n                new_solution[idx] = 0\n                # Check feasibility\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight <= capacity:\n                    in_solution[idx] = 0\n                else:\n                    new_solution[idx] = 1  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.9071560006117696,
            6.4616846442222595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Step 1: Select a promising solution based on potential for improvement\n    # We prioritize solutions that are not too close to the boundary in either objective\n    # and have a good balance between the two objectives\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            continue  # Skip infeasible solutions (shouldn't happen in a proper archive)\n        # Calculate potential improvement score (simplified)\n        potential = (v1 + v2) / (1 + total_weight)  # Higher is better\n        candidates.append((potential, sol))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Sort candidates by potential and select top 30% for random choice\n    candidates.sort(reverse=True, key=lambda x: x[0])\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected_sol = random.choice(top_candidates)[1].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # First, try to add items that have high marginal value\n    # Calculate marginal values\n    marginal_value1 = value1_lst * (1 - selected_sol)\n    marginal_value2 = value2_lst * (1 - selected_sol)\n    marginal_weight = weight_lst * (1 - selected_sol)\n\n    # Normalize marginal values\n    total_weight = np.sum(weight_lst * selected_sol)\n    remaining_capacity = capacity - total_weight\n\n    if remaining_capacity > 0:\n        # Select items with highest combined marginal value-to-weight ratio\n        ratios = (marginal_value1 + marginal_value2) / (marginal_weight + 1e-6)\n        candidate_indices = np.argsort(ratios)[::-1]\n\n        for idx in candidate_indices:\n            if marginal_weight[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= marginal_weight[idx]\n\n    # Then, try to remove items with low marginal contribution\n    # Calculate marginal contribution for items in the solution\n    in_solution = selected_sol == 1\n    if np.any(in_solution):\n        marginal_contrib1 = value1_lst * in_solution\n        marginal_contrib2 = value2_lst * in_solution\n        marginal_contrib_weight = weight_lst * in_solution\n\n        # Select items with lowest combined marginal contribution-to-weight ratio\n        contrib_ratios = (marginal_contrib1 + marginal_contrib2) / (marginal_contrib_weight + 1e-6)\n        candidate_indices = np.argsort(contrib_ratios)\n\n        for idx in candidate_indices:\n            if in_solution[idx]:\n                new_solution[idx] = 0\n                # Check feasibility\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight <= capacity:\n                    in_solution[idx] = 0\n                else:\n                    new_solution[idx] = 1  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and solution density\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        density = np.sum(sol) / len(sol) if len(sol) > 0 else 0\n        # Score combines objective values and solution density to prioritize diverse and potentially improvable solutions\n        score = (obj[0] + obj[1]) * (1 + density)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of bit-flip and swap\n    new_solution = base_solution.copy()\n\n    # First, perform a bit-flip operation (flip one random bit)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        new_solution[flip_idx] = 0\n\n    # Then perform a swap operation (swap two items if feasible)\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        swap_out = np.random.choice(one_indices)\n        swap_in = np.random.choice(zero_indices)\n\n        # Check feasibility before swapping\n        current_weight = np.sum(new_solution * weight_lst)\n        delta_weight = weight_lst[swap_in] - weight_lst[swap_out]\n\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n\n    # Ensure solution is feasible (fallback if needed)\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove heaviest items until feasible\n        items_sorted = np.argsort(weight_lst[new_solution == 1] * -1)  # Descending order\n        for idx in items_sorted:\n            if total_weight <= capacity:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5381867861863157,
            2.1285969018936157
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and solution density\n    scores = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        density = np.sum(sol) / len(sol) if len(sol) > 0 else 0\n        # Score combines objective values and solution density to prioritize diverse and potentially improvable solutions\n        score = (obj[0] + obj[1]) * (1 + density)\n        scores.append(score)\n\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of bit-flip and swap\n    new_solution = base_solution.copy()\n\n    # First, perform a bit-flip operation (flip one random bit)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        new_solution[flip_idx] = 0\n\n    # Then perform a swap operation (swap two items if feasible)\n    zero_indices = np.where(new_solution == 0)[0]\n    one_indices = np.where(new_solution == 1)[0]\n\n    if len(zero_indices) > 0 and len(one_indices) > 0:\n        swap_out = np.random.choice(one_indices)\n        swap_in = np.random.choice(zero_indices)\n\n        # Check feasibility before swapping\n        current_weight = np.sum(new_solution * weight_lst)\n        delta_weight = weight_lst[swap_in] - weight_lst[swap_out]\n\n        if current_weight + delta_weight <= capacity:\n            new_solution[swap_out] = 0\n            new_solution[swap_in] = 1\n\n    # Ensure solution is feasible (fallback if needed)\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove heaviest items until feasible\n        items_sorted = np.argsort(weight_lst[new_solution == 1] * -1)  # Descending order\n        for idx in items_sorted:\n            if total_weight <= capacity:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with higher potential for improvement\n    # Here, we select a solution that is neither too full nor too empty\n    selected_idx = random.choices(range(len(archive)), weights=[1 - np.mean(sol[0]) for sol in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios for hybrid selection\n    combined_ratio = 0.5 * ratio1 + 0.5 * ratio2\n\n    # Identify items that could be flipped (either included or excluded)\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append(i)\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append(i)\n\n    if not candidates:\n        return base_solution.copy()\n\n    # Select a candidate based on the combined ratio\n    selected_item = random.choices(candidates, weights=[combined_ratio[i] for i in candidates])[0]\n\n    # Flip the selected item\n    new_solution = base_solution.copy()\n    new_solution[selected_item] = 1 - new_solution[selected_item]\n\n    return new_solution\n\n",
        "score": [
            -0.8706414434233223,
            2.6330073177814484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with higher potential for improvement\n    # Here, we select a solution that is neither too full nor too empty\n    selected_idx = random.choices(range(len(archive)), weights=[1 - np.mean(sol[0]) for sol in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios for hybrid selection\n    combined_ratio = 0.5 * ratio1 + 0.5 * ratio2\n\n    # Identify items that could be flipped (either included or excluded)\n    candidates = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if excluding this item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append(i)\n        else:\n            # Check if including this item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append(i)\n\n    if not candidates:\n        return base_solution.copy()\n\n    # Select a candidate based on the combined ratio\n    selected_item = random.choices(candidates, weights=[combined_ratio[i] for i in candidates])[0]\n\n    # Flip the selected item\n    new_solution = base_solution.copy()\n    new_solution[selected_item] = 1 - new_solution[selected_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly but biased towards better solutions)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Prefer solutions with higher combined value\n        values = np.array([sum(archive[i][1]) for i in range(len(archive))])\n        probs = values / np.sum(values)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a random subset of items and then greedily improve\n    n_items = len(new_solution)\n    if n_items == 0:\n        return new_solution\n\n    # Step 1: Randomly flip a subset of items (10% of items)\n    flip_indices = np.random.choice(n_items, size=max(1, n_items // 10), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flip\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(excess_indices) > 0:\n            remove_idx = np.random.choice(excess_indices)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            excess_indices = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement - add items with highest marginal value ratio\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n\n    for idx in remaining_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Calculate marginal value ratios for both objectives\n            marginal1 = value1_lst[idx] / weight_lst[idx]\n            marginal2 = value2_lst[idx] / weight_lst[idx]\n            # Combine objectives with equal weight (can be adjusted)\n            combined_marginal = marginal1 + marginal2\n            if combined_marginal > 0:  # Only add if positive contribution\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Optional - Remove low-value items to free up capacity\n    selected_items = np.where(new_solution == 1)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n    for idx in selected_items:\n        # If removing this item doesn't violate capacity and reduces both objectives\n        if current_weight - weight_lst[idx] >= 0:\n            if value1_lst[idx] < 0 or value2_lst[idx] < 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.39457295833530526,
            4.431834846735001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly but biased towards better solutions)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Prefer solutions with higher combined value\n        values = np.array([sum(archive[i][1]) for i in range(len(archive))])\n        probs = values / np.sum(values)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip a random subset of items and then greedily improve\n    n_items = len(new_solution)\n    if n_items == 0:\n        return new_solution\n\n    # Step 1: Randomly flip a subset of items (10% of items)\n    flip_indices = np.random.choice(n_items, size=max(1, n_items // 10), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flip\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(excess_indices) > 0:\n            remove_idx = np.random.choice(excess_indices)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n            excess_indices = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement - add items with highest marginal value ratio\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n\n    for idx in remaining_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Calculate marginal value ratios for both objectives\n            marginal1 = value1_lst[idx] / weight_lst[idx]\n            marginal2 = value2_lst[idx] / weight_lst[idx]\n            # Combine objectives with equal weight (can be adjusted)\n            combined_marginal = marginal1 + marginal2\n            if combined_marginal > 0:  # Only add if positive contribution\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Optional - Remove low-value items to free up capacity\n    selected_items = np.where(new_solution == 1)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n    for idx in selected_items:\n        # If removing this item doesn't violate capacity and reduces both objectives\n        if current_weight - weight_lst[idx] >= 0:\n            if value1_lst[idx] < 0 or value2_lst[idx] < 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * (np.sum(value1_lst[x[0].astype(bool)]) + np.sum(value2_lst[x[0].astype(bool)])))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution.astype(bool)])\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # 1. Randomly select a subset of items to flip\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        flip_candidates = new_solution[flip_indices]\n\n        # 2. Evaluate potential flips\n        best_improvement = 0\n        best_flip = None\n\n        for i in flip_indices:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1 - temp_solution[i]  # Flip the bit\n            temp_weight = np.sum(weight_lst[temp_solution.astype(bool)])\n\n            if temp_weight <= capacity:\n                # Calculate improvement in both objectives\n                improvement1 = np.sum(value1_lst[temp_solution.astype(bool)]) - np.sum(value1_lst[new_solution.astype(bool)])\n                improvement2 = np.sum(value2_lst[temp_solution.astype(bool)]) - np.sum(value2_lst[new_solution.astype(bool)])\n\n                # Weighted improvement for multi-objective optimization\n                total_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_flip = i\n\n        # 3. Apply the best flip if it improves the solution\n        if best_flip is not None and best_improvement > 0:\n            new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # 4. If no improvement found, perform a random walk to escape local optima\n    if np.array_equal(new_solution, base_solution):\n        # Find a random item to flip that keeps the solution feasible\n        feasible_indices = [i for i in range(len(new_solution)) if\n                           (new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity) or\n                           (new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity)]\n\n        if feasible_indices:\n            flip_index = np.random.choice(feasible_indices)\n            new_solution[flip_index] = 1 - new_solution[flip_index]\n\n    return new_solution\n\n",
        "score": [
            -0.8025767128514536,
            9.666461646556854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: np.sum(x[0]) * (np.sum(value1_lst[x[0].astype(bool)]) + np.sum(value2_lst[x[0].astype(bool)])))\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution.astype(bool)])\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # 1. Randomly select a subset of items to flip\n        flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n        flip_candidates = new_solution[flip_indices]\n\n        # 2. Evaluate potential flips\n        best_improvement = 0\n        best_flip = None\n\n        for i in flip_indices:\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1 - temp_solution[i]  # Flip the bit\n            temp_weight = np.sum(weight_lst[temp_solution.astype(bool)])\n\n            if temp_weight <= capacity:\n                # Calculate improvement in both objectives\n                improvement1 = np.sum(value1_lst[temp_solution.astype(bool)]) - np.sum(value1_lst[new_solution.astype(bool)])\n                improvement2 = np.sum(value2_lst[temp_solution.astype(bool)]) - np.sum(value2_lst[new_solution.astype(bool)])\n\n                # Weighted improvement for multi-objective optimization\n                total_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_flip = i\n\n        # 3. Apply the best flip if it improves the solution\n        if best_flip is not None and best_improvement > 0:\n            new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # 4. If no improvement found, perform a random walk to escape local optima\n    if np.array_equal(new_solution, base_solution):\n        # Find a random item to flip that keeps the solution feasible\n        feasible_indices = [i for i in range(len(new_solution)) if\n                           (new_solution[i] == 1 and (current_weight - weight_lst[i]) <= capacity) or\n                           (new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity)]\n\n        if feasible_indices:\n            flip_index = np.random.choice(feasible_indices)\n            new_solution[flip_index] = 1 - new_solution[flip_index]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine random swaps with greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Perform a number of random swaps (up to 10% of items)\n    max_swaps = max(1, int(0.1 * n_items))\n    for _ in range(max_swaps):\n        # Select two distinct random items\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate potential changes\n        delta_weight = (weight_lst[i] - weight_lst[j]) * (new_solution[i] - new_solution[j])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap if feasible\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = new_weight\n\n    # Additional greedy improvement: try to add items with highest value ratios\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value ratios for objectives\n        value_ratio1 = value1_lst / (weight_lst + 1e-10)\n        value_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios with random weights for diversity\n        combined_ratio = random.uniform(0.3, 0.7) * value_ratio1 + (1 - random.uniform(0.3, 0.7)) * value_ratio2\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.336019922581966,
            1.946839600801468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine random swaps with greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Perform a number of random swaps (up to 10% of items)\n    max_swaps = max(1, int(0.1 * n_items))\n    for _ in range(max_swaps):\n        # Select two distinct random items\n        i, j = random.sample(range(n_items), 2)\n\n        # Calculate potential changes\n        delta_weight = (weight_lst[i] - weight_lst[j]) * (new_solution[i] - new_solution[j])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap if feasible\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight = new_weight\n\n    # Additional greedy improvement: try to add items with highest value ratios\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value ratios for objectives\n        value_ratio1 = value1_lst / (weight_lst + 1e-10)\n        value_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios with random weights for diversity\n        combined_ratio = random.uniform(0.3, 0.7) * value_ratio1 + (1 - random.uniform(0.3, 0.7)) * value_ratio2\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.dot(sol, weight_lst)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Intelligent selection: prioritize solutions with high marginal gains\n    best_candidate = None\n    best_score = -1\n    for sol in candidates:\n        total_weight = np.dot(sol, weight_lst)\n        remaining_capacity = capacity - total_weight\n        # Calculate potential marginal gains for both objectives\n        potential_gains = np.where(sol == 0, weight_lst <= remaining_capacity, False)\n        marginal_value1 = np.sum(value1_lst * potential_gains)\n        marginal_value2 = np.sum(value2_lst * potential_gains)\n        score = marginal_value1 + marginal_value2  # Combined score\n        if score > best_score:\n            best_score = score\n            best_candidate = sol\n\n    base_solution = best_candidate.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of flip and swap\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Random flip with weight-based probability\n    flip_candidates = np.where(new_solution == 0)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = random.choice(flip_candidates)\n        if np.dot(new_solution, weight_lst) + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    # Step 2: Random swap with value-based probability\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        idx1, idx2 = random.sample(list(swap_candidates), 2)\n        # Calculate weight difference\n        weight_diff = weight_lst[idx1] - weight_lst[idx2]\n        current_weight = np.dot(new_solution, weight_lst)\n        if (weight_diff <= 0) or (current_weight + weight_diff <= capacity):\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Step 3: Random removal to create space\n    remove_candidates = np.where(new_solution == 1)[0]\n    if len(remove_candidates) > 0:\n        remove_idx = random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n\n    # Ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight = np.dot(new_solution, weight_lst)\n\n    return new_solution\n\n",
        "score": [
            -0.8394215466690482,
            4.974530100822449
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.dot(sol, weight_lst)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Intelligent selection: prioritize solutions with high marginal gains\n    best_candidate = None\n    best_score = -1\n    for sol in candidates:\n        total_weight = np.dot(sol, weight_lst)\n        remaining_capacity = capacity - total_weight\n        # Calculate potential marginal gains for both objectives\n        potential_gains = np.where(sol == 0, weight_lst <= remaining_capacity, False)\n        marginal_value1 = np.sum(value1_lst * potential_gains)\n        marginal_value2 = np.sum(value2_lst * potential_gains)\n        score = marginal_value1 + marginal_value2  # Combined score\n        if score > best_score:\n            best_score = score\n            best_candidate = sol\n\n    base_solution = best_candidate.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of flip and swap\n    n_items = len(weight_lst)\n    if n_items < 2:\n        return new_solution\n\n    # Step 1: Random flip with weight-based probability\n    flip_candidates = np.where(new_solution == 0)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = random.choice(flip_candidates)\n        if np.dot(new_solution, weight_lst) + weight_lst[flip_idx] <= capacity:\n            new_solution[flip_idx] = 1\n\n    # Step 2: Random swap with value-based probability\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        idx1, idx2 = random.sample(list(swap_candidates), 2)\n        # Calculate weight difference\n        weight_diff = weight_lst[idx1] - weight_lst[idx2]\n        current_weight = np.dot(new_solution, weight_lst)\n        if (weight_diff <= 0) or (current_weight + weight_diff <= capacity):\n            new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Step 3: Random removal to create space\n    remove_candidates = np.where(new_solution == 1)[0]\n    if len(remove_candidates) > 0:\n        remove_idx = random.choice(remove_candidates)\n        new_solution[remove_idx] = 0\n\n    # Ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight = np.dot(new_solution, weight_lst)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 118,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Identify solutions with potential for improvement by checking their neighbors\n    candidate_indices = []\n    for i, (sol, _) in enumerate(archive):\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity * 0.9:  # Solutions with room for more items\n            candidate_indices.append(i)\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    # Randomly select a candidate solution\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine item swaps and perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip items to explore nearby solutions\n    for _ in range(3):  # Number of perturbations\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n        else:\n            # Ensure adding the item doesn't exceed capacity\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Step 2: Objective-aware swaps to improve Pareto front\n    # Identify items that can be swapped to improve both objectives\n    for _ in range(2):  # Number of swaps\n        # Find items that are in the solution and can be replaced\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove and a random item to add\n            remove_idx = random.choice(in_items)\n            add_idx = random.choice(out_items)\n\n            # Check feasibility of swap\n            if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.30753758037238044,
            2.26808962225914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Identify solutions with potential for improvement by checking their neighbors\n    candidate_indices = []\n    for i, (sol, _) in enumerate(archive):\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity * 0.9:  # Solutions with room for more items\n            candidate_indices.append(i)\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    # Randomly select a candidate solution\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine item swaps and perturbations\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip items to explore nearby solutions\n    for _ in range(3):  # Number of perturbations\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[flip_idx] == 1:\n            new_solution[flip_idx] = 0\n        else:\n            # Ensure adding the item doesn't exceed capacity\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n\n    # Step 2: Objective-aware swaps to improve Pareto front\n    # Identify items that can be swapped to improve both objectives\n    for _ in range(2):  # Number of swaps\n        # Find items that are in the solution and can be replaced\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove and a random item to add\n            remove_idx = random.choice(in_items)\n            add_idx = random.choice(out_items)\n\n            # Check feasibility of swap\n            if (current_weight - weight_lst[remove_idx] + weight_lst[add_idx]) <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 119,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest hypervolume contribution (simplified as the sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    hypervolume = np.array([sum(obj) for obj in archive_objectives])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Random subset flipping (flip a random subset of items)\n    subset_size = min(5, len(new_solution))\n    flip_indices = np.random.choice(len(new_solution), subset_size, replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Value-to-weight ratio-based swap (swap items with high value-to-weight ratios)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Calculate value-to-weight ratios for both objectives\n        ratio1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n        ratio2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Combine ratios to prioritize items with high value-to-weight in either objective\n        combined_ratio = ratio1 + ratio2\n        best_excluded = excluded_items[np.argmax(combined_ratio)]\n\n        # Find the worst included item (lowest combined value-to-weight ratio)\n        ratio1_included = value1_lst[included_items] / weight_lst[included_items]\n        ratio2_included = value2_lst[included_items] / weight_lst[included_items]\n        combined_ratio_included = ratio1_included + ratio2_included\n        worst_included = included_items[np.argmin(combined_ratio_included)]\n\n        # Check if swapping is feasible\n        if (current_weight - weight_lst[worst_included] + weight_lst[best_excluded]) <= capacity:\n            new_solution[worst_included] = 0\n            new_solution[best_excluded] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.30193214148037983,
            1.476536124944687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest hypervolume contribution (simplified as the sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    hypervolume = np.array([sum(obj) for obj in archive_objectives])\n    selected_idx = np.argmax(hypervolume)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Random subset flipping (flip a random subset of items)\n    subset_size = min(5, len(new_solution))\n    flip_indices = np.random.choice(len(new_solution), subset_size, replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Value-to-weight ratio-based swap (swap items with high value-to-weight ratios)\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    if len(included_items) > 0 and len(excluded_items) > 0:\n        # Calculate value-to-weight ratios for both objectives\n        ratio1 = value1_lst[excluded_items] / weight_lst[excluded_items]\n        ratio2 = value2_lst[excluded_items] / weight_lst[excluded_items]\n\n        # Combine ratios to prioritize items with high value-to-weight in either objective\n        combined_ratio = ratio1 + ratio2\n        best_excluded = excluded_items[np.argmax(combined_ratio)]\n\n        # Find the worst included item (lowest combined value-to-weight ratio)\n        ratio1_included = value1_lst[included_items] / weight_lst[included_items]\n        ratio2_included = value2_lst[included_items] / weight_lst[included_items]\n        combined_ratio_included = ratio1_included + ratio2_included\n        worst_included = included_items[np.argmin(combined_ratio_included)]\n\n        # Check if swapping is feasible\n        if (current_weight - weight_lst[worst_included] + weight_lst[best_excluded]) <= capacity:\n            new_solution[worst_included] = 0\n            new_solution[best_excluded] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 120,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front\n    # and have a good balance between the two objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the crowding distance to identify less crowded solutions\n    crowding_distances = np.zeros(len(archive_objectives))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive_objectives)-1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] - archive_objectives[sorted_indices[j-1]][i])\n\n    # Select solutions with high crowding distance (less crowded regions)\n    potential_indices = np.where(crowding_distances > np.percentile(crowding_distances, 75))[0]\n    if len(potential_indices) == 0:\n        potential_indices = np.arange(len(archive_solutions))\n\n    selected_idx = random.choice(potential_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Strategy 1: Swap items with high marginal utility\n    if random.random() < 0.5:\n        # Calculate marginal utility for each item\n        marginal_utils = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                # Utility if removed: value1 + value2 - weight\n                util = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                marginal_utils.append((util, i, -1))  # -1 indicates removal\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    # Utility if added: value1 + value2 + weight\n                    util = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                    marginal_utils.append((util, i, 1))  # 1 indicates addition\n\n        if marginal_utils:\n            # Select top 3 items with highest marginal utility\n            marginal_utils.sort(reverse=True, key=lambda x: x[0])\n            selected_items = [x[1] for x in marginal_utils[:min(3, len(marginal_utils))]]\n            for i in selected_items:\n                new_solution[i] = 1 - new_solution[i]  # Flip the bit\n    else:\n        # Strategy 2: Random flip with bias towards improving both objectives\n        # Calculate the average value per weight for both objectives\n        avg_value1_per_weight = np.sum(value1_lst) / (np.sum(weight_lst) + 1e-6)\n        avg_value2_per_weight = np.sum(value2_lst) / (np.sum(weight_lst) + 1e-6)\n\n        # Flip items with probability proportional to their value/weight ratio\n        for i in range(len(new_solution)):\n            if random.random() < 0.1:  # Base probability\n                # Calculate the combined value/weight ratio\n                value_ratio = (value1_lst[i] / (weight_lst[i] + 1e-6)) / avg_value1_per_weight + \\\n                              (value2_lst[i] / (weight_lst[i] + 1e-6)) / avg_value2_per_weight\n                if random.random() < value_ratio:\n                    # Check feasibility before flipping\n                    if new_solution[i] == 1 or (current_weight + weight_lst[i] <= capacity):\n                        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure the solution is feasible\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        excess_weight = current_weight - capacity\n        items_in_solution = np.where(new_solution == 1)[0]\n        np.random.shuffle(items_in_solution)\n        for i in items_in_solution:\n            if excess_weight <= 0:\n                break\n            excess_weight -= weight_lst[i]\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.6037254480294119,
            2.7604015469551086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front\n    # and have a good balance between the two objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the crowding distance to identify less crowded solutions\n    crowding_distances = np.zeros(len(archive_objectives))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive_objectives)-1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] - archive_objectives[sorted_indices[j-1]][i])\n\n    # Select solutions with high crowding distance (less crowded regions)\n    potential_indices = np.where(crowding_distances > np.percentile(crowding_distances, 75))[0]\n    if len(potential_indices) == 0:\n        potential_indices = np.arange(len(archive_solutions))\n\n    selected_idx = random.choice(potential_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Strategy 1: Swap items with high marginal utility\n    if random.random() < 0.5:\n        # Calculate marginal utility for each item\n        marginal_utils = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                # Utility if removed: value1 + value2 - weight\n                util = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                marginal_utils.append((util, i, -1))  # -1 indicates removal\n            else:\n                if current_weight + weight_lst[i] <= capacity:\n                    # Utility if added: value1 + value2 + weight\n                    util = (value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6)\n                    marginal_utils.append((util, i, 1))  # 1 indicates addition\n\n        if marginal_utils:\n            # Select top 3 items with highest marginal utility\n            marginal_utils.sort(reverse=True, key=lambda x: x[0])\n            selected_items = [x[1] for x in marginal_utils[:min(3, len(marginal_utils))]]\n            for i in selected_items:\n                new_solution[i] = 1 - new_solution[i]  # Flip the bit\n    else:\n        # Strategy 2: Random flip with bias towards improving both objectives\n        # Calculate the average value per weight for both objectives\n        avg_value1_per_weight = np.sum(value1_lst) / (np.sum(weight_lst) + 1e-6)\n        avg_value2_per_weight = np.sum(value2_lst) / (np.sum(weight_lst) + 1e-6)\n\n        # Flip items with probability proportional to their value/weight ratio\n        for i in range(len(new_solution)):\n            if random.random() < 0.1:  # Base probability\n                # Calculate the combined value/weight ratio\n                value_ratio = (value1_lst[i] / (weight_lst[i] + 1e-6)) / avg_value1_per_weight + \\\n                              (value2_lst[i] / (weight_lst[i] + 1e-6)) / avg_value2_per_weight\n                if random.random() < value_ratio:\n                    # Check feasibility before flipping\n                    if new_solution[i] == 1 or (current_weight + weight_lst[i] <= capacity):\n                        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure the solution is feasible\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        excess_weight = current_weight - capacity\n        items_in_solution = np.where(new_solution == 1)[0]\n        np.random.shuffle(items_in_solution)\n        for i in items_in_solution:\n            if excess_weight <= 0:\n                break\n            excess_weight -= weight_lst[i]\n            new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with a higher chance for those with lower total weight (more room for improvement)\n    weights = [np.sum(weight_lst[sol[0] == 1]) for sol in archive]\n    probabilities = [1 - (w / capacity) for w in weights]  # Higher probability for solutions with lower total weight\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping a random subset of bits\n    new_solution = base_solution.copy()\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Only flip to 1 if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Apply a greedy improvement step: flip bits that improve both objectives\n    for _ in range(2):  # Limit the number of improvements to avoid excessive computation\n        improved = False\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                # Try removing item i\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    # Calculate potential improvement in both objectives\n                    delta_value1 = -value1_lst[i]\n                    delta_value2 = -value2_lst[i]\n                    # If removing improves both objectives, do it\n                    if delta_value1 < 0 and delta_value2 < 0:\n                        new_solution = temp_solution\n                        improved = True\n                        break\n            else:\n                # Try adding item i\n                if current_weight + weight_lst[i] <= capacity:\n                    temp_solution = new_solution.copy()\n                    temp_solution[i] = 1\n                    # Calculate potential improvement in both objectives\n                    delta_value1 = value1_lst[i]\n                    delta_value2 = value2_lst[i]\n                    # If adding improves both objectives, do it\n                    if delta_value1 > 0 and delta_value2 > 0:\n                        new_solution = temp_solution\n                        current_weight += weight_lst[i]\n                        improved = True\n                        break\n        if not improved:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8359713874299192,
            2.9527775645256042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with a higher chance for those with lower total weight (more room for improvement)\n    weights = [np.sum(weight_lst[sol[0] == 1]) for sol in archive]\n    probabilities = [1 - (w / capacity) for w in weights]  # Higher probability for solutions with lower total weight\n    probabilities = [p / sum(probabilities) for p in probabilities]  # Normalize\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Generate a neighbor by flipping a random subset of bits\n    new_solution = base_solution.copy()\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            # Only flip to 1 if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Apply a greedy improvement step: flip bits that improve both objectives\n    for _ in range(2):  # Limit the number of improvements to avoid excessive computation\n        improved = False\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                # Try removing item i\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 0\n                temp_weight = np.sum(weight_lst[temp_solution == 1])\n                if temp_weight <= capacity:\n                    # Calculate potential improvement in both objectives\n                    delta_value1 = -value1_lst[i]\n                    delta_value2 = -value2_lst[i]\n                    # If removing improves both objectives, do it\n                    if delta_value1 < 0 and delta_value2 < 0:\n                        new_solution = temp_solution\n                        improved = True\n                        break\n            else:\n                # Try adding item i\n                if current_weight + weight_lst[i] <= capacity:\n                    temp_solution = new_solution.copy()\n                    temp_solution[i] = 1\n                    # Calculate potential improvement in both objectives\n                    delta_value1 = value1_lst[i]\n                    delta_value2 = value2_lst[i]\n                    # If adding improves both objectives, do it\n                    if delta_value1 > 0 and delta_value2 > 0:\n                        new_solution = temp_solution\n                        current_weight += weight_lst[i]\n                        improved = True\n                        break\n        if not improved:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 122,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Potential is defined as the ratio of the sum of the two objectives to the total weight\n    potentials = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight == 0:\n            potential = 0.0\n        else:\n            potential = (obj[0] + obj[1]) / total_weight\n        potentials.append(potential)\n\n    # Normalize potentials to create a probability distribution\n    if sum(potentials) == 0:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        probs = [p / sum(potentials) for p in potentials]\n\n    selected_idx = random.choices(range(len(archive)), weights=probs, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Random perturbation: flip a random subset of items\n    num_items = len(weight_lst)\n    perturbation_size = min(3, num_items)  # Limit perturbation size for efficiency\n    flip_indices = random.sample(range(num_items), perturbation_size)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # 2. Greedy improvement: evaluate flipping each item and keep the best feasible improvement\n    best_improvement = 0.0\n    best_index = -1\n    current_weight = np.sum(weight_lst * new_solution)\n\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Try removing item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                improvement = -(value1_lst[idx] + value2_lst[idx])\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_index = idx\n        else:\n            # Try adding item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                improvement = (value1_lst[idx] + value2_lst[idx])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_index = idx\n\n    if best_index != -1:\n        new_solution[best_index] = 1 - new_solution[best_index]\n\n    return new_solution\n\n",
        "score": [
            -0.3767797024935632,
            2.182316690683365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # Potential is defined as the ratio of the sum of the two objectives to the total weight\n    potentials = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight == 0:\n            potential = 0.0\n        else:\n            potential = (obj[0] + obj[1]) / total_weight\n        potentials.append(potential)\n\n    # Normalize potentials to create a probability distribution\n    if sum(potentials) == 0:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        probs = [p / sum(potentials) for p in potentials]\n\n    selected_idx = random.choices(range(len(archive)), weights=probs, k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Random perturbation: flip a random subset of items\n    num_items = len(weight_lst)\n    perturbation_size = min(3, num_items)  # Limit perturbation size for efficiency\n    flip_indices = random.sample(range(num_items), perturbation_size)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # 2. Greedy improvement: evaluate flipping each item and keep the best feasible improvement\n    best_improvement = 0.0\n    best_index = -1\n    current_weight = np.sum(weight_lst * new_solution)\n\n    for idx in range(num_items):\n        if new_solution[idx] == 1:\n            # Try removing item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                improvement = -(value1_lst[idx] + value2_lst[idx])\n                if improvement < best_improvement:\n                    best_improvement = improvement\n                    best_index = idx\n        else:\n            # Try adding item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                improvement = (value1_lst[idx] + value2_lst[idx])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_index = idx\n\n    if best_index != -1:\n        new_solution[best_index] = 1 - new_solution[best_index]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 123,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution that is not on the extreme Pareto front (has potential for improvement)\n    if len(archive) > 2:\n        # Sort solutions by the sum of objectives to find less extreme ones\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution in the middle (not too extreme)\n        candidate_indices = range(1, len(archive_sorted)-1)\n        if candidate_indices:\n            selected_idx = random.choice(candidate_indices)\n            base_solution = archive_sorted[selected_idx][0].copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Flip a random bit (standard move)\n    flip_idx = random.randint(0, len(new_solution)-1)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # 2. Check feasibility and repair if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, remove the heaviest items until feasible\n        while total_weight > capacity:\n            # Find the indices of items currently in the knapsack\n            in_knapsack = np.where(new_solution == 1)[0]\n            if len(in_knapsack) == 0:\n                break  # No items to remove\n            # Remove the heaviest item\n            heaviest_idx = in_knapsack[np.argmax(weight_lst[in_knapsack])]\n            new_solution[heaviest_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # 3. Add a probabilistic move: with 20% chance, perform a swap of two items\n    if random.random() < 0.2:\n        # Select two distinct items to swap\n        item_indices = np.where(new_solution == 1)[0]\n        if len(item_indices) >= 2:\n            swap_indices = random.sample(list(item_indices), 2)\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n            # Check feasibility after swap\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                # If infeasible, revert the swap\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.41899192312727274,
            2.86159211397171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution that is not on the extreme Pareto front (has potential for improvement)\n    if len(archive) > 2:\n        # Sort solutions by the sum of objectives to find less extreme ones\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution in the middle (not too extreme)\n        candidate_indices = range(1, len(archive_sorted)-1)\n        if candidate_indices:\n            selected_idx = random.choice(candidate_indices)\n            base_solution = archive_sorted[selected_idx][0].copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(archive)[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Flip a random bit (standard move)\n    flip_idx = random.randint(0, len(new_solution)-1)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # 2. Check feasibility and repair if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, remove the heaviest items until feasible\n        while total_weight > capacity:\n            # Find the indices of items currently in the knapsack\n            in_knapsack = np.where(new_solution == 1)[0]\n            if len(in_knapsack) == 0:\n                break  # No items to remove\n            # Remove the heaviest item\n            heaviest_idx = in_knapsack[np.argmax(weight_lst[in_knapsack])]\n            new_solution[heaviest_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # 3. Add a probabilistic move: with 20% chance, perform a swap of two items\n    if random.random() < 0.2:\n        # Select two distinct items to swap\n        item_indices = np.where(new_solution == 1)[0]\n        if len(item_indices) >= 2:\n            swap_indices = random.sample(list(item_indices), 2)\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n            # Check feasibility after swap\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                # If infeasible, revert the swap\n                new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 124,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: flip a random subset of items with high value-to-weight ratio\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n\n    # Combine value-to-weight ratios for both objectives\n    combined_ratio = value_to_weight1 + value_to_weight2\n\n    # Sort items by combined ratio in descending order\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Select a subset of top items to flip\n    flip_subset_size = min(5, len(sorted_items))\n    flip_candidates = sorted_items[:flip_subset_size]\n\n    new_solution = base_solution.copy()\n\n    # Randomly flip items in the subset to explore new solutions\n    for item in flip_candidates:\n        if np.random.rand() < 0.5:  # 50% chance to flip\n            if new_solution[item] == 1:\n                # If removing the item keeps the solution feasible, do it\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # If adding the item keeps the solution feasible, do it\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3762356093251168,
            2.3826531767845154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: flip a random subset of items with high value-to-weight ratio\n    value_to_weight1 = value1_lst / weight_lst\n    value_to_weight2 = value2_lst / weight_lst\n\n    # Combine value-to-weight ratios for both objectives\n    combined_ratio = value_to_weight1 + value_to_weight2\n\n    # Sort items by combined ratio in descending order\n    sorted_items = np.argsort(-combined_ratio)\n\n    # Select a subset of top items to flip\n    flip_subset_size = min(5, len(sorted_items))\n    flip_candidates = sorted_items[:flip_subset_size]\n\n    new_solution = base_solution.copy()\n\n    # Randomly flip items in the subset to explore new solutions\n    for item in flip_candidates:\n        if np.random.rand() < 0.5:  # 50% chance to flip\n            if new_solution[item] == 1:\n                # If removing the item keeps the solution feasible, do it\n                if current_weight - weight_lst[item] <= capacity:\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n            else:\n                # If adding the item keeps the solution feasible, do it\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 125,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objective values and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential items to flip\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Strategy 1: Random swap between included and excluded items (if feasible)\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        swap_candidate = np.random.choice(excluded_items)\n        if remaining_capacity >= weight_lst[swap_candidate]:\n            new_solution[swap_candidate] = 1\n            # Remove one item to maintain feasibility\n            if current_weight + weight_lst[swap_candidate] > capacity:\n                remove_candidate = np.random.choice(included_items)\n                new_solution[remove_candidate] = 0\n        else:\n            # If swap is not feasible, try to remove an item\n            if len(included_items) > 0:\n                remove_candidate = np.random.choice(included_items)\n                new_solution[remove_candidate] = 0\n\n    # Strategy 2: Flip items with high value-to-weight ratio for objective 1\n    if len(excluded_items) > 0:\n        value_to_weight1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        top_candidates1 = excluded_items[np.argsort(value_to_weight1)[-min(3, len(excluded_items)):]]\n        for item in top_candidates1:\n            if remaining_capacity >= weight_lst[item]:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    # Strategy 3: Flip items with high value-to-weight ratio for objective 2\n    if len(excluded_items) > 0:\n        value_to_weight2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        top_candidates2 = excluded_items[np.argsort(value_to_weight2)[-min(3, len(excluded_items)):]]\n        for item in top_candidates2:\n            if remaining_capacity >= weight_lst[item]:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    # Ensure feasibility by removing items if necessary\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        remove_candidate = np.random.choice(included_items)\n        new_solution[remove_candidate] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9155806069187393,
            1.4944700002670288
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objective values and potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential items to flip\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n    excluded_items = np.where(new_solution == 0)[0]\n    included_items = np.where(new_solution == 1)[0]\n\n    # Strategy 1: Random swap between included and excluded items (if feasible)\n    if len(excluded_items) > 0 and len(included_items) > 0:\n        swap_candidate = np.random.choice(excluded_items)\n        if remaining_capacity >= weight_lst[swap_candidate]:\n            new_solution[swap_candidate] = 1\n            # Remove one item to maintain feasibility\n            if current_weight + weight_lst[swap_candidate] > capacity:\n                remove_candidate = np.random.choice(included_items)\n                new_solution[remove_candidate] = 0\n        else:\n            # If swap is not feasible, try to remove an item\n            if len(included_items) > 0:\n                remove_candidate = np.random.choice(included_items)\n                new_solution[remove_candidate] = 0\n\n    # Strategy 2: Flip items with high value-to-weight ratio for objective 1\n    if len(excluded_items) > 0:\n        value_to_weight1 = value1_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        top_candidates1 = excluded_items[np.argsort(value_to_weight1)[-min(3, len(excluded_items)):]]\n        for item in top_candidates1:\n            if remaining_capacity >= weight_lst[item]:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    # Strategy 3: Flip items with high value-to-weight ratio for objective 2\n    if len(excluded_items) > 0:\n        value_to_weight2 = value2_lst[excluded_items] / (weight_lst[excluded_items] + 1e-6)\n        top_candidates2 = excluded_items[np.argsort(value_to_weight2)[-min(3, len(excluded_items)):]]\n        for item in top_candidates2:\n            if remaining_capacity >= weight_lst[item]:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    # Ensure feasibility by removing items if necessary\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break\n        remove_candidate = np.random.choice(included_items)\n        new_solution[remove_candidate] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 126,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive with a bias towards higher-value solutions\n    weights = [obj[0] + obj[1] for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly flip a subset of items to introduce diversity\n    num_flips = min(3, len(new_solution))  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedily improve the solution by adding the most valuable items not in the solution\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Sort excluded items by the sum of their values (normalized by weight to avoid bias)\n    value_ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / (weight_lst[excluded_items] + 1e-6)\n    sorted_indices = excluded_items[np.argsort(value_ratios)[::-1]]\n\n    # Add items until capacity is reached\n    for idx in sorted_indices:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        else:\n            break\n\n    # Ensure feasibility by removing the least valuable items if necessary\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        value_ratios = (value1_lst[included_items] + value2_lst[included_items]) / (weight_lst[included_items] + 1e-6)\n        sorted_indices = included_items[np.argsort(value_ratios)]\n        for idx in sorted_indices:\n            if current_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.36814166741651977,
            2.418537139892578
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive with a bias towards higher-value solutions\n    weights = [obj[0] + obj[1] for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator\n    # Step 1: Randomly flip a subset of items to introduce diversity\n    num_flips = min(3, len(new_solution))  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedily improve the solution by adding the most valuable items not in the solution\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Sort excluded items by the sum of their values (normalized by weight to avoid bias)\n    value_ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / (weight_lst[excluded_items] + 1e-6)\n    sorted_indices = excluded_items[np.argsort(value_ratios)[::-1]]\n\n    # Add items until capacity is reached\n    for idx in sorted_indices:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        else:\n            break\n\n    # Ensure feasibility by removing the least valuable items if necessary\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        included_items = np.where(new_solution == 1)[0]\n        value_ratios = (value1_lst[included_items] + value2_lst[included_items]) / (weight_lst[included_items] + 1e-6)\n        sorted_indices = included_items[np.argsort(value_ratios)]\n        for idx in sorted_indices:\n            if current_weight <= capacity:\n                break\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 127,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate normalized scores for each solution based on both objectives\n        max_val1 = max(obj[1][0] for obj in archive)\n        max_val2 = max(obj[1][1] for obj in archive)\n        if max_val1 == 0 or max_val2 == 0:\n            # Fallback to random selection if objectives are zero\n            base_solution = random.choice(archive)[0].copy()\n        else:\n            # Normalize objectives and compute a combined score\n            scores = []\n            for sol, (val1, val2) in archive:\n                norm_val1 = val1 / max_val1\n                norm_val2 = val2 / max_val2\n                score = norm_val1 + norm_val2  # Simple additive scoring\n                scores.append(score)\n            # Select with probability proportional to score\n            selected_idx = random.choices(range(len(archive)), weights=scores, k=1)[0]\n            base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items\n    # 2. Apply a biased flip towards items that improve both objectives\n    num_flips = min(3, len(new_solution))  # Limit the number of flips\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, consider removing it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, consider adding it with a bias towards high-value items\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate a score for adding the item based on both objectives\n                score = (value1_lst[idx] / (max(value1_lst) + 1e-6)) + (value2_lst[idx] / (max(value2_lst) + 1e-6))\n                if random.random() < score:  # Higher score increases chance of being added\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3244585729715128,
            1.3213013112545013
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate normalized scores for each solution based on both objectives\n        max_val1 = max(obj[1][0] for obj in archive)\n        max_val2 = max(obj[1][1] for obj in archive)\n        if max_val1 == 0 or max_val2 == 0:\n            # Fallback to random selection if objectives are zero\n            base_solution = random.choice(archive)[0].copy()\n        else:\n            # Normalize objectives and compute a combined score\n            scores = []\n            for sol, (val1, val2) in archive:\n                norm_val1 = val1 / max_val1\n                norm_val2 = val2 / max_val2\n                score = norm_val1 + norm_val2  # Simple additive scoring\n                scores.append(score)\n            # Select with probability proportional to score\n            selected_idx = random.choices(range(len(archive)), weights=scores, k=1)[0]\n            base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items\n    # 2. Apply a biased flip towards items that improve both objectives\n    num_flips = min(3, len(new_solution))  # Limit the number of flips\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, consider removing it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, consider adding it with a bias towards high-value items\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate a score for adding the item based on both objectives\n                score = (value1_lst[idx] / (max(value1_lst) + 1e-6)) + (value2_lst[idx] / (max(value2_lst) + 1e-6))\n                if random.random() < score:  # Higher score increases chance of being added\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 128,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we prioritize solutions that are not fully packed and have high value per weight ratio\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity * 0.9:  # Not too close to full capacity\n            value_per_weight1 = obj[0] / total_weight if total_weight > 0 else 0\n            value_per_weight2 = obj[1] / total_weight if total_weight > 0 else 0\n            candidates.append((sol, value_per_weight1 + value_per_weight2))\n\n    if not candidates:\n        # Fallback: select a random solution if no candidates found\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select the solution with the highest combined value per weight ratio\n        base_solution = max(candidates, key=lambda x: x[1])[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with a probability based on their value)\n    # 2. If the solution becomes infeasible, undo the changes\n    # 3. If feasible, accept the change\n    flip_prob = 0.3  # Probability of flipping each item\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            # Try flipping the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1 - temp_solution[i]\n\n            # Check feasibility\n            total_weight = np.sum(temp_solution * weight_lst)\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    # Additional improvement: if the solution is not fully packed, try adding items with high value per weight ratio\n    if np.sum(new_solution * weight_lst) < capacity * 0.9:\n        # Sort items by value per weight ratio in descending order\n        value_per_weight = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-value_per_weight)\n\n        for i in sorted_indices:\n            if new_solution[i] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                total_weight = np.sum(temp_solution * weight_lst)\n                if total_weight <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.4260970400184384,
            4.076703995466232
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we prioritize solutions that are not fully packed and have high value per weight ratio\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity * 0.9:  # Not too close to full capacity\n            value_per_weight1 = obj[0] / total_weight if total_weight > 0 else 0\n            value_per_weight2 = obj[1] / total_weight if total_weight > 0 else 0\n            candidates.append((sol, value_per_weight1 + value_per_weight2))\n\n    if not candidates:\n        # Fallback: select a random solution if no candidates found\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select the solution with the highest combined value per weight ratio\n        base_solution = max(candidates, key=lambda x: x[1])[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with a probability based on their value)\n    # 2. If the solution becomes infeasible, undo the changes\n    # 3. If feasible, accept the change\n    flip_prob = 0.3  # Probability of flipping each item\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            # Try flipping the item\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1 - temp_solution[i]\n\n            # Check feasibility\n            total_weight = np.sum(temp_solution * weight_lst)\n            if total_weight <= capacity:\n                new_solution = temp_solution\n\n    # Additional improvement: if the solution is not fully packed, try adding items with high value per weight ratio\n    if np.sum(new_solution * weight_lst) < capacity * 0.9:\n        # Sort items by value per weight ratio in descending order\n        value_per_weight = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(-value_per_weight)\n\n        for i in sorted_indices:\n            if new_solution[i] == 0:\n                temp_solution = new_solution.copy()\n                temp_solution[i] = 1\n                total_weight = np.sum(temp_solution * weight_lst)\n                if total_weight <= capacity:\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Intelligently select a base solution (e.g., highest value in one objective)\n    base_solution, _ = max(archive, key=lambda x: x[1][0])  # Select solution with highest value1\n    new_solution = base_solution.copy()\n\n    # Step 2: Compute current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 3: Hybrid local search strategy\n    # Option A: Randomly flip items with high value-to-weight ratio\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine both objectives' value-to-weight ratios\n    combined_ratio = value_to_weight1 + value_to_weight2\n\n    # Identify top-k items to consider for flipping\n    k = max(1, len(new_solution) // 10)  # Consider top 10% of items\n    top_items = np.argsort(-combined_ratio)[:k]\n\n    # Randomly select an item from top_items to flip\n    if len(top_items) > 0:\n        idx = np.random.choice(top_items)\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the item\n\n        # Ensure feasibility\n        new_weight = current_weight + (1 - 2 * new_solution[idx]) * weight_lst[idx]\n        if new_weight > capacity:\n            # Revert if infeasible\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Option B: If no flip occurred, perform a capacity-aware perturbation\n    if np.array_equal(new_solution, base_solution):\n        # Remove the heaviest item if over capacity\n        if current_weight > capacity:\n            heaviest_item = np.argmax(weight_lst * new_solution)\n            new_solution[heaviest_item] = 0\n        # Otherwise, add a random item if possible\n        else:\n            available_items = np.where((new_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n            if len(available_items) > 0:\n                idx = np.random.choice(available_items)\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5763816777005738,
            10.082253098487854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Intelligently select a base solution (e.g., highest value in one objective)\n    base_solution, _ = max(archive, key=lambda x: x[1][0])  # Select solution with highest value1\n    new_solution = base_solution.copy()\n\n    # Step 2: Compute current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 3: Hybrid local search strategy\n    # Option A: Randomly flip items with high value-to-weight ratio\n    value_to_weight1 = value1_lst / (weight_lst + 1e-6)\n    value_to_weight2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine both objectives' value-to-weight ratios\n    combined_ratio = value_to_weight1 + value_to_weight2\n\n    # Identify top-k items to consider for flipping\n    k = max(1, len(new_solution) // 10)  # Consider top 10% of items\n    top_items = np.argsort(-combined_ratio)[:k]\n\n    # Randomly select an item from top_items to flip\n    if len(top_items) > 0:\n        idx = np.random.choice(top_items)\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the item\n\n        # Ensure feasibility\n        new_weight = current_weight + (1 - 2 * new_solution[idx]) * weight_lst[idx]\n        if new_weight > capacity:\n            # Revert if infeasible\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Option B: If no flip occurred, perform a capacity-aware perturbation\n    if np.array_equal(new_solution, base_solution):\n        # Remove the heaviest item if over capacity\n        if current_weight > capacity:\n            heaviest_item = np.argmax(weight_lst * new_solution)\n            new_solution[heaviest_item] = 0\n        # Otherwise, add a random item if possible\n        else:\n            available_items = np.where((new_solution == 0) & (weight_lst <= (capacity - current_weight)))[0]\n            if len(available_items) > 0:\n                idx = np.random.choice(available_items)\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 130,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high values but not fully packed)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential for improvement\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that could be added without exceeding capacity\n    candidate_items = np.where(new_solution == 0)[0]\n    feasible_candidates = [i for i in candidate_items if weight_lst[i] <= remaining_capacity]\n\n    # If no feasible candidates, try removing items to free up space\n    if not feasible_candidates:\n        candidate_items = np.where(new_solution == 1)[0]\n        feasible_candidates = [i for i in candidate_items if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity]\n\n    # Hybrid local search: randomly select an item to flip (add/remove) with bias toward higher value items\n    if feasible_candidates:\n        # Calculate value-to-weight ratios for feasible candidates\n        value1_ratios = value1_lst[feasible_candidates] / weight_lst[feasible_candidates]\n        value2_ratios = value2_lst[feasible_candidates] / weight_lst[feasible_candidates]\n\n        # Combine ratios with randomness for selection probability\n        combined_ratios = 0.7 * value1_ratios + 0.3 * value2_ratios\n        probabilities = combined_ratios / np.sum(combined_ratios)\n\n        # Select an item to flip\n        selected_item = np.random.choice(feasible_candidates, p=probabilities)\n        new_solution[selected_item] = 1 - new_solution[selected_item]\n\n        # Ensure feasibility (shouldn't be needed due to previous checks, but added for safety)\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # If adding caused overflow, remove the highest value-to-weight item that can be removed\n            excess = new_weight - capacity\n            removable_items = np.where(new_solution == 1)[0]\n            removable_ratios = (value1_lst[removable_items] + value2_lst[removable_items]) / weight_lst[removable_items]\n            sorted_indices = np.argsort(removable_ratios)[::-1]\n            for i in sorted_indices:\n                if weight_lst[removable_items[i]] <= excess:\n                    new_solution[removable_items[i]] = 0\n                    excess -= weight_lst[removable_items[i]]\n                    if np.sum(weight_lst * new_solution) <= capacity:\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.8490672446851781,
            4.473238945007324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., with high values but not fully packed)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential for improvement\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that could be added without exceeding capacity\n    candidate_items = np.where(new_solution == 0)[0]\n    feasible_candidates = [i for i in candidate_items if weight_lst[i] <= remaining_capacity]\n\n    # If no feasible candidates, try removing items to free up space\n    if not feasible_candidates:\n        candidate_items = np.where(new_solution == 1)[0]\n        feasible_candidates = [i for i in candidate_items if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity]\n\n    # Hybrid local search: randomly select an item to flip (add/remove) with bias toward higher value items\n    if feasible_candidates:\n        # Calculate value-to-weight ratios for feasible candidates\n        value1_ratios = value1_lst[feasible_candidates] / weight_lst[feasible_candidates]\n        value2_ratios = value2_lst[feasible_candidates] / weight_lst[feasible_candidates]\n\n        # Combine ratios with randomness for selection probability\n        combined_ratios = 0.7 * value1_ratios + 0.3 * value2_ratios\n        probabilities = combined_ratios / np.sum(combined_ratios)\n\n        # Select an item to flip\n        selected_item = np.random.choice(feasible_candidates, p=probabilities)\n        new_solution[selected_item] = 1 - new_solution[selected_item]\n\n        # Ensure feasibility (shouldn't be needed due to previous checks, but added for safety)\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # If adding caused overflow, remove the highest value-to-weight item that can be removed\n            excess = new_weight - capacity\n            removable_items = np.where(new_solution == 1)[0]\n            removable_ratios = (value1_lst[removable_items] + value2_lst[removable_items]) / weight_lst[removable_items]\n            sorted_indices = np.argsort(removable_ratios)[::-1]\n            for i in sorted_indices:\n                if weight_lst[removable_items[i]] <= excess:\n                    new_solution[removable_items[i]] = 0\n                    excess -= weight_lst[removable_items[i]]\n                    if np.sum(weight_lst * new_solution) <= capacity:\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 131,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select a solution that is not already non-dominated in the archive\n    # Alternatively, select a random solution with some bias toward lower objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip followed by greedy improvement\n    # Step 1: Randomly flip a subset of items (1 to 3 items)\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    while total_weight > capacity:\n        # Remove the item with the smallest ratio of (value1 + value2) / weight\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break  # No items left to remove\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        worst_item = included_items[np.argmin(ratios)]\n        new_solution[worst_item] = 0\n        total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Greedy improvement - add the most promising item not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Evaluate the impact of adding each excluded item\n        # For simplicity, we use a weighted sum of the two objectives\n        weights = np.random.uniform(0.3, 0.7)  # Randomly weigh the two objectives\n        gains = (weights * value1_lst[excluded_items] + (1 - weights) * value2_lst[excluded_items]) / weight_lst[excluded_items]\n        best_candidate = excluded_items[np.argmax(gains)]\n        if weight_lst[best_candidate] <= (capacity - total_weight):\n            new_solution[best_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36868420523051715,
            5.570395082235336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select a solution that is not already non-dominated in the archive\n    # Alternatively, select a random solution with some bias toward lower objectives\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip followed by greedy improvement\n    # Step 1: Randomly flip a subset of items (1 to 3 items)\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    while total_weight > capacity:\n        # Remove the item with the smallest ratio of (value1 + value2) / weight\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) == 0:\n            break  # No items left to remove\n        ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        worst_item = included_items[np.argmin(ratios)]\n        new_solution[worst_item] = 0\n        total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 2: Greedy improvement - add the most promising item not in the solution\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Evaluate the impact of adding each excluded item\n        # For simplicity, we use a weighted sum of the two objectives\n        weights = np.random.uniform(0.3, 0.7)  # Randomly weigh the two objectives\n        gains = (weights * value1_lst[excluded_items] + (1 - weights) * value2_lst[excluded_items]) / weight_lst[excluded_items]\n        best_candidate = excluded_items[np.argmax(gains)]\n        if weight_lst[best_candidate] <= (capacity - total_weight):\n            new_solution[best_candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 132,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with a bias towards higher objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    scores = normalized[:, 0] + normalized[:, 1]  # Combine objectives\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.dot(base_solution, weight_lst)\n    current_value1 = np.dot(base_solution, value1_lst)\n    current_value2 = np.dot(base_solution, value2_lst)\n\n    # Identify items that can be flipped (either added or removed)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, 'remove'))\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 'add'))\n\n    if not candidate_items:\n        return base_solution\n\n    # Select a candidate item based on marginal contribution to both objectives\n    item_scores = []\n    for i, action in candidate_items:\n        if action == 'remove':\n            marginal1 = -value1_lst[i]\n            marginal2 = -value2_lst[i]\n        else:\n            marginal1 = value1_lst[i]\n            marginal2 = value2_lst[i]\n        # Combine marginal contributions with a bias towards the less improved objective\n        score = abs(marginal1 / (current_value1 + 1e-10)) + abs(marginal2 / (current_value2 + 1e-10))\n        item_scores.append(score)\n\n    # Normalize scores and select a candidate\n    item_scores = np.array(item_scores)\n    if item_scores.sum() == 0:\n        selected_candidate = random.choice(candidate_items)\n    else:\n        selected_candidate = candidate_items[np.random.choice(len(candidate_items), p=item_scores/item_scores.sum())]\n\n    # Create the new solution\n    new_solution = base_solution.copy()\n    item_idx, action = selected_candidate\n    if action == 'remove':\n        new_solution[item_idx] = 0\n    else:\n        new_solution[item_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8673565979903725,
            2.5726844370365143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with a bias towards higher objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    scores = normalized[:, 0] + normalized[:, 1]  # Combine objectives\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and values\n    current_weight = np.dot(base_solution, weight_lst)\n    current_value1 = np.dot(base_solution, value1_lst)\n    current_value2 = np.dot(base_solution, value2_lst)\n\n    # Identify items that can be flipped (either added or removed)\n    candidate_items = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Check if removing the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidate_items.append((i, 'remove'))\n        else:\n            # Check if adding the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidate_items.append((i, 'add'))\n\n    if not candidate_items:\n        return base_solution\n\n    # Select a candidate item based on marginal contribution to both objectives\n    item_scores = []\n    for i, action in candidate_items:\n        if action == 'remove':\n            marginal1 = -value1_lst[i]\n            marginal2 = -value2_lst[i]\n        else:\n            marginal1 = value1_lst[i]\n            marginal2 = value2_lst[i]\n        # Combine marginal contributions with a bias towards the less improved objective\n        score = abs(marginal1 / (current_value1 + 1e-10)) + abs(marginal2 / (current_value2 + 1e-10))\n        item_scores.append(score)\n\n    # Normalize scores and select a candidate\n    item_scores = np.array(item_scores)\n    if item_scores.sum() == 0:\n        selected_candidate = random.choice(candidate_items)\n    else:\n        selected_candidate = candidate_items[np.random.choice(len(candidate_items), p=item_scores/item_scores.sum())]\n\n    # Create the new solution\n    new_solution = base_solution.copy()\n    item_idx, action = selected_candidate\n    if action == 'remove':\n        new_solution[item_idx] = 0\n    else:\n        new_solution[item_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 133,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with higher potential for improvement\n    base_solution, (current_value1, current_value2) = archive[np.random.choice(len(archive))]\n\n    # Calculate current weight and potential for improvement\n    current_weight = np.sum(base_solution * weight_lst)\n    potential_value1 = np.sum(value1_lst)\n    potential_value2 = np.sum(value2_lst)\n    improvement_potential = (potential_value1 - current_value1) + (potential_value2 - current_value2)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items based on a combination of randomness and value\n    for i in range(len(base_solution)):\n        # Flip probability based on value-to-weight ratio and current solution state\n        if np.random.rand() < 0.5 or improvement_potential > 0:\n            if base_solution[i] == 0:\n                # Try adding an item if it fits within capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n            else:\n                # Try removing an item\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Ensure solution is feasible\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Remove items with the lowest value-to-weight ratio\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        item_ratios[new_solution == 0] = np.inf  # Ignore items not in solution\n        worst_item = np.argmin(item_ratios)\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.33240903663706106,
            2.356528013944626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with higher potential for improvement\n    base_solution, (current_value1, current_value2) = archive[np.random.choice(len(archive))]\n\n    # Calculate current weight and potential for improvement\n    current_weight = np.sum(base_solution * weight_lst)\n    potential_value1 = np.sum(value1_lst)\n    potential_value2 = np.sum(value2_lst)\n    improvement_potential = (potential_value1 - current_value1) + (potential_value2 - current_value2)\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items based on a combination of randomness and value\n    for i in range(len(base_solution)):\n        # Flip probability based on value-to-weight ratio and current solution state\n        if np.random.rand() < 0.5 or improvement_potential > 0:\n            if base_solution[i] == 0:\n                # Try adding an item if it fits within capacity\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n            else:\n                # Try removing an item\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Ensure solution is feasible\n    while np.sum(new_solution * weight_lst) > capacity:\n        # Remove items with the lowest value-to-weight ratio\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        item_ratios[new_solution == 0] = np.inf  # Ignore items not in solution\n        worst_item = np.argmin(item_ratios)\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive with probability proportional to its non-dominated rank\n    # Here, we assume the archive is sorted by non-domination, so higher index = better rank\n    weights = np.arange(1, len(archive) + 1)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios to identify items with high potential for both objectives\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Sort in descending order\n\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: flip items in a way that balances both objectives\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n    # If no changes were made, randomly flip one item to ensure progress\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(10):  # Try up to 10 random flips\n            idx = random.randint(0, len(weight_lst) - 1)\n            if base_solution[idx] == 1:\n                temp_weight = current_weight - weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 0\n                    break\n            else:\n                temp_weight = current_weight + weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -1.0227767740866083,
            1.9764595031738281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive with probability proportional to its non-dominated rank\n    # Here, we assume the archive is sorted by non-domination, so higher index = better rank\n    weights = np.arange(1, len(archive) + 1)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios to identify items with high potential for both objectives\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Sort in descending order\n\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: flip items in a way that balances both objectives\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n    # If no changes were made, randomly flip one item to ensure progress\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(10):  # Try up to 10 random flips\n            idx = random.randint(0, len(weight_lst) - 1)\n            if base_solution[idx] == 1:\n                temp_weight = current_weight - weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 0\n                    break\n            else:\n                temp_weight = current_weight + weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 1\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive with probability proportional to its non-dominated rank\n    # Here, we assume the archive is sorted by non-domination, so higher index = better rank\n    weights = np.arange(1, len(archive) + 1)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios to identify items with high potential for both objectives\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Sort in descending order\n\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: flip items in a way that balances both objectives\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n    # If no changes were made, randomly flip one item to ensure progress\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(10):  # Try up to 10 random flips\n            idx = random.randint(0, len(weight_lst) - 1)\n            if base_solution[idx] == 1:\n                temp_weight = current_weight - weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 0\n                    break\n            else:\n                temp_weight = current_weight + weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -1.0227767740866083,
            1.9764595031738281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive with probability proportional to its non-dominated rank\n    # Here, we assume the archive is sorted by non-domination, so higher index = better rank\n    weights = np.arange(1, len(archive) + 1)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios to identify items with high potential for both objectives\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = np.argsort(combined_ratio)[::-1]  # Sort in descending order\n\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: flip items in a way that balances both objectives\n    for idx in sorted_indices:\n        if base_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = temp_weight\n        else:\n            # Try adding the item\n            temp_weight = current_weight + weight_lst[idx]\n            if temp_weight <= capacity:\n                new_solution[idx] = 1\n                current_weight = temp_weight\n\n    # If no changes were made, randomly flip one item to ensure progress\n    if np.array_equal(new_solution, base_solution):\n        for _ in range(10):  # Try up to 10 random flips\n            idx = random.randint(0, len(weight_lst) - 1)\n            if base_solution[idx] == 1:\n                temp_weight = current_weight - weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 0\n                    break\n            else:\n                temp_weight = current_weight + weight_lst[idx]\n                if temp_weight <= capacity:\n                    new_solution[idx] = 1\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 135,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive, weighted by their non-dominated status\n    # Solutions with higher objective values are more likely to be selected\n    weights = [obj1 + obj2 for (sol, (obj1, obj2)) in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    base_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[base_idx][0].copy()\n    current_obj1, current_obj2 = archive[base_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (intensification)\n    # 2. Apply a greedy improvement step (diversification)\n    # 3. Ensure feasibility\n\n    # Step 1: Random flip\n    flip_mask = np.random.rand(len(base_solution)) < 0.2  # 20% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Greedy improvement\n    # For items not in solution, try adding them if they improve at least one objective\n    # and don't violate capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                # Calculate potential improvement\n                delta_obj1 = value1_lst[i]\n                delta_obj2 = value2_lst[i]\n\n                # Add if it improves at least one objective\n                if delta_obj1 > 0 or delta_obj2 > 0:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 3: Remove items if capacity is exceeded\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Sort items by (value1 + value2)/weight ratio and remove least valuable\n        selected_items = np.where(new_solution == 1)[0]\n        ratios = (value1_lst[selected_items] + value2_lst[selected_items]) / weight_lst[selected_items]\n        sorted_indices = selected_items[np.argsort(ratios)]\n\n        current_weight = np.sum(weight_lst * new_solution)\n        for i in sorted_indices:\n            if current_weight > capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.407249169535804,
            1.7503086924552917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive, weighted by their non-dominated status\n    # Solutions with higher objective values are more likely to be selected\n    weights = [obj1 + obj2 for (sol, (obj1, obj2)) in archive]\n    total_weight = sum(weights)\n    if total_weight == 0:\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [w / total_weight for w in weights]\n\n    base_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[base_idx][0].copy()\n    current_obj1, current_obj2 = archive[base_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (intensification)\n    # 2. Apply a greedy improvement step (diversification)\n    # 3. Ensure feasibility\n\n    # Step 1: Random flip\n    flip_mask = np.random.rand(len(base_solution)) < 0.2  # 20% chance to flip each item\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Greedy improvement\n    # For items not in solution, try adding them if they improve at least one objective\n    # and don't violate capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            if current_weight + weight_lst[i] <= capacity:\n                # Calculate potential improvement\n                delta_obj1 = value1_lst[i]\n                delta_obj2 = value2_lst[i]\n\n                # Add if it improves at least one objective\n                if delta_obj1 > 0 or delta_obj2 > 0:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 3: Remove items if capacity is exceeded\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Sort items by (value1 + value2)/weight ratio and remove least valuable\n        selected_items = np.where(new_solution == 1)[0]\n        ratios = (value1_lst[selected_items] + value2_lst[selected_items]) / weight_lst[selected_items]\n        sorted_indices = selected_items[np.argsort(ratios)]\n\n        current_weight = np.sum(weight_lst * new_solution)\n        for i in sorted_indices:\n            if current_weight > capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n            else:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 136,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in both objectives)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])  # Select the solution with the most items\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a candidate solution by flipping items that improve at least one objective\n    new_solution = base_solution.copy()\n\n    # Identify items that can be flipped (either added or removed)\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 - value1_lst[i]\n                temp_value2 = current_value2 - value2_lst[i]\n                # Check if removing improves at least one objective\n                if (temp_value1 > current_value1) or (temp_value2 > current_value2):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 + value1_lst[i]\n                temp_value2 = current_value2 + value2_lst[i]\n                # Check if adding improves at least one objective\n                if (temp_value1 > current_value1) or (temp_value2 > current_value2):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # If no improvement found, perform a random flip among feasible items\n    if np.array_equal(new_solution, base_solution):\n        feasible_indices = [i for i in range(len(weight_lst)) if (base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity) or\n                          (base_solution[i] == 1 and current_weight - weight_lst[i] >= 0)]\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9101674940668801,
            4.610168039798737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not already optimal in both objectives)\n    selected_idx = np.argmax([np.sum(sol[0]) for sol in archive])  # Select the solution with the most items\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a candidate solution by flipping items that improve at least one objective\n    new_solution = base_solution.copy()\n\n    # Identify items that can be flipped (either added or removed)\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 1:\n            # Try removing item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 0\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 - value1_lst[i]\n                temp_value2 = current_value2 - value2_lst[i]\n                # Check if removing improves at least one objective\n                if (temp_value1 > current_value1) or (temp_value2 > current_value2):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n        else:\n            # Try adding item i\n            temp_solution = new_solution.copy()\n            temp_solution[i] = 1\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                temp_value1 = current_value1 + value1_lst[i]\n                temp_value2 = current_value2 + value2_lst[i]\n                # Check if adding improves at least one objective\n                if (temp_value1 > current_value1) or (temp_value2 > current_value2):\n                    new_solution = temp_solution\n                    current_weight = temp_weight\n                    current_value1 = temp_value1\n                    current_value2 = temp_value2\n\n    # If no improvement found, perform a random flip among feasible items\n    if np.array_equal(new_solution, base_solution):\n        feasible_indices = [i for i in range(len(weight_lst)) if (base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity) or\n                          (base_solution[i] == 1 and current_weight - weight_lst[i] >= 0)]\n        if feasible_indices:\n            flip_idx = np.random.choice(feasible_indices)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 137,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    probabilities = (capacity - weights) / np.sum(capacity - weights)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search strategy: combination of item swap and random flip with weight adjustment\n    for _ in range(5):  # Number of local search iterations\n        # Randomly select two items to swap\n        item1, item2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Check if swapping these items would keep the solution feasible\n        if (new_solution[item1] != new_solution[item2] and\n            current_weight - weight_lst[item1] + weight_lst[item2] <= capacity):\n            # Perform the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n        # Randomly flip a bit with probability based on weight savings\n        flip_candidate = np.random.randint(len(new_solution))\n        if new_solution[flip_candidate] == 1 and (current_weight - weight_lst[flip_candidate] <= capacity):\n            new_solution[flip_candidate] = 0\n            current_weight -= weight_lst[flip_candidate]\n        elif new_solution[flip_candidate] == 0 and (current_weight + weight_lst[flip_candidate] <= capacity):\n            new_solution[flip_candidate] = 1\n            current_weight += weight_lst[flip_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.4562472048822978,
            3.0555135309696198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([np.sum(weight_lst * sol) for sol, _ in archive])\n    probabilities = (capacity - weights) / np.sum(capacity - weights)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search strategy: combination of item swap and random flip with weight adjustment\n    for _ in range(5):  # Number of local search iterations\n        # Randomly select two items to swap\n        item1, item2 = np.random.choice(len(new_solution), 2, replace=False)\n\n        # Check if swapping these items would keep the solution feasible\n        if (new_solution[item1] != new_solution[item2] and\n            current_weight - weight_lst[item1] + weight_lst[item2] <= capacity):\n            # Perform the swap\n            new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n            current_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n\n        # Randomly flip a bit with probability based on weight savings\n        flip_candidate = np.random.randint(len(new_solution))\n        if new_solution[flip_candidate] == 1 and (current_weight - weight_lst[flip_candidate] <= capacity):\n            new_solution[flip_candidate] = 0\n            current_weight -= weight_lst[flip_candidate]\n        elif new_solution[flip_candidate] == 0 and (current_weight + weight_lst[flip_candidate] <= capacity):\n            new_solution[flip_candidate] = 1\n            current_weight += weight_lst[flip_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 138,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the \"potential\" for each solution (e.g., distance to the ideal point)\n    ideal_point = (max(obj[0] for obj in archive_objectives), max(obj[1] for obj in archive_objectives))\n    potentials = [np.linalg.norm(np.array(ideal_point) - np.array(obj)) for obj in archive_objectives]\n\n    # Select a solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: combine random swaps with objective-specific improvements\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items (local search component)\n    num_flips = min(3, len(new_solution))  # Limit the number of flips for efficiency\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, try to include it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Objective-specific improvement (greedy component)\n    # Try to improve the solution by adding items with the best marginal gain\n    for _ in range(2):  # Limit iterations for efficiency\n        excluded_indices = np.where(new_solution == 0)[0]\n        if len(excluded_indices) == 0:\n            break\n\n        # Calculate marginal gains for excluded items\n        marginal_gains = []\n        for idx in excluded_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Use a weighted combination of both objectives for marginal gain\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains.append((gain1 + gain2, idx))\n            else:\n                marginal_gains.append((0, idx))\n\n        if not marginal_gains:\n            break\n\n        # Select the item with the highest marginal gain\n        best_gain, best_idx = max(marginal_gains, key=lambda x: x[0])\n        if best_gain > 0:\n            new_solution[best_idx] = 1\n            current_weight += weight_lst[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8329204308720264,
            3.0849654376506805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    archive_objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the \"potential\" for each solution (e.g., distance to the ideal point)\n    ideal_point = (max(obj[0] for obj in archive_objectives), max(obj[1] for obj in archive_objectives))\n    potentials = [np.linalg.norm(np.array(ideal_point) - np.array(obj)) for obj in archive_objectives]\n\n    # Select a solution with the highest potential\n    selected_idx = np.argmax(potentials)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    current_value1 = np.sum(value1_lst[base_solution == 1])\n    current_value2 = np.sum(value2_lst[base_solution == 1])\n\n    # Hybrid local search: combine random swaps with objective-specific improvements\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items (local search component)\n    num_flips = min(3, len(new_solution))  # Limit the number of flips for efficiency\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, try to include it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Objective-specific improvement (greedy component)\n    # Try to improve the solution by adding items with the best marginal gain\n    for _ in range(2):  # Limit iterations for efficiency\n        excluded_indices = np.where(new_solution == 0)[0]\n        if len(excluded_indices) == 0:\n            break\n\n        # Calculate marginal gains for excluded items\n        marginal_gains = []\n        for idx in excluded_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Use a weighted combination of both objectives for marginal gain\n                gain1 = value1_lst[idx]\n                gain2 = value2_lst[idx]\n                marginal_gains.append((gain1 + gain2, idx))\n            else:\n                marginal_gains.append((0, idx))\n\n        if not marginal_gains:\n            break\n\n        # Select the item with the highest marginal gain\n        best_gain, best_idx = max(marginal_gains, key=lambda x: x[0])\n        if best_gain > 0:\n            new_solution[best_idx] = 1\n            current_weight += weight_lst[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 139,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not at the extreme ends of the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = np.sum(value1_lst * selected_solution)\n    current_value2 = np.sum(value2_lst * selected_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1 -> 0 or 0 -> 1)\n    flip_indices = np.random.choice(len(selected_solution), size=min(3, len(selected_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it doesn't make the solution infeasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try to add the item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 2. Value-based flips: Flip items that have high marginal value-to-weight ratios\n    marginal_ratios1 = (value1_lst / weight_lst) * (1 - selected_solution) + (value1_lst / weight_lst) * selected_solution\n    marginal_ratios2 = (value2_lst / weight_lst) * (1 - selected_solution) + (value2_lst / weight_lst) * selected_solution\n\n    # Combine the ratios to get a unified metric\n    combined_ratios = marginal_ratios1 + marginal_ratios2\n    top_indices = np.argsort(combined_ratios)[-min(2, len(selected_solution)):]\n\n    for idx in top_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # 3. Weight-based adjustments: Remove items with low value-to-weight ratios if capacity is tight\n    if current_weight > 0.9 * capacity:\n        low_value_indices = np.where((value1_lst + value2_lst) < np.median(value1_lst + value2_lst))[0]\n        for idx in low_value_indices:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7989923397185643,
            2.1341923773288727
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not at the extreme ends of the Pareto front)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * selected_solution)\n    current_value1 = np.sum(value1_lst * selected_solution)\n    current_value2 = np.sum(value2_lst * selected_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1 -> 0 or 0 -> 1)\n    flip_indices = np.random.choice(len(selected_solution), size=min(3, len(selected_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it doesn't make the solution infeasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Try to add the item if it doesn't exceed capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 2. Value-based flips: Flip items that have high marginal value-to-weight ratios\n    marginal_ratios1 = (value1_lst / weight_lst) * (1 - selected_solution) + (value1_lst / weight_lst) * selected_solution\n    marginal_ratios2 = (value2_lst / weight_lst) * (1 - selected_solution) + (value2_lst / weight_lst) * selected_solution\n\n    # Combine the ratios to get a unified metric\n    combined_ratios = marginal_ratios1 + marginal_ratios2\n    top_indices = np.argsort(combined_ratios)[-min(2, len(selected_solution)):]\n\n    for idx in top_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # 3. Weight-based adjustments: Remove items with low value-to-weight ratios if capacity is tight\n    if current_weight > 0.9 * capacity:\n        low_value_indices = np.where((value1_lst + value2_lst) < np.median(value1_lst + value2_lst))[0]\n        for idx in low_value_indices:\n            if new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 140,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Create a copy for modification\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a few items to escape local optima\n    for _ in range(min(3, len(new_solution))):\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            # Remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 2. Perform objective-driven flips: add items that improve both objectives\n    for idx in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Add item if it improves both objectives\n            if value1_lst[idx] > 0 and value2_lst[idx] > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # 3. Remove items that are dominated in both objectives\n    for idx in np.where(new_solution == 1)[0]:\n        # Check if removing this item could improve both objectives\n        if (current_value1 - value1_lst[idx] > current_value1 and\n            current_value2 - value2_lst[idx] > current_value2):\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.39665239746430725,
            2.617030292749405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst[selected_solution == 1])\n    current_value1 = np.sum(value1_lst[selected_solution == 1])\n    current_value2 = np.sum(value2_lst[selected_solution == 1])\n\n    # Create a copy for modification\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a few items to escape local optima\n    for _ in range(min(3, len(new_solution))):\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            # Remove the item if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Add the item if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # 2. Perform objective-driven flips: add items that improve both objectives\n    for idx in np.where(new_solution == 0)[0]:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Add item if it improves both objectives\n            if value1_lst[idx] > 0 and value2_lst[idx] > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # 3. Remove items that are dominated in both objectives\n    for idx in np.where(new_solution == 1)[0]:\n        # Check if removing this item could improve both objectives\n        if (current_value1 - value1_lst[idx] > current_value1 and\n            current_value2 - value2_lst[idx] > current_value2):\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 141,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_n = max(1, int(0.3 * len(archive)))\n    selected_idx = random.randint(0, top_n - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify candidate items to flip (not in solution or in solution)\n    in_solution = np.where(base_solution == 1)[0]\n    out_solution = np.where(base_solution == 0)[0]\n\n    # Hybrid flip strategy:\n    # 1. For items in solution: flip if it reduces weight or improves both objectives\n    # 2. For items out of solution: flip if it improves at least one objective and fits in capacity\n    for i in in_solution:\n        if (weight_lst[i] <= current_weight - capacity + 1e-6) or \\\n           ((value1_lst[i] > 0 or value2_lst[i] > 0) and\n            (current_weight - weight_lst[i] <= capacity)):\n            if random.random() < 0.7:  # 70% chance to flip\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    for i in out_solution:\n        if (weight_lst[i] <= capacity - current_weight) and \\\n           (value1_lst[i] > 0 or value2_lst[i] > 0):\n            if random.random() < 0.4:  # 40% chance to flip\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility (shouldn't be needed due to checks above, but just in case)\n    if current_weight > capacity:\n        # Remove heaviest items until feasible\n        excess = current_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            heavy_items = np.where(new_solution == 1)[0]\n            heaviest = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest] = 0\n            excess -= weight_lst[heaviest]\n\n    return new_solution\n\n",
        "score": [
            -0.4639913511817195,
            1.9292708337306976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    top_n = max(1, int(0.3 * len(archive)))\n    selected_idx = random.randint(0, top_n - 1)\n    base_solution, (current_v1, current_v2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Identify candidate items to flip (not in solution or in solution)\n    in_solution = np.where(base_solution == 1)[0]\n    out_solution = np.where(base_solution == 0)[0]\n\n    # Hybrid flip strategy:\n    # 1. For items in solution: flip if it reduces weight or improves both objectives\n    # 2. For items out of solution: flip if it improves at least one objective and fits in capacity\n    for i in in_solution:\n        if (weight_lst[i] <= current_weight - capacity + 1e-6) or \\\n           ((value1_lst[i] > 0 or value2_lst[i] > 0) and\n            (current_weight - weight_lst[i] <= capacity)):\n            if random.random() < 0.7:  # 70% chance to flip\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    for i in out_solution:\n        if (weight_lst[i] <= capacity - current_weight) and \\\n           (value1_lst[i] > 0 or value2_lst[i] > 0):\n            if random.random() < 0.4:  # 40% chance to flip\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Ensure feasibility (shouldn't be needed due to checks above, but just in case)\n    if current_weight > capacity:\n        # Remove heaviest items until feasible\n        excess = current_weight - capacity\n        while excess > 0 and np.sum(new_solution) > 0:\n            heavy_items = np.where(new_solution == 1)[0]\n            heaviest = heavy_items[np.argmax(weight_lst[heavy_items])]\n            new_solution[heaviest] = 0\n            excess -= weight_lst[heaviest]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 142,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < 0.9 * capacity:  # Avoid solutions near capacity\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Strategy 1: Random swap of two items (if feasible)\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_total_weight = total_weight - weight_lst[i] + weight_lst[j]\n            if new_total_weight <= capacity:\n                return new_solution\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Flip items with high value-to-weight ratio for one objective\n    # Randomly choose between value1 and value2\n    if random.random() < 0.5:\n        value_ratio = value1_lst / weight_lst\n    else:\n        value_ratio = value2_lst / weight_lst\n\n    # Find items to flip (exclude those that would make the solution infeasible)\n    flip_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] >= 0:\n                flip_candidates.append((i, -value_ratio[i]))  # Sort by descending value ratio\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                flip_candidates.append((i, value_ratio[i]))  # Sort by ascending value ratio\n\n    if flip_candidates:\n        flip_candidates.sort(key=lambda x: x[1])\n        best_flip = flip_candidates[0][0]\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n        return new_solution\n\n    # Strategy 3: Randomly flip one item if no better move is found\n    flip_candidates = [i for i in range(len(new_solution)) if (new_solution[i] == 1 and total_weight - weight_lst[i] >= 0) or\n                      (new_solution[i] == 0 and total_weight + weight_lst[i] <= capacity)]\n    if flip_candidates:\n        i = random.choice(flip_candidates)\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5601890058268879,
            2.141506791114807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < 0.9 * capacity:  # Avoid solutions near capacity\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Strategy 1: Random swap of two items (if feasible)\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_total_weight = total_weight - weight_lst[i] + weight_lst[j]\n            if new_total_weight <= capacity:\n                return new_solution\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Flip items with high value-to-weight ratio for one objective\n    # Randomly choose between value1 and value2\n    if random.random() < 0.5:\n        value_ratio = value1_lst / weight_lst\n    else:\n        value_ratio = value2_lst / weight_lst\n\n    # Find items to flip (exclude those that would make the solution infeasible)\n    flip_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if total_weight - weight_lst[i] >= 0:\n                flip_candidates.append((i, -value_ratio[i]))  # Sort by descending value ratio\n        else:\n            if total_weight + weight_lst[i] <= capacity:\n                flip_candidates.append((i, value_ratio[i]))  # Sort by ascending value ratio\n\n    if flip_candidates:\n        flip_candidates.sort(key=lambda x: x[1])\n        best_flip = flip_candidates[0][0]\n        new_solution[best_flip] = 1 - new_solution[best_flip]\n        return new_solution\n\n    # Strategy 3: Randomly flip one item if no better move is found\n    flip_candidates = [i for i in range(len(new_solution)) if (new_solution[i] == 1 and total_weight - weight_lst[i] >= 0) or\n                      (new_solution[i] == 0 and total_weight + weight_lst[i] <= capacity)]\n    if flip_candidates:\n        i = random.choice(flip_candidates)\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 143,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive with a bias towards solutions with higher total values\n    weights = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = weights / np.sum(weights)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate value-to-weight ratios for each item\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Identify items that can be flipped (either included or excluded) without violating capacity\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if excluding the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Check if including the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates inclusion\n\n    if not candidates:\n        # If no candidates, perform a random flip (guaranteed to be feasible)\n        candidates = [(i, 1 - 2 * new_solution[i]) for i in range(len(new_solution)) if (current_weight + (1 - 2 * new_solution[i]) * weight_lst[i]) <= capacity]\n\n    if not candidates:\n        return new_solution  # No feasible moves, return original solution\n\n    # Select the best candidate based on combined ratio\n    best_candidate = max(candidates, key=lambda x: combined_ratio[x[0]] if x[1] == 1 else -combined_ratio[x[0]])\n    item_idx, flip = best_candidate\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    return new_solution\n\n",
        "score": [
            -0.8473746890821622,
            1.5793536603450775
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive with a bias towards solutions with higher total values\n    weights = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = weights / np.sum(weights)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Calculate value-to-weight ratios for each item\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratio = ratio1 + ratio2\n\n    # Identify items that can be flipped (either included or excluded) without violating capacity\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if excluding the item keeps the solution feasible\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Check if including the item keeps the solution feasible\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))  # 1 indicates inclusion\n\n    if not candidates:\n        # If no candidates, perform a random flip (guaranteed to be feasible)\n        candidates = [(i, 1 - 2 * new_solution[i]) for i in range(len(new_solution)) if (current_weight + (1 - 2 * new_solution[i]) * weight_lst[i]) <= capacity]\n\n    if not candidates:\n        return new_solution  # No feasible moves, return original solution\n\n    # Select the best candidate based on combined ratio\n    best_candidate = max(candidates, key=lambda x: combined_ratio[x[0]] if x[1] == 1 else -combined_ratio[x[0]])\n    item_idx, flip = best_candidate\n    new_solution[item_idx] = 1 if flip == 1 else 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 144,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with a higher chance for those with lower weights (more room for improvement)\n    weights = np.array([np.sum(sol[0] * weight_lst) for sol in archive])\n    probabilities = 1 / (weights + 1e-6)  # Avoid division by zero\n    probabilities /= np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine move and swap operations\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Randomly choose between move and swap operations\n    if np.random.rand() < 0.5:\n        # Move operation: flip a random item\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            item_to_remove = np.random.choice(candidate_items)\n            new_weight = current_weight - weight_lst[item_to_remove]\n            new_solution[item_to_remove] = 0\n        else:\n            # If no items are selected, try adding a random item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                item_to_add = np.random.choice(candidate_items)\n                if current_weight + weight_lst[item_to_add] <= capacity:\n                    new_solution[item_to_add] = 1\n    else:\n        # Swap operation: swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            item_to_remove = np.random.choice(in_items)\n            item_to_add = np.random.choice(out_items)\n\n            new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n            if new_weight <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5542638289527807,
            3.0859348475933075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with a higher chance for those with lower weights (more room for improvement)\n    weights = np.array([np.sum(sol[0] * weight_lst) for sol in archive])\n    probabilities = 1 / (weights + 1e-6)  # Avoid division by zero\n    probabilities /= np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine move and swap operations\n    new_solution = base_solution.copy()\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Randomly choose between move and swap operations\n    if np.random.rand() < 0.5:\n        # Move operation: flip a random item\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) > 0:\n            item_to_remove = np.random.choice(candidate_items)\n            new_weight = current_weight - weight_lst[item_to_remove]\n            new_solution[item_to_remove] = 0\n        else:\n            # If no items are selected, try adding a random item\n            candidate_items = np.where(new_solution == 0)[0]\n            if len(candidate_items) > 0:\n                item_to_add = np.random.choice(candidate_items)\n                if current_weight + weight_lst[item_to_add] <= capacity:\n                    new_solution[item_to_add] = 1\n    else:\n        # Swap operation: swap two items (one in, one out)\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            item_to_remove = np.random.choice(in_items)\n            item_to_add = np.random.choice(out_items)\n\n            new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n            if new_weight <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 145,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search strategy: randomly flip bits with a bias toward improving both objectives\n    for i in range(len(weight_lst)):\n        if np.random.rand() < 0.5:  # 50% chance to consider flipping\n            if base_solution[i] == 1:\n                # Try removing item if it doesn't violate capacity\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try adding item if it fits within remaining capacity\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    remaining_capacity -= weight_lst[i]\n\n    # Additional improvement: try to add items that improve both objectives\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            # Check if adding this item would improve both objectives\n            if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8215888588321154,
            2.40274241566658
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search strategy: randomly flip bits with a bias toward improving both objectives\n    for i in range(len(weight_lst)):\n        if np.random.rand() < 0.5:  # 50% chance to consider flipping\n            if base_solution[i] == 1:\n                # Try removing item if it doesn't violate capacity\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try adding item if it fits within remaining capacity\n                if weight_lst[i] <= remaining_capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n                    remaining_capacity -= weight_lst[i]\n\n    # Additional improvement: try to add items that improve both objectives\n    for i in range(len(weight_lst)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            # Check if adding this item would improve both objectives\n            if (value1_lst[i] > 0 and value2_lst[i] > 0):\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 146,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_weights = np.array([np.sum(weight_lst * sol) for sol in archive_solutions])\n    archive_values1 = np.array([np.sum(value1_lst * sol) for sol in archive_solutions])\n    archive_values2 = np.array([np.sum(value2_lst * sol) for sol in archive_solutions])\n\n    # Calculate potential improvement scores (value-to-weight ratio)\n    improvement_scores = (archive_values1 + archive_values2) / (archive_weights + 1e-6)\n    sorted_indices = np.argsort(improvement_scores)[::-1]  # Descending order\n\n    # Select top 20% of solutions with highest improvement potential\n    top_k = max(1, len(archive) // 5)\n    selected_indices = sorted_indices[:top_k]\n    selected_solutions = [archive_solutions[i] for i in selected_indices]\n\n    # Randomly select one of the top solutions\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # First, perform random flips with probability based on value-to-weight ratio\n    for i in range(num_items):\n        if random.random() < 0.3:  # 30% chance to flip\n            if base_solution[i] == 1:\n                # Try to remove item\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Second, apply value-to-weight ratio heuristic for items not flipped\n    value_weight_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_items = np.argsort(value_weight_ratio)[::-1]  # Descending order\n\n    for i in sorted_items:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Add high-value items first\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif new_solution[i] == 1 and current_weight - weight_lst[i] > capacity:\n            # Remove low-value items if over capacity\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Third, perform a small number of random swaps to escape local optima\n    for _ in range(2):\n        i, j = random.sample(range(num_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Try swapping items\n            if new_solution[i] == 1:\n                # Remove i and add j\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            else:\n                # Remove j and add i\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[j] + weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.40250358801330655,
            3.419516682624817
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_weights = np.array([np.sum(weight_lst * sol) for sol in archive_solutions])\n    archive_values1 = np.array([np.sum(value1_lst * sol) for sol in archive_solutions])\n    archive_values2 = np.array([np.sum(value2_lst * sol) for sol in archive_solutions])\n\n    # Calculate potential improvement scores (value-to-weight ratio)\n    improvement_scores = (archive_values1 + archive_values2) / (archive_weights + 1e-6)\n    sorted_indices = np.argsort(improvement_scores)[::-1]  # Descending order\n\n    # Select top 20% of solutions with highest improvement potential\n    top_k = max(1, len(archive) // 5)\n    selected_indices = sorted_indices[:top_k]\n    selected_solutions = [archive_solutions[i] for i in selected_indices]\n\n    # Randomly select one of the top solutions\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    num_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # First, perform random flips with probability based on value-to-weight ratio\n    for i in range(num_items):\n        if random.random() < 0.3:  # 30% chance to flip\n            if base_solution[i] == 1:\n                # Try to remove item\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try to add item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Second, apply value-to-weight ratio heuristic for items not flipped\n    value_weight_ratio = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    sorted_items = np.argsort(value_weight_ratio)[::-1]  # Descending order\n\n    for i in sorted_items:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Add high-value items first\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif new_solution[i] == 1 and current_weight - weight_lst[i] > capacity:\n            # Remove low-value items if over capacity\n            new_solution[i] = 0\n            current_weight -= weight_lst[i]\n\n    # Third, perform a small number of random swaps to escape local optima\n    for _ in range(2):\n        i, j = random.sample(range(num_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Try swapping items\n            if new_solution[i] == 1:\n                # Remove i and add j\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            else:\n                # Remove j and add i\n                if current_weight - weight_lst[j] + weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                    current_weight = current_weight - weight_lst[j] + weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 147,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_solution = max(archive, key=lambda x: sum(weight_lst[x[0] == 1]))[0].copy()\n\n    # Calculate current total weight\n    current_weight = sum(weight_lst[selected_solution == 1])\n\n    # Hybrid local search: Random swap with value-based selection\n    new_solution = selected_solution.copy()\n    num_items = len(weight_lst)\n\n    # Perform random swaps with value-based selection\n    for _ in range(min(5, num_items // 2)):\n        # Randomly select two items\n        idx1, idx2 = random.sample(range(num_items), 2)\n\n        # Calculate potential changes\n        delta_weight = -weight_lst[idx1] + weight_lst[idx2] if selected_solution[idx1] else weight_lst[idx2] - weight_lst[idx1]\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap if it improves at least one objective\n            delta_value1 = -value1_lst[idx1] + value1_lst[idx2] if selected_solution[idx1] else value1_lst[idx2] - value1_lst[idx1]\n            delta_value2 = -value2_lst[idx1] + value2_lst[idx2] if selected_solution[idx1] else value2_lst[idx2] - value2_lst[idx1]\n\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight = new_weight\n\n    # Additional greedy improvement: Add high-value items if possible\n    for idx in np.where(selected_solution == 0)[0]:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Add item if it improves both objectives\n            if value1_lst[idx] > 0 and value2_lst[idx] > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3900578521803153,
            7.488067775964737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_solution = max(archive, key=lambda x: sum(weight_lst[x[0] == 1]))[0].copy()\n\n    # Calculate current total weight\n    current_weight = sum(weight_lst[selected_solution == 1])\n\n    # Hybrid local search: Random swap with value-based selection\n    new_solution = selected_solution.copy()\n    num_items = len(weight_lst)\n\n    # Perform random swaps with value-based selection\n    for _ in range(min(5, num_items // 2)):\n        # Randomly select two items\n        idx1, idx2 = random.sample(range(num_items), 2)\n\n        # Calculate potential changes\n        delta_weight = -weight_lst[idx1] + weight_lst[idx2] if selected_solution[idx1] else weight_lst[idx2] - weight_lst[idx1]\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap if it improves at least one objective\n            delta_value1 = -value1_lst[idx1] + value1_lst[idx2] if selected_solution[idx1] else value1_lst[idx2] - value1_lst[idx1]\n            delta_value2 = -value2_lst[idx1] + value2_lst[idx2] if selected_solution[idx1] else value2_lst[idx2] - value2_lst[idx1]\n\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                current_weight = new_weight\n\n    # Additional greedy improvement: Add high-value items if possible\n    for idx in np.where(selected_solution == 0)[0]:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Add item if it improves both objectives\n            if value1_lst[idx] > 0 and value2_lst[idx] > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 148,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a subset of items to explore the neighborhood\n    flip_mask = np.random.rand(len(new_solution)) < 0.2  # Flip 20% of items randomly\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing excess items\n    excess_weight = np.sum(weight_lst[new_solution == 1]) - capacity\n    if excess_weight > 0:\n        # Remove items with the smallest ratio of (value1 + value2) / weight to minimize loss\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        item_ratios[new_solution == 0] = np.inf  # Ignore items not in the solution\n        while excess_weight > 0 and np.any(new_solution == 1):\n            # Remove the item with the smallest ratio\n            worst_item = np.argmin(item_ratios)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n                excess_weight -= weight_lst[worst_item]\n                item_ratios[worst_item] = np.inf  # Mark as removed\n\n    # Greedy improvement step: add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    for item in remaining_items:\n        if weight_lst[item] <= remaining_capacity:\n            # Add the item if it improves both objectives\n            new_value1 = value1_lst[item]\n            new_value2 = value2_lst[item]\n            if new_value1 > 0 and new_value2 > 0:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.33849868673859995,
            2.4104630947113037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a subset of items to explore the neighborhood\n    flip_mask = np.random.rand(len(new_solution)) < 0.2  # Flip 20% of items randomly\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Ensure feasibility by removing excess items\n    excess_weight = np.sum(weight_lst[new_solution == 1]) - capacity\n    if excess_weight > 0:\n        # Remove items with the smallest ratio of (value1 + value2) / weight to minimize loss\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        item_ratios[new_solution == 0] = np.inf  # Ignore items not in the solution\n        while excess_weight > 0 and np.any(new_solution == 1):\n            # Remove the item with the smallest ratio\n            worst_item = np.argmin(item_ratios)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n                excess_weight -= weight_lst[worst_item]\n                item_ratios[worst_item] = np.inf  # Mark as removed\n\n    # Greedy improvement step: add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    for item in remaining_items:\n        if weight_lst[item] <= remaining_capacity:\n            # Add the item if it improves both objectives\n            new_value1 = value1_lst[item]\n            new_value2 = value2_lst[item]\n            if new_value1 > 0 and new_value2 > 0:\n                new_solution[item] = 1\n                remaining_capacity -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 149,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a candidate solution by flipping a subset of items\n    new_solution = base_solution.copy()\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing items if capacity is exceeded\n    excess = np.sum(weight_lst * new_solution) - capacity\n    if excess > 0:\n        # Remove items with lowest marginal contribution to both objectives\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess > 0:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    # Apply a greedy improvement step: add items with high marginal contribution\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate marginal contribution per unit weight for each item\n        marginal_contribution = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        available_items = np.where((new_solution == 0) & (weight_lst <= remaining_weight))[0]\n\n        if len(available_items) > 0:\n            # Select the item with highest marginal contribution\n            best_item = available_items[np.argmax(marginal_contribution[available_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.33392305376584214,
            6.063689649105072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on potential for improvement\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a candidate solution by flipping a subset of items\n    new_solution = base_solution.copy()\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing items if capacity is exceeded\n    excess = np.sum(weight_lst * new_solution) - capacity\n    if excess > 0:\n        # Remove items with lowest marginal contribution to both objectives\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess > 0:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    # Apply a greedy improvement step: add items with high marginal contribution\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate marginal contribution per unit weight for each item\n        marginal_contribution = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        available_items = np.where((new_solution == 0) & (weight_lst <= remaining_weight))[0]\n\n        if len(available_items) > 0:\n            # Select the item with highest marginal contribution\n            best_item = available_items[np.argmax(marginal_contribution[available_items])]\n            new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 150,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combination of objectives to identify less explored regions\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        # Select a solution from the middle to avoid extreme solutions\n        base_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly flip a subset of items (intelligent selection)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it if feasible\n            if (np.sum(weight_lst * new_solution) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, try to include it if feasible\n            if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Greedy improvement step to maximize both objectives\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Try to add or remove items to improve both objectives\n    for idx in np.random.permutation(n_items):\n        if new_solution[idx] == 0:\n            # Check if adding this item is feasible and improves both objectives\n            if (current_weight + weight_lst[idx]) <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # If both objectives improve, add the item\n                if new_value1 > current_value1 and new_value2 > current_value2:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Check if removing this item is feasible and still leaves a good solution\n            if (current_weight - weight_lst[idx]) <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # If both objectives do not worsen too much, remove the item\n                if (new_value1 >= current_value1 * 0.9) and (new_value2 >= current_value2 * 0.9):\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n",
        "score": [
            -0.3830294605420365,
            2.908996671438217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by a combination of objectives to identify less explored regions\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n        # Select a solution from the middle to avoid extreme solutions\n        base_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly flip a subset of items (intelligent selection)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it if feasible\n            if (np.sum(weight_lst * new_solution) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If item is excluded, try to include it if feasible\n            if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Greedy improvement step to maximize both objectives\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Try to add or remove items to improve both objectives\n    for idx in np.random.permutation(n_items):\n        if new_solution[idx] == 0:\n            # Check if adding this item is feasible and improves both objectives\n            if (current_weight + weight_lst[idx]) <= capacity:\n                new_value1 = current_value1 + value1_lst[idx]\n                new_value2 = current_value2 + value2_lst[idx]\n                # If both objectives improve, add the item\n                if new_value1 > current_value1 and new_value2 > current_value2:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n        else:\n            # Check if removing this item is feasible and still leaves a good solution\n            if (current_weight - weight_lst[idx]) <= capacity:\n                new_value1 = current_value1 - value1_lst[idx]\n                new_value2 = current_value2 - value2_lst[idx]\n                # If both objectives do not worsen too much, remove the item\n                if (new_value1 >= current_value1 * 0.9) and (new_value2 >= current_value2 * 0.9):\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n                    current_value1 = new_value1\n                    current_value2 = new_value2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 151,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = random.choice(archive_sorted[:max(1, len(archive_sorted) // 2)])[0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: Random flip with greedy selection\n    for _ in range(min(5, len(new_solution))):  # Limit the number of flips to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(new_solution) - 1)\n\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Greedily select the item that improves both objectives the most\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                if improvement1 > 0 or improvement2 > 0:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.34734018516650883,
            0.9323576986789703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = random.choice(archive_sorted[:max(1, len(archive_sorted) // 2)])[0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: Random flip with greedy selection\n    for _ in range(min(5, len(new_solution))):  # Limit the number of flips to avoid excessive computation\n        # Randomly select an item to flip\n        idx = random.randint(0, len(new_solution) - 1)\n\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                current_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Greedily select the item that improves both objectives the most\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                if improvement1 > 0 or improvement2 > 0:\n                    new_solution[idx] = 1\n                    current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 152,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high potential for improvement (e.g., not too crowded in the objective space)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Consider solutions that are not at capacity and have room for improvement\n        if total_weight < capacity * 0.9:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no candidates, fall back to random selection\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a candidate with high potential (e.g., high objective values but not at capacity)\n        base_solution = max(candidates, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly perturb the solution by flipping a few bits\n    num_perturbations = min(3, len(new_solution) // 2)\n    perturb_indices = np.random.choice(len(new_solution), num_perturbations, replace=False)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # 2. Ensure feasibility by removing excess weight\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        excess = total_weight - capacity\n        # Remove items with the smallest value-to-weight ratio until feasible\n        while excess > 0:\n            item_ratios = (value1_lst + value2_lst) / weight_lst\n            item_ratios[new_solution == 0] = np.inf  # Ignore items not in the solution\n            worst_item = np.argmin(item_ratios)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n                excess -= weight_lst[worst_item]\n            else:\n                break\n\n    # 3. Apply a value-based swap to improve both objectives\n    # Find the best item not in the solution and the worst item in the solution\n    if np.any(new_solution == 0):\n        best_item = np.argmax((value1_lst + value2_lst) * (new_solution == 0))\n        if weight_lst[best_item] <= capacity - total_weight:\n            new_solution[best_item] = 1\n\n    # Find the worst item in the solution (smallest value-to-weight ratio)\n    item_ratios = (value1_lst + value2_lst) / weight_lst\n    item_ratios[new_solution == 0] = np.inf  # Ignore items not in the solution\n    worst_item = np.argmin(item_ratios)\n    if new_solution[worst_item] == 1:\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.2924846843071828,
            2.654918909072876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high potential for improvement (e.g., not too crowded in the objective space)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        # Consider solutions that are not at capacity and have room for improvement\n        if total_weight < capacity * 0.9:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        # If no candidates, fall back to random selection\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select a candidate with high potential (e.g., high objective values but not at capacity)\n        base_solution = max(candidates, key=lambda x: sum(x[1]))[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly perturb the solution by flipping a few bits\n    num_perturbations = min(3, len(new_solution) // 2)\n    perturb_indices = np.random.choice(len(new_solution), num_perturbations, replace=False)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # 2. Ensure feasibility by removing excess weight\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        excess = total_weight - capacity\n        # Remove items with the smallest value-to-weight ratio until feasible\n        while excess > 0:\n            item_ratios = (value1_lst + value2_lst) / weight_lst\n            item_ratios[new_solution == 0] = np.inf  # Ignore items not in the solution\n            worst_item = np.argmin(item_ratios)\n            if new_solution[worst_item] == 1:\n                new_solution[worst_item] = 0\n                excess -= weight_lst[worst_item]\n            else:\n                break\n\n    # 3. Apply a value-based swap to improve both objectives\n    # Find the best item not in the solution and the worst item in the solution\n    if np.any(new_solution == 0):\n        best_item = np.argmax((value1_lst + value2_lst) * (new_solution == 0))\n        if weight_lst[best_item] <= capacity - total_weight:\n            new_solution[best_item] = 1\n\n    # Find the worst item in the solution (smallest value-to-weight ratio)\n    item_ratios = (value1_lst + value2_lst) / weight_lst\n    item_ratios[new_solution == 0] = np.inf  # Ignore items not in the solution\n    worst_item = np.argmin(item_ratios)\n    if new_solution[worst_item] == 1:\n        new_solution[worst_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 153,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that are in the solution and those not in it\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to consider for swapping\n    if len(in_items) > 0 and len(out_items) > 0:\n        num_swaps = min(3, len(in_items), len(out_items))\n        selected_in = np.random.choice(in_items, size=num_swaps, replace=False)\n        selected_out = np.random.choice(out_items, size=num_swaps, replace=False)\n\n        for in_idx, out_idx in zip(selected_in, selected_out):\n            # Calculate the weight difference if we swap in_idx (remove) and out_idx (add)\n            weight_diff = weight_lst[out_idx] - weight_lst[in_idx]\n\n            # Only perform the swap if it keeps the solution feasible\n            if current_weight + weight_diff <= capacity:\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n                current_weight += weight_diff\n\n    # Additional greedy improvement: try to add items with high value-to-weight ratio\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Calculate value-to-weight ratios for items not in the solution\n        out_items = np.where(new_solution == 0)[0]\n        if len(out_items) > 0:\n            # Combine both objectives into a single score (weighted sum)\n            value_ratio1 = value1_lst[out_items] / weight_lst[out_items]\n            value_ratio2 = value2_lst[out_items] / weight_lst[out_items]\n            combined_ratio = 0.5 * value_ratio1 + 0.5 * value_ratio2  # Equal weights for both objectives\n\n            # Sort by combined ratio in descending order\n            sorted_out_items = out_items[np.argsort(-combined_ratio)]\n\n            for item in sorted_out_items:\n                if weight_lst[item] <= remaining_weight:\n                    new_solution[item] = 1\n                    remaining_weight -= weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.37978943722572706,
            4.813438206911087
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that are in the solution and those not in it\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Randomly select a subset of items to consider for swapping\n    if len(in_items) > 0 and len(out_items) > 0:\n        num_swaps = min(3, len(in_items), len(out_items))\n        selected_in = np.random.choice(in_items, size=num_swaps, replace=False)\n        selected_out = np.random.choice(out_items, size=num_swaps, replace=False)\n\n        for in_idx, out_idx in zip(selected_in, selected_out):\n            # Calculate the weight difference if we swap in_idx (remove) and out_idx (add)\n            weight_diff = weight_lst[out_idx] - weight_lst[in_idx]\n\n            # Only perform the swap if it keeps the solution feasible\n            if current_weight + weight_diff <= capacity:\n                new_solution[in_idx] = 0\n                new_solution[out_idx] = 1\n                current_weight += weight_diff\n\n    # Additional greedy improvement: try to add items with high value-to-weight ratio\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Calculate value-to-weight ratios for items not in the solution\n        out_items = np.where(new_solution == 0)[0]\n        if len(out_items) > 0:\n            # Combine both objectives into a single score (weighted sum)\n            value_ratio1 = value1_lst[out_items] / weight_lst[out_items]\n            value_ratio2 = value2_lst[out_items] / weight_lst[out_items]\n            combined_ratio = 0.5 * value_ratio1 + 0.5 * value_ratio2  # Equal weights for both objectives\n\n            # Sort by combined ratio in descending order\n            sorted_out_items = out_items[np.argsort(-combined_ratio)]\n\n            for item in sorted_out_items:\n                if weight_lst[item] <= remaining_weight:\n                    new_solution[item] = 1\n                    remaining_weight -= weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 154,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the current total weight and objective values for each solution\n    solution_weights = [np.sum(weight_lst[solution[0] == 1]) for solution in archive]\n    solution_values = [solution[1] for solution in archive]\n\n    # Normalize objective values for selection\n    max_value1 = max(v[0] for v in solution_values) if max(v[0] for v in solution_values) != 0 else 1\n    max_value2 = max(v[1] for v in solution_values) if max(v[1] for v in solution_values) != 0 else 1\n\n    # Calculate a score for each solution based on normalized objectives and weight utilization\n    scores = []\n    for i, (weight, value) in enumerate(zip(solution_weights, solution_values)):\n        # Prefer solutions with high objective values and good weight utilization\n        score = (value[0] / max_value1 + value[1] / max_value2) * (1 - (weight / capacity))\n        scores.append(score)\n\n    # Select top 10% of solutions based on score\n    top_indices = np.argsort(scores)[-max(1, len(scores) // 10):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine bit-flip with item swapping\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a number of items to flip (1-3)\n    num_flips = random.randint(1, min(3, n_items))\n    flip_indices = random.sample(range(n_items), num_flips)\n\n    # Apply bit-flip with feasibility check\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # If no bit-flips were made, perform item swapping\n    if np.array_equal(new_solution, base_solution):\n        # Select two random items (one included, one excluded)\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            item_in = random.choice(included_items)\n            item_out = random.choice(excluded_items)\n\n            # Check if swapping is feasible\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5920450472024521,
            3.3019542396068573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the current total weight and objective values for each solution\n    solution_weights = [np.sum(weight_lst[solution[0] == 1]) for solution in archive]\n    solution_values = [solution[1] for solution in archive]\n\n    # Normalize objective values for selection\n    max_value1 = max(v[0] for v in solution_values) if max(v[0] for v in solution_values) != 0 else 1\n    max_value2 = max(v[1] for v in solution_values) if max(v[1] for v in solution_values) != 0 else 1\n\n    # Calculate a score for each solution based on normalized objectives and weight utilization\n    scores = []\n    for i, (weight, value) in enumerate(zip(solution_weights, solution_values)):\n        # Prefer solutions with high objective values and good weight utilization\n        score = (value[0] / max_value1 + value[1] / max_value2) * (1 - (weight / capacity))\n        scores.append(score)\n\n    # Select top 10% of solutions based on score\n    top_indices = np.argsort(scores)[-max(1, len(scores) // 10):]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine bit-flip with item swapping\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Randomly select a number of items to flip (1-3)\n    num_flips = random.randint(1, min(3, n_items))\n    flip_indices = random.sample(range(n_items), num_flips)\n\n    # Apply bit-flip with feasibility check\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if feasible\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if feasible\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # If no bit-flips were made, perform item swapping\n    if np.array_equal(new_solution, base_solution):\n        # Select two random items (one included, one excluded)\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        if len(included_items) > 0 and len(excluded_items) > 0:\n            item_in = random.choice(included_items)\n            item_out = random.choice(excluded_items)\n\n            # Check if swapping is feasible\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[item_in] + weight_lst[item_out]) <= capacity:\n                new_solution[item_in] = 0\n                new_solution[item_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 155,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Candidates are solutions that are not fully packed and have at least one item that can be added without exceeding capacity\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.dot(sol, weight_lst)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity > 0:\n            # Check if there are items that can be added without exceeding capacity\n            possible_items = (weight_lst <= remaining_capacity) & (sol == 0)\n            if np.any(possible_items):\n                candidates.append(sol)\n\n    if not candidates:\n        # If no candidates, randomly select a solution and flip a random bit (if possible)\n        base_solution = random.choice(archive)[0].copy()\n        new_solution = base_solution.copy()\n        possible_flips = np.where((weight_lst <= (capacity - np.dot(new_solution, weight_lst))) | (new_solution == 1))[0]\n        if len(possible_flips) > 0:\n            flip_idx = random.choice(possible_flips)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Step 2: Randomly select a candidate solution\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid local search\n    # First, perform a random bit flip (add/remove an item)\n    current_weight = np.dot(new_solution, weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Get indices of items that can be added or removed\n    addable_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n    removable_items = np.where(new_solution == 1)[0]\n\n    # Choose between adding or removing with equal probability\n    if random.random() < 0.5 and len(addable_items) > 0:\n        # Add an item\n        add_idx = random.choice(addable_items)\n        new_solution[add_idx] = 1\n    elif len(removable_items) > 0:\n        # Remove an item\n        remove_idx = random.choice(removable_items)\n        new_solution[remove_idx] = 0\n\n    # Step 4: Greedy improvement step to maximize both objectives\n    # Try to add items that improve both objectives\n    current_weight = np.dot(new_solution, weight_lst)\n    remaining_capacity = capacity - current_weight\n    possible_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n\n    for idx in possible_items:\n        # Check if adding this item improves both objectives\n        if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            remaining_capacity = capacity - current_weight\n\n    # Step 5: Ensure feasibility (should not be necessary due to previous checks, but just in case)\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            removable = np.where(new_solution == 1)[0]\n            if len(removable) == 0:\n                break\n            remove_idx = random.choice(removable)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8527771462059932,
            2.710118532180786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Candidates are solutions that are not fully packed and have at least one item that can be added without exceeding capacity\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.dot(sol, weight_lst)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity > 0:\n            # Check if there are items that can be added without exceeding capacity\n            possible_items = (weight_lst <= remaining_capacity) & (sol == 0)\n            if np.any(possible_items):\n                candidates.append(sol)\n\n    if not candidates:\n        # If no candidates, randomly select a solution and flip a random bit (if possible)\n        base_solution = random.choice(archive)[0].copy()\n        new_solution = base_solution.copy()\n        possible_flips = np.where((weight_lst <= (capacity - np.dot(new_solution, weight_lst))) | (new_solution == 1))[0]\n        if len(possible_flips) > 0:\n            flip_idx = random.choice(possible_flips)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Step 2: Randomly select a candidate solution\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid local search\n    # First, perform a random bit flip (add/remove an item)\n    current_weight = np.dot(new_solution, weight_lst)\n    remaining_capacity = capacity - current_weight\n\n    # Get indices of items that can be added or removed\n    addable_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n    removable_items = np.where(new_solution == 1)[0]\n\n    # Choose between adding or removing with equal probability\n    if random.random() < 0.5 and len(addable_items) > 0:\n        # Add an item\n        add_idx = random.choice(addable_items)\n        new_solution[add_idx] = 1\n    elif len(removable_items) > 0:\n        # Remove an item\n        remove_idx = random.choice(removable_items)\n        new_solution[remove_idx] = 0\n\n    # Step 4: Greedy improvement step to maximize both objectives\n    # Try to add items that improve both objectives\n    current_weight = np.dot(new_solution, weight_lst)\n    remaining_capacity = capacity - current_weight\n    possible_items = np.where((weight_lst <= remaining_capacity) & (new_solution == 0))[0]\n\n    for idx in possible_items:\n        # Check if adding this item improves both objectives\n        if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            remaining_capacity = capacity - current_weight\n\n    # Step 5: Ensure feasibility (should not be necessary due to previous checks, but just in case)\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            removable = np.where(new_solution == 1)[0]\n            if len(removable) == 0:\n                break\n            remove_idx = random.choice(removable)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 156,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the 'potential' as a combination of objective values and solution density\n        density = np.sum(sol) / len(sol)\n        potential = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - density)\n        candidates.append((potential, sol))\n\n    # Select the solution with highest potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Create a neighbor by flipping items based on a hybrid strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Strategy 1: Random flip with probability based on item value\n    for i in range(n_items):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if base_solution[i] == 1:\n                # Remove item if it's in the solution\n                new_solution[i] = 0\n            else:\n                # Add item if it fits\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Strategy 2: Objective-specific flips (add high-value items for each objective)\n    # For objective 1\n    if np.random.rand() < 0.5:\n        # Find items not in solution with highest value1\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value1_lst[candidate_items])]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    # For objective 2\n    if np.random.rand() < 0.5:\n        # Find items not in solution with highest value2\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value2_lst[candidate_items])]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    # Strategy 3: Capacity-aware adjustment (remove low-value items if over capacity)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    while current_weight > capacity:\n        # Find items in solution with lowest combined value\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            break\n        worst_item = candidate_items[np.argmin(value1_lst[candidate_items] + value2_lst[candidate_items])]\n        new_solution[worst_item] = 0\n        current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.9723670148908632,
            2.607099771499634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the 'potential' as a combination of objective values and solution density\n        density = np.sum(sol) / len(sol)\n        potential = (obj[0] * 0.6 + obj[1] * 0.4) * (1 - density)\n        candidates.append((potential, sol))\n\n    # Select the solution with highest potential\n    candidates.sort(key=lambda x: -x[0])\n    base_solution = candidates[0][1].copy()\n\n    # Create a neighbor by flipping items based on a hybrid strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Strategy 1: Random flip with probability based on item value\n    for i in range(n_items):\n        if np.random.rand() < 0.3:  # 30% chance to consider flipping\n            if base_solution[i] == 1:\n                # Remove item if it's in the solution\n                new_solution[i] = 0\n            else:\n                # Add item if it fits\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Strategy 2: Objective-specific flips (add high-value items for each objective)\n    # For objective 1\n    if np.random.rand() < 0.5:\n        # Find items not in solution with highest value1\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value1_lst[candidate_items])]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    # For objective 2\n    if np.random.rand() < 0.5:\n        # Find items not in solution with highest value2\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value2_lst[candidate_items])]\n            if current_weight + weight_lst[best_item] <= capacity:\n                new_solution[best_item] = 1\n\n    # Strategy 3: Capacity-aware adjustment (remove low-value items if over capacity)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    while current_weight > capacity:\n        # Find items in solution with lowest combined value\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            break\n        worst_item = candidate_items[np.argmin(value1_lst[candidate_items] + value2_lst[candidate_items])]\n        new_solution[worst_item] = 0\n        current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 157,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with higher potential for improvement\n    # Here, we prioritize solutions with lower total weight (more room for improvement)\n    archive_sorted = sorted(archive, key=lambda x: np.sum(weight_lst[x[0] == 1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 most underutilized solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a neighbor by flipping a random subset of items\n    new_solution = base_solution.copy()\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing items if capacity is exceeded\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Greedy removal of items with lowest ratio of (value1 + value2) / weight\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break  # No items left to remove\n            # Calculate value-to-weight ratio for each included item\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            # Remove the item with the lowest ratio\n            remove_idx = included_items[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Further improve the solution by adding items with highest value-to-weight ratio\n    excluded_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for item in excluded_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.22125191835098618,
            5.929953157901764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with higher potential for improvement\n    # Here, we prioritize solutions with lower total weight (more room for improvement)\n    archive_sorted = sorted(archive, key=lambda x: np.sum(weight_lst[x[0] == 1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 most underutilized solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Create a neighbor by flipping a random subset of items\n    new_solution = base_solution.copy()\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing items if capacity is exceeded\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Greedy removal of items with lowest ratio of (value1 + value2) / weight\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break  # No items left to remove\n            # Calculate value-to-weight ratio for each included item\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            # Remove the item with the lowest ratio\n            remove_idx = included_items[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Further improve the solution by adding items with highest value-to-weight ratio\n    excluded_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    for item in excluded_items:\n        if current_weight + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 158,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential gains/losses\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (exploration)\n    # 2. Flip items with high marginal gains (exploitation)\n    # Ensure feasibility by rejecting infeasible flips\n\n    # Step 1: Random flips (exploration)\n    n_items = len(base_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Flip items with high marginal gains (exploitation)\n    # Calculate marginal gains for both objectives\n    marginal_gain1 = value1_lst * (1 - base_solution) - value1_lst * base_solution\n    marginal_gain2 = value2_lst * (1 - base_solution) - value2_lst * base_solution\n\n    # Combine gains using weighted sum\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort by combined gain and flip top candidates\n    sorted_indices = np.argsort(combined_gain)[::-1]\n    for idx in sorted_indices[:min(5, n_items)]:\n        if base_solution[idx] == 0 and np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n        elif base_solution[idx] == 1 and np.sum(weight_lst * new_solution) - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.32009739112316826,
            2.0371463298797607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and potential gains/losses\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (exploration)\n    # 2. Flip items with high marginal gains (exploitation)\n    # Ensure feasibility by rejecting infeasible flips\n\n    # Step 1: Random flips (exploration)\n    n_items = len(base_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Flip items with high marginal gains (exploitation)\n    # Calculate marginal gains for both objectives\n    marginal_gain1 = value1_lst * (1 - base_solution) - value1_lst * base_solution\n    marginal_gain2 = value2_lst * (1 - base_solution) - value2_lst * base_solution\n\n    # Combine gains using weighted sum\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort by combined gain and flip top candidates\n    sorted_indices = np.argsort(combined_gain)[::-1]\n    for idx in sorted_indices[:min(5, n_items)]:\n        if base_solution[idx] == 0 and np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n        elif base_solution[idx] == 1 and np.sum(weight_lst * new_solution) - weight_lst[idx] >= 0:\n            new_solution[idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 159,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random perturbation with greedy improvement\n    # Step 1: Randomly flip a subset of items (with probability based on their marginal contribution)\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                # Try to remove item if it doesn't violate capacity when removed\n                if (np.sum(weight_lst * new_solution) - weight_lst[i]) <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Try to add item if it doesn't violate capacity\n                if (np.sum(weight_lst * new_solution) + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Greedily improve the solution by considering marginal contributions\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Try to add the most valuable item (considering both objectives) that fits\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Calculate marginal value per weight for each item (combining both objectives)\n        marginal_value1 = value1_lst / weight_lst\n        marginal_value2 = value2_lst / weight_lst\n        marginal_combined = marginal_value1 + marginal_value2  # Simple combination\n\n        # Sort items by combined marginal value\n        sorted_indices = np.argsort(marginal_combined)[::-1]\n\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_weight:\n                new_solution[i] = 1\n                remaining_weight -= weight_lst[i]\n\n    # Verify feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If not feasible, perform a quick repair by removing the least valuable items\n        while np.sum(weight_lst * new_solution) > capacity:\n            # Find the item with the smallest combined marginal value that's currently included\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break  # No items left to remove\n            item_to_remove = included_items[np.argmin(marginal_combined[included_items])]\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.40481413860006277,
            5.1343508660793304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, base_objective = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random perturbation with greedy improvement\n    # Step 1: Randomly flip a subset of items (with probability based on their marginal contribution)\n    for i in range(len(new_solution)):\n        if np.random.rand() < 0.3:  # 30% chance to flip\n            if new_solution[i] == 1:\n                # Try to remove item if it doesn't violate capacity when removed\n                if (np.sum(weight_lst * new_solution) - weight_lst[i]) <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Try to add item if it doesn't violate capacity\n                if (np.sum(weight_lst * new_solution) + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Greedily improve the solution by considering marginal contributions\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Try to add the most valuable item (considering both objectives) that fits\n    remaining_weight = capacity - current_weight\n    if remaining_weight > 0:\n        # Calculate marginal value per weight for each item (combining both objectives)\n        marginal_value1 = value1_lst / weight_lst\n        marginal_value2 = value2_lst / weight_lst\n        marginal_combined = marginal_value1 + marginal_value2  # Simple combination\n\n        # Sort items by combined marginal value\n        sorted_indices = np.argsort(marginal_combined)[::-1]\n\n        for i in sorted_indices:\n            if new_solution[i] == 0 and weight_lst[i] <= remaining_weight:\n                new_solution[i] = 1\n                remaining_weight -= weight_lst[i]\n\n    # Verify feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If not feasible, perform a quick repair by removing the least valuable items\n        while np.sum(weight_lst * new_solution) > capacity:\n            # Find the item with the smallest combined marginal value that's currently included\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break  # No items left to remove\n            item_to_remove = included_items[np.argmin(marginal_combined[included_items])]\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 160,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with potential for improvement (e.g., not already optimal in both objectives)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Intelligent selection: prefer solutions with higher potential for improvement\n    selected_sol = None\n    max_potential = -1\n    for sol, obj in candidates:\n        potential = (obj[0] + obj[1])  # Simple heuristic for potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_sol = sol\n\n    if selected_sol is None:\n        selected_sol = random.choice(candidates)[0]\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + objective-aware swaps\n    n_items = len(weight_lst)\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Randomly perturb the solution (add/remove items)\n    for _ in range(min(3, n_items // 2)):  # Limit perturbation to avoid excessive changes\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Objective-aware swaps: try to improve both objectives\n    for _ in range(min(5, n_items // 3)):  # Limit swaps to avoid excessive changes\n        # Find items to swap: one in the solution and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items to swap based on value ratios\n        in_idx = random.choice(in_items)\n        out_idx = random.choice(out_items)\n\n        # Check if swap improves both objectives\n        delta_weight = weight_lst[out_idx] - weight_lst[in_idx]\n        delta_value1 = value1_lst[out_idx] - value1_lst[in_idx]\n        delta_value2 = value2_lst[out_idx] - value2_lst[in_idx]\n\n        if (delta_weight + current_weight <= capacity) and (delta_value1 > 0 or delta_value2 > 0):\n            new_solution[in_idx] = 0\n            new_solution[out_idx] = 1\n            current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.32447695015205213,
            4.537989228963852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with potential for improvement (e.g., not already optimal in both objectives)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            candidates.append((sol, obj))\n\n    if not candidates:\n        return archive[0][0].copy()\n\n    # Intelligent selection: prefer solutions with higher potential for improvement\n    selected_sol = None\n    max_potential = -1\n    for sol, obj in candidates:\n        potential = (obj[0] + obj[1])  # Simple heuristic for potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_sol = sol\n\n    if selected_sol is None:\n        selected_sol = random.choice(candidates)[0]\n\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + objective-aware swaps\n    n_items = len(weight_lst)\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Randomly perturb the solution (add/remove items)\n    for _ in range(min(3, n_items // 2)):  # Limit perturbation to avoid excessive changes\n        idx = random.randint(0, n_items - 1)\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try to add item if feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Objective-aware swaps: try to improve both objectives\n    for _ in range(min(5, n_items // 3)):  # Limit swaps to avoid excessive changes\n        # Find items to swap: one in the solution and one out\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) == 0 or len(out_items) == 0:\n            break\n\n        # Select items to swap based on value ratios\n        in_idx = random.choice(in_items)\n        out_idx = random.choice(out_items)\n\n        # Check if swap improves both objectives\n        delta_weight = weight_lst[out_idx] - weight_lst[in_idx]\n        delta_value1 = value1_lst[out_idx] - value1_lst[in_idx]\n        delta_value2 = value2_lst[out_idx] - value2_lst[in_idx]\n\n        if (delta_weight + current_weight <= capacity) and (delta_value1 > 0 or delta_value2 > 0):\n            new_solution[in_idx] = 0\n            new_solution[out_idx] = 1\n            current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 161,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            candidates.append((sol, obj, remaining_capacity))\n\n    if not candidates:\n        return archive[0][0].copy()  # Return a copy if no candidates (shouldn't happen in practice)\n\n    # Select a solution with the most remaining capacity (promising for further improvement)\n    selected_sol, _, remaining_capacity = max(candidates, key=lambda x: x[2])\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly swap a few items (exploration)\n    num_swaps = min(3, len(new_solution) // 2)\n    for _ in range(num_swaps):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Greedily add high-value items (exploitation)\n    # Calculate marginal gains for each item not in the solution\n    marginal_gains = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            weight = weight_lst[i]\n            if weight <= remaining_capacity:\n                # Use a weighted sum of both objectives as the gain metric\n                gain = value1_lst[i] + value2_lst[i]\n                marginal_gains.append((i, gain, weight))\n\n    # Sort by gain in descending order\n    marginal_gains.sort(key=lambda x: -x[1])\n\n    # Add the top items that fit\n    for i, gain, weight in marginal_gains:\n        if weight <= remaining_capacity:\n            new_solution[i] = 1\n            remaining_capacity -= weight\n\n    # 3. Remove low-value items if capacity is tight\n    if remaining_capacity < 0.1 * capacity:  # If less than 10% capacity left\n        # Calculate marginal losses for each item in the solution\n        marginal_losses = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                loss = value1_lst[i] + value2_lst[i]\n                marginal_losses.append((i, loss))\n\n        # Sort by loss in ascending order (remove least valuable first)\n        marginal_losses.sort(key=lambda x: x[1])\n\n        # Remove items until feasible\n        for i, loss in marginal_losses:\n            if np.sum(weight_lst * new_solution) <= capacity:\n                break\n            new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7067799700053112,
            3.513475775718689
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        if remaining_capacity > 0:\n            candidates.append((sol, obj, remaining_capacity))\n\n    if not candidates:\n        return archive[0][0].copy()  # Return a copy if no candidates (shouldn't happen in practice)\n\n    # Select a solution with the most remaining capacity (promising for further improvement)\n    selected_sol, _, remaining_capacity = max(candidates, key=lambda x: x[2])\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly swap a few items (exploration)\n    num_swaps = min(3, len(new_solution) // 2)\n    for _ in range(num_swaps):\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Greedily add high-value items (exploitation)\n    # Calculate marginal gains for each item not in the solution\n    marginal_gains = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0:\n            weight = weight_lst[i]\n            if weight <= remaining_capacity:\n                # Use a weighted sum of both objectives as the gain metric\n                gain = value1_lst[i] + value2_lst[i]\n                marginal_gains.append((i, gain, weight))\n\n    # Sort by gain in descending order\n    marginal_gains.sort(key=lambda x: -x[1])\n\n    # Add the top items that fit\n    for i, gain, weight in marginal_gains:\n        if weight <= remaining_capacity:\n            new_solution[i] = 1\n            remaining_capacity -= weight\n\n    # 3. Remove low-value items if capacity is tight\n    if remaining_capacity < 0.1 * capacity:  # If less than 10% capacity left\n        # Calculate marginal losses for each item in the solution\n        marginal_losses = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 1:\n                loss = value1_lst[i] + value2_lst[i]\n                marginal_losses.append((i, loss))\n\n        # Sort by loss in ascending order (remove least valuable first)\n        marginal_losses.sort(key=lambda x: x[1])\n\n        # Remove items until feasible\n        for i, loss in marginal_losses:\n            if np.sum(weight_lst * new_solution) <= capacity:\n                break\n            new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 162,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values to find promising candidates\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2, reverse=True)\n        selected_idx = np.random.choice(min(3, len(archive_sorted)), 1)[0]\n        base_solution, _ = archive_sorted[selected_idx]\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flips with guided improvements\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly flip a subset of items to introduce diversity\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Guided improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Sort remaining items by a combined score of both objectives\n        combined_scores = (value1_lst[remaining_items] + value2_lst[remaining_items]) / 2\n        sorted_indices = remaining_items[np.argsort(combined_scores)[::-1]]\n\n        for idx in sorted_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            else:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.3101600075536579,
            2.195097714662552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values to find promising candidates\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2, reverse=True)\n        selected_idx = np.random.choice(min(3, len(archive_sorted)), 1)[0]\n        base_solution, _ = archive_sorted[selected_idx]\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flips with guided improvements\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Step 1: Randomly flip a subset of items to introduce diversity\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Guided improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Sort remaining items by a combined score of both objectives\n        combined_scores = (value1_lst[remaining_items] + value2_lst[remaining_items]) / 2\n        sorted_indices = remaining_items[np.argsort(combined_scores)[::-1]]\n\n        for idx in sorted_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n            else:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 163,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small subset of items (local perturbation)\n    # 2. If feasible, perform a greedy insertion of items not in the solution\n    # 3. If not feasible, perform a greedy removal of items in the solution\n\n    # Step 1: Randomly flip a small subset of items\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after flipping\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Step 3: Greedy removal if not feasible\n        excess_weight = new_weight - capacity\n        sorted_indices = np.argsort(weight_lst * new_solution)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess_weight > 0:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n                if excess_weight <= 0:\n                    break\n    else:\n        # Step 2: Greedy insertion if feasible\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Sort by the sum of normalized values (to balance both objectives)\n            value1_norm = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n            value2_norm = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n            combined_value = value1_norm + value2_norm\n            sorted_available = np.argsort(combined_value[available_items])[::-1]\n\n            for idx in sorted_available:\n                item_idx = available_items[idx]\n                if new_weight + weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 1\n                    new_weight += weight_lst[item_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.391910234705106,
            1.5848628878593445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small subset of items (local perturbation)\n    # 2. If feasible, perform a greedy insertion of items not in the solution\n    # 3. If not feasible, perform a greedy removal of items in the solution\n\n    # Step 1: Randomly flip a small subset of items\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after flipping\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Step 3: Greedy removal if not feasible\n        excess_weight = new_weight - capacity\n        sorted_indices = np.argsort(weight_lst * new_solution)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1 and excess_weight > 0:\n                new_solution[idx] = 0\n                excess_weight -= weight_lst[idx]\n                if excess_weight <= 0:\n                    break\n    else:\n        # Step 2: Greedy insertion if feasible\n        available_items = np.where(new_solution == 0)[0]\n        if len(available_items) > 0:\n            # Sort by the sum of normalized values (to balance both objectives)\n            value1_norm = (value1_lst - np.min(value1_lst)) / (np.max(value1_lst) - np.min(value1_lst) + 1e-10)\n            value2_norm = (value2_lst - np.min(value2_lst)) / (np.max(value2_lst) - np.min(value2_lst) + 1e-10)\n            combined_value = value1_norm + value2_norm\n            sorted_available = np.argsort(combined_value[available_items])[::-1]\n\n            for idx in sorted_available:\n                item_idx = available_items[idx]\n                if new_weight + weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 1\n                    new_weight += weight_lst[item_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 164,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(base_solution * weight_lst)\n\n    # Generate a neighbor by flipping a random bit (perturbation)\n    new_solution = base_solution.copy()\n    candidate_items = np.where(new_solution == 1)[0]\n\n    if len(candidate_items) > 0:\n        # Flip a random item to exclude\n        flip_idx = np.random.choice(candidate_items)\n        new_solution[flip_idx] = 0\n        new_weight = current_weight - weight_lst[flip_idx]\n\n        # Find items that can be added without exceeding capacity\n        available_items = np.where((new_solution == 0) & (weight_lst <= capacity - new_weight))[0]\n\n        if len(available_items) > 0:\n            # Select an item with high value-to-weight ratio for both objectives\n            value_ratio1 = value1_lst[available_items] / weight_lst[available_items]\n            value_ratio2 = value2_lst[available_items] / weight_lst[available_items]\n            combined_ratio = value_ratio1 + value_ratio2  # Simple heuristic for bi-objective\n\n            best_item_idx = available_items[np.argmax(combined_ratio)]\n            new_solution[best_item_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.39684346684238714,
            9.425779938697815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too crowded in the objective space)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate current total weight\n    current_weight = np.sum(base_solution * weight_lst)\n\n    # Generate a neighbor by flipping a random bit (perturbation)\n    new_solution = base_solution.copy()\n    candidate_items = np.where(new_solution == 1)[0]\n\n    if len(candidate_items) > 0:\n        # Flip a random item to exclude\n        flip_idx = np.random.choice(candidate_items)\n        new_solution[flip_idx] = 0\n        new_weight = current_weight - weight_lst[flip_idx]\n\n        # Find items that can be added without exceeding capacity\n        available_items = np.where((new_solution == 0) & (weight_lst <= capacity - new_weight))[0]\n\n        if len(available_items) > 0:\n            # Select an item with high value-to-weight ratio for both objectives\n            value_ratio1 = value1_lst[available_items] / weight_lst[available_items]\n            value_ratio2 = value2_lst[available_items] / weight_lst[available_items]\n            combined_ratio = value_ratio1 + value_ratio2  # Simple heuristic for bi-objective\n\n            best_item_idx = available_items[np.argmax(combined_ratio)]\n            new_solution[best_item_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 165,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a promising solution based on a combination of objective values and solution diversity\n    selected_idx = random.choices(range(len(archive)), weights=[(obj1 + obj2) for _, (obj1, obj2) in archive], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of flip-based and swap-based moves\n    current_weight = np.dot(new_solution, weight_lst)\n\n    # First, try to flip a single item (add or remove) if feasible\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # Remove candidate\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))   # Add candidate\n\n    if candidates:\n        # Evaluate candidates based on their potential improvement in both objectives\n        best_candidate = None\n        best_score = -1\n        for i, delta in candidates:\n            if delta == 1:\n                score = value1_lst[i] + value2_lst[i]\n            else:\n                score = -(value1_lst[i] + value2_lst[i])\n            if score > best_score:\n                best_score = score\n                best_candidate = (i, delta)\n\n        if best_candidate:\n            i, delta = best_candidate\n            new_solution[i] = 1 if delta == 1 else 0\n            return new_solution\n\n    # If no single flip improves, try a 1-1 swap between items\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Find the best pair to swap\n        best_swap = None\n        best_score = -1\n        for i in items_in:\n            for j in items_out:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    score = -(value1_lst[i] + value2_lst[i]) + (value1_lst[j] + value2_lst[j])\n                    if score > best_score:\n                        best_score = score\n                        best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i] = 0\n            new_solution[j] = 1\n            return new_solution\n\n    # If no improvement found, try a random mutation\n    candidates = [i for i in range(len(new_solution)) if\n                 (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                 (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n\n    if candidates:\n        i = random.choice(candidates)\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8760959659469463,
            1.6600687801837921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a promising solution based on a combination of objective values and solution diversity\n    selected_idx = random.choices(range(len(archive)), weights=[(obj1 + obj2) for _, (obj1, obj2) in archive], k=1)[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of flip-based and swap-based moves\n    current_weight = np.dot(new_solution, weight_lst)\n\n    # First, try to flip a single item (add or remove) if feasible\n    candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                candidates.append((i, -1))  # Remove candidate\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                candidates.append((i, 1))   # Add candidate\n\n    if candidates:\n        # Evaluate candidates based on their potential improvement in both objectives\n        best_candidate = None\n        best_score = -1\n        for i, delta in candidates:\n            if delta == 1:\n                score = value1_lst[i] + value2_lst[i]\n            else:\n                score = -(value1_lst[i] + value2_lst[i])\n            if score > best_score:\n                best_score = score\n                best_candidate = (i, delta)\n\n        if best_candidate:\n            i, delta = best_candidate\n            new_solution[i] = 1 if delta == 1 else 0\n            return new_solution\n\n    # If no single flip improves, try a 1-1 swap between items\n    items_in = np.where(new_solution == 1)[0]\n    items_out = np.where(new_solution == 0)[0]\n\n    if len(items_in) > 0 and len(items_out) > 0:\n        # Find the best pair to swap\n        best_swap = None\n        best_score = -1\n        for i in items_in:\n            for j in items_out:\n                if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                    score = -(value1_lst[i] + value2_lst[i]) + (value1_lst[j] + value2_lst[j])\n                    if score > best_score:\n                        best_score = score\n                        best_swap = (i, j)\n\n        if best_swap:\n            i, j = best_swap\n            new_solution[i] = 0\n            new_solution[j] = 1\n            return new_solution\n\n    # If no improvement found, try a random mutation\n    candidates = [i for i in range(len(new_solution)) if\n                 (new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity) or\n                 (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity)]\n\n    if candidates:\n        i = random.choice(candidates)\n        new_solution[i] = 1 - new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 166,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: flip items based on value-to-weight ratio and randomness\n    for _ in range(10):  # Perform multiple flips\n        # Calculate value-to-weight ratios for both objectives\n        vw_ratio1 = value1_lst / (weight_lst + 1e-10)\n        vw_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios with random weights to balance exploration\n        combined_ratio = random.uniform(0.3, 0.7) * vw_ratio1 + (1 - random.uniform(0.3, 0.7)) * vw_ratio2\n\n        # Find items not in the solution with highest combined ratio\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) == 0:\n            break\n\n        # Select top 20% candidates by combined ratio\n        top_candidates = candidate_items[np.argsort(combined_ratio[candidate_items])[-max(1, len(candidate_items)//5):]]\n\n        # Randomly select one candidate to flip\n        if len(top_candidates) > 0:\n            item_to_add = random.choice(top_candidates)\n            if current_weight + weight_lst[item_to_add] <= capacity:\n                new_solution[item_to_add] = 1\n                current_weight += weight_lst[item_to_add]\n\n    # Optionally remove some low-value items to free up capacity\n    for _ in range(5):\n        current_items = np.where(new_solution == 1)[0]\n        if len(current_items) == 0:\n            break\n\n        # Calculate removal impact (combined value impact)\n        removal_impact = (value1_lst[current_items] + value2_lst[current_items]) / (weight_lst[current_items] + 1e-10)\n        worst_item = current_items[np.argmin(removal_impact)]\n\n        # Remove item if it doesn't significantly impact both objectives\n        if removal_impact[np.argmin(removal_impact)] < 0.1 * np.mean(removal_impact):\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.7722475611220967,
            8.035031706094742
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (base_value1, base_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: flip items based on value-to-weight ratio and randomness\n    for _ in range(10):  # Perform multiple flips\n        # Calculate value-to-weight ratios for both objectives\n        vw_ratio1 = value1_lst / (weight_lst + 1e-10)\n        vw_ratio2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios with random weights to balance exploration\n        combined_ratio = random.uniform(0.3, 0.7) * vw_ratio1 + (1 - random.uniform(0.3, 0.7)) * vw_ratio2\n\n        # Find items not in the solution with highest combined ratio\n        candidate_items = np.where(new_solution == 0)[0]\n        if len(candidate_items) == 0:\n            break\n\n        # Select top 20% candidates by combined ratio\n        top_candidates = candidate_items[np.argsort(combined_ratio[candidate_items])[-max(1, len(candidate_items)//5):]]\n\n        # Randomly select one candidate to flip\n        if len(top_candidates) > 0:\n            item_to_add = random.choice(top_candidates)\n            if current_weight + weight_lst[item_to_add] <= capacity:\n                new_solution[item_to_add] = 1\n                current_weight += weight_lst[item_to_add]\n\n    # Optionally remove some low-value items to free up capacity\n    for _ in range(5):\n        current_items = np.where(new_solution == 1)[0]\n        if len(current_items) == 0:\n            break\n\n        # Calculate removal impact (combined value impact)\n        removal_impact = (value1_lst[current_items] + value2_lst[current_items]) / (weight_lst[current_items] + 1e-10)\n        worst_item = current_items[np.argmin(removal_impact)]\n\n        # Remove item if it doesn't significantly impact both objectives\n        if removal_impact[np.argmin(removal_impact)] < 0.1 * np.mean(removal_impact):\n            new_solution[worst_item] = 0\n            current_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 167,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Combine random flips with guided improvements\n    for _ in range(10):  # Number of improvement attempts\n        # Randomly select a subset of items to flip\n        flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n\n        for idx in flip_indices:\n            # Calculate potential new weight\n            if new_solution[idx] == 1:\n                potential_weight = current_weight - weight_lst[idx]\n            else:\n                potential_weight = current_weight + weight_lst[idx]\n\n            if potential_weight <= capacity:\n                # Flip the item if feasible\n                new_solution[idx] = 1 - new_solution[idx]\n                current_weight = potential_weight\n\n                # Additional guided improvement: prioritize items with better value-to-weight ratio\n                if new_solution[idx] == 1:\n                    # Sort items by value1/weight ratio and flip top candidates\n                    ratios1 = value1_lst / (weight_lst + 1e-10)\n                    top_indices = np.argsort(ratios1)[-3:]  # Top 3 by value1\n                    for ti in top_indices:\n                        if new_solution[ti] == 0 and (current_weight + weight_lst[ti]) <= capacity:\n                            new_solution[ti] = 1\n                            current_weight += weight_lst[ti]\n\n                    # Similarly for value2\n                    ratios2 = value2_lst / (weight_lst + 1e-10)\n                    top_indices = np.argsort(ratios2)[-3:]  # Top 3 by value2\n                    for ti in top_indices:\n                        if new_solution[ti] == 0 and (current_weight + weight_lst[ti]) <= capacity:\n                            new_solution[ti] = 1\n                            current_weight += weight_lst[ti]\n\n    return new_solution\n\n",
        "score": [
            -0.474722392367107,
            5.012641221284866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive\n    selected_idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Combine random flips with guided improvements\n    for _ in range(10):  # Number of improvement attempts\n        # Randomly select a subset of items to flip\n        flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n\n        for idx in flip_indices:\n            # Calculate potential new weight\n            if new_solution[idx] == 1:\n                potential_weight = current_weight - weight_lst[idx]\n            else:\n                potential_weight = current_weight + weight_lst[idx]\n\n            if potential_weight <= capacity:\n                # Flip the item if feasible\n                new_solution[idx] = 1 - new_solution[idx]\n                current_weight = potential_weight\n\n                # Additional guided improvement: prioritize items with better value-to-weight ratio\n                if new_solution[idx] == 1:\n                    # Sort items by value1/weight ratio and flip top candidates\n                    ratios1 = value1_lst / (weight_lst + 1e-10)\n                    top_indices = np.argsort(ratios1)[-3:]  # Top 3 by value1\n                    for ti in top_indices:\n                        if new_solution[ti] == 0 and (current_weight + weight_lst[ti]) <= capacity:\n                            new_solution[ti] = 1\n                            current_weight += weight_lst[ti]\n\n                    # Similarly for value2\n                    ratios2 = value2_lst / (weight_lst + 1e-10)\n                    top_indices = np.argsort(ratios2)[-3:]  # Top 3 by value2\n                    for ti in top_indices:\n                        if new_solution[ti] == 0 and (current_weight + weight_lst[ti]) <= capacity:\n                            new_solution[ti] = 1\n                            current_weight += weight_lst[ti]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 168,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Sort solutions by the sum of their objective values (higher is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    top_k = min(5, len(archive_sorted))  # Consider top 5 solutions or fewer if archive is small\n    selected_solution = random.choice(archive_sorted[:top_k])[0].copy()\n\n    # Step 2: Hybrid local search strategy\n    # Identify high-value and low-value items based on both objectives\n    high_value_items = np.logical_or(value1_lst > np.median(value1_lst), value2_lst > np.median(value2_lst))\n    low_value_items = ~high_value_items\n\n    # Randomly swap items between high-value and low-value regions\n    swap_indices = np.where(np.random.rand(len(selected_solution)) < 0.3)[0]  # 30% chance to swap\n    for idx in swap_indices:\n        if selected_solution[idx] == 1:\n            # Try to swap with a low-value item not in the solution\n            low_value_candidates = np.where((low_value_items == 1) & (selected_solution == 0))[0]\n            if len(low_value_candidates) > 0:\n                swap_candidate = random.choice(low_value_candidates)\n                selected_solution[idx], selected_solution[swap_candidate] = selected_solution[swap_candidate], selected_solution[idx]\n        else:\n            # Try to swap with a high-value item in the solution\n            high_value_candidates = np.where((high_value_items == 1) & (selected_solution == 1))[0]\n            if len(high_value_candidates) > 0:\n                swap_candidate = random.choice(high_value_candidates)\n                selected_solution[idx], selected_solution[swap_candidate] = selected_solution[swap_candidate], selected_solution[idx]\n\n    # Ensure feasibility by removing items until the capacity is satisfied\n    total_weight = np.sum(weight_lst * selected_solution)\n    while total_weight > capacity:\n        # Remove the heaviest item in the solution\n        heavy_items_in_solution = np.where((selected_solution == 1) & (weight_lst > 0))[0]\n        if len(heavy_items_in_solution) == 0:\n            break  # No more items to remove\n        heaviest_idx = heavy_items_in_solution[np.argmax(weight_lst[heavy_items_in_solution])]\n        selected_solution[heaviest_idx] = 0\n        total_weight = np.sum(weight_lst * selected_solution)\n\n    return selected_solution\n\n",
        "score": [
            -0.8663053025294645,
            5.38435161113739
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with high potential for improvement\n    # Sort solutions by the sum of their objective values (higher is better)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    top_k = min(5, len(archive_sorted))  # Consider top 5 solutions or fewer if archive is small\n    selected_solution = random.choice(archive_sorted[:top_k])[0].copy()\n\n    # Step 2: Hybrid local search strategy\n    # Identify high-value and low-value items based on both objectives\n    high_value_items = np.logical_or(value1_lst > np.median(value1_lst), value2_lst > np.median(value2_lst))\n    low_value_items = ~high_value_items\n\n    # Randomly swap items between high-value and low-value regions\n    swap_indices = np.where(np.random.rand(len(selected_solution)) < 0.3)[0]  # 30% chance to swap\n    for idx in swap_indices:\n        if selected_solution[idx] == 1:\n            # Try to swap with a low-value item not in the solution\n            low_value_candidates = np.where((low_value_items == 1) & (selected_solution == 0))[0]\n            if len(low_value_candidates) > 0:\n                swap_candidate = random.choice(low_value_candidates)\n                selected_solution[idx], selected_solution[swap_candidate] = selected_solution[swap_candidate], selected_solution[idx]\n        else:\n            # Try to swap with a high-value item in the solution\n            high_value_candidates = np.where((high_value_items == 1) & (selected_solution == 1))[0]\n            if len(high_value_candidates) > 0:\n                swap_candidate = random.choice(high_value_candidates)\n                selected_solution[idx], selected_solution[swap_candidate] = selected_solution[swap_candidate], selected_solution[idx]\n\n    # Ensure feasibility by removing items until the capacity is satisfied\n    total_weight = np.sum(weight_lst * selected_solution)\n    while total_weight > capacity:\n        # Remove the heaviest item in the solution\n        heavy_items_in_solution = np.where((selected_solution == 1) & (weight_lst > 0))[0]\n        if len(heavy_items_in_solution) == 0:\n            break  # No more items to remove\n        heaviest_idx = heavy_items_in_solution[np.argmax(weight_lst[heavy_items_in_solution])]\n        selected_solution[heaviest_idx] = 0\n        total_weight = np.sum(weight_lst * selected_solution)\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 169,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending) to prioritize less dominated solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 50% of solutions to encourage exploration\n        candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 2)]\n        selected = random.choice(candidate_solutions)\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Random flip followed by greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Random flip: Flip up to 3 random items to introduce diversity\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flip\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        while current_weight > capacity:\n            # Remove the item with the smallest ratio of (value1 + value2) / weight\n            ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            ratios[new_solution == 0] = np.inf  # Ignore already excluded items\n            remove_idx = np.argmin(ratios)\n            new_solution[remove_idx] = 0\n            current_weight = np.sum(weight_lst * new_solution)\n\n    # Greedy improvement: Add items that improve both objectives without exceeding capacity\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate potential improvements for each item\n        improvements = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        improvements[new_solution == 1] = -np.inf  # Ignore already included items\n\n        # Add items in order of highest improvement until capacity is reached\n        for idx in np.argsort(-improvements):\n            if weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3906786316361675,
            6.814244836568832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (ascending) to prioritize less dominated solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from the top 50% of solutions to encourage exploration\n        candidate_solutions = archive_sorted[:max(1, len(archive_sorted) // 2)]\n        selected = random.choice(candidate_solutions)\n    else:\n        selected = archive[0]\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: Random flip followed by greedy improvement\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Random flip: Flip up to 3 random items to introduce diversity\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flip\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        while current_weight > capacity:\n            # Remove the item with the smallest ratio of (value1 + value2) / weight\n            ratios = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n            ratios[new_solution == 0] = np.inf  # Ignore already excluded items\n            remove_idx = np.argmin(ratios)\n            new_solution[remove_idx] = 0\n            current_weight = np.sum(weight_lst * new_solution)\n\n    # Greedy improvement: Add items that improve both objectives without exceeding capacity\n    remaining_weight = capacity - np.sum(weight_lst * new_solution)\n    if remaining_weight > 0:\n        # Calculate potential improvements for each item\n        improvements = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        improvements[new_solution == 1] = -np.inf  # Ignore already included items\n\n        # Add items in order of highest improvement until capacity is reached\n        for idx in np.argsort(-improvements):\n            if weight_lst[idx] <= remaining_weight:\n                new_solution[idx] = 1\n                remaining_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 170,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(weight_lst[x[0] == 1]) / capacity)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with bias towards items with high marginal value)\n    # 2. If infeasible, perform a repair step (remove low-value items first)\n    # 3. If still infeasible, perform a random walk to feasibility\n\n    # Step 1: Identify items with high marginal value for both objectives\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_value1 = value1_lst - np.sum(value1_lst[base_solution == 1]) / len(base_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst[base_solution == 1]) / len(base_solution)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Select items to flip with probability proportional to their marginal value\n    flip_probs = np.maximum(0, combined_marginal) / np.sum(np.maximum(0, combined_marginal))\n    flip_mask = np.random.rand(len(base_solution)) < flip_probs * 0.3  # 30% chance of flipping high-value items\n\n    # Apply the flip\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Repair if infeasible\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # Remove items with lowest combined marginal value until feasible\n        while new_weight > capacity:\n            # Find items to remove (prioritize low-value items)\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break  # Shouldn't happen as we're over capacity\n            remove_idx = remove_candidates[np.argmin(combined_marginal[remove_candidates])]\n            new_solution[remove_idx] = 0\n            new_weight -= weight_lst[remove_idx]\n\n    # Step 3: If still infeasible (due to random walk), perform a random walk to feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Randomly remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.7779555622141998,
            3.089899569749832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = max(archive, key=lambda x: np.sum(weight_lst[x[0] == 1]) / capacity)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with bias towards items with high marginal value)\n    # 2. If infeasible, perform a repair step (remove low-value items first)\n    # 3. If still infeasible, perform a random walk to feasibility\n\n    # Step 1: Identify items with high marginal value for both objectives\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    marginal_value1 = value1_lst - np.sum(value1_lst[base_solution == 1]) / len(base_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst[base_solution == 1]) / len(base_solution)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Select items to flip with probability proportional to their marginal value\n    flip_probs = np.maximum(0, combined_marginal) / np.sum(np.maximum(0, combined_marginal))\n    flip_mask = np.random.rand(len(base_solution)) < flip_probs * 0.3  # 30% chance of flipping high-value items\n\n    # Apply the flip\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Repair if infeasible\n    new_weight = np.sum(weight_lst[new_solution == 1])\n    if new_weight > capacity:\n        # Remove items with lowest combined marginal value until feasible\n        while new_weight > capacity:\n            # Find items to remove (prioritize low-value items)\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break  # Shouldn't happen as we're over capacity\n            remove_idx = remove_candidates[np.argmin(combined_marginal[remove_candidates])]\n            new_solution[remove_idx] = 0\n            new_weight -= weight_lst[remove_idx]\n\n    # Step 3: If still infeasible (due to random walk), perform a random walk to feasibility\n    if np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Randomly remove items until feasible\n        while np.sum(weight_lst[new_solution == 1]) > capacity:\n            remove_idx = np.random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 171,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of values (ascending) to prioritize less optimal solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best in either objective\n        base_solution = archive_sorted[random.randint(0, len(archive_sorted) // 2)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1->0 or 0->1)\n    # 2. Apply a greedy improvement step to fix any infeasibility\n    # 3. Apply a diversification step to explore new regions\n\n    # Step 1: Random flip with probability based on solution quality\n    flip_prob = 0.3  # Higher probability for less optimal solutions\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Greedy improvement to fix infeasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest marginal value (weight / (value1 + value2))\n        marginal_values = (value1_lst + value2_lst) / weight_lst\n        # Sort items by marginal value (ascending)\n        sorted_indices = np.argsort(marginal_values)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight = np.sum(weight_lst * new_solution)\n                if total_weight <= capacity:\n                    break\n\n    # Step 3: Diversification - randomly add items if space allows\n    if random.random() < 0.2:  # 20% chance to diversify\n        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n        if remaining_capacity > 0:\n            # Add items with highest marginal value that fit\n            marginal_values = (value1_lst + value2_lst) / weight_lst\n            sorted_indices = np.argsort(marginal_values)[::-1]  # Descending order\n            for idx in sorted_indices:\n                if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                    new_solution[idx] = 1\n                    remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3555934442860317,
            2.332745611667633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of values (ascending) to prioritize less optimal solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution that is not the best in either objective\n        base_solution = archive_sorted[random.randint(0, len(archive_sorted) // 2)][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1->0 or 0->1)\n    # 2. Apply a greedy improvement step to fix any infeasibility\n    # 3. Apply a diversification step to explore new regions\n\n    # Step 1: Random flip with probability based on solution quality\n    flip_prob = 0.3  # Higher probability for less optimal solutions\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Greedy improvement to fix infeasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest marginal value (weight / (value1 + value2))\n        marginal_values = (value1_lst + value2_lst) / weight_lst\n        # Sort items by marginal value (ascending)\n        sorted_indices = np.argsort(marginal_values)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight = np.sum(weight_lst * new_solution)\n                if total_weight <= capacity:\n                    break\n\n    # Step 3: Diversification - randomly add items if space allows\n    if random.random() < 0.2:  # 20% chance to diversify\n        remaining_capacity = capacity - np.sum(weight_lst * new_solution)\n        if remaining_capacity > 0:\n            # Add items with highest marginal value that fit\n            marginal_values = (value1_lst + value2_lst) / weight_lst\n            sorted_indices = np.argsort(marginal_values)[::-1]  # Descending order\n            for idx in sorted_indices:\n                if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                    new_solution[idx] = 1\n                    remaining_capacity -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 172,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not already at the Pareto front boundary)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with a bias toward low-value/high-weight items)\n    mask = np.random.rand(len(weight_lst)) < 0.2  # 20% chance to consider flipping each item\n    flip_candidates = np.where(mask)[0]\n\n    # Calculate value-to-weight ratios for the candidates\n    ratios = (value1_lst[flip_candidates] + value2_lst[flip_candidates]) / weight_lst[flip_candidates]\n    # Prefer flipping items with low ratios (potential for improvement)\n    flip_prob = 1 / (1 + np.exp(-ratios))  # Sigmoid to create a probability distribution\n\n    # Randomly select items to flip based on the probability\n    flip_indices = np.random.choice(flip_candidates, size=min(3, len(flip_candidates)), p=flip_prob/np.sum(flip_prob), replace=False)\n\n    # Toggle the selected items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Check if adding the item keeps the solution feasible\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # 2. Greedy improvement step: add items that improve both objectives\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    candidate_items = np.where(new_solution == 0)[0]\n    feasible_items = candidate_items[weight_lst[candidate_items] <= remaining_capacity]\n\n    if len(feasible_items) > 0:\n        # Calculate combined improvement potential\n        improvement = (value1_lst[feasible_items] + value2_lst[feasible_items]) / weight_lst[feasible_items]\n\n        # Select top 2 items with highest improvement potential\n        top_items = feasible_items[np.argsort(improvement)[-min(2, len(feasible_items)):]]\n\n        for item in top_items:\n            new_solution[item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.32584049219888883,
            5.680742293596268
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not already at the Pareto front boundary)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with a bias toward low-value/high-weight items)\n    mask = np.random.rand(len(weight_lst)) < 0.2  # 20% chance to consider flipping each item\n    flip_candidates = np.where(mask)[0]\n\n    # Calculate value-to-weight ratios for the candidates\n    ratios = (value1_lst[flip_candidates] + value2_lst[flip_candidates]) / weight_lst[flip_candidates]\n    # Prefer flipping items with low ratios (potential for improvement)\n    flip_prob = 1 / (1 + np.exp(-ratios))  # Sigmoid to create a probability distribution\n\n    # Randomly select items to flip based on the probability\n    flip_indices = np.random.choice(flip_candidates, size=min(3, len(flip_candidates)), p=flip_prob/np.sum(flip_prob), replace=False)\n\n    # Toggle the selected items\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Check if removing the item keeps the solution feasible\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Check if adding the item keeps the solution feasible\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # 2. Greedy improvement step: add items that improve both objectives\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    candidate_items = np.where(new_solution == 0)[0]\n    feasible_items = candidate_items[weight_lst[candidate_items] <= remaining_capacity]\n\n    if len(feasible_items) > 0:\n        # Calculate combined improvement potential\n        improvement = (value1_lst[feasible_items] + value2_lst[feasible_items]) / weight_lst[feasible_items]\n\n        # Select top 2 items with highest improvement potential\n        top_items = feasible_items[np.argsort(improvement)[-min(2, len(feasible_items)):]]\n\n        for item in top_items:\n            new_solution[item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 173,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not too crowded in the objective space\n    # We use a simple crowding distance approximation (here, just the distance to the nearest neighbor)\n    def crowding_distance(sol_obj):\n        distances = []\n        for other_sol, other_obj in archive:\n            if np.array_equal(sol_obj[0], other_sol):\n                continue\n            dist = np.sqrt((sol_obj[1][0] - other_obj[0])**2 + (sol_obj[1][1] - other_obj[1])**2)\n            distances.append(dist)\n        return min(distances) if distances else float('inf')\n\n    # Sort solutions by crowding distance (higher is better for diversity)\n    archive.sort(key=lambda x: -crowding_distance(x))\n    base_solution, base_obj = archive[0]\n\n    # Create a neighbor by applying a hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = base_obj[0]\n    current_value2 = base_obj[1]\n\n    # Step 1: Randomly flip a small number of items (1-3) to introduce diversity\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove the item if it's in the solution\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Step 2: Apply a value-to-weight ratio-based improvement\n    # Calculate the ratio for all items\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine ratios using a weighted sum (could be adaptive)\n    combined_ratio = 0.5 * ratio1 + 0.5 * ratio2\n\n    # Select top-k items not in the solution that could improve both objectives\n    k = min(5, len(new_solution) - np.sum(new_solution))\n    candidate_indices = np.argsort(-combined_ratio)[np.where(new_solution == 0)[0]]\n\n    for idx in candidate_indices[:k]:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Step 3: Optional: Remove low-value items to free up capacity\n    if current_weight < capacity:\n        # Calculate the \"utility\" of each item in the solution\n        utility = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        in_solution_indices = np.where(new_solution == 1)[0]\n        sorted_utility = np.argsort(utility[in_solution_indices])\n\n        # Remove items with lowest utility until capacity is reached or no more items can be removed\n        for i in sorted_utility:\n            idx = in_solution_indices[i]\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            else:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8547834646363546,
            1.604574739933014
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not too crowded in the objective space\n    # We use a simple crowding distance approximation (here, just the distance to the nearest neighbor)\n    def crowding_distance(sol_obj):\n        distances = []\n        for other_sol, other_obj in archive:\n            if np.array_equal(sol_obj[0], other_sol):\n                continue\n            dist = np.sqrt((sol_obj[1][0] - other_obj[0])**2 + (sol_obj[1][1] - other_obj[1])**2)\n            distances.append(dist)\n        return min(distances) if distances else float('inf')\n\n    # Sort solutions by crowding distance (higher is better for diversity)\n    archive.sort(key=lambda x: -crowding_distance(x))\n    base_solution, base_obj = archive[0]\n\n    # Create a neighbor by applying a hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = base_obj[0]\n    current_value2 = base_obj[1]\n\n    # Step 1: Randomly flip a small number of items (1-3) to introduce diversity\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove the item if it's in the solution\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                current_value1 -= value1_lst[idx]\n                current_value2 -= value2_lst[idx]\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n\n    # Step 2: Apply a value-to-weight ratio-based improvement\n    # Calculate the ratio for all items\n    ratio1 = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-10)\n\n    # Combine ratios using a weighted sum (could be adaptive)\n    combined_ratio = 0.5 * ratio1 + 0.5 * ratio2\n\n    # Select top-k items not in the solution that could improve both objectives\n    k = min(5, len(new_solution) - np.sum(new_solution))\n    candidate_indices = np.argsort(-combined_ratio)[np.where(new_solution == 0)[0]]\n\n    for idx in candidate_indices[:k]:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Step 3: Optional: Remove low-value items to free up capacity\n    if current_weight < capacity:\n        # Calculate the \"utility\" of each item in the solution\n        utility = (value1_lst + value2_lst) / (weight_lst + 1e-10)\n        in_solution_indices = np.where(new_solution == 1)[0]\n        sorted_utility = np.argsort(utility[in_solution_indices])\n\n        # Remove items with lowest utility until capacity is reached or no more items can be removed\n        for i in sorted_utility:\n            idx = in_solution_indices[i]\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            else:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 174,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        candidates.append((sol, obj, total_weight))\n\n    # Sort candidates by a weighted sum of objectives and weight utilization\n    candidates.sort(key=lambda x: (0.4 * x[1][0] + 0.4 * x[1][1] - 0.2 * x[2] / capacity), reverse=True)\n\n    # Select top 30% of candidates\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected_sol, _, selected_weight = random.choice(top_candidates)\n\n    # Hybrid local search strategy\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly flip a subset of items (with probability based on their marginal contribution)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to consider flipping\n            if new_solution[i] == 1:\n                # Probability of flipping based on marginal contribution\n                marginal_contrib1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                marginal_contrib2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                flip_prob = 0.3 * (marginal_contrib1 + marginal_contrib2)\n                if random.random() < flip_prob:\n                    new_solution[i] = 0\n            else:\n                # Probability of adding based on potential contribution\n                potential_contrib1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                potential_contrib2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                add_prob = 0.2 * (potential_contrib1 + potential_contrib2)\n                if random.random() < add_prob and (selected_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Perform a guided local search based on objective trade-off\n    total_value1 = np.sum(new_solution * value1_lst)\n    total_value2 = np.sum(new_solution * value2_lst)\n    value_ratio = total_value1 / total_value2 if total_value2 > 0 else float('inf')\n\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Consider removing items that are less valuable in the current trade-off\n            item_ratio = value1_lst[i] / value2_lst[i] if value2_lst[i] > 0 else float('inf')\n            if item_ratio < 0.8 * value_ratio and random.random() < 0.3:\n                new_solution[i] = 0\n        else:\n            # Consider adding items that are more valuable in the current trade-off\n            if (selected_weight + weight_lst[i]) <= capacity:\n                item_ratio = value1_lst[i] / value2_lst[i] if value2_lst[i] > 0 else float('inf')\n                if item_ratio > 1.2 * value_ratio and random.random() < 0.2:\n                    new_solution[i] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # If infeasible, remove items with lowest marginal contribution\n        while current_weight > capacity:\n            marginal_contribs = []\n            for i in range(n_items):\n                if new_solution[i] == 1:\n                    marginal_contrib = (value1_lst[i] + value2_lst[i]) / weight_lst[i] if weight_lst[i] > 0 else float('inf')\n                    marginal_contribs.append((marginal_contrib, i))\n            if not marginal_contribs:\n                break\n            marginal_contribs.sort()\n            _, item_to_remove = marginal_contribs[0]\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.7934883524625005,
            2.498353987932205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        candidates.append((sol, obj, total_weight))\n\n    # Sort candidates by a weighted sum of objectives and weight utilization\n    candidates.sort(key=lambda x: (0.4 * x[1][0] + 0.4 * x[1][1] - 0.2 * x[2] / capacity), reverse=True)\n\n    # Select top 30% of candidates\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected_sol, _, selected_weight = random.choice(top_candidates)\n\n    # Hybrid local search strategy\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Randomly flip a subset of items (with probability based on their marginal contribution)\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to consider flipping\n            if new_solution[i] == 1:\n                # Probability of flipping based on marginal contribution\n                marginal_contrib1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                marginal_contrib2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                flip_prob = 0.3 * (marginal_contrib1 + marginal_contrib2)\n                if random.random() < flip_prob:\n                    new_solution[i] = 0\n            else:\n                # Probability of adding based on potential contribution\n                potential_contrib1 = value1_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                potential_contrib2 = value2_lst[i] / weight_lst[i] if weight_lst[i] > 0 else 0\n                add_prob = 0.2 * (potential_contrib1 + potential_contrib2)\n                if random.random() < add_prob and (selected_weight + weight_lst[i]) <= capacity:\n                    new_solution[i] = 1\n\n    # Step 2: Perform a guided local search based on objective trade-off\n    total_value1 = np.sum(new_solution * value1_lst)\n    total_value2 = np.sum(new_solution * value2_lst)\n    value_ratio = total_value1 / total_value2 if total_value2 > 0 else float('inf')\n\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Consider removing items that are less valuable in the current trade-off\n            item_ratio = value1_lst[i] / value2_lst[i] if value2_lst[i] > 0 else float('inf')\n            if item_ratio < 0.8 * value_ratio and random.random() < 0.3:\n                new_solution[i] = 0\n        else:\n            # Consider adding items that are more valuable in the current trade-off\n            if (selected_weight + weight_lst[i]) <= capacity:\n                item_ratio = value1_lst[i] / value2_lst[i] if value2_lst[i] > 0 else float('inf')\n                if item_ratio > 1.2 * value_ratio and random.random() < 0.2:\n                    new_solution[i] = 1\n\n    # Ensure feasibility\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # If infeasible, remove items with lowest marginal contribution\n        while current_weight > capacity:\n            marginal_contribs = []\n            for i in range(n_items):\n                if new_solution[i] == 1:\n                    marginal_contrib = (value1_lst[i] + value2_lst[i]) / weight_lst[i] if weight_lst[i] > 0 else float('inf')\n                    marginal_contribs.append((marginal_contrib, i))\n            if not marginal_contribs:\n                break\n            marginal_contribs.sort()\n            _, item_to_remove = marginal_contribs[0]\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 175,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its objective values\n    total_values = np.array([sum(obj) for _, obj in archive])\n    if np.sum(total_values) == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probs = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    available_items = np.where(base_solution == 0)[0]\n    feasible_items = available_items[weight_lst[available_items] <= remaining_capacity]\n\n    # If no items can be added, try removing items to free up space\n    if len(feasible_items) == 0:\n        # Remove items with the lowest marginal value contribution\n        included_items = np.where(base_solution == 1)[0]\n        if len(included_items) > 0:\n            # Calculate marginal value contribution for each included item\n            marginal_values = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            # Remove the item with the lowest marginal value\n            item_to_remove = included_items[np.argmin(marginal_values)]\n            new_solution[item_to_remove] = 0\n            # Now try to add items again\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            remaining_capacity = capacity - current_weight\n            feasible_items = available_items[weight_lst[available_items] <= remaining_capacity]\n\n    # If there are feasible items to add, select the one with the highest combined value\n    if len(feasible_items) > 0:\n        # Calculate combined value for feasible items\n        combined_values = value1_lst[feasible_items] + value2_lst[feasible_items]\n        # Select the item with the highest combined value\n        best_item = feasible_items[np.argmax(combined_values)]\n        new_solution[best_item] = 1\n\n    # Randomly flip a small number of items to escape local optima\n    if len(base_solution) > 1:\n        num_flips = min(3, len(base_solution) - 1)  # Flip up to 3 items\n        flip_indices = np.random.choice(len(base_solution), size=num_flips, replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure the new solution is feasible\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If not feasible, remove items until feasible\n        included_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(included_items)\n        for item in included_items:\n            new_solution[item] = 0\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight <= capacity:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.35058185287496435,
            1.9762036800384521
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its objective values\n    total_values = np.array([sum(obj) for _, obj in archive])\n    if np.sum(total_values) == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        probs = total_values / np.sum(total_values)\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and remaining capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    available_items = np.where(base_solution == 0)[0]\n    feasible_items = available_items[weight_lst[available_items] <= remaining_capacity]\n\n    # If no items can be added, try removing items to free up space\n    if len(feasible_items) == 0:\n        # Remove items with the lowest marginal value contribution\n        included_items = np.where(base_solution == 1)[0]\n        if len(included_items) > 0:\n            # Calculate marginal value contribution for each included item\n            marginal_values = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            # Remove the item with the lowest marginal value\n            item_to_remove = included_items[np.argmin(marginal_values)]\n            new_solution[item_to_remove] = 0\n            # Now try to add items again\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            remaining_capacity = capacity - current_weight\n            feasible_items = available_items[weight_lst[available_items] <= remaining_capacity]\n\n    # If there are feasible items to add, select the one with the highest combined value\n    if len(feasible_items) > 0:\n        # Calculate combined value for feasible items\n        combined_values = value1_lst[feasible_items] + value2_lst[feasible_items]\n        # Select the item with the highest combined value\n        best_item = feasible_items[np.argmax(combined_values)]\n        new_solution[best_item] = 1\n\n    # Randomly flip a small number of items to escape local optima\n    if len(base_solution) > 1:\n        num_flips = min(3, len(base_solution) - 1)  # Flip up to 3 items\n        flip_indices = np.random.choice(len(base_solution), size=num_flips, replace=False)\n        for idx in flip_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure the new solution is feasible\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If not feasible, remove items until feasible\n        included_items = np.where(new_solution == 1)[0]\n        np.random.shuffle(included_items)\n        for item in included_items:\n            new_solution[item] = 0\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if current_weight <= capacity:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 176,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search strategy: combination of random flip and value-based flip\n    for _ in range(10):  # Number of local search iterations\n        # Random flip with probability based on solution quality\n        flip_prob = 0.5 if np.random.rand() < 0.7 else 0.3\n        if np.random.rand() < flip_prob:\n            # Random flip\n            flip_pos = np.random.randint(0, len(new_solution))\n            new_solution[flip_pos] = 1 - new_solution[flip_pos]\n        else:\n            # Value-based flip: flip items with high marginal value\n            included = new_solution == 1\n            excluded = new_solution == 0\n\n            # Calculate marginal value for included items\n            if np.any(included):\n                marginal_value1_in = value1_lst[included] / weight_lst[included]\n                marginal_value2_in = value2_lst[included] / weight_lst[included]\n                flip_candidate_in = np.argmax(marginal_value1_in + marginal_value2_in)\n                flip_pos_in = np.where(included)[0][flip_candidate_in]\n\n                # Calculate marginal value for excluded items\n                if np.any(excluded):\n                    marginal_value1_out = value1_lst[excluded] / weight_lst[excluded]\n                    marginal_value2_out = value2_lst[excluded] / weight_lst[excluded]\n                    flip_candidate_out = np.argmax(marginal_value1_out + marginal_value2_out)\n                    flip_pos_out = np.where(excluded)[0][flip_candidate_out]\n\n                    # Compare and decide which flip to perform\n                    if (marginal_value1_in[flip_candidate_in] + marginal_value2_in[flip_candidate_in]) < \\\n                       (marginal_value1_out[flip_candidate_out] + marginal_value2_out[flip_candidate_out]):\n                        flip_pos = flip_pos_out\n                    else:\n                        flip_pos = flip_pos_in\n                else:\n                    flip_pos = flip_pos_in\n            elif np.any(excluded):\n                # Only excluded items available\n                marginal_value1_out = value1_lst[excluded] / weight_lst[excluded]\n                marginal_value2_out = value2_lst[excluded] / weight_lst[excluded]\n                flip_candidate_out = np.argmax(marginal_value1_out + marginal_value2_out)\n                flip_pos = np.where(excluded)[0][flip_candidate_out]\n            else:\n                break  # No items to flip\n\n            new_solution[flip_pos] = 1 - new_solution[flip_pos]\n\n        # Check feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # If infeasible, undo the last flip\n            new_solution[flip_pos] = 1 - new_solution[flip_pos]\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.34491009325031785,
            3.0312731564044952
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Hybrid local search strategy: combination of random flip and value-based flip\n    for _ in range(10):  # Number of local search iterations\n        # Random flip with probability based on solution quality\n        flip_prob = 0.5 if np.random.rand() < 0.7 else 0.3\n        if np.random.rand() < flip_prob:\n            # Random flip\n            flip_pos = np.random.randint(0, len(new_solution))\n            new_solution[flip_pos] = 1 - new_solution[flip_pos]\n        else:\n            # Value-based flip: flip items with high marginal value\n            included = new_solution == 1\n            excluded = new_solution == 0\n\n            # Calculate marginal value for included items\n            if np.any(included):\n                marginal_value1_in = value1_lst[included] / weight_lst[included]\n                marginal_value2_in = value2_lst[included] / weight_lst[included]\n                flip_candidate_in = np.argmax(marginal_value1_in + marginal_value2_in)\n                flip_pos_in = np.where(included)[0][flip_candidate_in]\n\n                # Calculate marginal value for excluded items\n                if np.any(excluded):\n                    marginal_value1_out = value1_lst[excluded] / weight_lst[excluded]\n                    marginal_value2_out = value2_lst[excluded] / weight_lst[excluded]\n                    flip_candidate_out = np.argmax(marginal_value1_out + marginal_value2_out)\n                    flip_pos_out = np.where(excluded)[0][flip_candidate_out]\n\n                    # Compare and decide which flip to perform\n                    if (marginal_value1_in[flip_candidate_in] + marginal_value2_in[flip_candidate_in]) < \\\n                       (marginal_value1_out[flip_candidate_out] + marginal_value2_out[flip_candidate_out]):\n                        flip_pos = flip_pos_out\n                    else:\n                        flip_pos = flip_pos_in\n                else:\n                    flip_pos = flip_pos_in\n            elif np.any(excluded):\n                # Only excluded items available\n                marginal_value1_out = value1_lst[excluded] / weight_lst[excluded]\n                marginal_value2_out = value2_lst[excluded] / weight_lst[excluded]\n                flip_candidate_out = np.argmax(marginal_value1_out + marginal_value2_out)\n                flip_pos = np.where(excluded)[0][flip_candidate_out]\n            else:\n                break  # No items to flip\n\n            new_solution[flip_pos] = 1 - new_solution[flip_pos]\n\n        # Check feasibility\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # If infeasible, undo the last flip\n            new_solution[flip_pos] = 1 - new_solution[flip_pos]\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 177,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with higher total value sums\n    weights = [sum(sol[0] * weight_lst) for sol in archive]\n    values = [sum(sol[1]) for sol in archive]\n    normalized_values = np.array(values) / np.max(values) if np.max(values) != 0 else np.ones(len(values))\n    selection_probs = normalized_values / np.sum(normalized_values)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip random bits and then greedily add items with highest marginal value\n    n_items = len(weight_lst)\n    current_weight = sum(new_solution * weight_lst)\n\n    # Step 1: Randomly flip a few bits (20% of items)\n    flip_indices = random.sample(range(n_items), max(1, int(0.2 * n_items)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Greedily add items with highest marginal value for either objective\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        # Calculate marginal value for both objectives\n        marginal_value1 = value1_lst[candidate_indices] / weight_lst[candidate_indices]\n        marginal_value2 = value2_lst[candidate_indices] / weight_lst[candidate_indices]\n\n        # Combine marginal values using a weighted sum (equal weights for simplicity)\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Sort candidates by combined marginal value (descending)\n        sorted_indices = candidate_indices[np.argsort(-combined_marginal)]\n\n        for idx in sorted_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.39277764715970326,
            4.175981342792511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with higher total value sums\n    weights = [sum(sol[0] * weight_lst) for sol in archive]\n    values = [sum(sol[1]) for sol in archive]\n    normalized_values = np.array(values) / np.max(values) if np.max(values) != 0 else np.ones(len(values))\n    selection_probs = normalized_values / np.sum(normalized_values)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip random bits and then greedily add items with highest marginal value\n    n_items = len(weight_lst)\n    current_weight = sum(new_solution * weight_lst)\n\n    # Step 1: Randomly flip a few bits (20% of items)\n    flip_indices = random.sample(range(n_items), max(1, int(0.2 * n_items)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Greedily add items with highest marginal value for either objective\n    candidate_indices = np.where(new_solution == 0)[0]\n    if len(candidate_indices) > 0:\n        # Calculate marginal value for both objectives\n        marginal_value1 = value1_lst[candidate_indices] / weight_lst[candidate_indices]\n        marginal_value2 = value2_lst[candidate_indices] / weight_lst[candidate_indices]\n\n        # Combine marginal values using a weighted sum (equal weights for simplicity)\n        combined_marginal = marginal_value1 + marginal_value2\n\n        # Sort candidates by combined marginal value (descending)\n        sorted_indices = candidate_indices[np.argsort(-combined_marginal)]\n\n        for idx in sorted_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 178,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with probability proportional to its non-dominated rank\n    # Here, we approximate rank by the number of solutions that dominate it\n    rank = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                # Check if archive[j] dominates archive[i]\n                if (archive[j][1][0] >= archive[i][1][0] and archive[j][1][1] >= archive[i][1][1]) and \\\n                   (archive[j][1][0] > archive[i][1][0] or archive[j][1][1] > archive[i][1][1]):\n                    rank[i] += 1\n\n    # Invert to make higher rank (more dominated) less likely to be selected\n    probabilities = 1 / (rank + 1)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly flip a subset of items (with value-based bias)\n    if np.random.rand() < 0.7:  # 70% chance of this strategy\n        # Calculate value-to-weight ratios for both objectives\n        ratio1 = value1_lst / weight_lst\n        ratio2 = value2_lst / weight_lst\n\n        # Combine ratios to identify high-value items\n        combined_ratio = ratio1 + ratio2\n        sorted_items = np.argsort(-combined_ratio)  # Highest ratio first\n\n        # Flip top-k items (k is randomly chosen between 1 and min(5, n_items))\n        k = np.random.randint(1, min(5, n_items) + 1)\n        for idx in sorted_items[:k]:\n            new_solution[idx] = 1 - new_solution[idx]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove items until feasible\n            excess = total_weight - capacity\n            while excess > 0:\n                # Remove the item with lowest combined ratio that is in the solution\n                in_solution = np.where(new_solution == 1)[0]\n                if len(in_solution) == 0:\n                    break\n                worst_item = np.argmin(combined_ratio[in_solution])\n                new_solution[in_solution[worst_item]] = 0\n                excess = np.sum(weight_lst * new_solution) - capacity\n    else:\n        # Strategy 2: Randomly swap two items (if possible)\n        if n_items >= 2:\n            i, j = np.random.choice(n_items, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Ensure feasibility\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                # If infeasible, revert the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.41186693538611396,
            4.489483267068863
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with probability proportional to its non-dominated rank\n    # Here, we approximate rank by the number of solutions that dominate it\n    rank = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                # Check if archive[j] dominates archive[i]\n                if (archive[j][1][0] >= archive[i][1][0] and archive[j][1][1] >= archive[i][1][1]) and \\\n                   (archive[j][1][0] > archive[i][1][0] or archive[j][1][1] > archive[i][1][1]):\n                    rank[i] += 1\n\n    # Invert to make higher rank (more dominated) less likely to be selected\n    probabilities = 1 / (rank + 1)\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly flip a subset of items (with value-based bias)\n    if np.random.rand() < 0.7:  # 70% chance of this strategy\n        # Calculate value-to-weight ratios for both objectives\n        ratio1 = value1_lst / weight_lst\n        ratio2 = value2_lst / weight_lst\n\n        # Combine ratios to identify high-value items\n        combined_ratio = ratio1 + ratio2\n        sorted_items = np.argsort(-combined_ratio)  # Highest ratio first\n\n        # Flip top-k items (k is randomly chosen between 1 and min(5, n_items))\n        k = np.random.randint(1, min(5, n_items) + 1)\n        for idx in sorted_items[:k]:\n            new_solution[idx] = 1 - new_solution[idx]\n\n        # Ensure feasibility\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove items until feasible\n            excess = total_weight - capacity\n            while excess > 0:\n                # Remove the item with lowest combined ratio that is in the solution\n                in_solution = np.where(new_solution == 1)[0]\n                if len(in_solution) == 0:\n                    break\n                worst_item = np.argmin(combined_ratio[in_solution])\n                new_solution[in_solution[worst_item]] = 0\n                excess = np.sum(weight_lst * new_solution) - capacity\n    else:\n        # Strategy 2: Randomly swap two items (if possible)\n        if n_items >= 2:\n            i, j = np.random.choice(n_items, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n            # Ensure feasibility\n            total_weight = np.sum(weight_lst * new_solution)\n            if total_weight > capacity:\n                # If infeasible, revert the swap\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 179,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of randomness and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip a random subset of items and then apply a greedy value-based adjustment\n    n_items = len(base_solution)\n    if n_items > 0:\n        # Randomly select a subset of items to flip\n        flip_indices = random.sample(range(n_items), min(3, n_items))\n        for idx in flip_indices:\n            if base_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                # Only flip to 1 if it doesn't violate capacity\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Greedy improvement: try to add items with high value-to-weight ratio\n        # Calculate value-to-weight ratios for objective 1 and 2\n        v1_ratio = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n        v2_ratio = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios to prioritize items that are good for both objectives\n        combined_ratio = v1_ratio + v2_ratio\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = np.argsort(-combined_ratio)\n\n        # Try to add items in order of highest combined ratio\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n        # Greedy removal: try to remove items with low combined ratio\n        sorted_indices = np.argsort(combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break  # Stop if feasible\n                else:\n                    new_solution[idx] = 1  # Undo if infeasible\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8056433280795152,
            1.810707300901413
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of randomness and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip a random subset of items and then apply a greedy value-based adjustment\n    n_items = len(base_solution)\n    if n_items > 0:\n        # Randomly select a subset of items to flip\n        flip_indices = random.sample(range(n_items), min(3, n_items))\n        for idx in flip_indices:\n            if base_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                # Only flip to 1 if it doesn't violate capacity\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n        # Greedy improvement: try to add items with high value-to-weight ratio\n        # Calculate value-to-weight ratios for objective 1 and 2\n        v1_ratio = value1_lst / (weight_lst + 1e-10)  # Avoid division by zero\n        v2_ratio = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios to prioritize items that are good for both objectives\n        combined_ratio = v1_ratio + v2_ratio\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = np.argsort(-combined_ratio)\n\n        # Try to add items in order of highest combined ratio\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and (current_weight + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n        # Greedy removal: try to remove items with low combined ratio\n        sorted_indices = np.argsort(combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n                if current_weight <= capacity:\n                    break  # Stop if feasible\n                else:\n                    new_solution[idx] = 1  # Undo if infeasible\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 180,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with potential for improvement\n    # Here, we prioritize solutions that are not too close to the Pareto front\n    # by selecting those with the highest sum of normalized objective values\n    normalized_objs = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / (np.sum(value1_lst) + 1e-10)\n        norm_obj2 = obj[1] / (np.sum(value2_lst) + 1e-10)\n        normalized_objs.append((sol, obj, norm_obj1 + norm_obj2))\n\n    # Sort by the sum of normalized objectives (descending) to prioritize less explored solutions\n    normalized_objs.sort(key=lambda x: -x[2])\n    selected_sol = normalized_objs[0][0].copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly flip a subset of items (exploration)\n    # 2. Greedily improve the solution by flipping items that increase both objectives (exploitation)\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Random flip (exploration)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items randomly\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove excess items by flipping back the ones that exceed capacity\n        excess_weight = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        for idx in excess_items:\n            if excess_weight <= 0:\n                break\n            new_solution[idx] = 0\n            excess_weight -= weight_lst[idx]\n\n    # Step 2: Greedy improvement (exploitation)\n    # Iterate through items and flip those that improve both objectives\n    for i in range(n_items):\n        if new_solution[i] == 0:\n            # Try adding the item\n            if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n        else:\n            # Try removing the item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) <= capacity:\n                pass  # Keep it removed\n            else:\n                new_solution[i] = 1  # Revert if infeasible\n\n    # Final check for feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If still infeasible, revert to the original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.33744845400719176,
            10.117747098207474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with potential for improvement\n    # Here, we prioritize solutions that are not too close to the Pareto front\n    # by selecting those with the highest sum of normalized objective values\n    normalized_objs = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / (np.sum(value1_lst) + 1e-10)\n        norm_obj2 = obj[1] / (np.sum(value2_lst) + 1e-10)\n        normalized_objs.append((sol, obj, norm_obj1 + norm_obj2))\n\n    # Sort by the sum of normalized objectives (descending) to prioritize less explored solutions\n    normalized_objs.sort(key=lambda x: -x[2])\n    selected_sol = normalized_objs[0][0].copy()\n\n    # Apply a hybrid local search strategy:\n    # 1. Randomly flip a subset of items (exploration)\n    # 2. Greedily improve the solution by flipping items that increase both objectives (exploitation)\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Step 1: Random flip (exploration)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items randomly\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove excess items by flipping back the ones that exceed capacity\n        excess_weight = total_weight - capacity\n        excess_items = np.where(new_solution == 1)[0]\n        for idx in excess_items:\n            if excess_weight <= 0:\n                break\n            new_solution[idx] = 0\n            excess_weight -= weight_lst[idx]\n\n    # Step 2: Greedy improvement (exploitation)\n    # Iterate through items and flip those that improve both objectives\n    for i in range(n_items):\n        if new_solution[i] == 0:\n            # Try adding the item\n            if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n        else:\n            # Try removing the item\n            new_solution[i] = 0\n            if np.sum(weight_lst * new_solution) <= capacity:\n                pass  # Keep it removed\n            else:\n                new_solution[i] = 1  # Revert if infeasible\n\n    # Final check for feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If still infeasible, revert to the original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 181,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    # We prioritize solutions that are not too close to the current Pareto front\n    # and have a good balance of objective values\n    def score_solution(solution_tuple):\n        solution, objectives = solution_tuple\n        value1, value2 = objectives\n        # Score based on diversity and potential for improvement\n        # Higher score means more promising for local improvement\n        return (value1 + value2) * (1 - 0.1 * np.sum(solution))  # Penalize densely packed solutions\n\n    scored_solutions = [(score_solution(sol), sol) for sol in archive]\n    scored_solutions.sort(key=lambda x: -x[0])  # Sort by score descending\n\n    # Select top 10% of solutions with highest scores\n    top_k = max(1, len(scored_solutions) // 10)\n    selected_solutions = [sol[1] for sol in scored_solutions[:top_k]]\n\n    # Randomly select one of the top solutions\n    base_solution, _ = selected_solutions[np.random.choice(len(selected_solutions))]\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # First, perform random flips (exploration)\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If infeasible, perform greedy repair\n        excess_weight = current_weight - capacity\n        # Remove items with lowest marginal utility (value1 + value2) until feasible\n        while excess_weight > 0:\n            # Find items to remove (currently included)\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break  # No items left to remove\n\n            # Calculate marginal utility of each included item\n            marginal_utilities = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n\n            # Remove item with lowest marginal utility\n            remove_idx = included_items[np.argmin(marginal_utilities)]\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    # Second, perform greedy improvement (exploitation)\n    # Try to add items that improve both objectives\n    available_items = np.where(new_solution == 0)[0]\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for idx in available_items:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            # Calculate potential improvement\n            delta_value1 = value1_lst[idx]\n            delta_value2 = value2_lst[idx]\n\n            # Only add if both objectives improve\n            if delta_value1 > 0 and delta_value2 > 0:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.4126088804173417,
            3.566049247980118
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    # We prioritize solutions that are not too close to the current Pareto front\n    # and have a good balance of objective values\n    def score_solution(solution_tuple):\n        solution, objectives = solution_tuple\n        value1, value2 = objectives\n        # Score based on diversity and potential for improvement\n        # Higher score means more promising for local improvement\n        return (value1 + value2) * (1 - 0.1 * np.sum(solution))  # Penalize densely packed solutions\n\n    scored_solutions = [(score_solution(sol), sol) for sol in archive]\n    scored_solutions.sort(key=lambda x: -x[0])  # Sort by score descending\n\n    # Select top 10% of solutions with highest scores\n    top_k = max(1, len(scored_solutions) // 10)\n    selected_solutions = [sol[1] for sol in scored_solutions[:top_k]]\n\n    # Randomly select one of the top solutions\n    base_solution, _ = selected_solutions[np.random.choice(len(selected_solutions))]\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n\n    # First, perform random flips (exploration)\n    flip_indices = np.random.choice(len(new_solution), size=min(5, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Check feasibility\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # If infeasible, perform greedy repair\n        excess_weight = current_weight - capacity\n        # Remove items with lowest marginal utility (value1 + value2) until feasible\n        while excess_weight > 0:\n            # Find items to remove (currently included)\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break  # No items left to remove\n\n            # Calculate marginal utility of each included item\n            marginal_utilities = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n\n            # Remove item with lowest marginal utility\n            remove_idx = included_items[np.argmin(marginal_utilities)]\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    # Second, perform greedy improvement (exploitation)\n    # Try to add items that improve both objectives\n    available_items = np.where(new_solution == 0)[0]\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for idx in available_items:\n        new_weight = current_weight + weight_lst[idx]\n        if new_weight <= capacity:\n            # Calculate potential improvement\n            delta_value1 = value1_lst[idx]\n            delta_value2 = value2_lst[idx]\n\n            # Only add if both objectives improve\n            if delta_value1 > 0 and delta_value2 > 0:\n                new_solution[idx] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 182,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with higher probability if it has high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Solutions with remaining capacity are more promising for improvement\n        candidates.append((sol, remaining_capacity))\n\n    # Sort candidates by remaining capacity (descending) to prioritize more promising solutions\n    candidates.sort(key=lambda x: -x[1])\n\n    # Select the top 30% of candidates with a bias towards higher remaining capacity\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected_sol = random.choice(top_candidates)[0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = selected_sol.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    num_items = len(new_solution)\n    subset_size = min(10, num_items)  # Limit subset size for efficiency\n    subset_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: For each item in the subset, decide to flip it based on its marginal contribution\n    for idx in subset_indices:\n        if new_solution[idx] == 1:\n            # If item is included, decide to remove it if it's not critical\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight - weight_lst[idx] >= 0:  # Ensure feasibility\n                # Calculate marginal contribution for both objectives\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n                # Probabilistically decide to remove based on marginal contribution\n                if random.random() < (1 / (1 + marginal_value1 + marginal_value2)):\n                    new_solution[idx] = 0\n        else:\n            # If item is excluded, decide to include it if it fits\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate marginal contribution for both objectives\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n                # Probabilistically decide to include based on marginal contribution\n                if random.random() < (marginal_value1 + marginal_value2) / (np.sum(value1_lst) + np.sum(value2_lst)):\n                    new_solution[idx] = 1\n\n    # Step 3: Ensure the solution is feasible (in case of any errors)\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        while current_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break  # No items left to remove\n            remove_idx = random.choice(included_indices)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.310798330649116,
            5.032461881637573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with higher probability if it has high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Solutions with remaining capacity are more promising for improvement\n        candidates.append((sol, remaining_capacity))\n\n    # Sort candidates by remaining capacity (descending) to prioritize more promising solutions\n    candidates.sort(key=lambda x: -x[1])\n\n    # Select the top 30% of candidates with a bias towards higher remaining capacity\n    top_candidates = candidates[:max(1, len(candidates) // 3)]\n    selected_sol = random.choice(top_candidates)[0].copy()\n\n    # Generate neighbor using a hybrid local search strategy\n    new_solution = selected_sol.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    num_items = len(new_solution)\n    subset_size = min(10, num_items)  # Limit subset size for efficiency\n    subset_indices = random.sample(range(num_items), subset_size)\n\n    # Step 2: For each item in the subset, decide to flip it based on its marginal contribution\n    for idx in subset_indices:\n        if new_solution[idx] == 1:\n            # If item is included, decide to remove it if it's not critical\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight - weight_lst[idx] >= 0:  # Ensure feasibility\n                # Calculate marginal contribution for both objectives\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n                # Probabilistically decide to remove based on marginal contribution\n                if random.random() < (1 / (1 + marginal_value1 + marginal_value2)):\n                    new_solution[idx] = 0\n        else:\n            # If item is excluded, decide to include it if it fits\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate marginal contribution for both objectives\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n                # Probabilistically decide to include based on marginal contribution\n                if random.random() < (marginal_value1 + marginal_value2) / (np.sum(value1_lst) + np.sum(value2_lst)):\n                    new_solution[idx] = 1\n\n    # Step 3: Ensure the solution is feasible (in case of any errors)\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        while current_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break  # No items left to remove\n            remove_idx = random.choice(included_indices)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 183,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions that are not too close to the Pareto front (more room for improvement)\n    # and have a good balance between the two objectives\n    candidates = []\n    for sol, obj in archive:\n        # Calculate crowding distance as a measure of potential for improvement\n        crowding_dist = np.linalg.norm(obj)\n        candidates.append((sol, obj, crowding_dist))\n\n    # Sort candidates by crowding distance (descending) to prioritize solutions with more room for improvement\n    candidates.sort(key=lambda x: -x[2])\n    selected_sol = candidates[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Random perturbation: flip a small number of randomly selected items\n    n_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = random.sample(range(n_items), n_flips)\n\n    for idx in flip_indices:\n        # Temporarily flip the item\n        temp_sol = new_solution.copy()\n        temp_sol[idx] = 1 - temp_sol[idx]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[temp_sol == 1])\n        if total_weight <= capacity:\n            new_solution = temp_sol\n\n    # Greedy improvement: try to add items that improve both objectives\n    # Calculate marginal gains for each item\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n\n    for idx in candidate_items:\n        if weight_lst[idx] <= remaining_capacity:\n            # Calculate marginal gains\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n\n            # Add the item if it improves both objectives\n            if marginal_value1 > 0 and marginal_value2 > 0:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Final check to ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        while total_weight > capacity:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.34866079373518016,
            7.737304270267487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions that are not too close to the Pareto front (more room for improvement)\n    # and have a good balance between the two objectives\n    candidates = []\n    for sol, obj in archive:\n        # Calculate crowding distance as a measure of potential for improvement\n        crowding_dist = np.linalg.norm(obj)\n        candidates.append((sol, obj, crowding_dist))\n\n    # Sort candidates by crowding distance (descending) to prioritize solutions with more room for improvement\n    candidates.sort(key=lambda x: -x[2])\n    selected_sol = candidates[0][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n\n    # Random perturbation: flip a small number of randomly selected items\n    n_flips = min(3, n_items)  # Limit the number of flips to avoid excessive changes\n    flip_indices = random.sample(range(n_items), n_flips)\n\n    for idx in flip_indices:\n        # Temporarily flip the item\n        temp_sol = new_solution.copy()\n        temp_sol[idx] = 1 - temp_sol[idx]\n\n        # Check feasibility\n        total_weight = np.sum(weight_lst[temp_sol == 1])\n        if total_weight <= capacity:\n            new_solution = temp_sol\n\n    # Greedy improvement: try to add items that improve both objectives\n    # Calculate marginal gains for each item\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution\n    candidate_items = np.where(new_solution == 0)[0]\n\n    for idx in candidate_items:\n        if weight_lst[idx] <= remaining_capacity:\n            # Calculate marginal gains\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n\n            # Add the item if it improves both objectives\n            if marginal_value1 > 0 and marginal_value2 > 0:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Final check to ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasible\n        while total_weight > capacity:\n            remove_idx = random.choice(np.where(new_solution == 1)[0])\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 184,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, (current_val1, current_val2) = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Check if swapping these items is feasible and beneficial\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1:\n                # If item1 is in the solution, check if removing it and adding item2 is feasible\n                new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n                if new_weight <= capacity:\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight = new_weight\n            else:\n                # If item1 is not in the solution, check if adding it and removing item2 is feasible\n                new_weight = current_weight + weight_lst[item1] - weight_lst[item2]\n                if new_weight <= capacity:\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight = new_weight\n\n    # Objective-biased improvement: try to add items that improve both objectives\n    for item in range(len(new_solution)):\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            # Check if adding this item improves both objectives\n            if (value1_lst[item] > 0) and (value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final check to ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If not feasible, remove items randomly until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            items_in_solution = np.where(new_solution == 1)[0]\n            if len(items_in_solution) == 0:\n                break\n            item_to_remove = random.choice(items_in_solution)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.34071801353731995,
            5.290257006883621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with high potential for improvement\n    base_solution, (current_val1, current_val2) = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(new_solution)), 2)\n\n        # Check if swapping these items is feasible and beneficial\n        if new_solution[item1] != new_solution[item2]:\n            if new_solution[item1] == 1:\n                # If item1 is in the solution, check if removing it and adding item2 is feasible\n                new_weight = current_weight - weight_lst[item1] + weight_lst[item2]\n                if new_weight <= capacity:\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight = new_weight\n            else:\n                # If item1 is not in the solution, check if adding it and removing item2 is feasible\n                new_weight = current_weight + weight_lst[item1] - weight_lst[item2]\n                if new_weight <= capacity:\n                    new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                    current_weight = new_weight\n\n    # Objective-biased improvement: try to add items that improve both objectives\n    for item in range(len(new_solution)):\n        if new_solution[item] == 0 and (current_weight + weight_lst[item]) <= capacity:\n            # Check if adding this item improves both objectives\n            if (value1_lst[item] > 0) and (value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Final check to ensure feasibility\n    if np.sum(weight_lst * new_solution) > capacity:\n        # If not feasible, remove items randomly until feasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            items_in_solution = np.where(new_solution == 1)[0]\n            if len(items_in_solution) == 0:\n                break\n            item_to_remove = random.choice(items_in_solution)\n            new_solution[item_to_remove] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 185,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution = None\n    max_potential = -1\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential = capacity - total_weight  # Higher potential means more room to add items\n        if potential > max_potential:\n            max_potential = potential\n            base_solution = sol\n\n    if base_solution is None:\n        base_solution = random.choice(archive)[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with value-to-weight ratio-based selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    num_swaps = min(5, n_items // 2)  # Limit the number of swaps\n    swap_indices = random.sample(range(n_items), num_swaps)\n\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            # Consider removing this item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Consider adding this item based on value-to-weight ratio\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate combined value-to-weight ratio for both objectives\n                ratio1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n                ratio2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n                combined_ratio = ratio1 + ratio2  # Simple heuristic for bi-objective\n\n                # Randomly decide to add based on ratio (higher ratio = more likely to add)\n                if random.random() < combined_ratio / (combined_ratio + 1.0):\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6185356111693819,
            1.3599980771541595
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with high potential for improvement\n    base_solution = None\n    max_potential = -1\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential = capacity - total_weight  # Higher potential means more room to add items\n        if potential > max_potential:\n            max_potential = potential\n            base_solution = sol\n\n    if base_solution is None:\n        base_solution = random.choice(archive)[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine random swaps with value-to-weight ratio-based selection\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a subset of items to consider for swapping\n    num_swaps = min(5, n_items // 2)  # Limit the number of swaps\n    swap_indices = random.sample(range(n_items), num_swaps)\n\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            # Consider removing this item\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Consider adding this item based on value-to-weight ratio\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate combined value-to-weight ratio for both objectives\n                ratio1 = value1_lst[idx] / (weight_lst[idx] + 1e-10)\n                ratio2 = value2_lst[idx] / (weight_lst[idx] + 1e-10)\n                combined_ratio = ratio1 + ratio2  # Simple heuristic for bi-objective\n\n                # Randomly decide to add based on ratio (higher ratio = more likely to add)\n                if random.random() < combined_ratio / (combined_ratio + 1.0):\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 186,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidate_indices = []\n    for idx, (sol, _) in enumerate(archive):\n        # Calculate the total weight and values of the solution\n        total_weight = np.sum(sol * weight_lst)\n        total_value1 = np.sum(sol * value1_lst)\n        total_value2 = np.sum(sol * value2_lst)\n\n        # Check if the solution is not too close to the Pareto front (simple heuristic)\n        if total_weight < capacity * 0.9:  # Allow some room for improvement\n            candidate_indices.append(idx)\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))  # Fallback to all solutions if no candidates\n\n    # Select a random solution from the candidates\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random perturbation + greedy improvement\n    # Step 1: Randomly flip a subset of items to explore neighborhood\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items randomly\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Ensure feasibility after random flip\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # If infeasible, remove items until feasible\n        excess_weight = total_weight - capacity\n        candidate_remove = np.where(new_solution == 1)[0]\n        np.random.shuffle(candidate_remove)\n        for idx in candidate_remove:\n            if excess_weight <= 0:\n                break\n            excess_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n\n    # Step 2: Greedy improvement - add the most valuable item not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Calculate the \"value-to-weight ratio\" for each objective\n        value1_ratio = value1_lst[remaining_items] / (weight_lst[remaining_items] + 1e-6)\n        value2_ratio = value2_lst[remaining_items] / (weight_lst[remaining_items] + 1e-6)\n\n        # Combine ratios using a weighted sum (could be adaptive)\n        combined_ratio = 0.5 * value1_ratio + 0.5 * value2_ratio\n        best_candidate = remaining_items[np.argmax(combined_ratio)]\n\n        # Add the best candidate if it fits\n        if weight_lst[best_candidate] <= (capacity - np.sum(new_solution * weight_lst)):\n            new_solution[best_candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3416377915572505,
            2.9795218408107758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidate_indices = []\n    for idx, (sol, _) in enumerate(archive):\n        # Calculate the total weight and values of the solution\n        total_weight = np.sum(sol * weight_lst)\n        total_value1 = np.sum(sol * value1_lst)\n        total_value2 = np.sum(sol * value2_lst)\n\n        # Check if the solution is not too close to the Pareto front (simple heuristic)\n        if total_weight < capacity * 0.9:  # Allow some room for improvement\n            candidate_indices.append(idx)\n\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))  # Fallback to all solutions if no candidates\n\n    # Select a random solution from the candidates\n    selected_idx = random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random perturbation + greedy improvement\n    # Step 1: Randomly flip a subset of items to explore neighborhood\n    num_items = len(weight_lst)\n    flip_indices = random.sample(range(num_items), min(3, num_items))  # Flip up to 3 items randomly\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Ensure feasibility after random flip\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # If infeasible, remove items until feasible\n        excess_weight = total_weight - capacity\n        candidate_remove = np.where(new_solution == 1)[0]\n        np.random.shuffle(candidate_remove)\n        for idx in candidate_remove:\n            if excess_weight <= 0:\n                break\n            excess_weight -= weight_lst[idx]\n            new_solution[idx] = 0\n\n    # Step 2: Greedy improvement - add the most valuable item not in the solution\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Calculate the \"value-to-weight ratio\" for each objective\n        value1_ratio = value1_lst[remaining_items] / (weight_lst[remaining_items] + 1e-6)\n        value2_ratio = value2_lst[remaining_items] / (weight_lst[remaining_items] + 1e-6)\n\n        # Combine ratios using a weighted sum (could be adaptive)\n        combined_ratio = 0.5 * value1_ratio + 0.5 * value2_ratio\n        best_candidate = remaining_items[np.argmax(combined_ratio)]\n\n        # Add the best candidate if it fits\n        if weight_lst[best_candidate] <= (capacity - np.sum(new_solution * weight_lst)):\n            new_solution[best_candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 187,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already at the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for swapping\n    # 2. Evaluate swaps based on value-to-weight ratio for both objectives\n    # 3. Apply the most promising swap while maintaining feasibility\n\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Consider a subset of items to swap (to avoid excessive computation)\n    num_candidates = min(10, len(items) + len(non_items))\n    candidates = np.concatenate([items, non_items])\n    np.random.shuffle(candidates)\n    candidates = candidates[:num_candidates]\n\n    best_swap = None\n    best_improvement = 0\n\n    for i in candidates:\n        if base_solution[i] == 1:\n            # Evaluate removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                # Calculate improvement potential (sum of normalized value improvements)\n                improvement = (value1_lst[i] / weight_lst[i] + value2_lst[i] / weight_lst[i])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, 0)  # Remove item i\n        else:\n            # Evaluate adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Calculate improvement potential (sum of normalized value improvements)\n                improvement = (value1_lst[i] / weight_lst[i] + value2_lst[i] / weight_lst[i])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, 1)  # Add item i\n\n    if best_swap is not None:\n        i, action = best_swap\n        new_solution[i] = action\n\n    return new_solution\n\n",
        "score": [
            -0.4959678952558251,
            0.9972383081912994
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already at the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for swapping\n    # 2. Evaluate swaps based on value-to-weight ratio for both objectives\n    # 3. Apply the most promising swap while maintaining feasibility\n\n    new_solution = base_solution.copy()\n    items = np.where(base_solution == 1)[0]\n    non_items = np.where(base_solution == 0)[0]\n\n    # Consider a subset of items to swap (to avoid excessive computation)\n    num_candidates = min(10, len(items) + len(non_items))\n    candidates = np.concatenate([items, non_items])\n    np.random.shuffle(candidates)\n    candidates = candidates[:num_candidates]\n\n    best_swap = None\n    best_improvement = 0\n\n    for i in candidates:\n        if base_solution[i] == 1:\n            # Evaluate removing item i\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                # Calculate improvement potential (sum of normalized value improvements)\n                improvement = (value1_lst[i] / weight_lst[i] + value2_lst[i] / weight_lst[i])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, 0)  # Remove item i\n        else:\n            # Evaluate adding item i\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                # Calculate improvement potential (sum of normalized value improvements)\n                improvement = (value1_lst[i] / weight_lst[i] + value2_lst[i] / weight_lst[i])\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_swap = (i, 1)  # Add item i\n\n    if best_swap is not None:\n        i, action = best_swap\n        new_solution[i] = action\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 188,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Prioritize solutions that are not too close to the boundary (to allow more flexibility)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for flipping\n    # 2. Evaluate the impact of flipping each item in the subset\n    # 3. Select the best flip that improves at least one objective without violating capacity\n\n    # Randomly select a subset of items (20% of the items)\n    n_items = len(weight_lst)\n    subset_size = max(1, int(0.2 * n_items))\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    best_delta1, best_delta2 = -np.inf, -np.inf\n    best_candidate = None\n\n    for idx in subset_indices:\n        # Calculate the effect of flipping this item\n        delta_weight = weight_lst[idx] * (1 - 2 * new_solution[idx])\n        new_weight = current_weight + delta_weight\n\n        if new_weight > capacity:\n            continue  # Skip if flipping violates capacity\n\n        delta_value1 = value1_lst[idx] * (1 - 2 * new_solution[idx])\n        delta_value2 = value2_lst[idx] * (1 - 2 * new_solution[idx])\n\n        # Check if this flip improves at least one objective\n        if (delta_value1 > 0 or delta_value2 > 0):\n            if (delta_value1 > best_delta1) or (delta_value2 > best_delta2):\n                best_delta1, best_delta2 = delta_value1, delta_value2\n                best_candidate = idx\n\n    # If we found a beneficial flip, apply it\n    if best_candidate is not None:\n        new_solution[best_candidate] = 1 - new_solution[best_candidate]\n    else:\n        # If no beneficial flip found, try a random flip that doesn't violate capacity\n        random.shuffle(subset_indices)\n        for idx in subset_indices:\n            delta_weight = weight_lst[idx] * (1 - 2 * new_solution[idx])\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx] = 1 - new_solution[idx]\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9481067830374188,
            1.348952829837799
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Prioritize solutions that are not too close to the boundary (to allow more flexibility)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for flipping\n    # 2. Evaluate the impact of flipping each item in the subset\n    # 3. Select the best flip that improves at least one objective without violating capacity\n\n    # Randomly select a subset of items (20% of the items)\n    n_items = len(weight_lst)\n    subset_size = max(1, int(0.2 * n_items))\n    subset_indices = random.sample(range(n_items), subset_size)\n\n    best_delta1, best_delta2 = -np.inf, -np.inf\n    best_candidate = None\n\n    for idx in subset_indices:\n        # Calculate the effect of flipping this item\n        delta_weight = weight_lst[idx] * (1 - 2 * new_solution[idx])\n        new_weight = current_weight + delta_weight\n\n        if new_weight > capacity:\n            continue  # Skip if flipping violates capacity\n\n        delta_value1 = value1_lst[idx] * (1 - 2 * new_solution[idx])\n        delta_value2 = value2_lst[idx] * (1 - 2 * new_solution[idx])\n\n        # Check if this flip improves at least one objective\n        if (delta_value1 > 0 or delta_value2 > 0):\n            if (delta_value1 > best_delta1) or (delta_value2 > best_delta2):\n                best_delta1, best_delta2 = delta_value1, delta_value2\n                best_candidate = idx\n\n    # If we found a beneficial flip, apply it\n    if best_candidate is not None:\n        new_solution[best_candidate] = 1 - new_solution[best_candidate]\n    else:\n        # If no beneficial flip found, try a random flip that doesn't violate capacity\n        random.shuffle(subset_indices)\n        for idx in subset_indices:\n            delta_weight = weight_lst[idx] * (1 - 2 * new_solution[idx])\n            if current_weight + delta_weight <= capacity:\n                new_solution[idx] = 1 - new_solution[idx]\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 189,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (not on the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Get indices of included and excluded items\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select an item to remove\n        remove_idx = np.random.choice(included)\n        # Calculate potential weight after removal\n        new_weight = current_weight - weight_lst[remove_idx]\n\n        # Find best item to add that doesn't exceed capacity\n        possible_adds = [i for i in excluded if new_weight + weight_lst[i] <= capacity]\n        if possible_adds:\n            # Evaluate potential additions based on both objectives\n            potential_values1 = value1_lst[possible_adds]\n            potential_values2 = value2_lst[possible_adds]\n            # Normalize and combine objectives for selection\n            norm1 = (potential_values1 - np.min(potential_values1)) / (np.max(potential_values1) - np.min(potential_values1) + 1e-8)\n            norm2 = (potential_values2 - np.min(potential_values2)) / (np.max(potential_values2) - np.min(potential_values2) + 1e-8)\n            combined_scores = norm1 + norm2\n            # Select the item with highest combined score\n            add_idx = possible_adds[np.argmax(combined_scores)]\n            # Perform the swap\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n    else:\n        # If no items to swap, try adding a random item if possible\n        possible_adds = [i for i in excluded if current_weight + weight_lst[i] <= capacity]\n        if possible_adds:\n            add_idx = np.random.choice(possible_adds)\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.5104568609085793,
            2.16680309176445
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (not on the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Get indices of included and excluded items\n    included = np.where(base_solution == 1)[0]\n    excluded = np.where(base_solution == 0)[0]\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy\n    if len(included) > 0 and len(excluded) > 0:\n        # Randomly select an item to remove\n        remove_idx = np.random.choice(included)\n        # Calculate potential weight after removal\n        new_weight = current_weight - weight_lst[remove_idx]\n\n        # Find best item to add that doesn't exceed capacity\n        possible_adds = [i for i in excluded if new_weight + weight_lst[i] <= capacity]\n        if possible_adds:\n            # Evaluate potential additions based on both objectives\n            potential_values1 = value1_lst[possible_adds]\n            potential_values2 = value2_lst[possible_adds]\n            # Normalize and combine objectives for selection\n            norm1 = (potential_values1 - np.min(potential_values1)) / (np.max(potential_values1) - np.min(potential_values1) + 1e-8)\n            norm2 = (potential_values2 - np.min(potential_values2)) / (np.max(potential_values2) - np.min(potential_values2) + 1e-8)\n            combined_scores = norm1 + norm2\n            # Select the item with highest combined score\n            add_idx = possible_adds[np.argmax(combined_scores)]\n            # Perform the swap\n            new_solution[remove_idx] = 0\n            new_solution[add_idx] = 1\n    else:\n        # If no items to swap, try adding a random item if possible\n        possible_adds = [i for i in excluded if current_weight + weight_lst[i] <= capacity]\n        if possible_adds:\n            add_idx = np.random.choice(possible_adds)\n            new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 190,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and solution quality\n    # Here, we prioritize solutions with higher combined objective values and those with more diverse item selections\n    archive_with_metrics = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(sol * weight_lst)\n        diversity = np.sum(sol != sol[0])  # Simple diversity metric (number of items different from the first item)\n        archive_with_metrics.append((sol, (val1, val2), total_weight, diversity))\n\n    # Sort by combined objective values (val1 + val2) and diversity\n    archive_with_metrics.sort(key=lambda x: (x[1][0] + x[1][1], x[3]), reverse=True)\n\n    # Select top 20% of solutions for random selection\n    selection_pool = archive_with_metrics[:max(1, len(archive_with_metrics) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: Random perturbation + Greedy improvement\n    new_solution = base_solution.copy()\n\n    # Step 1: Random perturbation - flip a few random bits\n    num_flips = min(5, len(new_solution) // 2)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n\n    for item in remaining_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Calculate potential improvement in both objectives\n            val1_improvement = value1_lst[item]\n            val2_improvement = value2_lst[item]\n\n            # Add item if it improves both objectives\n            if val1_improvement > 0 and val2_improvement > 0:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.34551225574148414,
            2.849148064851761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and solution quality\n    # Here, we prioritize solutions with higher combined objective values and those with more diverse item selections\n    archive_with_metrics = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(sol * weight_lst)\n        diversity = np.sum(sol != sol[0])  # Simple diversity metric (number of items different from the first item)\n        archive_with_metrics.append((sol, (val1, val2), total_weight, diversity))\n\n    # Sort by combined objective values (val1 + val2) and diversity\n    archive_with_metrics.sort(key=lambda x: (x[1][0] + x[1][1], x[3]), reverse=True)\n\n    # Select top 20% of solutions for random selection\n    selection_pool = archive_with_metrics[:max(1, len(archive_with_metrics) // 5)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: Random perturbation + Greedy improvement\n    new_solution = base_solution.copy()\n\n    # Step 1: Random perturbation - flip a few random bits\n    num_flips = min(5, len(new_solution) // 2)  # Limit the number of flips to avoid excessive changes\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        while total_weight > capacity and len(excess_items) > 0:\n            remove_idx = np.random.choice(excess_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n            excess_items = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n\n    for item in remaining_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Calculate potential improvement in both objectives\n            val1_improvement = value1_lst[item]\n            val2_improvement = value2_lst[item]\n\n            # Add item if it improves both objectives\n            if val1_improvement > 0 and val2_improvement > 0:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 191,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine flipping, swapping, and insertion\n    n_items = len(base_solution)\n    operations = ['flip', 'swap', 'insert']\n\n    # Randomly select an operation\n    operation = random.choice(operations)\n\n    if operation == 'flip':\n        # Flip a random item (0 to 1 or 1 to 0)\n        item_idx = random.randint(0, n_items - 1)\n        if base_solution[item_idx] == 1:\n            # If removing, ensure weight constraint is not violated\n            if (np.sum(weight_lst * new_solution) - weight_lst[item_idx]) <= capacity:\n                new_solution[item_idx] = 0\n        else:\n            # If adding, ensure weight constraint is not violated\n            if (np.sum(weight_lst * new_solution) + weight_lst[item_idx]) <= capacity:\n                new_solution[item_idx] = 1\n\n    elif operation == 'swap':\n        # Swap two items (0 and 1)\n        zero_indices = np.where(base_solution == 0)[0]\n        one_indices = np.where(base_solution == 1)[0]\n\n        if len(zero_indices) > 0 and len(one_indices) > 0:\n            # Select a random 0 and 1 to swap\n            zero_idx = random.choice(zero_indices)\n            one_idx = random.choice(one_indices)\n\n            # Check weight constraint\n            delta_weight = weight_lst[zero_idx] - weight_lst[one_idx]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if (current_weight + delta_weight) <= capacity:\n                new_solution[zero_idx] = 1\n                new_solution[one_idx] = 0\n\n    elif operation == 'insert':\n        # Insert a new item (flip a 0 to 1) with a focus on high-value items\n        zero_indices = np.where(base_solution == 0)[0]\n        if len(zero_indices) > 0:\n            # Sort by value1 + value2 to prioritize high-value items\n            sorted_indices = sorted(zero_indices, key=lambda x: -(value1_lst[x] + value2_lst[x]))\n            for idx in sorted_indices:\n                if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.2832370717421246,
            6.026901990175247
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine flipping, swapping, and insertion\n    n_items = len(base_solution)\n    operations = ['flip', 'swap', 'insert']\n\n    # Randomly select an operation\n    operation = random.choice(operations)\n\n    if operation == 'flip':\n        # Flip a random item (0 to 1 or 1 to 0)\n        item_idx = random.randint(0, n_items - 1)\n        if base_solution[item_idx] == 1:\n            # If removing, ensure weight constraint is not violated\n            if (np.sum(weight_lst * new_solution) - weight_lst[item_idx]) <= capacity:\n                new_solution[item_idx] = 0\n        else:\n            # If adding, ensure weight constraint is not violated\n            if (np.sum(weight_lst * new_solution) + weight_lst[item_idx]) <= capacity:\n                new_solution[item_idx] = 1\n\n    elif operation == 'swap':\n        # Swap two items (0 and 1)\n        zero_indices = np.where(base_solution == 0)[0]\n        one_indices = np.where(base_solution == 1)[0]\n\n        if len(zero_indices) > 0 and len(one_indices) > 0:\n            # Select a random 0 and 1 to swap\n            zero_idx = random.choice(zero_indices)\n            one_idx = random.choice(one_indices)\n\n            # Check weight constraint\n            delta_weight = weight_lst[zero_idx] - weight_lst[one_idx]\n            current_weight = np.sum(weight_lst * new_solution)\n\n            if (current_weight + delta_weight) <= capacity:\n                new_solution[zero_idx] = 1\n                new_solution[one_idx] = 0\n\n    elif operation == 'insert':\n        # Insert a new item (flip a 0 to 1) with a focus on high-value items\n        zero_indices = np.where(base_solution == 0)[0]\n        if len(zero_indices) > 0:\n            # Sort by value1 + value2 to prioritize high-value items\n            sorted_indices = sorted(zero_indices, key=lambda x: -(value1_lst[x] + value2_lst[x]))\n            for idx in sorted_indices:\n                if (np.sum(weight_lst * new_solution) + weight_lst[idx]) <= capacity:\n                    new_solution[idx] = 1\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 192,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objective values and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip a subset of items to introduce diversity\n    num_flips = min(3, len(new_solution))  # Limit the number of flips to avoid excessive changes\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, check if removing it keeps the solution feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If the item is excluded, check if adding it keeps the solution feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Value-based flips - flip items with high marginal value\n    # Calculate marginal values for each item\n    marginal_value1 = value1_lst - np.sum(value1_lst * new_solution) / len(new_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst * new_solution) / len(new_solution)\n\n    # Combine marginal values for both objectives\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Flip items with the highest combined marginal value that fit within capacity\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Step 3: Weight-based adjustments - remove items with the smallest ratio of value to weight\n    # Calculate value-to-weight ratios for included items\n    included_indices = np.where(new_solution == 1)[0]\n    if len(included_indices) > 0:\n        value_to_weight1 = value1_lst[included_indices] / weight_lst[included_indices]\n        value_to_weight2 = value2_lst[included_indices] / weight_lst[included_indices]\n        combined_ratios = value_to_weight1 + value_to_weight2\n\n        # Sort by combined ratio and remove the worst ones if necessary\n        sorted_included = included_indices[np.argsort(combined_ratios)]\n        for idx in sorted_included:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            else:\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.9178882377500315,
            2.943678468465805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objective values and potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n\n    # Create a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip a subset of items to introduce diversity\n    num_flips = min(3, len(new_solution))  # Limit the number of flips to avoid excessive changes\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, check if removing it keeps the solution feasible\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If the item is excluded, check if adding it keeps the solution feasible\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Value-based flips - flip items with high marginal value\n    # Calculate marginal values for each item\n    marginal_value1 = value1_lst - np.sum(value1_lst * new_solution) / len(new_solution)\n    marginal_value2 = value2_lst - np.sum(value2_lst * new_solution) / len(new_solution)\n\n    # Combine marginal values for both objectives\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Flip items with the highest combined marginal value that fit within capacity\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1 and current_weight - weight_lst[idx] <= capacity:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    # Step 3: Weight-based adjustments - remove items with the smallest ratio of value to weight\n    # Calculate value-to-weight ratios for included items\n    included_indices = np.where(new_solution == 1)[0]\n    if len(included_indices) > 0:\n        value_to_weight1 = value1_lst[included_indices] / weight_lst[included_indices]\n        value_to_weight2 = value2_lst[included_indices] / weight_lst[included_indices]\n        combined_ratios = value_to_weight1 + value_to_weight2\n\n        # Sort by combined ratio and remove the worst ones if necessary\n        sorted_included = included_indices[np.argsort(combined_ratios)]\n        for idx in sorted_included:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n            else:\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 193,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, (v1, v2) in archive:\n        current_weight = np.dot(sol, weight_lst)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            scores.append(0)  # No room for improvement\n            continue\n\n        # Calculate potential improvement in both objectives\n        potential_v1 = np.sum((1 - sol) * value1_lst)\n        potential_v2 = np.sum((1 - sol) * value2_lst)\n        potential_weight = np.sum((1 - sol) * weight_lst)\n\n        # Score based on normalized potential improvement and remaining capacity\n        score = (potential_v1 + potential_v2) / (potential_weight + 1e-6) * min(1, remaining_capacity / capacity)\n        scores.append(score)\n\n    # Select the solution with the highest score, with some randomness\n    selected_idx = np.argmax(scores)\n    if random.random() < 0.3:  # 30% chance to explore other solutions\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small number of items (2-5) to maintain diversity\n    num_flips = random.randint(2, 5)\n    flip_indices = random.sample(range(len(weight_lst)), num_flips)\n\n    # 2. For each flipped item, decide based on value-to-weight ratio and objective potential\n    for idx in flip_indices:\n        current_weight = np.dot(new_solution, weight_lst)\n        if new_solution[idx] == 1:\n            # Consider removing if it doesn't contribute significantly to either objective\n            v1_ratio = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            v2_ratio = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n            if (v1_ratio < 0.5 and v2_ratio < 0.5) or current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Consider adding if it fits and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Ensure feasibility\n    current_weight = np.dot(new_solution, weight_lst)\n    if current_weight > capacity:\n        # Remove items with lowest value-to-weight ratio until feasible\n        while current_weight > capacity:\n            # Calculate value-to-weight ratios for included items\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n\n            ratios = [(value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6) for i in included_indices]\n            worst_idx = included_indices[np.argmin(ratios)]\n\n            new_solution[worst_idx] = 0\n            current_weight -= weight_lst[worst_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.33179003795549034,
            8.425508201122284
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, (v1, v2) in archive:\n        current_weight = np.dot(sol, weight_lst)\n        remaining_capacity = capacity - current_weight\n        if remaining_capacity <= 0:\n            scores.append(0)  # No room for improvement\n            continue\n\n        # Calculate potential improvement in both objectives\n        potential_v1 = np.sum((1 - sol) * value1_lst)\n        potential_v2 = np.sum((1 - sol) * value2_lst)\n        potential_weight = np.sum((1 - sol) * weight_lst)\n\n        # Score based on normalized potential improvement and remaining capacity\n        score = (potential_v1 + potential_v2) / (potential_weight + 1e-6) * min(1, remaining_capacity / capacity)\n        scores.append(score)\n\n    # Select the solution with the highest score, with some randomness\n    selected_idx = np.argmax(scores)\n    if random.random() < 0.3:  # 30% chance to explore other solutions\n        selected_idx = random.randint(0, len(archive) - 1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small number of items (2-5) to maintain diversity\n    num_flips = random.randint(2, 5)\n    flip_indices = random.sample(range(len(weight_lst)), num_flips)\n\n    # 2. For each flipped item, decide based on value-to-weight ratio and objective potential\n    for idx in flip_indices:\n        current_weight = np.dot(new_solution, weight_lst)\n        if new_solution[idx] == 1:\n            # Consider removing if it doesn't contribute significantly to either objective\n            v1_ratio = value1_lst[idx] / (weight_lst[idx] + 1e-6)\n            v2_ratio = value2_lst[idx] / (weight_lst[idx] + 1e-6)\n            if (v1_ratio < 0.5 and v2_ratio < 0.5) or current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Consider adding if it fits and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Ensure feasibility\n    current_weight = np.dot(new_solution, weight_lst)\n    if current_weight > capacity:\n        # Remove items with lowest value-to-weight ratio until feasible\n        while current_weight > capacity:\n            # Calculate value-to-weight ratios for included items\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n\n            ratios = [(value1_lst[i] + value2_lst[i]) / (weight_lst[i] + 1e-6) for i in included_indices]\n            worst_idx = included_indices[np.argmin(ratios)]\n\n            new_solution[worst_idx] = 0\n            current_weight -= weight_lst[worst_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 194,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Find items that can be added without exceeding capacity\n        possible_additions = (weight_lst <= remaining_capacity) & (sol == 0)\n        # Find items that can be removed\n        possible_removals = (sol == 1)\n        # Calculate potential improvements\n        potential_value1 = np.sum(value1_lst * possible_additions) - np.sum(value1_lst * possible_removals)\n        potential_value2 = np.sum(value2_lst * possible_additions) - np.sum(value2_lst * possible_removals)\n        # Score based on potential improvements\n        score = potential_value1 + potential_value2\n        candidates.append((sol, score))\n\n    # Select the solution with the highest improvement potential\n    if not candidates:\n        return archive[0][0].copy()\n    best_sol, _ = max(candidates, key=lambda x: x[1])\n    new_solution = best_sol.copy()\n\n    # Hybrid local search: flip bits with high marginal gain\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n    # Combine marginal gains for both objectives\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain in descending order\n    sorted_indices = np.argsort(-combined_gain)\n\n    # Try to add items with highest marginal gain first\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Try to remove items with negative marginal gain\n            if combined_gain[idx] < 0:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8549439795790947,
            7.530047059059143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Find items that can be added without exceeding capacity\n        possible_additions = (weight_lst <= remaining_capacity) & (sol == 0)\n        # Find items that can be removed\n        possible_removals = (sol == 1)\n        # Calculate potential improvements\n        potential_value1 = np.sum(value1_lst * possible_additions) - np.sum(value1_lst * possible_removals)\n        potential_value2 = np.sum(value2_lst * possible_additions) - np.sum(value2_lst * possible_removals)\n        # Score based on potential improvements\n        score = potential_value1 + potential_value2\n        candidates.append((sol, score))\n\n    # Select the solution with the highest improvement potential\n    if not candidates:\n        return archive[0][0].copy()\n    best_sol, _ = max(candidates, key=lambda x: x[1])\n    new_solution = best_sol.copy()\n\n    # Hybrid local search: flip bits with high marginal gain\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate marginal gains for each item\n    marginal_gain1 = value1_lst / weight_lst\n    marginal_gain2 = value2_lst / weight_lst\n    # Combine marginal gains for both objectives\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain in descending order\n    sorted_indices = np.argsort(-combined_gain)\n\n    # Try to add items with highest marginal gain first\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Try to remove items with negative marginal gain\n            if combined_gain[idx] < 0:\n                new_solution[idx] = 0\n                remaining_capacity += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 195,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential: prioritize those with high value1 and value2\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: swap items based on value ratios and perturb based on objective dominance\n    n_items = len(selected_solution)\n    for i in range(n_items):\n        if selected_solution[i] == 1:\n            # Consider removing item i if it's not critical (low value or high weight)\n            if (value1_lst[i] + value2_lst[i]) < np.mean(value1_lst + value2_lst) or weight_lst[i] > 0.3 * capacity:\n                new_solution[i] = 0\n                # Add a high-value item not in the solution\n                candidate_items = np.where((selected_solution == 0) &\n                                          (np.sum(weight_lst * selected_solution) + weight_lst <= capacity))[0]\n                if len(candidate_items) > 0:\n                    # Select item with highest combined value\n                    best_candidate = candidate_items[np.argmax(value1_lst[candidate_items] + value2_lst[candidate_items])]\n                    new_solution[best_candidate] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest value until feasible\n        while total_weight > capacity:\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break\n            # Remove item with lowest combined value\n            worst_item = removable_items[np.argmin(value1_lst[removable_items] + value2_lst[removable_items])]\n            new_solution[worst_item] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7779474499628632,
            7.584985375404358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential: prioritize those with high value1 and value2\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: swap items based on value ratios and perturb based on objective dominance\n    n_items = len(selected_solution)\n    for i in range(n_items):\n        if selected_solution[i] == 1:\n            # Consider removing item i if it's not critical (low value or high weight)\n            if (value1_lst[i] + value2_lst[i]) < np.mean(value1_lst + value2_lst) or weight_lst[i] > 0.3 * capacity:\n                new_solution[i] = 0\n                # Add a high-value item not in the solution\n                candidate_items = np.where((selected_solution == 0) &\n                                          (np.sum(weight_lst * selected_solution) + weight_lst <= capacity))[0]\n                if len(candidate_items) > 0:\n                    # Select item with highest combined value\n                    best_candidate = candidate_items[np.argmax(value1_lst[candidate_items] + value2_lst[candidate_items])]\n                    new_solution[best_candidate] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest value until feasible\n        while total_weight > capacity:\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break\n            # Remove item with lowest combined value\n            worst_item = removable_items[np.argmin(value1_lst[removable_items] + value2_lst[removable_items])]\n            new_solution[worst_item] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 196,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    # We prioritize solutions with high combined value but not already at the Pareto front\n    archive_solutions = [sol for sol, _ in archive]\n    archive_values = np.array([val for _, val in archive])\n\n    # Calculate normalized values for both objectives\n    norm_value1 = (archive_values[:, 0] - np.min(archive_values[:, 0])) / (np.max(archive_values[:, 0]) - np.min(archive_values[:, 0]))\n    norm_value2 = (archive_values[:, 1] - np.min(archive_values[:, 1])) / (np.max(archive_values[:, 1]) - np.min(archive_values[:, 1]))\n\n    # Combine the normalized values with weights to prioritize solutions with high potential\n    combined_score = 0.6 * norm_value1 + 0.4 * norm_value2  # More weight to value1\n\n    # Select the solution with the highest combined score\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a subset of items (exploration)\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove the item if it's in the solution\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy improvement (exploitation) - add items with highest weighted value\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate weighted value (sum of both objectives)\n        weighted_value = 0.6 * value1_lst + 0.4 * value2_lst  # Same weights as selection\n        available_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(available_items) > 0:\n            # Select the item with the highest weighted value\n            best_item = available_items[np.argmax(weighted_value[available_items])]\n            new_solution[best_item] = 1\n\n    # Ensure feasibility (shouldn't be needed due to checks above, but just in case)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove the lightest item in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            lightest_item = in_solution[np.argmin(weight_lst[in_solution])]\n            new_solution[lightest_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.32088442557946656,
            6.478310167789459
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    # We prioritize solutions with high combined value but not already at the Pareto front\n    archive_solutions = [sol for sol, _ in archive]\n    archive_values = np.array([val for _, val in archive])\n\n    # Calculate normalized values for both objectives\n    norm_value1 = (archive_values[:, 0] - np.min(archive_values[:, 0])) / (np.max(archive_values[:, 0]) - np.min(archive_values[:, 0]))\n    norm_value2 = (archive_values[:, 1] - np.min(archive_values[:, 1])) / (np.max(archive_values[:, 1]) - np.min(archive_values[:, 1]))\n\n    # Combine the normalized values with weights to prioritize solutions with high potential\n    combined_score = 0.6 * norm_value1 + 0.4 * norm_value2  # More weight to value1\n\n    # Select the solution with the highest combined score\n    selected_idx = np.argmax(combined_score)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly flip a subset of items (exploration)\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove the item if it's in the solution\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Greedy improvement (exploitation) - add items with highest weighted value\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate weighted value (sum of both objectives)\n        weighted_value = 0.6 * value1_lst + 0.4 * value2_lst  # Same weights as selection\n        available_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(available_items) > 0:\n            # Select the item with the highest weighted value\n            best_item = available_items[np.argmax(weighted_value[available_items])]\n            new_solution[best_item] = 1\n\n    # Ensure feasibility (shouldn't be needed due to checks above, but just in case)\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove the lightest item in the solution\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            lightest_item = in_solution[np.argmin(weight_lst[in_solution])]\n            new_solution[lightest_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 197,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution: prioritize those near the Pareto front and with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.dot(sol, weight_lst)\n        if total_weight > 0:  # Avoid division by zero\n            efficiency1 = obj[0] / total_weight\n            efficiency2 = obj[1] / total_weight\n        else:\n            efficiency1, efficiency2 = 0.0, 0.0\n        # Higher efficiency and lower weight utilization indicate potential for improvement\n        score = (efficiency1 + efficiency2) * (1.0 - total_weight / capacity)\n        candidates.append((sol, score))\n\n    # Select the top 20% of candidates by score\n    candidates.sort(key=lambda x: -x[1])\n    top_candidates = candidates[:max(1, len(candidates) // 5)]\n    selected_sol, _ = random.choice(top_candidates)\n    base_solution = selected_sol.copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly flip bits with high value-to-weight ratio\n    if random.random() < 0.6:\n        value_weight_ratios = (value1_lst + value2_lst) / weight_lst\n        top_items = np.argsort(-value_weight_ratios)[:min(10, n_items)]\n        for idx in top_items:\n            if random.random() < 0.3:  # Flip with 30% probability\n                new_solution[idx] = 1 - new_solution[idx]\n\n    # Strategy 2: Capacity-aware perturbations\n    current_weight = np.dot(new_solution, weight_lst)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess = current_weight - capacity\n        items_sorted_by_weight = np.argsort(weight_lst)\n        for idx in items_sorted_by_weight:\n            if new_solution[idx] == 1 and excess > 0:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    # Strategy 3: Random swaps to escape local optima\n    if random.random() < 0.4:\n        indices = np.where(new_solution == 1)[0]\n        if len(indices) >= 2:\n            i, j = random.sample(list(indices), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # If still infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6733244931435989,
            8.029679536819458
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution: prioritize those near the Pareto front and with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.dot(sol, weight_lst)\n        if total_weight > 0:  # Avoid division by zero\n            efficiency1 = obj[0] / total_weight\n            efficiency2 = obj[1] / total_weight\n        else:\n            efficiency1, efficiency2 = 0.0, 0.0\n        # Higher efficiency and lower weight utilization indicate potential for improvement\n        score = (efficiency1 + efficiency2) * (1.0 - total_weight / capacity)\n        candidates.append((sol, score))\n\n    # Select the top 20% of candidates by score\n    candidates.sort(key=lambda x: -x[1])\n    top_candidates = candidates[:max(1, len(candidates) // 5)]\n    selected_sol, _ = random.choice(top_candidates)\n    base_solution = selected_sol.copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Randomly flip bits with high value-to-weight ratio\n    if random.random() < 0.6:\n        value_weight_ratios = (value1_lst + value2_lst) / weight_lst\n        top_items = np.argsort(-value_weight_ratios)[:min(10, n_items)]\n        for idx in top_items:\n            if random.random() < 0.3:  # Flip with 30% probability\n                new_solution[idx] = 1 - new_solution[idx]\n\n    # Strategy 2: Capacity-aware perturbations\n    current_weight = np.dot(new_solution, weight_lst)\n    if current_weight > capacity:\n        # Remove items until feasible\n        excess = current_weight - capacity\n        items_sorted_by_weight = np.argsort(weight_lst)\n        for idx in items_sorted_by_weight:\n            if new_solution[idx] == 1 and excess > 0:\n                new_solution[idx] = 0\n                excess -= weight_lst[idx]\n\n    # Strategy 3: Random swaps to escape local optima\n    if random.random() < 0.4:\n        indices = np.where(new_solution == 1)[0]\n        if len(indices) >= 2:\n            i, j = random.sample(list(indices), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n    if total_weight > capacity:\n        # If still infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 198,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on high potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = (np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol)))  # Potential if all remaining items were added\n        candidates.append((sol, v1, v2, potential, current_weight))\n\n    # Sort by potential and select top 30% or at least 1\n    candidates.sort(key=lambda x: x[3], reverse=True)\n    selected = candidates[min(3, len(candidates) // 3)]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = selected[4]\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Perform multiple local search steps\n        # Randomly select a flip operation (better for exploration)\n        if np.random.rand() < 0.7:  # Higher probability for flip\n            idx = np.random.randint(0, len(new_solution))\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n        else:\n            # Random swap between two items (better for exploitation)\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            if new_solution[idx1] != new_solution[idx2]:\n                delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] else (weight_lst[idx1] - weight_lst[idx2])\n                if current_weight + delta_weight <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                    current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8322266966114746,
            4.658528804779053
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on high potential for improvement\n    candidates = []\n    for sol, (v1, v2) in archive:\n        current_weight = np.sum(weight_lst * sol)\n        potential = (np.sum(value1_lst * (1 - sol)) + np.sum(value2_lst * (1 - sol)))  # Potential if all remaining items were added\n        candidates.append((sol, v1, v2, potential, current_weight))\n\n    # Sort by potential and select top 30% or at least 1\n    candidates.sort(key=lambda x: x[3], reverse=True)\n    selected = candidates[min(3, len(candidates) // 3)]\n    base_solution = selected[0].copy()\n\n    new_solution = base_solution.copy()\n    current_weight = selected[4]\n\n    # Hybrid local search strategy\n    for _ in range(5):  # Perform multiple local search steps\n        # Randomly select a flip operation (better for exploration)\n        if np.random.rand() < 0.7:  # Higher probability for flip\n            idx = np.random.randint(0, len(new_solution))\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n        else:\n            # Random swap between two items (better for exploitation)\n            idx1, idx2 = np.random.choice(len(new_solution), 2, replace=False)\n            if new_solution[idx1] != new_solution[idx2]:\n                delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] else (weight_lst[idx1] - weight_lst[idx2])\n                if current_weight + delta_weight <= capacity:\n                    new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n                    current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 199,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance to identify solutions with potential for improvement\n    crowding_distances = []\n    for i in range(len(archive_solutions)):\n        left = max(0, i - 1)\n        right = min(len(archive_solutions) - 1, i + 1)\n        if left == right:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = archive_objectives[right][0] - archive_objectives[left][0]\n            dist2 = archive_objectives[right][1] - archive_objectives[left][1]\n            crowding_distances.append(dist1 + dist2)\n\n    # Select a solution with low crowding distance (promising for improvement)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combination of bit-flip and item swap\n    new_solution = base_solution.copy()\n\n    # Step 1: Bit-flip (flip a random item if feasible)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        new_solution[flip_idx] = 0\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight <= capacity:\n            # Try to add a new item\n            add_candidates = np.where(new_solution == 0)[0]\n            if len(add_candidates) > 0:\n                for _ in range(10):  # Limit attempts to avoid excessive computation\n                    add_idx = np.random.choice(add_candidates)\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        break\n\n    # Step 2: Item swap (swap two items if feasible)\n    if np.sum(new_solution) >= 2:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Revert if infeasible\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.5130352743825254,
            1.7314266562461853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance to identify solutions with potential for improvement\n    crowding_distances = []\n    for i in range(len(archive_solutions)):\n        left = max(0, i - 1)\n        right = min(len(archive_solutions) - 1, i + 1)\n        if left == right:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = archive_objectives[right][0] - archive_objectives[left][0]\n            dist2 = archive_objectives[right][1] - archive_objectives[left][1]\n            crowding_distances.append(dist1 + dist2)\n\n    # Select a solution with low crowding distance (promising for improvement)\n    selected_idx = np.argmin(crowding_distances)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combination of bit-flip and item swap\n    new_solution = base_solution.copy()\n\n    # Step 1: Bit-flip (flip a random item if feasible)\n    flip_candidates = np.where(new_solution == 1)[0]\n    if len(flip_candidates) > 0:\n        flip_idx = np.random.choice(flip_candidates)\n        new_solution[flip_idx] = 0\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight <= capacity:\n            # Try to add a new item\n            add_candidates = np.where(new_solution == 0)[0]\n            if len(add_candidates) > 0:\n                for _ in range(10):  # Limit attempts to avoid excessive computation\n                    add_idx = np.random.choice(add_candidates)\n                    if total_weight + weight_lst[add_idx] <= capacity:\n                        new_solution[add_idx] = 1\n                        break\n\n    # Step 2: Item swap (swap two items if feasible)\n    if np.sum(new_solution) >= 2:\n        swap_indices = np.random.choice(np.where(new_solution == 1)[0], size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n        total_weight = np.sum(weight_lst[new_solution == 1])\n        if total_weight > capacity:\n            # Revert if infeasible\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 200,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we select the solution that is most crowded in the objective space (indicating room for improvement)\n    # Alternatively, we could select a solution with high marginal gains\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. First, try to add items that are not in the solution but have high marginal gains\n    # 2. Then, try to remove items from the solution that have low marginal gains\n    # 3. Finally, perform a random swap to escape local optima\n\n    # Step 1: Add items with high marginal gains\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Calculate marginal gains for both objectives\n            marginal_value1 = value1_lst[i]\n            marginal_value2 = value2_lst[i]\n\n            # If both objectives improve, add the item\n            if marginal_value1 > 0 and marginal_value2 > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    # Step 2: Remove items with low marginal gains\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Calculate marginal loss for both objectives\n            marginal_value1 = -value1_lst[i]\n            marginal_value2 = -value2_lst[i]\n\n            # If removing the item doesn't significantly degrade both objectives, remove it\n            if (marginal_value1 > -1e-6 and marginal_value2 > -1e-6) or np.random.rand() < 0.3:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                break\n\n    # Step 3: Random swap to escape local optima\n    if np.random.rand() < 0.5:\n        # Find a random item to remove\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            remove_idx = np.random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n            # Find a random item to add\n            add_candidates = np.where((new_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n            if len(add_candidates) > 0:\n                add_idx = np.random.choice(add_candidates)\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.556871516239108,
            1.2054131925106049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we select the solution that is most crowded in the objective space (indicating room for improvement)\n    # Alternatively, we could select a solution with high marginal gains\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. First, try to add items that are not in the solution but have high marginal gains\n    # 2. Then, try to remove items from the solution that have low marginal gains\n    # 3. Finally, perform a random swap to escape local optima\n\n    # Step 1: Add items with high marginal gains\n    for i in range(len(base_solution)):\n        if base_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Calculate marginal gains for both objectives\n            marginal_value1 = value1_lst[i]\n            marginal_value2 = value2_lst[i]\n\n            # If both objectives improve, add the item\n            if marginal_value1 > 0 and marginal_value2 > 0:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    # Step 2: Remove items with low marginal gains\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # Calculate marginal loss for both objectives\n            marginal_value1 = -value1_lst[i]\n            marginal_value2 = -value2_lst[i]\n\n            # If removing the item doesn't significantly degrade both objectives, remove it\n            if (marginal_value1 > -1e-6 and marginal_value2 > -1e-6) or np.random.rand() < 0.3:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n                break\n\n    # Step 3: Random swap to escape local optima\n    if np.random.rand() < 0.5:\n        # Find a random item to remove\n        remove_candidates = np.where(new_solution == 1)[0]\n        if len(remove_candidates) > 0:\n            remove_idx = np.random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n            # Find a random item to add\n            add_candidates = np.where((new_solution == 0) & (weight_lst <= capacity - current_weight))[0]\n            if len(add_candidates) > 0:\n                add_idx = np.random.choice(add_candidates)\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 201,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (ascending) to prioritize less explored regions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a random solution from the top 30% of the archive (or the entire archive if small)\n        selection_pool = archive_sorted[:max(1, len(archive) // 3)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small number of items (1-3) to introduce diversity\n    num_flips = random.randint(1, 3)\n    for _ in range(num_flips):\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            # If removing, ensure it doesn't violate capacity\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If adding, ensure it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # 2. Add items with high value-to-weight ratio that are not currently selected\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios and select top candidates\n    combined_ratio = ratio1 + ratio2\n    candidate_indices = np.where(new_solution == 0)[0]\n\n    if len(candidate_indices) > 0:\n        # Sort candidates by combined ratio in descending order\n        sorted_candidates = sorted(candidate_indices, key=lambda x: -combined_ratio[x])\n        # Try to add the top 2 candidates if they fit\n        for i in range(min(2, len(sorted_candidates))):\n            idx = sorted_candidates[i]\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.840777943559233,
            1.5924979746341705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objective values (ascending) to prioritize less explored regions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a random solution from the top 30% of the archive (or the entire archive if small)\n        selection_pool = archive_sorted[:max(1, len(archive) // 3)]\n        selected = random.choice(selection_pool)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small number of items (1-3) to introduce diversity\n    num_flips = random.randint(1, 3)\n    for _ in range(num_flips):\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            # If removing, ensure it doesn't violate capacity\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If adding, ensure it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # 2. Add items with high value-to-weight ratio that are not currently selected\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Combine ratios and select top candidates\n    combined_ratio = ratio1 + ratio2\n    candidate_indices = np.where(new_solution == 0)[0]\n\n    if len(candidate_indices) > 0:\n        # Sort candidates by combined ratio in descending order\n        sorted_candidates = sorted(candidate_indices, key=lambda x: -combined_ratio[x])\n        # Try to add the top 2 candidates if they fit\n        for i in range(min(2, len(sorted_candidates))):\n            idx = sorted_candidates[i]\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 202,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [np.sum(value1_lst[sol[0] == 1]) + np.sum(value2_lst[sol[0] == 1]) for sol in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution and their value-to-weight ratios\n    candidate_indices = np.where(base_solution == 0)[0]\n    if len(candidate_indices) == 0:\n        return base_solution  # No items to add\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst[candidate_indices] / weight_lst[candidate_indices]\n    ratio2 = value2_lst[candidate_indices] / weight_lst[candidate_indices]\n\n    # Combine ratios to prioritize items that improve both objectives\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = candidate_indices[np.argsort(combined_ratio)[::-1]]\n\n    # Try to add the top items that fit within remaining capacity\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Randomly flip some items to escape local optima\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36324725975998784,
            8.043507099151611
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [np.sum(value1_lst[sol[0] == 1]) + np.sum(value2_lst[sol[0] == 1]) for sol in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution and their value-to-weight ratios\n    candidate_indices = np.where(base_solution == 0)[0]\n    if len(candidate_indices) == 0:\n        return base_solution  # No items to add\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst[candidate_indices] / weight_lst[candidate_indices]\n    ratio2 = value2_lst[candidate_indices] / weight_lst[candidate_indices]\n\n    # Combine ratios to prioritize items that improve both objectives\n    combined_ratio = ratio1 + ratio2\n    sorted_indices = candidate_indices[np.argsort(combined_ratio)[::-1]]\n\n    # Try to add the top items that fit within remaining capacity\n    new_solution = base_solution.copy()\n    for idx in sorted_indices:\n        if weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n\n    # Randomly flip some items to escape local optima\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 203,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Criteria: solutions that are not too close to the boundary (not all items included) and have non-zero values\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity and (obj[0] > 0 or obj[1] > 0):\n            # Calculate \"improvement potential\" based on value-to-weight ratio\n            value_ratio1 = obj[0] / (total_weight + 1e-6)\n            value_ratio2 = obj[1] / (total_weight + 1e-6)\n            potential = value_ratio1 + value_ratio2\n            candidates.append((sol, potential))\n\n    if not candidates:\n        # If no good candidates, just pick the first one\n        base_solution = archive[0][0].copy()\n    else:\n        # Select the solution with highest potential\n        candidates.sort(key=lambda x: -x[1])\n        base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of bit flip and value-based swaps\n    # 1. Random bit flip with probability based on solution density\n    density = np.mean(new_solution)\n    flip_prob = 0.3 * (1 - density)  # Higher probability if solution is sparse\n\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            new_value = 1 - new_solution[i]\n            new_weight = np.sum(weight_lst * (new_solution + (new_value - new_solution[i]) * np.eye(1, len(new_solution), i).flatten()))\n            if new_weight <= capacity:\n                new_solution[i] = new_value\n\n    # 2. Value-based swaps: swap items that improve at least one objective\n    for _ in range(3):  # Limit number of swaps per iteration\n        # Find items that are in the solution and could be swapped\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove\n            remove_idx = np.random.choice(in_items)\n            # Select a random item to add\n            add_idx = np.random.choice(out_items)\n\n            # Calculate new weights and values\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[remove_idx] + weight_lst[add_idx]\n            new_value1 = np.sum(value1_lst * new_solution) - value1_lst[remove_idx] + value1_lst[add_idx]\n            new_value2 = np.sum(value2_lst * new_solution) - value2_lst[remove_idx] + value2_lst[add_idx]\n\n            # Check feasibility and improvement\n            if new_weight <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3577971793113402,
            7.902233153581619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Criteria: solutions that are not too close to the boundary (not all items included) and have non-zero values\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity and (obj[0] > 0 or obj[1] > 0):\n            # Calculate \"improvement potential\" based on value-to-weight ratio\n            value_ratio1 = obj[0] / (total_weight + 1e-6)\n            value_ratio2 = obj[1] / (total_weight + 1e-6)\n            potential = value_ratio1 + value_ratio2\n            candidates.append((sol, potential))\n\n    if not candidates:\n        # If no good candidates, just pick the first one\n        base_solution = archive[0][0].copy()\n    else:\n        # Select the solution with highest potential\n        candidates.sort(key=lambda x: -x[1])\n        base_solution = candidates[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of bit flip and value-based swaps\n    # 1. Random bit flip with probability based on solution density\n    density = np.mean(new_solution)\n    flip_prob = 0.3 * (1 - density)  # Higher probability if solution is sparse\n\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            new_value = 1 - new_solution[i]\n            new_weight = np.sum(weight_lst * (new_solution + (new_value - new_solution[i]) * np.eye(1, len(new_solution), i).flatten()))\n            if new_weight <= capacity:\n                new_solution[i] = new_value\n\n    # 2. Value-based swaps: swap items that improve at least one objective\n    for _ in range(3):  # Limit number of swaps per iteration\n        # Find items that are in the solution and could be swapped\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Select a random item to remove\n            remove_idx = np.random.choice(in_items)\n            # Select a random item to add\n            add_idx = np.random.choice(out_items)\n\n            # Calculate new weights and values\n            new_weight = np.sum(weight_lst * new_solution) - weight_lst[remove_idx] + weight_lst[add_idx]\n            new_value1 = np.sum(value1_lst * new_solution) - value1_lst[remove_idx] + value1_lst[add_idx]\n            new_value2 = np.sum(value2_lst * new_solution) - value2_lst[remove_idx] + value2_lst[add_idx]\n\n            # Check feasibility and improvement\n            if new_weight <= capacity:\n                new_solution[remove_idx] = 0\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 204,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards those that are not too similar to others\n    def is_promising(sol, archive):\n        for (other_sol, _) in archive:\n            if np.array_equal(sol, other_sol):\n                return False\n        return True\n\n    promising_solutions = [sol for (sol, _) in archive if is_promising(sol, archive)]\n    if not promising_solutions:\n        promising_solutions = [sol for (sol, _) in archive]\n\n    base_solution = random.choice(promising_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: item swapping and random flipping\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select two items to swap (if possible)\n    if np.sum(new_solution) >= 2:\n        swap_indices = random.sample(list(np.where(new_solution == 1)[0]), 2)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Randomly flip a few items to explore the neighborhood\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.33624508180017076,
            7.398852378129959
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards those that are not too similar to others\n    def is_promising(sol, archive):\n        for (other_sol, _) in archive:\n            if np.array_equal(sol, other_sol):\n                return False\n        return True\n\n    promising_solutions = [sol for (sol, _) in archive if is_promising(sol, archive)]\n    if not promising_solutions:\n        promising_solutions = [sol for (sol, _) in archive]\n\n    base_solution = random.choice(promising_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: item swapping and random flipping\n    n_items = len(weight_lst)\n    total_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select two items to swap (if possible)\n    if np.sum(new_solution) >= 2:\n        swap_indices = random.sample(list(np.where(new_solution == 1)[0]), 2)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Randomly flip a few items to explore the neighborhood\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if total_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n        else:\n            if total_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                total_weight += weight_lst[idx]\n\n    # Ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        excess_items = np.where(new_solution == 1)[0]\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 205,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = np.argmax([np.sum(weight_lst[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy: flip a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n    candidate_indices = np.where(base_solution == 1)[0]\n\n    # Calculate marginal gains for each item in the solution\n    marginal_gains1 = value1_lst[candidate_indices] / weight_lst[candidate_indices]\n    marginal_gains2 = value2_lst[candidate_indices] / weight_lst[candidate_indices]\n\n    # Sort items by combined marginal gain (prioritize items with high marginal gains)\n    combined_gains = marginal_gains1 + marginal_gains2\n    sorted_indices = candidate_indices[np.argsort(combined_gains)[::-1]]\n\n    # Flip the top 20% of items with highest marginal gains (or at least 1 item)\n    flip_count = max(1, int(0.2 * len(sorted_indices)))\n    flip_indices = sorted_indices[:flip_count]\n\n    # Try to flip items to improve both objectives\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                current_weight = new_weight\n            else:\n                new_solution[idx] = 1  # Revert if infeasible\n\n    # Add random items not in the solution to explore new regions\n    remaining_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_indices)\n    for idx in remaining_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            break  # Add at most one new item to maintain diversity\n\n    return new_solution\n\n",
        "score": [
            -0.8512577567548695,
            2.5461173355579376
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_idx = np.argmax([np.sum(weight_lst[sol[0] == 1]) for sol in archive])\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n\n    # Hybrid local search strategy: flip a subset of items based on marginal gains\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n    candidate_indices = np.where(base_solution == 1)[0]\n\n    # Calculate marginal gains for each item in the solution\n    marginal_gains1 = value1_lst[candidate_indices] / weight_lst[candidate_indices]\n    marginal_gains2 = value2_lst[candidate_indices] / weight_lst[candidate_indices]\n\n    # Sort items by combined marginal gain (prioritize items with high marginal gains)\n    combined_gains = marginal_gains1 + marginal_gains2\n    sorted_indices = candidate_indices[np.argsort(combined_gains)[::-1]]\n\n    # Flip the top 20% of items with highest marginal gains (or at least 1 item)\n    flip_count = max(1, int(0.2 * len(sorted_indices)))\n    flip_indices = sorted_indices[:flip_count]\n\n    # Try to flip items to improve both objectives\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                current_weight = new_weight\n            else:\n                new_solution[idx] = 1  # Revert if infeasible\n\n    # Add random items not in the solution to explore new regions\n    remaining_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_indices)\n    for idx in remaining_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n            break  # Add at most one new item to maintain diversity\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 206,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        slack = capacity - total_weight\n        if slack > 0:\n            # Prefer solutions with some slack and high marginal potential\n            candidates.append((sol, obj, slack))\n\n    if not candidates:\n        # If no candidates, return a random solution from the archive\n        return random.choice(archive)[0].copy()\n\n    # Sort candidates by slack (ascending) and then by sum of objectives (descending)\n    candidates.sort(key=lambda x: (x[2], -(x[1][0] + x[1][1])))\n    selected_sol = candidates[0][0].copy()\n    current_weight = np.sum(weight_lst * selected_sol)\n\n    # Hybrid local search: random flip with greedy selection\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n    max_attempts = min(10, n_items)  # Limit attempts to avoid excessive computation\n\n    for _ in range(max_attempts):\n        # Randomly select a subset of items to flip\n        flip_indices = random.sample(range(n_items), min(3, n_items))\n        temp_solution = new_solution.copy()\n\n        for idx in flip_indices:\n            # Flip the item if it doesn't violate capacity\n            if temp_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    temp_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    temp_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n        # Evaluate the temporary solution\n        temp_value1 = np.sum(value1_lst * temp_solution)\n        temp_value2 = np.sum(value2_lst * temp_solution)\n\n        # Accept if it improves both objectives or if it's non-dominated\n        current_value1 = np.sum(value1_lst * new_solution)\n        current_value2 = np.sum(value2_lst * new_solution)\n\n        if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n           (temp_value1 >= current_value1 and temp_value2 > current_value2):\n            new_solution = temp_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.3304127977545998,
            5.723142087459564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        slack = capacity - total_weight\n        if slack > 0:\n            # Prefer solutions with some slack and high marginal potential\n            candidates.append((sol, obj, slack))\n\n    if not candidates:\n        # If no candidates, return a random solution from the archive\n        return random.choice(archive)[0].copy()\n\n    # Sort candidates by slack (ascending) and then by sum of objectives (descending)\n    candidates.sort(key=lambda x: (x[2], -(x[1][0] + x[1][1])))\n    selected_sol = candidates[0][0].copy()\n    current_weight = np.sum(weight_lst * selected_sol)\n\n    # Hybrid local search: random flip with greedy selection\n    new_solution = selected_sol.copy()\n    n_items = len(weight_lst)\n    max_attempts = min(10, n_items)  # Limit attempts to avoid excessive computation\n\n    for _ in range(max_attempts):\n        # Randomly select a subset of items to flip\n        flip_indices = random.sample(range(n_items), min(3, n_items))\n        temp_solution = new_solution.copy()\n\n        for idx in flip_indices:\n            # Flip the item if it doesn't violate capacity\n            if temp_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    temp_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    temp_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n        # Evaluate the temporary solution\n        temp_value1 = np.sum(value1_lst * temp_solution)\n        temp_value2 = np.sum(value2_lst * temp_solution)\n\n        # Accept if it improves both objectives or if it's non-dominated\n        current_value1 = np.sum(value1_lst * new_solution)\n        current_value2 = np.sum(value2_lst * new_solution)\n\n        if (temp_value1 > current_value1 and temp_value2 >= current_value2) or \\\n           (temp_value1 >= current_value1 and temp_value2 > current_value2):\n            new_solution = temp_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 207,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a promising solution from the archive\n    # Here, we select a solution that is not already fully explored (i.e., has some items included)\n    candidates = [sol for sol, _ in archive if np.sum(sol) > 0 and np.sum(sol) < len(sol)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    # Randomly select a candidate solution\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Greedily improve the solution by adding/removing items that improve both objectives\n\n    # Step 1: Random perturbation (flip a subset of items)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after perturbation\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_weight = current_weight - capacity\n        removable_indices = np.where(new_solution == 1)[0]\n        while excess_weight > 0 and len(removable_indices) > 0:\n            idx_to_remove = np.random.choice(removable_indices)\n            new_solution[idx_to_remove] = 0\n            excess_weight -= weight_lst[idx_to_remove]\n            removable_indices = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement (add items that improve both objectives)\n    current_value1 = np.sum(new_solution * value1_lst)\n    current_value2 = np.sum(new_solution * value2_lst)\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Identify items not in the solution\n    zero_indices = np.where(new_solution == 0)[0]\n    for idx in zero_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Step 3: Greedy improvement (remove items that do not contribute to both objectives)\n    one_indices = np.where(new_solution == 1)[0]\n    for idx in one_indices:\n        # Check if removing the item does not worsen both objectives\n        if (current_value1 - value1_lst[idx] >= 0 and current_value2 - value2_lst[idx] >= 0):\n            new_solution[idx] = 0\n            current_value1 -= value1_lst[idx]\n            current_value2 -= value2_lst[idx]\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.792548389653759,
            3.8504534363746643
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a promising solution from the archive\n    # Here, we select a solution that is not already fully explored (i.e., has some items included)\n    candidates = [sol for sol, _ in archive if np.sum(sol) > 0 and np.sum(sol) < len(sol)]\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    # Randomly select a candidate solution\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Greedily improve the solution by adding/removing items that improve both objectives\n\n    # Step 1: Random perturbation (flip a subset of items)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after perturbation\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_weight = current_weight - capacity\n        removable_indices = np.where(new_solution == 1)[0]\n        while excess_weight > 0 and len(removable_indices) > 0:\n            idx_to_remove = np.random.choice(removable_indices)\n            new_solution[idx_to_remove] = 0\n            excess_weight -= weight_lst[idx_to_remove]\n            removable_indices = np.where(new_solution == 1)[0]\n\n    # Step 2: Greedy improvement (add items that improve both objectives)\n    current_value1 = np.sum(new_solution * value1_lst)\n    current_value2 = np.sum(new_solution * value2_lst)\n    current_weight = np.sum(new_solution * weight_lst)\n\n    # Identify items not in the solution\n    zero_indices = np.where(new_solution == 0)[0]\n    for idx in zero_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding the item improves both objectives\n            if (value1_lst[idx] > 0 and value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_value1 += value1_lst[idx]\n                current_value2 += value2_lst[idx]\n                current_weight += weight_lst[idx]\n\n    # Step 3: Greedy improvement (remove items that do not contribute to both objectives)\n    one_indices = np.where(new_solution == 1)[0]\n    for idx in one_indices:\n        # Check if removing the item does not worsen both objectives\n        if (current_value1 - value1_lst[idx] >= 0 and current_value2 - value2_lst[idx] >= 0):\n            new_solution[idx] = 0\n            current_value1 -= value1_lst[idx]\n            current_value2 -= value2_lst[idx]\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 208,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Sort solutions by their objective values (prioritize those with higher values)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search strategy: combine swap and flip operations\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a subset of items to flip (1 -> 0 or 0 -> 1)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if np.dot(new_solution, weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if np.dot(new_solution, weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Perform a swap operation between two items (if feasible)\n    if len(new_solution) >= 2:\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        i, j = swap_indices[0], swap_indices[1]\n\n        # Check if swapping i and j maintains feasibility\n        current_weight = np.dot(new_solution, weight_lst)\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif (new_solution[i] == 0 and new_solution[j] == 1 and\n              current_weight + weight_lst[i] - weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3091773035930618,
            1.5405661463737488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Sort solutions by their objective values (prioritize those with higher values)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = sorted_archive[0][0].copy()\n\n    # Hybrid local search strategy: combine swap and flip operations\n    new_solution = selected_solution.copy()\n\n    # Step 1: Randomly select a subset of items to flip (1 -> 0 or 0 -> 1)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if np.dot(new_solution, weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if np.dot(new_solution, weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 2: Perform a swap operation between two items (if feasible)\n    if len(new_solution) >= 2:\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        i, j = swap_indices[0], swap_indices[1]\n\n        # Check if swapping i and j maintains feasibility\n        current_weight = np.dot(new_solution, weight_lst)\n        if (new_solution[i] == 1 and new_solution[j] == 0 and\n            current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        elif (new_solution[i] == 0 and new_solution[j] == 1 and\n              current_weight + weight_lst[i] - weight_lst[j] <= capacity):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 209,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    # Here, we select a solution with high combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by performing a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a few items to introduce diversity\n    num_flips = min(3, len(new_solution))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedily add items that improve both objectives\n    for _ in range(3):  # Perform a few greedy steps\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) == 0:\n            break\n\n        # Evaluate potential additions\n        potential_additions = []\n        for idx in candidate_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate the improvement in both objectives\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                potential_additions.append((idx, improvement1, improvement2))\n\n        if not potential_additions:\n            break\n\n        # Select the item that improves both objectives the most\n        best_idx, _, _ = max(potential_additions, key=lambda x: (x[1] + x[2]))\n        new_solution[best_idx] = 1\n        current_weight += weight_lst[best_idx]\n\n    # Step 3: Greedily remove items that don't contribute to both objectives\n    for _ in range(2):  # Perform a few greedy steps\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            break\n\n        # Evaluate potential removals\n        potential_removals = []\n        for idx in candidate_indices:\n            # Calculate the loss in both objectives if we remove this item\n            loss1 = value1_lst[idx]\n            loss2 = value2_lst[idx]\n            potential_removals.append((idx, loss1, loss2))\n\n        if not potential_removals:\n            break\n\n        # Select the item that contributes the least to both objectives\n        worst_idx, _, _ = min(potential_removals, key=lambda x: (x[1] + x[2]))\n        new_solution[worst_idx] = 0\n        current_weight -= weight_lst[worst_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4972468089852111,
            1.8738190829753876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution from the archive\n    # Here, we select a solution with high combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    combined_scores = [sum(obj) for obj in archive_objectives]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by performing a hybrid local search\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a few items to introduce diversity\n    num_flips = min(3, len(new_solution))\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedily add items that improve both objectives\n    for _ in range(3):  # Perform a few greedy steps\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) == 0:\n            break\n\n        # Evaluate potential additions\n        potential_additions = []\n        for idx in candidate_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate the improvement in both objectives\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                potential_additions.append((idx, improvement1, improvement2))\n\n        if not potential_additions:\n            break\n\n        # Select the item that improves both objectives the most\n        best_idx, _, _ = max(potential_additions, key=lambda x: (x[1] + x[2]))\n        new_solution[best_idx] = 1\n        current_weight += weight_lst[best_idx]\n\n    # Step 3: Greedily remove items that don't contribute to both objectives\n    for _ in range(2):  # Perform a few greedy steps\n        candidate_indices = np.where(new_solution == 1)[0]\n        if len(candidate_indices) == 0:\n            break\n\n        # Evaluate potential removals\n        potential_removals = []\n        for idx in candidate_indices:\n            # Calculate the loss in both objectives if we remove this item\n            loss1 = value1_lst[idx]\n            loss2 = value2_lst[idx]\n            potential_removals.append((idx, loss1, loss2))\n\n        if not potential_removals:\n            break\n\n        # Select the item that contributes the least to both objectives\n        worst_idx, _, _ = min(potential_removals, key=lambda x: (x[1] + x[2]))\n        new_solution[worst_idx] = 0\n        current_weight -= weight_lst[worst_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 210,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with higher combined objective values\n        objectives = np.array([obj for _, obj in archive])\n        scores = objectives[:, 0] + objectives[:, 1]\n        probabilities = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Phase 1: Random bit flips with feasibility check\n    for _ in range(min(3, len(new_solution))):  # Limit the number of flips to prevent excessive changes\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try adding the item\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Phase 2: Greedy improvement for both objectives\n    # Calculate current total weights and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Try to improve by flipping items that offer the best marginal gain\n    for _ in range(2):  # Limit the number of improvements\n        best_improvement = -1\n        best_idx = -1\n        best_obj = None\n\n        for idx in range(len(new_solution)):\n            if new_solution[idx] == 1:\n                # Evaluate removing the item\n                new_weight = current_weight - weight_lst[idx]\n                if new_weight <= capacity:\n                    # Calculate marginal gains\n                    gain1 = current_value1 - value1_lst[idx]\n                    gain2 = current_value2 - value2_lst[idx]\n                    # Use a simple weighted sum to evaluate improvement\n                    improvement = gain1 + gain2\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_idx = idx\n                        best_obj = (gain1, gain2)\n            else:\n                # Evaluate adding the item\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    # Calculate marginal gains\n                    gain1 = current_value1 + value1_lst[idx]\n                    gain2 = current_value2 + value2_lst[idx]\n                    # Use a simple weighted sum to evaluate improvement\n                    improvement = gain1 + gain2\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_idx = idx\n                        best_obj = (gain1, gain2)\n\n        if best_idx != -1:\n            new_solution[best_idx] = 1 - new_solution[best_idx]\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            current_value1 = np.sum(value1_lst[new_solution == 1])\n            current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    return new_solution\n\n",
        "score": [
            -0.35961354384072597,
            5.798631936311722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 1:\n        base_solution = archive[0][0].copy()\n    else:\n        # Prioritize solutions with higher combined objective values\n        objectives = np.array([obj for _, obj in archive])\n        scores = objectives[:, 0] + objectives[:, 1]\n        probabilities = scores / np.sum(scores)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    # Phase 1: Random bit flips with feasibility check\n    for _ in range(min(3, len(new_solution))):  # Limit the number of flips to prevent excessive changes\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try adding the item\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Phase 2: Greedy improvement for both objectives\n    # Calculate current total weights and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Try to improve by flipping items that offer the best marginal gain\n    for _ in range(2):  # Limit the number of improvements\n        best_improvement = -1\n        best_idx = -1\n        best_obj = None\n\n        for idx in range(len(new_solution)):\n            if new_solution[idx] == 1:\n                # Evaluate removing the item\n                new_weight = current_weight - weight_lst[idx]\n                if new_weight <= capacity:\n                    # Calculate marginal gains\n                    gain1 = current_value1 - value1_lst[idx]\n                    gain2 = current_value2 - value2_lst[idx]\n                    # Use a simple weighted sum to evaluate improvement\n                    improvement = gain1 + gain2\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_idx = idx\n                        best_obj = (gain1, gain2)\n            else:\n                # Evaluate adding the item\n                new_weight = current_weight + weight_lst[idx]\n                if new_weight <= capacity:\n                    # Calculate marginal gains\n                    gain1 = current_value1 + value1_lst[idx]\n                    gain2 = current_value2 + value2_lst[idx]\n                    # Use a simple weighted sum to evaluate improvement\n                    improvement = gain1 + gain2\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_idx = idx\n                        best_obj = (gain1, gain2)\n\n        if best_idx != -1:\n            new_solution[best_idx] = 1 - new_solution[best_idx]\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            current_value1 = np.sum(value1_lst[new_solution == 1])\n            current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 211,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    # Prioritize solutions that are not too close to the capacity and have high values\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity * 0.9:  # Avoid solutions near capacity\n            candidates.append((sol, v1 + v2, total_weight))\n\n    if not candidates:\n        # Fallback: select any solution if no candidates meet the criteria\n        candidates = [(sol, v1 + v2, np.sum(weight_lst * sol)) for sol, (v1, v2) in archive]\n\n    # Select the candidate with the highest combined value\n    base_solution, _, current_weight = max(candidates, key=lambda x: x[1])\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Random item swaps with weight-based filtering\n    for _ in range(3):  # Number of attempts\n        i, j = np.random.choice(n_items, 2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Swap items if feasible\n            if (new_solution[i] == 1 and new_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            elif (new_solution[i] == 0 and new_solution[j] == 1 and\n                  current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[j] + weight_lst[i]\n\n    # Strategy 2: Add or remove items based on value density\n    # Calculate value densities for both objectives\n    density1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    density2 = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high value density in either objective\n    high_density_items = np.where((density1 > np.percentile(density1, 75)) |\n                                 (density2 > np.percentile(density2, 75)))[0]\n\n    if len(high_density_items) > 0:\n        # Try to add a high-density item if there's space\n        available_items = np.where(new_solution == 0)[0]\n        high_density_available = np.intersect1d(high_density_items, available_items)\n\n        if len(high_density_available) > 0:\n            item = np.random.choice(high_density_available)\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Strategy 3: Remove low-value items to make space\n    if current_weight > capacity * 0.9:  # If close to capacity\n        low_value_items = np.where(new_solution == 1)[0]\n        if len(low_value_items) > 0:\n            # Remove the item with the lowest combined value density\n            item_densities = density1 + density2\n            item_to_remove = low_value_items[np.argmin(item_densities[low_value_items])]\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.3761554847951874,
            6.913170218467712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution with high potential for improvement\n    # Prioritize solutions that are not too close to the capacity and have high values\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity * 0.9:  # Avoid solutions near capacity\n            candidates.append((sol, v1 + v2, total_weight))\n\n    if not candidates:\n        # Fallback: select any solution if no candidates meet the criteria\n        candidates = [(sol, v1 + v2, np.sum(weight_lst * sol)) for sol, (v1, v2) in archive]\n\n    # Select the candidate with the highest combined value\n    base_solution, _, current_weight = max(candidates, key=lambda x: x[1])\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Random item swaps with weight-based filtering\n    for _ in range(3):  # Number of attempts\n        i, j = np.random.choice(n_items, 2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Swap items if feasible\n            if (new_solution[i] == 1 and new_solution[j] == 0 and\n                current_weight - weight_lst[i] + weight_lst[j] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[i] + weight_lst[j]\n            elif (new_solution[i] == 0 and new_solution[j] == 1 and\n                  current_weight - weight_lst[j] + weight_lst[i] <= capacity):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = current_weight - weight_lst[j] + weight_lst[i]\n\n    # Strategy 2: Add or remove items based on value density\n    # Calculate value densities for both objectives\n    density1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    density2 = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high value density in either objective\n    high_density_items = np.where((density1 > np.percentile(density1, 75)) |\n                                 (density2 > np.percentile(density2, 75)))[0]\n\n    if len(high_density_items) > 0:\n        # Try to add a high-density item if there's space\n        available_items = np.where(new_solution == 0)[0]\n        high_density_available = np.intersect1d(high_density_items, available_items)\n\n        if len(high_density_available) > 0:\n            item = np.random.choice(high_density_available)\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    # Strategy 3: Remove low-value items to make space\n    if current_weight > capacity * 0.9:  # If close to capacity\n        low_value_items = np.where(new_solution == 1)[0]\n        if len(low_value_items) > 0:\n            # Remove the item with the lowest combined value density\n            item_densities = density1 + density2\n            item_to_remove = low_value_items[np.argmin(item_densities[low_value_items])]\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 212,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if 0.2 * capacity <= total_weight <= 0.8 * capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Calculate marginal utility ratios for each item\n    marginal_ratios1 = value1_lst / (weight_lst + 1e-10)\n    marginal_ratios2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratios = marginal_ratios1 + marginal_ratios2\n\n    # Identify items not in the current solution with high combined marginal utility\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) == 0:\n        return new_solution  # No items to add\n\n    # Prioritize items with high combined marginal utility\n    top_items = candidate_items[np.argsort(combined_ratios[candidate_items])[-min(5, len(candidate_items)):]]\n\n    # Try adding one of the top items\n    for item in top_items:\n        if np.sum(weight_lst * new_solution) + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            break\n\n    # If no addition was possible, try removing low-utility items\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            return new_solution  # No items to remove\n\n        # Remove items with the lowest combined marginal utility\n        bottom_items = candidate_items[np.argsort(combined_ratios[candidate_items])[:min(3, len(candidate_items))]]\n        for item in bottom_items:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            if np.sum(weight_lst * temp_solution) <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8772872539429637,
            2.151311933994293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if 0.2 * capacity <= total_weight <= 0.8 * capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n\n    # Step 2: Generate a neighbor using a hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Calculate marginal utility ratios for each item\n    marginal_ratios1 = value1_lst / (weight_lst + 1e-10)\n    marginal_ratios2 = value2_lst / (weight_lst + 1e-10)\n    combined_ratios = marginal_ratios1 + marginal_ratios2\n\n    # Identify items not in the current solution with high combined marginal utility\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) == 0:\n        return new_solution  # No items to add\n\n    # Prioritize items with high combined marginal utility\n    top_items = candidate_items[np.argsort(combined_ratios[candidate_items])[-min(5, len(candidate_items)):]]\n\n    # Try adding one of the top items\n    for item in top_items:\n        if np.sum(weight_lst * new_solution) + weight_lst[item] <= capacity:\n            new_solution[item] = 1\n            break\n\n    # If no addition was possible, try removing low-utility items\n    if np.array_equal(new_solution, base_solution):\n        candidate_items = np.where(new_solution == 1)[0]\n        if len(candidate_items) == 0:\n            return new_solution  # No items to remove\n\n        # Remove items with the lowest combined marginal utility\n        bottom_items = candidate_items[np.argsort(combined_ratios[candidate_items])[:min(3, len(candidate_items))]]\n        for item in bottom_items:\n            temp_solution = new_solution.copy()\n            temp_solution[item] = 0\n            if np.sum(weight_lst * temp_solution) <= capacity:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 213,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    selected = random.choices(\n        archive,\n        weights=[(1 - (obj[0] / (np.sum(value1_lst) + 1e-6)) + 1 - (obj[1] / (np.sum(value2_lst) + 1e-6))) for _, obj in archive],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected.copy()\n    current_weight = np.sum(weight_lst[selected == 1])\n\n    # Hybrid local search: flip a random item if it improves both objectives\n    for _ in range(min(10, len(new_solution))):\n        item_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding the item if it improves both objectives\n            if current_weight + weight_lst[item_idx] <= capacity:\n                # Calculate potential improvement in both objectives\n                delta1 = value1_lst[item_idx]\n                delta2 = value2_lst[item_idx]\n                if delta1 > 0 and delta2 > 0:\n                    new_solution[item_idx] = 1\n                    current_weight += weight_lst[item_idx]\n\n    # Additional greedy step: add items with highest combined value density\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value density for each item (combined for both objectives)\n        value_density = (value1_lst + value2_lst) / weight_lst\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value_density[candidate_items])]\n            if value_density[best_item] > 0:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3695437820953668,
            2.144276797771454
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    selected = random.choices(\n        archive,\n        weights=[(1 - (obj[0] / (np.sum(value1_lst) + 1e-6)) + 1 - (obj[1] / (np.sum(value2_lst) + 1e-6))) for _, obj in archive],\n        k=1\n    )[0][0].copy()\n\n    new_solution = selected.copy()\n    current_weight = np.sum(weight_lst[selected == 1])\n\n    # Hybrid local search: flip a random item if it improves both objectives\n    for _ in range(min(10, len(new_solution))):\n        item_idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[item_idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item_idx] <= capacity:\n                new_solution[item_idx] = 0\n                current_weight -= weight_lst[item_idx]\n        else:\n            # Try adding the item if it improves both objectives\n            if current_weight + weight_lst[item_idx] <= capacity:\n                # Calculate potential improvement in both objectives\n                delta1 = value1_lst[item_idx]\n                delta2 = value2_lst[item_idx]\n                if delta1 > 0 and delta2 > 0:\n                    new_solution[item_idx] = 1\n                    current_weight += weight_lst[item_idx]\n\n    # Additional greedy step: add items with highest combined value density\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value density for each item (combined for both objectives)\n        value_density = (value1_lst + value2_lst) / weight_lst\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n        if len(candidate_items) > 0:\n            best_item = candidate_items[np.argmax(value_density[candidate_items])]\n            if value_density[best_item] > 0:\n                new_solution[best_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 214,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive with a bias towards higher objective values\n    if len(archive) > 1:\n        # Normalize objectives to create a selection probability distribution\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives - objectives.min(axis=0)\n        normalized = normalized / (normalized.max(axis=0) + 1e-10)  # Avoid division by zero\n        scores = normalized.mean(axis=1)  # Combine objectives\n        probs = scores / scores.sum()\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps followed by greedy improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swaps to explore neighborhood\n    for _ in range(min(10, n_items)):  # Limit swaps to prevent excessive computation\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Try swapping items i and j\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = current_weight + (weight_lst[j] - weight_lst[i]) * (temp_solution[j] - temp_solution[i])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Greedy improvement step: flip items to improve both objectives\n    for _ in range(min(5, n_items)):  # Limit flips to prevent excessive computation\n        # Calculate marginal gains for both objectives\n        included = new_solution == 1\n        excluded = new_solution == 0\n\n        # Calculate marginal gains for each item\n        marginal1 = value1_lst - (value1_lst * included + value1_lst * excluded)\n        marginal2 = value2_lst - (value2_lst * included + value2_lst * excluded)\n        marginal_weight = weight_lst - (weight_lst * included + weight_lst * excluded)\n\n        # Combine objectives and select best flip\n        combined_marginal = marginal1 + marginal2\n        valid_indices = np.where((marginal_weight <= (capacity - current_weight)) | (included & (marginal_weight <= 0)))[0]\n\n        if len(valid_indices) > 0:\n            best_idx = valid_indices[np.argmax(combined_marginal[valid_indices])]\n            if combined_marginal[best_idx] > 0:\n                new_solution[best_idx] = 1 - new_solution[best_idx]\n                current_weight += marginal_weight[best_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.5006446460370648,
            4.5308191776275635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a random solution from the archive with a bias towards higher objective values\n    if len(archive) > 1:\n        # Normalize objectives to create a selection probability distribution\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives - objectives.min(axis=0)\n        normalized = normalized / (normalized.max(axis=0) + 1e-10)  # Avoid division by zero\n        scores = normalized.mean(axis=1)  # Combine objectives\n        probs = scores / scores.sum()\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random swaps followed by greedy improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Random swaps to explore neighborhood\n    for _ in range(min(10, n_items)):  # Limit swaps to prevent excessive computation\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Try swapping items i and j\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n            temp_weight = current_weight + (weight_lst[j] - weight_lst[i]) * (temp_solution[j] - temp_solution[i])\n\n            if temp_weight <= capacity:\n                new_solution = temp_solution\n                current_weight = temp_weight\n\n    # Greedy improvement step: flip items to improve both objectives\n    for _ in range(min(5, n_items)):  # Limit flips to prevent excessive computation\n        # Calculate marginal gains for both objectives\n        included = new_solution == 1\n        excluded = new_solution == 0\n\n        # Calculate marginal gains for each item\n        marginal1 = value1_lst - (value1_lst * included + value1_lst * excluded)\n        marginal2 = value2_lst - (value2_lst * included + value2_lst * excluded)\n        marginal_weight = weight_lst - (weight_lst * included + weight_lst * excluded)\n\n        # Combine objectives and select best flip\n        combined_marginal = marginal1 + marginal2\n        valid_indices = np.where((marginal_weight <= (capacity - current_weight)) | (included & (marginal_weight <= 0)))[0]\n\n        if len(valid_indices) > 0:\n            best_idx = valid_indices[np.argmax(combined_marginal[valid_indices])]\n            if combined_marginal[best_idx] > 0:\n                new_solution[best_idx] = 1 - new_solution[best_idx]\n                current_weight += marginal_weight[best_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 215,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Perform a series of random swaps to generate a neighbor\n    num_swaps = min(3, len(new_solution) // 2)  # Limit the number of swaps to avoid excessive changes\n    for _ in range(num_swaps):\n        # Randomly select two distinct items\n        i, j = random.sample(range(len(new_solution)), 2)\n        # Swap their inclusion status\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible by removing the heaviest items if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Identify items that are in the solution and sort by weight-to-value ratio\n        included_items = np.where(new_solution == 1)[0]\n        # Sort by the sum of the two objective values per unit weight (greedy removal)\n        value_per_weight = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        sorted_indices = np.argsort(value_per_weight)\n        # Remove items until the solution is feasible\n        for idx in sorted_indices:\n            if total_weight <= capacity:\n                break\n            item_idx = included_items[idx]\n            new_solution[item_idx] = 0\n            total_weight -= weight_lst[item_idx]\n\n    # Perform a greedy improvement step to enhance the solution\n    # Calculate the current total values and weight\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Try to add items that are not in the solution but can improve at least one objective\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            # Calculate the potential improvement in both objectives\n            new_value1 = current_value1 + value1_lst[i]\n            new_value2 = current_value2 + value2_lst[i]\n            # Check if at least one objective improves\n            if (new_value1 > current_value1) or (new_value2 > current_value2):\n                new_solution[i] = 1\n                current_value1 = new_value1\n                current_value2 = new_value2\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.40812707740449283,
            1.426147311925888
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Perform a series of random swaps to generate a neighbor\n    num_swaps = min(3, len(new_solution) // 2)  # Limit the number of swaps to avoid excessive changes\n    for _ in range(num_swaps):\n        # Randomly select two distinct items\n        i, j = random.sample(range(len(new_solution)), 2)\n        # Swap their inclusion status\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible by removing the heaviest items if necessary\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Identify items that are in the solution and sort by weight-to-value ratio\n        included_items = np.where(new_solution == 1)[0]\n        # Sort by the sum of the two objective values per unit weight (greedy removal)\n        value_per_weight = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n        sorted_indices = np.argsort(value_per_weight)\n        # Remove items until the solution is feasible\n        for idx in sorted_indices:\n            if total_weight <= capacity:\n                break\n            item_idx = included_items[idx]\n            new_solution[item_idx] = 0\n            total_weight -= weight_lst[item_idx]\n\n    # Perform a greedy improvement step to enhance the solution\n    # Calculate the current total values and weight\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Try to add items that are not in the solution but can improve at least one objective\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            # Calculate the potential improvement in both objectives\n            new_value1 = current_value1 + value1_lst[i]\n            new_value2 = current_value2 + value2_lst[i]\n            # Check if at least one objective improves\n            if (new_value1 > current_value1) or (new_value2 > current_value2):\n                new_solution[i] = 1\n                current_value1 = new_value1\n                current_value2 = new_value2\n                current_weight += weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 216,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its Pareto front rank (simplified here)\n    # In practice, you'd use a proper Pareto front ranking mechanism\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (with bias towards low-weight/high-value items)\n    n_items = len(weight_lst)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    # 2. For each selected item, decide to flip based on a heuristic:\n    #    - Flip if it's currently excluded and adding it doesn't exceed capacity\n    #    - Flip if it's currently included and removing it improves at least one objective\n    for idx in flip_indices:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[idx] == 0:  # Currently excluded\n            if current_weight + weight_lst[idx] <= capacity:\n                # Add item if it improves at least one objective significantly\n                if (value1_lst[idx] > 0.1 * current_obj1) or (value2_lst[idx] > 0.1 * current_obj2):\n                    new_solution[idx] = 1\n        else:  # Currently included\n            # Remove item if it's not significantly contributing to both objectives\n            if (value1_lst[idx] < 0.1 * current_obj1) and (value2_lst[idx] < 0.1 * current_obj2):\n                new_solution[idx] = 0\n\n    # 3. Additional random swap to explore neighborhood\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check if swap maintains feasibility\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] - weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5617679181717553,
            1.3200847208499908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its Pareto front rank (simplified here)\n    # In practice, you'd use a proper Pareto front ranking mechanism\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (with bias towards low-weight/high-value items)\n    n_items = len(weight_lst)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n\n    # 2. For each selected item, decide to flip based on a heuristic:\n    #    - Flip if it's currently excluded and adding it doesn't exceed capacity\n    #    - Flip if it's currently included and removing it improves at least one objective\n    for idx in flip_indices:\n        current_weight = np.sum(weight_lst[new_solution == 1])\n        if new_solution[idx] == 0:  # Currently excluded\n            if current_weight + weight_lst[idx] <= capacity:\n                # Add item if it improves at least one objective significantly\n                if (value1_lst[idx] > 0.1 * current_obj1) or (value2_lst[idx] > 0.1 * current_obj2):\n                    new_solution[idx] = 1\n        else:  # Currently included\n            # Remove item if it's not significantly contributing to both objectives\n            if (value1_lst[idx] < 0.1 * current_obj1) and (value2_lst[idx] < 0.1 * current_obj2):\n                new_solution[idx] = 0\n\n    # 3. Additional random swap to explore neighborhood\n    if n_items > 1:\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            # Check if swap maintains feasibility\n            if new_solution[i] == 1 and new_solution[j] == 0:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[j] - weight_lst[i] <= capacity:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 217,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher combined values\n    values = np.array([sum(obj) for _, obj in archive])\n    probabilities = values / np.sum(values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine the type of local search to apply\n    search_type = random.choices(\n        [\"random_flip\", \"value_flip\", \"weight_flip\"],\n        weights=[0.4, 0.3, 0.3],\n        k=1\n    )[0]\n\n    if search_type == \"random_flip\":\n        # Randomly flip a small number of items\n        num_flips = min(3, len(new_solution))\n        flip_indices = np.random.choice(len(new_solution), num_flips, replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    elif search_type == \"value_flip\":\n        # Flip items with the highest value ratios (value/weight)\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_ratio)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    elif search_type == \"weight_flip\":\n        # Flip items with the smallest weights first\n        sorted_indices = np.argsort(weight_lst)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3130623187816727,
            2.208333045244217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher combined values\n    values = np.array([sum(obj) for _, obj in archive])\n    probabilities = values / np.sum(values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine the type of local search to apply\n    search_type = random.choices(\n        [\"random_flip\", \"value_flip\", \"weight_flip\"],\n        weights=[0.4, 0.3, 0.3],\n        k=1\n    )[0]\n\n    if search_type == \"random_flip\":\n        # Randomly flip a small number of items\n        num_flips = min(3, len(new_solution))\n        flip_indices = np.random.choice(len(new_solution), num_flips, replace=False)\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    elif search_type == \"value_flip\":\n        # Flip items with the highest value ratios (value/weight)\n        value_ratio = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_ratio)[::-1]\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    elif search_type == \"weight_flip\":\n        # Flip items with the smallest weights first\n        sorted_indices = np.argsort(weight_lst)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] >= 0:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 218,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a higher probability if it has potential for improvement\n    # Here, we consider solutions that are not on the extreme Pareto front\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the crowding distance to identify solutions with potential for improvement\n    crowding_distances = np.zeros(len(archive))\n    sorted_obj1 = sorted(archive_objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(archive_objectives, key=lambda x: x[1])\n\n    for i in range(len(archive)):\n        # Find neighbors in the objective space\n        idx_obj1 = [j for j, obj in enumerate(sorted_obj1) if obj == archive_objectives[i]]\n        idx_obj2 = [j for j, obj in enumerate(sorted_obj2) if obj == archive_objectives[i]]\n\n        if len(idx_obj1) > 1:\n            left_obj1 = idx_obj1[idx_obj1.index(i) - 1] if idx_obj1.index(i) > 0 else idx_obj1[0]\n            right_obj1 = idx_obj1[idx_obj1.index(i) + 1] if idx_obj1.index(i) < len(idx_obj1) - 1 else idx_obj1[-1]\n            crowding_distances[i] += (sorted_obj1[right_obj1][0] - sorted_obj1[left_obj1][0]) / (sorted_obj1[-1][0] - sorted_obj1[0][0])\n\n        if len(idx_obj2) > 1:\n            left_obj2 = idx_obj2[idx_obj2.index(i) - 1] if idx_obj2.index(i) > 0 else idx_obj2[0]\n            right_obj2 = idx_obj2[idx_obj2.index(i) + 1] if idx_obj2.index(i) < len(idx_obj2) - 1 else idx_obj2[-1]\n            crowding_distances[i] += (sorted_obj2[right_obj2][1] - sorted_obj2[left_obj2][1]) / (sorted_obj2[-1][1] - sorted_obj2[0][1])\n\n    # Select a solution with high crowding distance (more potential for improvement)\n    if np.max(crowding_distances) > 0:\n        selection_probs = crowding_distances / np.sum(crowding_distances)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_contributions = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # For items in the solution, calculate the reduction in value if removed\n            marginal_value1 = -value1_lst[i]\n            marginal_value2 = -value2_lst[i]\n            marginal_weight = -weight_lst[i]\n        else:\n            # For items not in the solution, calculate the increase in value if added\n            marginal_value1 = value1_lst[i]\n            marginal_value2 = value2_lst[i]\n            marginal_weight = weight_lst[i]\n\n        # Check feasibility\n        if current_weight + marginal_weight <= capacity:\n            marginal_contributions.append((i, marginal_value1, marginal_value2, marginal_weight))\n        else:\n            marginal_contributions.append((i, -np.inf, -np.inf, marginal_weight))\n\n    # Sort items by their combined marginal contribution (weighted sum of both objectives)\n    # Here, we use a random weight to balance both objectives\n    weight_obj1 = random.random()\n    weight_obj2 = 1 - weight_obj1\n    marginal_contributions.sort(key=lambda x: -(weight_obj1 * x[1] + weight_obj2 * x[2]), reverse=True)\n\n    # Select top k items to flip (here, k=3)\n    k = min(3, len(marginal_contributions))\n    selected_items = [item[0] for item in marginal_contributions[:k]]\n\n    # Flip the selected items\n    for i in selected_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing the least valuable items if necessary\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Calculate the value density for each item (value per unit weight)\n        value_density1 = value1_lst / weight_lst\n        value_density2 = value2_lst / weight_lst\n\n        # Randomly choose between the two objectives to prioritize\n        if random.random() < 0.5:\n            # Prioritize value1\n            items_sorted = np.argsort(-value_density1)\n        else:\n            # Prioritize value2\n            items_sorted = np.argsort(-value_density2)\n\n        # Remove items until feasible\n        for i in items_sorted:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                new_weight -= weight_lst[i]\n                if new_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8327330867334642,
            3.7121779918670654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a higher probability if it has potential for improvement\n    # Here, we consider solutions that are not on the extreme Pareto front\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the crowding distance to identify solutions with potential for improvement\n    crowding_distances = np.zeros(len(archive))\n    sorted_obj1 = sorted(archive_objectives, key=lambda x: x[0])\n    sorted_obj2 = sorted(archive_objectives, key=lambda x: x[1])\n\n    for i in range(len(archive)):\n        # Find neighbors in the objective space\n        idx_obj1 = [j for j, obj in enumerate(sorted_obj1) if obj == archive_objectives[i]]\n        idx_obj2 = [j for j, obj in enumerate(sorted_obj2) if obj == archive_objectives[i]]\n\n        if len(idx_obj1) > 1:\n            left_obj1 = idx_obj1[idx_obj1.index(i) - 1] if idx_obj1.index(i) > 0 else idx_obj1[0]\n            right_obj1 = idx_obj1[idx_obj1.index(i) + 1] if idx_obj1.index(i) < len(idx_obj1) - 1 else idx_obj1[-1]\n            crowding_distances[i] += (sorted_obj1[right_obj1][0] - sorted_obj1[left_obj1][0]) / (sorted_obj1[-1][0] - sorted_obj1[0][0])\n\n        if len(idx_obj2) > 1:\n            left_obj2 = idx_obj2[idx_obj2.index(i) - 1] if idx_obj2.index(i) > 0 else idx_obj2[0]\n            right_obj2 = idx_obj2[idx_obj2.index(i) + 1] if idx_obj2.index(i) < len(idx_obj2) - 1 else idx_obj2[-1]\n            crowding_distances[i] += (sorted_obj2[right_obj2][1] - sorted_obj2[left_obj2][1]) / (sorted_obj2[-1][1] - sorted_obj2[0][1])\n\n    # Select a solution with high crowding distance (more potential for improvement)\n    if np.max(crowding_distances) > 0:\n        selection_probs = crowding_distances / np.sum(crowding_distances)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Calculate marginal contributions for each item\n    marginal_contributions = []\n    for i in range(len(base_solution)):\n        if base_solution[i] == 1:\n            # For items in the solution, calculate the reduction in value if removed\n            marginal_value1 = -value1_lst[i]\n            marginal_value2 = -value2_lst[i]\n            marginal_weight = -weight_lst[i]\n        else:\n            # For items not in the solution, calculate the increase in value if added\n            marginal_value1 = value1_lst[i]\n            marginal_value2 = value2_lst[i]\n            marginal_weight = weight_lst[i]\n\n        # Check feasibility\n        if current_weight + marginal_weight <= capacity:\n            marginal_contributions.append((i, marginal_value1, marginal_value2, marginal_weight))\n        else:\n            marginal_contributions.append((i, -np.inf, -np.inf, marginal_weight))\n\n    # Sort items by their combined marginal contribution (weighted sum of both objectives)\n    # Here, we use a random weight to balance both objectives\n    weight_obj1 = random.random()\n    weight_obj2 = 1 - weight_obj1\n    marginal_contributions.sort(key=lambda x: -(weight_obj1 * x[1] + weight_obj2 * x[2]), reverse=True)\n\n    # Select top k items to flip (here, k=3)\n    k = min(3, len(marginal_contributions))\n    selected_items = [item[0] for item in marginal_contributions[:k]]\n\n    # Flip the selected items\n    for i in selected_items:\n        new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility by removing the least valuable items if necessary\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Calculate the value density for each item (value per unit weight)\n        value_density1 = value1_lst / weight_lst\n        value_density2 = value2_lst / weight_lst\n\n        # Randomly choose between the two objectives to prioritize\n        if random.random() < 0.5:\n            # Prioritize value1\n            items_sorted = np.argsort(-value_density1)\n        else:\n            # Prioritize value2\n            items_sorted = np.argsort(-value_density2)\n\n        # Remove items until feasible\n        for i in items_sorted:\n            if new_solution[i] == 1:\n                new_solution[i] = 0\n                new_weight -= weight_lst[i]\n                if new_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 219,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to consider for swaps (items not in the solution)\n    candidate_items = np.where(new_solution == 0)[0]\n\n    # Hybrid local search: Randomly select a subset of items to swap\n    if len(candidate_items) > 0:\n        num_swaps = min(3, len(candidate_items))  # Limit the number of swaps\n        swap_indices = np.random.choice(candidate_items, num_swaps, replace=False)\n\n        for item in swap_indices:\n            # Check if adding this item would exceed capacity\n            if current_weight + weight_lst[item] <= capacity:\n                # Calculate potential improvement in both objectives\n                delta_value1 = value1_lst[item]\n                delta_value2 = value2_lst[item]\n\n                # If both objectives improve, accept the swap\n                if delta_value1 > 0 and delta_value2 > 0:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 += delta_value1\n                    current_value2 += delta_value2\n\n    # Additional local search: Randomly remove items to free up capacity for better items\n    if current_weight > 0:\n        # Identify items to consider for removal\n        removable_items = np.where(new_solution == 1)[0]\n        if len(removable_items) > 0:\n            num_removals = min(2, len(removable_items))\n            remove_indices = np.random.choice(removable_items, num_removals, replace=False)\n\n            for item in remove_indices:\n                # Remove the item and update the solution\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.8738188499346746,
            1.3300924003124237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution from the archive\n    idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items to consider for swaps (items not in the solution)\n    candidate_items = np.where(new_solution == 0)[0]\n\n    # Hybrid local search: Randomly select a subset of items to swap\n    if len(candidate_items) > 0:\n        num_swaps = min(3, len(candidate_items))  # Limit the number of swaps\n        swap_indices = np.random.choice(candidate_items, num_swaps, replace=False)\n\n        for item in swap_indices:\n            # Check if adding this item would exceed capacity\n            if current_weight + weight_lst[item] <= capacity:\n                # Calculate potential improvement in both objectives\n                delta_value1 = value1_lst[item]\n                delta_value2 = value2_lst[item]\n\n                # If both objectives improve, accept the swap\n                if delta_value1 > 0 and delta_value2 > 0:\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n                    current_value1 += delta_value1\n                    current_value2 += delta_value2\n\n    # Additional local search: Randomly remove items to free up capacity for better items\n    if current_weight > 0:\n        # Identify items to consider for removal\n        removable_items = np.where(new_solution == 1)[0]\n        if len(removable_items) > 0:\n            num_removals = min(2, len(removable_items))\n            remove_indices = np.random.choice(removable_items, num_removals, replace=False)\n\n            for item in remove_indices:\n                # Remove the item and update the solution\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 220,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances to identify less crowded solutions\n        crowding_distances = []\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        for i in range(len(sorted_solutions)):\n            if i == 0 or i == len(sorted_solutions) - 1:\n                crowding_distances.append(float('inf'))\n            else:\n                dist1 = sorted_solutions[i+1][1][0] - sorted_solutions[i-1][1][0]\n                dist2 = sorted_solutions[i+1][1][1] - sorted_solutions[i-1][1][1]\n                crowding_distances.append(dist1 + dist2)\n        # Select solutions with lowest crowding distance (more crowded = better potential)\n        candidates = [sol for sol, dist in zip(sorted_solutions, crowding_distances) if dist != float('inf')]\n        if candidates:\n            selected = random.choice(candidates)\n        else:\n            selected = random.choice(archive)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with greedy improvement\n    # Step 1: Randomly flip a subset of items (with probability 0.3)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            idx = random.choice(items_in)\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    # Step 2: Greedy improvement - add best items that improve both objectives\n    items_out = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    improved = True\n\n    while improved and len(items_out) > 0:\n        improved = False\n        best_item = None\n        best_score = -float('inf')\n\n        for i in items_out:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight > capacity:\n                continue\n\n            # Calculate the combined improvement score (simple weighted sum)\n            delta1 = value1_lst[i]\n            delta2 = value2_lst[i]\n            score = delta1 + delta2  # Simple approach, could be enhanced\n\n            if score > best_score:\n                best_score = score\n                best_item = i\n\n        if best_item is not None:\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n            improved = True\n            items_out = np.where(new_solution == 0)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.3675783327393463,
            3.7282780706882477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distances to identify less crowded solutions\n        crowding_distances = []\n        sorted_solutions = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n        for i in range(len(sorted_solutions)):\n            if i == 0 or i == len(sorted_solutions) - 1:\n                crowding_distances.append(float('inf'))\n            else:\n                dist1 = sorted_solutions[i+1][1][0] - sorted_solutions[i-1][1][0]\n                dist2 = sorted_solutions[i+1][1][1] - sorted_solutions[i-1][1][1]\n                crowding_distances.append(dist1 + dist2)\n        # Select solutions with lowest crowding distance (more crowded = better potential)\n        candidates = [sol for sol, dist in zip(sorted_solutions, crowding_distances) if dist != float('inf')]\n        if candidates:\n            selected = random.choice(candidates)\n        else:\n            selected = random.choice(archive)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip with greedy improvement\n    # Step 1: Randomly flip a subset of items (with probability 0.3)\n    for i in range(len(new_solution)):\n        if random.random() < 0.3:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) == 0:\n                break\n            idx = random.choice(items_in)\n            new_solution[idx] = 0\n            total_weight -= weight_lst[idx]\n\n    # Step 2: Greedy improvement - add best items that improve both objectives\n    items_out = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    improved = True\n\n    while improved and len(items_out) > 0:\n        improved = False\n        best_item = None\n        best_score = -float('inf')\n\n        for i in items_out:\n            new_weight = current_weight + weight_lst[i]\n            if new_weight > capacity:\n                continue\n\n            # Calculate the combined improvement score (simple weighted sum)\n            delta1 = value1_lst[i]\n            delta2 = value2_lst[i]\n            score = delta1 + delta2  # Simple approach, could be enhanced\n\n            if score > best_score:\n                best_score = score\n                best_item = i\n\n        if best_item is not None:\n            new_solution[best_item] = 1\n            current_weight += weight_lst[best_item]\n            improved = True\n            items_out = np.where(new_solution == 0)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 221,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Compute a score for each solution based on its objective values (normalized)\n    scores = []\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        normalized_score = (obj[0] / max_value1 + obj[1] / max_value2) / 2\n        scores.append(normalized_score)\n\n    # Select a solution with probability proportional to its score\n    selected_idx = random.choices(range(len(archive)), weights=scores, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by flipping a subset of items\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove the item if it's in the solution\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Apply a greedy improvement step: flip items that improve both objectives\n    for idx in range(n_items):\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                delta_value1 = -value1_lst[idx]\n                delta_value2 = -value2_lst[idx]\n                # Check if the removal improves both objectives\n                if delta_value1 >= 0 and delta_value2 >= 0:\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                delta_value1 = value1_lst[idx]\n                delta_value2 = value2_lst[idx]\n                # Check if the addition improves both objectives\n                if delta_value1 >= 0 and delta_value2 >= 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.38275469633285947,
            3.3892925679683685
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Compute a score for each solution based on its objective values (normalized)\n    scores = []\n    max_value1 = max(obj[0] for _, obj in archive)\n    max_value2 = max(obj[1] for _, obj in archive)\n    for sol, obj in archive:\n        normalized_score = (obj[0] / max_value1 + obj[1] / max_value2) / 2\n        scores.append(normalized_score)\n\n    # Select a solution with probability proportional to its score\n    selected_idx = random.choices(range(len(archive)), weights=scores, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Generate a neighbor by flipping a subset of items\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Remove the item if it's in the solution\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n        else:\n            # Add the item if it fits\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Apply a greedy improvement step: flip items that improve both objectives\n    for idx in range(n_items):\n        if new_solution[idx] == 1:\n            # Try removing the item\n            temp_weight = current_weight - weight_lst[idx]\n            if temp_weight <= capacity:\n                delta_value1 = -value1_lst[idx]\n                delta_value2 = -value2_lst[idx]\n                # Check if the removal improves both objectives\n                if delta_value1 >= 0 and delta_value2 >= 0:\n                    new_solution[idx] = 0\n                    current_weight = temp_weight\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                delta_value1 = value1_lst[idx]\n                delta_value2 = value2_lst[idx]\n                # Check if the addition improves both objectives\n                if delta_value1 >= 0 and delta_value2 >= 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 222,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (descending)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select top 30% solutions for potential improvement\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select one from top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of flip and swap\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Flip operation: randomly flip a subset of items\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Swap operation: swap two items if feasible\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if (new_solution[i] == 1 and delta_weight <= capacity - current_weight) or \\\n               (new_solution[j] == 1 and delta_weight >= -current_weight):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest value1/value2 ratio until feasible\n        while current_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            # Calculate value-to-weight ratios\n            ratios = (value1_lst[included_indices] + value2_lst[included_indices]) / weight_lst[included_indices]\n            # Remove item with lowest ratio\n            remove_idx = included_indices[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.29432705030841366,
            1.4868872463703156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (descending)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select top 30% solutions for potential improvement\n        top_solutions = archive_sorted[:max(1, len(archive) // 3)]\n        # Randomly select one from top solutions\n        base_solution, _ = random.choice(top_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of flip and swap\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Flip operation: randomly flip a subset of items\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Swap operation: swap two items if feasible\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            delta_weight = weight_lst[j] - weight_lst[i]\n            if (new_solution[i] == 1 and delta_weight <= capacity - current_weight) or \\\n               (new_solution[j] == 1 and delta_weight >= -current_weight):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest value1/value2 ratio until feasible\n        while current_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            # Calculate value-to-weight ratios\n            ratios = (value1_lst[included_indices] + value2_lst[included_indices]) / weight_lst[included_indices]\n            # Remove item with lowest ratio\n            remove_idx = included_indices[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            current_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 223,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with a higher chance of being non-dominated\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of random perturbation and greedy improvement\n    # Step 1: Random perturbation - flip a few randomly selected items\n    perturb_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy improvement - add items with highest marginal value-to-weight ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal value-to-weight ratios for items not in the solution\n        marginal_ratio1 = value1_lst / weight_lst\n        marginal_ratio2 = value2_lst / weight_lst\n        combined_ratio = marginal_ratio1 + marginal_ratio2  # Simple combination for bi-objective\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = np.argsort(-combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Step 3: Local improvement - try to replace one item with another if beneficial\n    # Calculate current total values\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Find items in the solution\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Try to replace one item with one not in the solution\n        for out_idx in np.where(new_solution == 0)[0]:\n            if weight_lst[out_idx] <= remaining_capacity:\n                for in_idx in in_items:\n                    if weight_lst[out_idx] + current_weight - weight_lst[in_idx] <= capacity:\n                        # Calculate new values if we replace in_idx with out_idx\n                        new_value1 = current_value1 - value1_lst[in_idx] + value1_lst[out_idx]\n                        new_value2 = current_value2 - value2_lst[in_idx] + value2_lst[out_idx]\n\n                        # If both values are better or at least one is better, accept the replacement\n                        if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                           (new_value1 >= current_value1 and new_value2 > current_value2):\n                            new_solution[in_idx] = 0\n                            new_solution[out_idx] = 1\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.3399459934511603,
            1.5329990684986115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with a higher chance of being non-dominated\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of random perturbation and greedy improvement\n    # Step 1: Random perturbation - flip a few randomly selected items\n    perturb_indices = np.random.choice(len(weight_lst), size=min(3, len(weight_lst)), replace=False)\n    for idx in perturb_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy improvement - add items with highest marginal value-to-weight ratio\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal value-to-weight ratios for items not in the solution\n        marginal_ratio1 = value1_lst / weight_lst\n        marginal_ratio2 = value2_lst / weight_lst\n        combined_ratio = marginal_ratio1 + marginal_ratio2  # Simple combination for bi-objective\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = np.argsort(-combined_ratio)\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n\n    # Step 3: Local improvement - try to replace one item with another if beneficial\n    # Calculate current total values\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Find items in the solution\n    in_items = np.where(new_solution == 1)[0]\n    if len(in_items) > 0:\n        # Try to replace one item with one not in the solution\n        for out_idx in np.where(new_solution == 0)[0]:\n            if weight_lst[out_idx] <= remaining_capacity:\n                for in_idx in in_items:\n                    if weight_lst[out_idx] + current_weight - weight_lst[in_idx] <= capacity:\n                        # Calculate new values if we replace in_idx with out_idx\n                        new_value1 = current_value1 - value1_lst[in_idx] + value1_lst[out_idx]\n                        new_value2 = current_value2 - value2_lst[in_idx] + value2_lst[out_idx]\n\n                        # If both values are better or at least one is better, accept the replacement\n                        if (new_value1 > current_value1 and new_value2 >= current_value2) or \\\n                           (new_value1 >= current_value1 and new_value2 > current_value2):\n                            new_solution[in_idx] = 0\n                            new_solution[out_idx] = 1\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 224,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high combined value and low crowding distance\n        values = np.array([obj[0] + obj[1] for _, obj in archive])\n        sorted_indices = np.argsort(values)[::-1]\n        top_solutions = [archive[i] for i in sorted_indices[:max(1, len(archive) // 2)]]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Random swaps (exploration)\n    for _ in range(min(3, len(base_solution))):\n        i, j = random.sample(range(len(base_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp_weight = current_weight - weight_lst[i] * new_solution[i] + weight_lst[j] * (1 - new_solution[i]) \\\n                          - weight_lst[j] * new_solution[j] + weight_lst[i] * (1 - new_solution[j])\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = temp_weight\n\n    # Step 2: Objective-specific flips (exploitation)\n    for obj in range(2):\n        if obj == 0:\n            values = value1_lst\n        else:\n            values = value2_lst\n\n        # Find items with high marginal value that can be added\n        for i in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[i] <= capacity:\n                if np.random.rand() < 0.3:  # 30% chance to add high-value item\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n        # Find items with low marginal value that can be removed\n        for i in np.where(new_solution == 1)[0]:\n            if np.random.rand() < 0.1:  # 10% chance to remove low-value item\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 3: Capacity adjustment (repair if needed)\n    while current_weight > capacity:\n        # Remove items with lowest value-to-weight ratio\n        ratios = (value1_lst + value2_lst) / weight_lst\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            worst = candidates[np.argmin(ratios[candidates])]\n            new_solution[worst] = 0\n            current_weight -= weight_lst[worst]\n\n    return new_solution\n\n",
        "score": [
            -0.39765401803631784,
            2.5068973302841187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Prioritize solutions with high combined value and low crowding distance\n        values = np.array([obj[0] + obj[1] for _, obj in archive])\n        sorted_indices = np.argsort(values)[::-1]\n        top_solutions = [archive[i] for i in sorted_indices[:max(1, len(archive) // 2)]]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Random swaps (exploration)\n    for _ in range(min(3, len(base_solution))):\n        i, j = random.sample(range(len(base_solution)), 2)\n        if new_solution[i] != new_solution[j]:\n            temp_weight = current_weight - weight_lst[i] * new_solution[i] + weight_lst[j] * (1 - new_solution[i]) \\\n                          - weight_lst[j] * new_solution[j] + weight_lst[i] * (1 - new_solution[j])\n            if temp_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                current_weight = temp_weight\n\n    # Step 2: Objective-specific flips (exploitation)\n    for obj in range(2):\n        if obj == 0:\n            values = value1_lst\n        else:\n            values = value2_lst\n\n        # Find items with high marginal value that can be added\n        for i in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[i] <= capacity:\n                if np.random.rand() < 0.3:  # 30% chance to add high-value item\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n        # Find items with low marginal value that can be removed\n        for i in np.where(new_solution == 1)[0]:\n            if np.random.rand() < 0.1:  # 10% chance to remove low-value item\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    # Step 3: Capacity adjustment (repair if needed)\n    while current_weight > capacity:\n        # Remove items with lowest value-to-weight ratio\n        ratios = (value1_lst + value2_lst) / weight_lst\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) > 0:\n            worst = candidates[np.argmin(ratios[candidates])]\n            new_solution[worst] = 0\n            current_weight -= weight_lst[worst]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 225,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., not too far from the Pareto front)\n    if len(archive) > 1:\n        # Sort solutions by a combined score of value1 and value2 (prioritize solutions with higher total value)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% of solutions for perturbation\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items to introduce diversity\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items until the weight constraint is satisfied\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Randomly remove items until feasible\n        while total_weight > capacity:\n            # Identify items that can be removed (currently included)\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break  # No items to remove, solution is already minimal\n            # Randomly select an item to remove\n            remove_idx = random.choice(removable_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Step 2: Greedily add items that improve both objectives\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Iterate over all items not in the solution\n    for item in range(len(new_solution)):\n        if new_solution[item] == 0:\n            new_weight = total_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Calculate the marginal improvement in both objectives\n                marginal_value1 = value1_lst[item]\n                marginal_value2 = value2_lst[item]\n                # If both objectives improve, add the item\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[item] = 1\n                    total_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.3563338272805344,
            1.4918425977230072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with high potential for improvement (e.g., not too far from the Pareto front)\n    if len(archive) > 1:\n        # Sort solutions by a combined score of value1 and value2 (prioritize solutions with higher total value)\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 20% of solutions for perturbation\n        top_solutions = archive_sorted[:max(1, len(archive) // 5)]\n        selected_idx = random.randint(0, len(top_solutions) - 1)\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a subset of items to introduce diversity\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by removing items until the weight constraint is satisfied\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Randomly remove items until feasible\n        while total_weight > capacity:\n            # Identify items that can be removed (currently included)\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break  # No items to remove, solution is already minimal\n            # Randomly select an item to remove\n            remove_idx = random.choice(removable_items)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Step 2: Greedily add items that improve both objectives\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Iterate over all items not in the solution\n    for item in range(len(new_solution)):\n        if new_solution[item] == 0:\n            new_weight = total_weight + weight_lst[item]\n            if new_weight <= capacity:\n                # Calculate the marginal improvement in both objectives\n                marginal_value1 = value1_lst[item]\n                marginal_value2 = value2_lst[item]\n                # If both objectives improve, add the item\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[item] = 1\n                    total_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 226,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a base solution with potential for improvement\n    # Prioritize solutions that are not dominated and have high marginal utility\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            # Calculate marginal utility (ratio of value to weight)\n            marginal1 = obj[0] / total_weight if total_weight > 0 else 0\n            marginal2 = obj[1] / total_weight if total_weight > 0 else 0\n            candidates.append((sol, obj, marginal1, marginal2))\n\n    if not candidates:\n        # Fallback to random selection if no suitable candidates\n        base_sol = random.choice(archive)[0].copy()\n    else:\n        # Select a candidate with high marginal utility in at least one objective\n        candidates.sort(key=lambda x: max(x[2], x[3]), reverse=True)\n        base_sol = candidates[0][0].copy()\n\n    new_solution = base_sol.copy()\n    n_items = len(weight_lst)\n\n    # Step 2: Apply hybrid local search\n    # Flip-based move: Randomly flip a subset of items\n    if random.random() < 0.7:\n        flip_indices = random.sample(range(n_items), min(3, n_items))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                new_solution[idx] = 1\n    else:\n        # Swap-based move: Swap two items if feasible\n        if n_items >= 2:\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] != new_solution[j]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest marginal utility until feasible\n        while total_weight > capacity:\n            # Calculate marginal utility of included items\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break  # No items to remove\n\n            # Calculate marginal utility (value / weight)\n            marginals = []\n            for idx in included_items:\n                marginal1 = value1_lst[idx] / weight_lst[idx]\n                marginal2 = value2_lst[idx] / weight_lst[idx]\n                marginals.append((idx, max(marginal1, marginal2)))\n\n            # Remove the item with the lowest marginal utility\n            marginals.sort(key=lambda x: x[1])\n            item_to_remove = marginals[0][0]\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.3728709706541793,
            9.322170794010162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a base solution with potential for improvement\n    # Prioritize solutions that are not dominated and have high marginal utility\n    candidates = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            # Calculate marginal utility (ratio of value to weight)\n            marginal1 = obj[0] / total_weight if total_weight > 0 else 0\n            marginal2 = obj[1] / total_weight if total_weight > 0 else 0\n            candidates.append((sol, obj, marginal1, marginal2))\n\n    if not candidates:\n        # Fallback to random selection if no suitable candidates\n        base_sol = random.choice(archive)[0].copy()\n    else:\n        # Select a candidate with high marginal utility in at least one objective\n        candidates.sort(key=lambda x: max(x[2], x[3]), reverse=True)\n        base_sol = candidates[0][0].copy()\n\n    new_solution = base_sol.copy()\n    n_items = len(weight_lst)\n\n    # Step 2: Apply hybrid local search\n    # Flip-based move: Randomly flip a subset of items\n    if random.random() < 0.7:\n        flip_indices = random.sample(range(n_items), min(3, n_items))\n        for idx in flip_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n            else:\n                new_solution[idx] = 1\n    else:\n        # Swap-based move: Swap two items if feasible\n        if n_items >= 2:\n            i, j = random.sample(range(n_items), 2)\n            if new_solution[i] != new_solution[j]:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items with lowest marginal utility until feasible\n        while total_weight > capacity:\n            # Calculate marginal utility of included items\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break  # No items to remove\n\n            # Calculate marginal utility (value / weight)\n            marginals = []\n            for idx in included_items:\n                marginal1 = value1_lst[idx] / weight_lst[idx]\n                marginal2 = value2_lst[idx] / weight_lst[idx]\n                marginals.append((idx, max(marginal1, marginal2)))\n\n            # Remove the item with the lowest marginal utility\n            marginals.sort(key=lambda x: x[1])\n            item_to_remove = marginals[0][0]\n            new_solution[item_to_remove] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 227,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a random solution from the archive\n    idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items in and out of the knapsack\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for out items\n    if len(out_items) > 0:\n        out_ratios1 = value1_lst[out_items] / weight_lst[out_items]\n        out_ratios2 = value2_lst[out_items] / weight_lst[out_items]\n\n        # Combine ratios for selection criteria\n        combined_ratios = out_ratios1 + out_ratios2\n\n        # Select top 20% of out items with highest combined ratio\n        num_candidates = max(1, len(out_items) // 5)\n        top_candidates = np.argsort(combined_ratios)[-num_candidates:]\n\n        # Randomly select one candidate to swap in\n        if len(top_candidates) > 0:\n            candidate = out_items[np.random.choice(top_candidates)]\n\n            # Try to swap in the candidate\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n\n                # Now try to swap out a low-value item to maintain feasibility\n                in_ratios1 = value1_lst[in_items] / weight_lst[in_items]\n                in_ratios2 = value2_lst[in_items] / weight_lst[in_items]\n                combined_in_ratios = in_ratios1 + in_ratios2\n\n                # Find the lowest value item to swap out\n                if len(in_items) > 0:\n                    worst_item = in_items[np.argmin(combined_in_ratios)]\n                    new_solution[worst_item] = 0\n\n    # If no changes were made (unlikely due to randomness), perform a random flip\n    if np.array_equal(new_solution, base_solution):\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Randomly flip one in item to out and one out item to in\n            flip_in = np.random.choice(in_items)\n            flip_out = np.random.choice(out_items)\n            if current_weight - weight_lst[flip_in] + weight_lst[flip_out] <= capacity:\n                new_solution[flip_in] = 0\n                new_solution[flip_out] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.358880730085028,
            1.0491515696048737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a random solution from the archive\n    idx = np.random.randint(0, len(archive))\n    base_solution, _ = archive[idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items in and out of the knapsack\n    in_items = np.where(new_solution == 1)[0]\n    out_items = np.where(new_solution == 0)[0]\n\n    # Calculate value-to-weight ratios for out items\n    if len(out_items) > 0:\n        out_ratios1 = value1_lst[out_items] / weight_lst[out_items]\n        out_ratios2 = value2_lst[out_items] / weight_lst[out_items]\n\n        # Combine ratios for selection criteria\n        combined_ratios = out_ratios1 + out_ratios2\n\n        # Select top 20% of out items with highest combined ratio\n        num_candidates = max(1, len(out_items) // 5)\n        top_candidates = np.argsort(combined_ratios)[-num_candidates:]\n\n        # Randomly select one candidate to swap in\n        if len(top_candidates) > 0:\n            candidate = out_items[np.random.choice(top_candidates)]\n\n            # Try to swap in the candidate\n            if current_weight + weight_lst[candidate] <= capacity:\n                new_solution[candidate] = 1\n\n                # Now try to swap out a low-value item to maintain feasibility\n                in_ratios1 = value1_lst[in_items] / weight_lst[in_items]\n                in_ratios2 = value2_lst[in_items] / weight_lst[in_items]\n                combined_in_ratios = in_ratios1 + in_ratios2\n\n                # Find the lowest value item to swap out\n                if len(in_items) > 0:\n                    worst_item = in_items[np.argmin(combined_in_ratios)]\n                    new_solution[worst_item] = 0\n\n    # If no changes were made (unlikely due to randomness), perform a random flip\n    if np.array_equal(new_solution, base_solution):\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Randomly flip one in item to out and one out item to in\n            flip_in = np.random.choice(in_items)\n            flip_out = np.random.choice(out_items)\n            if current_weight - weight_lst[flip_in] + weight_lst[flip_out] <= capacity:\n                new_solution[flip_in] = 0\n                new_solution[flip_out] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 228,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Combine flip-based and swap-based moves\n    # Step 1: Flip-based move (try to add/remove items that improve both objectives)\n    flip_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item improves both objectives\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if adding this item improves both objectives\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                flip_candidates.append(i)\n\n    if flip_candidates:\n        flip_idx = random.choice(flip_candidates)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Step 2: Swap-based move (try to swap items between objectives)\n    # Find items that are in the solution but could be swapped to improve both objectives\n    swap_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            for j in range(len(new_solution)):\n                if new_solution[j] == 0:\n                    # Check if swapping i and j is feasible and improves both objectives\n                    temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if temp_weight <= capacity:\n                        swap_candidates.append((i, j))\n\n    if swap_candidates:\n        i, j = random.choice(swap_candidates)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 3: Perturbation move (if no better moves found, randomly flip one item)\n    perturb_candidates = [i for i in range(len(new_solution))\n                         if (new_solution[i] * (current_weight - weight_lst[i]) <= capacity) or\n                         ((1 - new_solution[i]) * (current_weight + weight_lst[i]) <= capacity)]\n\n    if perturb_candidates:\n        perturb_idx = random.choice(perturb_candidates)\n        new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8574425334710611,
            1.2859843373298645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the boundary)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search: Combine flip-based and swap-based moves\n    # Step 1: Flip-based move (try to add/remove items that improve both objectives)\n    flip_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            # Check if removing this item improves both objectives\n            temp_weight = current_weight - weight_lst[i]\n            if temp_weight <= capacity:\n                flip_candidates.append(i)\n        else:\n            # Check if adding this item improves both objectives\n            temp_weight = current_weight + weight_lst[i]\n            if temp_weight <= capacity:\n                flip_candidates.append(i)\n\n    if flip_candidates:\n        flip_idx = random.choice(flip_candidates)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n        return new_solution\n\n    # Step 2: Swap-based move (try to swap items between objectives)\n    # Find items that are in the solution but could be swapped to improve both objectives\n    swap_candidates = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 1:\n            for j in range(len(new_solution)):\n                if new_solution[j] == 0:\n                    # Check if swapping i and j is feasible and improves both objectives\n                    temp_weight = current_weight - weight_lst[i] + weight_lst[j]\n                    if temp_weight <= capacity:\n                        swap_candidates.append((i, j))\n\n    if swap_candidates:\n        i, j = random.choice(swap_candidates)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 3: Perturbation move (if no better moves found, randomly flip one item)\n    perturb_candidates = [i for i in range(len(new_solution))\n                         if (new_solution[i] * (current_weight - weight_lst[i]) <= capacity) or\n                         ((1 - new_solution[i]) * (current_weight + weight_lst[i]) <= capacity)]\n\n    if perturb_candidates:\n        perturb_idx = random.choice(perturb_candidates)\n        new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 229,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive based on a combination of randomness and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: random swaps followed by greedy improvement\n    n_items = len(new_solution)\n    if n_items == 0:\n        return new_solution\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n\n    # Step 2: Attempt to swap the selected items (flip their inclusion status)\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, try to exclude it\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If the item is excluded, try to include it\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for idx in remaining_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves both objectives\n            if value1_lst[idx] > 0 and value2_lst[idx] > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.386397890614501,
            2.432136118412018
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive based on a combination of randomness and potential improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Perform a hybrid local search: random swaps followed by greedy improvement\n    n_items = len(new_solution)\n    if n_items == 0:\n        return new_solution\n\n    # Step 1: Randomly select a subset of items to swap\n    swap_indices = random.sample(range(n_items), min(3, n_items))\n\n    # Step 2: Attempt to swap the selected items (flip their inclusion status)\n    for idx in swap_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, try to exclude it\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            # If the item is excluded, try to include it\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Step 3: Greedy improvement - add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    for idx in remaining_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves both objectives\n            if value1_lst[idx] > 0 and value2_lst[idx] > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 230,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with higher combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    probabilities = combined_scores / np.sum(combined_scores)\n    base_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(3):  # Perform 3 iterations of the hybrid search\n        # Random swap: swap two random items\n        if len(new_solution) >= 2:\n            i, j = random.sample(range(len(new_solution)), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility after swap\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # Undo swap if infeasible\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = np.sum(weight_lst * new_solution)\n\n        # Objective-specific flip: flip an item that could improve either objective\n        # Choose objective to focus on randomly\n        if random.random() < 0.5:\n            # Focus on objective 1\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                # Find item that would add most to objective 1 without exceeding capacity\n                potential_add = np.where(new_solution == 0)[0]\n                if len(potential_add) > 0:\n                    potential_values = value1_lst[potential_add]\n                    potential_weights = weight_lst[potential_add]\n                    feasible_add = (new_weight + potential_weights) <= capacity\n                    if np.any(feasible_add):\n                        best_add = potential_add[np.argmax(potential_values * feasible_add)]\n                        new_solution[best_add] = 1\n        else:\n            # Focus on objective 2\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                # Find item that would add most to objective 2 without exceeding capacity\n                potential_add = np.where(new_solution == 0)[0]\n                if len(potential_add) > 0:\n                    potential_values = value2_lst[potential_add]\n                    potential_weights = weight_lst[potential_add]\n                    feasible_add = (new_weight + potential_weights) <= capacity\n                    if np.any(feasible_add):\n                        best_add = potential_add[np.argmax(potential_values * feasible_add)]\n                        new_solution[best_add] = 1\n\n        # Weight-aware perturbation: remove an item if weight is too high\n        if new_weight > 0.9 * capacity:\n            # Remove the item with highest weight that's in the knapsack\n            in_knapsack = np.where(new_solution == 1)[0]\n            if len(in_knapsack) > 0:\n                heaviest = in_knapsack[np.argmax(weight_lst[in_knapsack])]\n                new_solution[heaviest] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4716717140622196,
            2.3916117548942566
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards those with higher combined objective values\n    objectives = np.array([obj for _, obj in archive])\n    combined_scores = objectives[:, 0] + objectives[:, 1]\n    probabilities = combined_scores / np.sum(combined_scores)\n    base_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(3):  # Perform 3 iterations of the hybrid search\n        # Random swap: swap two random items\n        if len(new_solution) >= 2:\n            i, j = random.sample(range(len(new_solution)), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Check feasibility after swap\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            # Undo swap if infeasible\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_weight = np.sum(weight_lst * new_solution)\n\n        # Objective-specific flip: flip an item that could improve either objective\n        # Choose objective to focus on randomly\n        if random.random() < 0.5:\n            # Focus on objective 1\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                # Find item that would add most to objective 1 without exceeding capacity\n                potential_add = np.where(new_solution == 0)[0]\n                if len(potential_add) > 0:\n                    potential_values = value1_lst[potential_add]\n                    potential_weights = weight_lst[potential_add]\n                    feasible_add = (new_weight + potential_weights) <= capacity\n                    if np.any(feasible_add):\n                        best_add = potential_add[np.argmax(potential_values * feasible_add)]\n                        new_solution[best_add] = 1\n        else:\n            # Focus on objective 2\n            candidates = np.where(new_solution == 0)[0]\n            if len(candidates) > 0:\n                # Find item that would add most to objective 2 without exceeding capacity\n                potential_add = np.where(new_solution == 0)[0]\n                if len(potential_add) > 0:\n                    potential_values = value2_lst[potential_add]\n                    potential_weights = weight_lst[potential_add]\n                    feasible_add = (new_weight + potential_weights) <= capacity\n                    if np.any(feasible_add):\n                        best_add = potential_add[np.argmax(potential_values * feasible_add)]\n                        new_solution[best_add] = 1\n\n        # Weight-aware perturbation: remove an item if weight is too high\n        if new_weight > 0.9 * capacity:\n            # Remove the item with highest weight that's in the knapsack\n            in_knapsack = np.where(new_solution == 1)[0]\n            if len(in_knapsack) > 0:\n                heaviest = in_knapsack[np.argmax(weight_lst[in_knapsack])]\n                new_solution[heaviest] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 231,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly weighted by dominance)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + i) for i in range(len(archive))],  # Prefer earlier solutions (more promising)\n        k=1\n    )[0]\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: flip items based on value-to-weight ratio and randomness\n    for _ in range(5):  # Number of flips per iteration\n        # Calculate value-to-weight ratios for items not in the solution\n        not_in_solution = np.where(new_solution == 0)[0]\n        if len(not_in_solution) == 0:\n            break\n\n        # Select items to flip based on combined value-to-weight ratio and randomness\n        ratios = (value1_lst[not_in_solution] + value2_lst[not_in_solution]) / weight_lst[not_in_solution]\n        flip_candidates = not_in_solution[np.argsort(ratios)[-min(3, len(ratios)):]]  # Top 3 by ratio\n\n        if len(flip_candidates) == 0:\n            break\n\n        # Randomly select one of the top candidates\n        flip_item = random.choice(flip_candidates)\n\n        # Check if adding the item keeps the solution feasible\n        if current_weight + weight_lst[flip_item] <= capacity:\n            new_solution[flip_item] = 1\n            current_weight += weight_lst[flip_item]\n\n    # Optionally flip some items out of the solution to improve diversity\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) > 0:\n        flip_out = random.choice(in_solution)\n        new_solution[flip_out] = 0\n        current_weight -= weight_lst[flip_out]\n\n    return new_solution\n\n",
        "score": [
            -0.8620837932405447,
            1.4910417199134827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly weighted by dominance)\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + i) for i in range(len(archive))],  # Prefer earlier solutions (more promising)\n        k=1\n    )[0]\n    base_solution, (base_val1, base_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: flip items based on value-to-weight ratio and randomness\n    for _ in range(5):  # Number of flips per iteration\n        # Calculate value-to-weight ratios for items not in the solution\n        not_in_solution = np.where(new_solution == 0)[0]\n        if len(not_in_solution) == 0:\n            break\n\n        # Select items to flip based on combined value-to-weight ratio and randomness\n        ratios = (value1_lst[not_in_solution] + value2_lst[not_in_solution]) / weight_lst[not_in_solution]\n        flip_candidates = not_in_solution[np.argsort(ratios)[-min(3, len(ratios)):]]  # Top 3 by ratio\n\n        if len(flip_candidates) == 0:\n            break\n\n        # Randomly select one of the top candidates\n        flip_item = random.choice(flip_candidates)\n\n        # Check if adding the item keeps the solution feasible\n        if current_weight + weight_lst[flip_item] <= capacity:\n            new_solution[flip_item] = 1\n            current_weight += weight_lst[flip_item]\n\n    # Optionally flip some items out of the solution to improve diversity\n    in_solution = np.where(new_solution == 1)[0]\n    if len(in_solution) > 0:\n        flip_out = random.choice(in_solution)\n        new_solution[flip_out] = 0\n        current_weight -= weight_lst[flip_out]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 232,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution from the archive with a bias towards higher-value solutions\n    base_solution, _ = random.choices(\n        archive,\n        weights=[(obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate the current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with probability based on value-to-weight ratio)\n    # 2. Apply a value-to-weight ratio heuristic to flip items with high marginal gain\n\n    # Step 1: Random flips with probability based on value-to-weight ratio\n    for i in range(n_items):\n        if random.random() < 0.3:  # Base probability\n            # Adjust probability based on value-to-weight ratio for both objectives\n            ratio1 = value1_lst[i] / (weight_lst[i] + 1e-6)\n            ratio2 = value2_lst[i] / (weight_lst[i] + 1e-6)\n            combined_ratio = ratio1 + ratio2\n\n            flip_prob = 0.3 * combined_ratio / (np.mean(value1_lst + value2_lst) / (np.mean(weight_lst) + 1e-6))\n            flip_prob = min(flip_prob, 0.8)  # Cap the probability\n\n            if random.random() < flip_prob:\n                # Check if flipping this item keeps the solution feasible\n                if new_solution[i] == 1:\n                    if current_weight - weight_lst[i] <= capacity:\n                        new_solution[i] = 0\n                        current_weight -= weight_lst[i]\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Step 2: Apply value-to-weight ratio heuristic for high-marginal-gain items\n    # Calculate marginal gains for both objectives\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain (descending)\n    sorted_items = np.argsort(-combined_gain)\n\n    for i in sorted_items:\n        if random.random() < 0.5:  # Probabilistic acceptance\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6554170327471018,
            8.871256917715073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution from the archive with a bias towards higher-value solutions\n    base_solution, _ = random.choices(\n        archive,\n        weights=[(obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Calculate the current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with probability based on value-to-weight ratio)\n    # 2. Apply a value-to-weight ratio heuristic to flip items with high marginal gain\n\n    # Step 1: Random flips with probability based on value-to-weight ratio\n    for i in range(n_items):\n        if random.random() < 0.3:  # Base probability\n            # Adjust probability based on value-to-weight ratio for both objectives\n            ratio1 = value1_lst[i] / (weight_lst[i] + 1e-6)\n            ratio2 = value2_lst[i] / (weight_lst[i] + 1e-6)\n            combined_ratio = ratio1 + ratio2\n\n            flip_prob = 0.3 * combined_ratio / (np.mean(value1_lst + value2_lst) / (np.mean(weight_lst) + 1e-6))\n            flip_prob = min(flip_prob, 0.8)  # Cap the probability\n\n            if random.random() < flip_prob:\n                # Check if flipping this item keeps the solution feasible\n                if new_solution[i] == 1:\n                    if current_weight - weight_lst[i] <= capacity:\n                        new_solution[i] = 0\n                        current_weight -= weight_lst[i]\n                else:\n                    if current_weight + weight_lst[i] <= capacity:\n                        new_solution[i] = 1\n                        current_weight += weight_lst[i]\n\n    # Step 2: Apply value-to-weight ratio heuristic for high-marginal-gain items\n    # Calculate marginal gains for both objectives\n    marginal_gain1 = value1_lst / (weight_lst + 1e-6)\n    marginal_gain2 = value2_lst / (weight_lst + 1e-6)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain (descending)\n    sorted_items = np.argsort(-combined_gain)\n\n    for i in sorted_items:\n        if random.random() < 0.5:  # Probabilistic acceptance\n            if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n            elif new_solution[i] == 1 and current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 233,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability of being non-dominated and having room for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback if no feasible candidates\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    selected = random.choices(candidates, k=1)[0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search: random swaps with greedy improvement\n    num_items = len(weight_lst)\n    for _ in range(min(10, num_items)):  # Limit iterations to avoid excessive computation\n        # Randomly select two items to swap\n        idx1, idx2 = random.sample(range(num_items), 2)\n\n        # Apply swap if feasible\n        temp_solution = new_solution.copy()\n        temp_solution[idx1], temp_solution[idx2] = temp_solution[idx2], temp_solution[idx1]\n\n        # Check feasibility\n        total_weight = np.sum(temp_solution * weight_lst)\n        if total_weight <= capacity:\n            # Greedy acceptance: accept if both objectives improve\n            current_value1 = np.sum(new_solution * value1_lst)\n            current_value2 = np.sum(new_solution * value2_lst)\n            new_value1 = np.sum(temp_solution * value1_lst)\n            new_value2 = np.sum(temp_solution * value2_lst)\n\n            if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n               (random.random() < 0.2):  # Small chance to accept non-improving swaps for diversity\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.611317849977813,
            9.982889235019684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a high probability of being non-dominated and having room for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight < capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback if no feasible candidates\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    selected = random.choices(candidates, k=1)[0].copy()\n    new_solution = selected.copy()\n\n    # Hybrid local search: random swaps with greedy improvement\n    num_items = len(weight_lst)\n    for _ in range(min(10, num_items)):  # Limit iterations to avoid excessive computation\n        # Randomly select two items to swap\n        idx1, idx2 = random.sample(range(num_items), 2)\n\n        # Apply swap if feasible\n        temp_solution = new_solution.copy()\n        temp_solution[idx1], temp_solution[idx2] = temp_solution[idx2], temp_solution[idx1]\n\n        # Check feasibility\n        total_weight = np.sum(temp_solution * weight_lst)\n        if total_weight <= capacity:\n            # Greedy acceptance: accept if both objectives improve\n            current_value1 = np.sum(new_solution * value1_lst)\n            current_value2 = np.sum(new_solution * value2_lst)\n            new_value1 = np.sum(temp_solution * value1_lst)\n            new_value2 = np.sum(temp_solution * value2_lst)\n\n            if (new_value1 > current_value1 and new_value2 > current_value2) or \\\n               (random.random() < 0.2):  # Small chance to accept non-improving swaps for diversity\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 234,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its dominance count (higher dominance = more promising)\n    dominance_counts = np.array([len([s for s in archive if s[1][0] >= obj[0] and s[1][1] >= obj[1]]) for _, obj in archive])\n    if np.sum(dominance_counts) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=dominance_counts / np.sum(dominance_counts))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Randomly flip a subset of items (up to 5) to introduce diversity\n    num_flips = min(5, len(new_solution))\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Check feasibility and repair if necessary\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_indices)\n        for idx in excess_indices:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            if current_weight <= capacity:\n                break\n\n    # Greedy improvement: add items that improve both objectives\n    remaining_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_indices)\n    for idx in remaining_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.39841132279314173,
            1.7982195317745209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its dominance count (higher dominance = more promising)\n    dominance_counts = np.array([len([s for s in archive if s[1][0] >= obj[0] and s[1][1] >= obj[1]]) for _, obj in archive])\n    if np.sum(dominance_counts) == 0:\n        selected_idx = np.random.randint(0, len(archive))\n    else:\n        selected_idx = np.random.choice(len(archive), p=dominance_counts / np.sum(dominance_counts))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Randomly flip a subset of items (up to 5) to introduce diversity\n    num_flips = min(5, len(new_solution))\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Check feasibility and repair if necessary\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items randomly until feasible\n        excess_indices = np.where(new_solution == 1)[0]\n        np.random.shuffle(excess_indices)\n        for idx in excess_indices:\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n            if current_weight <= capacity:\n                break\n\n    # Greedy improvement: add items that improve both objectives\n    remaining_indices = np.where(new_solution == 0)[0]\n    np.random.shuffle(remaining_indices)\n    for idx in remaining_indices:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves both objectives\n            if (value1_lst[idx] > 0) and (value2_lst[idx] > 0):\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 235,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the total weight and values of the solution\n        total_weight = np.sum(sol * weight_lst)\n        total_value1 = obj[0]\n        total_value2 = obj[1]\n\n        # Check if the solution has unused capacity and potential for improvement\n        if total_weight < capacity:\n            # Calculate the potential improvement by adding items that are not in the solution\n            potential_items = np.where(sol == 0)[0]\n            if len(potential_items) > 0:\n                # Select items with high value-to-weight ratio for both objectives\n                value1_to_weight = value1_lst[potential_items] / weight_lst[potential_items]\n                value2_to_weight = value2_lst[potential_items] / weight_lst[potential_items]\n                combined_ratio = value1_to_weight + value2_to_weight\n                best_candidate_idx = potential_items[np.argmax(combined_ratio)]\n                candidates.append((sol, total_weight, best_candidate_idx))\n\n    if not candidates:\n        # If no candidates found, randomly select a solution from the archive\n        selected_sol, _ = random.choice(archive)\n    else:\n        # Select the solution with the highest potential improvement\n        selected_sol, _, best_candidate_idx = max(candidates, key=lambda x: x[2])\n\n    # Create a neighbor by flipping the best candidate item\n    new_solution = selected_sol.copy()\n    new_solution[best_candidate_idx] = 1 - new_solution[best_candidate_idx]\n\n    # Ensure the new solution is feasible\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasibility is restored\n        while total_weight > capacity:\n            items_in_solution = np.where(new_solution == 1)[0]\n            if len(items_in_solution) == 0:\n                break\n            # Remove the item with the lowest combined value-to-weight ratio\n            value1_to_weight = value1_lst[items_in_solution] / weight_lst[items_in_solution]\n            value2_to_weight = value2_lst[items_in_solution] / weight_lst[items_in_solution]\n            combined_ratio = value1_to_weight + value2_to_weight\n            worst_item_idx = items_in_solution[np.argmin(combined_ratio)]\n            new_solution[worst_item_idx] = 0\n            total_weight = np.sum(new_solution * weight_lst)\n\n    return new_solution\n\n",
        "score": [
            -0.8511351459180562,
            2.9769175946712494
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate the total weight and values of the solution\n        total_weight = np.sum(sol * weight_lst)\n        total_value1 = obj[0]\n        total_value2 = obj[1]\n\n        # Check if the solution has unused capacity and potential for improvement\n        if total_weight < capacity:\n            # Calculate the potential improvement by adding items that are not in the solution\n            potential_items = np.where(sol == 0)[0]\n            if len(potential_items) > 0:\n                # Select items with high value-to-weight ratio for both objectives\n                value1_to_weight = value1_lst[potential_items] / weight_lst[potential_items]\n                value2_to_weight = value2_lst[potential_items] / weight_lst[potential_items]\n                combined_ratio = value1_to_weight + value2_to_weight\n                best_candidate_idx = potential_items[np.argmax(combined_ratio)]\n                candidates.append((sol, total_weight, best_candidate_idx))\n\n    if not candidates:\n        # If no candidates found, randomly select a solution from the archive\n        selected_sol, _ = random.choice(archive)\n    else:\n        # Select the solution with the highest potential improvement\n        selected_sol, _, best_candidate_idx = max(candidates, key=lambda x: x[2])\n\n    # Create a neighbor by flipping the best candidate item\n    new_solution = selected_sol.copy()\n    new_solution[best_candidate_idx] = 1 - new_solution[best_candidate_idx]\n\n    # Ensure the new solution is feasible\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # If not feasible, remove items randomly until feasibility is restored\n        while total_weight > capacity:\n            items_in_solution = np.where(new_solution == 1)[0]\n            if len(items_in_solution) == 0:\n                break\n            # Remove the item with the lowest combined value-to-weight ratio\n            value1_to_weight = value1_lst[items_in_solution] / weight_lst[items_in_solution]\n            value2_to_weight = value2_lst[items_in_solution] / weight_lst[items_in_solution]\n            combined_ratio = value1_to_weight + value2_to_weight\n            worst_item_idx = items_in_solution[np.argmin(combined_ratio)]\n            new_solution[worst_item_idx] = 0\n            total_weight = np.sum(new_solution * weight_lst)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 236,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not on the Pareto front or has room for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (but ensure feasibility)\n    # 2. If no improvement, perform a targeted flip based on marginal gains\n    # 3. If still no improvement, perform a diversifying move (flip a random item)\n\n    # Step 1: Random flip with feasibility check\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Check if improvement occurred\n    new_val1 = np.sum(value1_lst * new_solution)\n    new_val2 = np.sum(value2_lst * new_solution)\n    if (new_val1 > current_val1 and new_val2 >= current_val2) or (new_val1 >= current_val1 and new_val2 > current_val2):\n        return new_solution\n\n    # Step 2: Targeted flip based on marginal gains\n    # Calculate marginal gains for each item not in the solution\n    marginal_gains1 = value1_lst / weight_lst\n    marginal_gains2 = value2_lst / weight_lst\n    candidate_indices = np.where(base_solution == 0)[0]\n\n    if len(candidate_indices) > 0:\n        # Sort by combined marginal gain\n        combined_gain = marginal_gains1 + marginal_gains2\n        sorted_indices = candidate_indices[np.argsort(-combined_gain[candidate_indices])]\n\n        for i in sorted_indices[:2]:  # Consider top 2 candidates\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    # Step 3: Diversifying move if no improvement\n    if np.array_equal(new_solution, base_solution):\n        # Flip a random item not in the solution\n        candidate_indices = np.where(base_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            i = np.random.choice(candidate_indices)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.3350419640046529,
            1.504850596189499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not on the Pareto front or has room for improvement)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (but ensure feasibility)\n    # 2. If no improvement, perform a targeted flip based on marginal gains\n    # 3. If still no improvement, perform a diversifying move (flip a random item)\n\n    # Step 1: Random flip with feasibility check\n    flip_indices = np.random.choice(len(base_solution), size=min(3, len(base_solution)), replace=False)\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            if current_weight - weight_lst[i] <= capacity:\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n        else:\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Check if improvement occurred\n    new_val1 = np.sum(value1_lst * new_solution)\n    new_val2 = np.sum(value2_lst * new_solution)\n    if (new_val1 > current_val1 and new_val2 >= current_val2) or (new_val1 >= current_val1 and new_val2 > current_val2):\n        return new_solution\n\n    # Step 2: Targeted flip based on marginal gains\n    # Calculate marginal gains for each item not in the solution\n    marginal_gains1 = value1_lst / weight_lst\n    marginal_gains2 = value2_lst / weight_lst\n    candidate_indices = np.where(base_solution == 0)[0]\n\n    if len(candidate_indices) > 0:\n        # Sort by combined marginal gain\n        combined_gain = marginal_gains1 + marginal_gains2\n        sorted_indices = candidate_indices[np.argsort(-combined_gain[candidate_indices])]\n\n        for i in sorted_indices[:2]:  # Consider top 2 candidates\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n                break\n\n    # Step 3: Diversifying move if no improvement\n    if np.array_equal(new_solution, base_solution):\n        # Flip a random item not in the solution\n        candidate_indices = np.where(base_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            i = np.random.choice(candidate_indices)\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 237,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front\n    # and have a good balance between the two objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance to identify less crowded solutions\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left = objectives[i-1] if i > 0 else None\n        right = objectives[i+1] if i < len(objectives)-1 else None\n\n        if left is None or right is None:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = abs(left[0] - right[0])\n            dist2 = abs(left[1] - right[1])\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solutions with highest crowding distance (more potential for improvement)\n    max_crowding = max(crowding_distances)\n    candidates = [i for i, dist in enumerate(crowding_distances) if dist == max_crowding]\n\n    if not candidates:\n        candidates = range(len(archive))\n\n    selected_idx = random.choice(candidates)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for flip\n    # 2. For each item in the subset, calculate the potential improvement\n    # 3. Flip the item that provides the best combined improvement\n    # 4. Ensure feasibility by checking capacity constraints\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flip\n    n_items = len(weight_lst)\n    subset_size = min(10, n_items)  # Consider up to 10 random items\n    candidate_indices = random.sample(range(n_items), subset_size)\n\n    best_improvement = -float('inf')\n    best_index = -1\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Case 1: Item is currently in the knapsack - consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate potential improvement\n                improvement1 = -value1_lst[idx]\n                improvement2 = -value2_lst[idx]\n                combined_improvement = improvement1 + improvement2\n\n                if combined_improvement > best_improvement:\n                    best_improvement = combined_improvement\n                    best_index = idx\n                    best_action = 0  # 0 means remove\n        else:\n            # Case 2: Item is not in the knapsack - consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate potential improvement\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                combined_improvement = improvement1 + improvement2\n\n                if combined_improvement > best_improvement:\n                    best_improvement = combined_improvement\n                    best_index = idx\n                    best_action = 1  # 1 means add\n\n    # Apply the best flip if found\n    if best_index != -1:\n        new_solution[best_index] = best_action\n\n    return new_solution\n\n",
        "score": [
            -0.723937825250255,
            1.0071822106838226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front\n    # and have a good balance between the two objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance to identify less crowded solutions\n    crowding_distances = []\n    for i in range(len(objectives)):\n        left = objectives[i-1] if i > 0 else None\n        right = objectives[i+1] if i < len(objectives)-1 else None\n\n        if left is None or right is None:\n            crowding_distances.append(float('inf'))\n        else:\n            dist1 = abs(left[0] - right[0])\n            dist2 = abs(left[1] - right[1])\n            crowding_distances.append(dist1 + dist2)\n\n    # Select solutions with highest crowding distance (more potential for improvement)\n    max_crowding = max(crowding_distances)\n    candidates = [i for i, dist in enumerate(crowding_distances) if dist == max_crowding]\n\n    if not candidates:\n        candidates = range(len(archive))\n\n    selected_idx = random.choice(candidates)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for flip\n    # 2. For each item in the subset, calculate the potential improvement\n    # 3. Flip the item that provides the best combined improvement\n    # 4. Ensure feasibility by checking capacity constraints\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly select a subset of items to consider for flip\n    n_items = len(weight_lst)\n    subset_size = min(10, n_items)  # Consider up to 10 random items\n    candidate_indices = random.sample(range(n_items), subset_size)\n\n    best_improvement = -float('inf')\n    best_index = -1\n\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # Case 1: Item is currently in the knapsack - consider removing it\n            new_weight = current_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate potential improvement\n                improvement1 = -value1_lst[idx]\n                improvement2 = -value2_lst[idx]\n                combined_improvement = improvement1 + improvement2\n\n                if combined_improvement > best_improvement:\n                    best_improvement = combined_improvement\n                    best_index = idx\n                    best_action = 0  # 0 means remove\n        else:\n            # Case 2: Item is not in the knapsack - consider adding it\n            new_weight = current_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate potential improvement\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                combined_improvement = improvement1 + improvement2\n\n                if combined_improvement > best_improvement:\n                    best_improvement = combined_improvement\n                    best_index = idx\n                    best_action = 1  # 1 means add\n\n    # Apply the best flip if found\n    if best_index != -1:\n        new_solution[best_index] = best_action\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 238,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with potential for improvement (not dominated by others in the archive)\n    potential_solutions = []\n    for sol, _ in archive:\n        dominated = False\n        for _, (obj1, obj2) in archive:\n            if (obj1 > sol.dot(value1_lst)) and (obj2 > sol.dot(value2_lst)):\n                dominated = True\n                break\n        if not dominated:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(potential_solutions).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: random swaps and guided flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a number of items to flip (1 to 3)\n    num_flips = random.randint(1, min(3, n_items))\n\n    # Guided flip: prioritize flipping items that improve both objectives\n    improvement_candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Check if removing the item improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                improvement_candidates.append(i)\n        else:\n            # Check if adding the item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                improvement_candidates.append(i)\n\n    # Perform the flips\n    for _ in range(min(num_flips, len(improvement_candidates))):\n        i = random.choice(improvement_candidates)\n        new_solution[i] = 1 - new_solution[i]\n        improvement_candidates.remove(i)\n        current_weight = np.sum(weight_lst * new_solution)\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the heaviest item that can be removed without violating feasibility\n        heavy_items = [i for i in range(n_items) if new_solution[i] == 1]\n        if not heavy_items:\n            break\n        i = max(heavy_items, key=lambda x: weight_lst[x])\n        new_solution[i] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.940719932838507,
            3.023312032222748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with potential for improvement (not dominated by others in the archive)\n    potential_solutions = []\n    for sol, _ in archive:\n        dominated = False\n        for _, (obj1, obj2) in archive:\n            if (obj1 > sol.dot(value1_lst)) and (obj2 > sol.dot(value2_lst)):\n                dominated = True\n                break\n        if not dominated:\n            potential_solutions.append(sol)\n\n    if not potential_solutions:\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = random.choice(potential_solutions).copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: random swaps and guided flips\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Randomly select a number of items to flip (1 to 3)\n    num_flips = random.randint(1, min(3, n_items))\n\n    # Guided flip: prioritize flipping items that improve both objectives\n    improvement_candidates = []\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Check if removing the item improves both objectives\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                improvement_candidates.append(i)\n        else:\n            # Check if adding the item improves both objectives\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                improvement_candidates.append(i)\n\n    # Perform the flips\n    for _ in range(min(num_flips, len(improvement_candidates))):\n        i = random.choice(improvement_candidates)\n        new_solution[i] = 1 - new_solution[i]\n        improvement_candidates.remove(i)\n        current_weight = np.sum(weight_lst * new_solution)\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove the heaviest item that can be removed without violating feasibility\n        heavy_items = [i for i in range(n_items) if new_solution[i] == 1]\n        if not heavy_items:\n            break\n        i = max(heavy_items, key=lambda x: weight_lst[x])\n        new_solution[i] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 239,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity * 0.9:  # Prefer solutions with room for improvement\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if none meet the criteria\n\n    base_solution = random.choice(candidates).copy()\n\n    # Step 2: Apply hybrid local search operators\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Operator 1: Random item swap (to escape local optima)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Operator 2: Value-based flip (prioritize high-value items)\n    if np.sum(new_solution) < n_items:  # If not all items are selected\n        # Calculate value-to-weight ratios for objective 1 and 2\n        value1_ratio = value1_lst / (weight_lst + 1e-6)\n        value2_ratio = value2_lst / (weight_lst + 1e-6)\n\n        # Combine ratios to prioritize items that are good for both objectives\n        combined_ratio = value1_ratio + value2_ratio\n\n        # Select top 20% of items by combined ratio\n        top_items = np.argsort(combined_ratio)[-max(1, n_items // 5):]\n\n        # Flip one of the top items if it's not already in the solution\n        for item in top_items:\n            if not new_solution[item]:\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    # Operator 3: Weight-balanced perturbation (ensure feasibility)\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        items_in_solution = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(items_in_solution) > 0:\n            # Remove the item with the smallest value-to-weight ratio\n            item_to_remove = items_in_solution[np.argmin((value1_lst + value2_lst)[items_in_solution] / (weight_lst[items_in_solution] + 1e-6))]\n            new_solution[item_to_remove] = 0\n            current_weight = np.sum(weight_lst * new_solution)\n            items_in_solution = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n",
        "score": [
            -0.35904381867481694,
            7.755821734666824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity * 0.9:  # Prefer solutions with room for improvement\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]  # Fallback to all solutions if none meet the criteria\n\n    base_solution = random.choice(candidates).copy()\n\n    # Step 2: Apply hybrid local search operators\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Operator 1: Random item swap (to escape local optima)\n    if n_items >= 2:\n        i, j = random.sample(range(n_items), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Operator 2: Value-based flip (prioritize high-value items)\n    if np.sum(new_solution) < n_items:  # If not all items are selected\n        # Calculate value-to-weight ratios for objective 1 and 2\n        value1_ratio = value1_lst / (weight_lst + 1e-6)\n        value2_ratio = value2_lst / (weight_lst + 1e-6)\n\n        # Combine ratios to prioritize items that are good for both objectives\n        combined_ratio = value1_ratio + value2_ratio\n\n        # Select top 20% of items by combined ratio\n        top_items = np.argsort(combined_ratio)[-max(1, n_items // 5):]\n\n        # Flip one of the top items if it's not already in the solution\n        for item in top_items:\n            if not new_solution[item]:\n                current_weight = np.sum(weight_lst * new_solution)\n                if current_weight + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break\n\n    # Operator 3: Weight-balanced perturbation (ensure feasibility)\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items until feasible\n        items_in_solution = np.where(new_solution == 1)[0]\n        while current_weight > capacity and len(items_in_solution) > 0:\n            # Remove the item with the smallest value-to-weight ratio\n            item_to_remove = items_in_solution[np.argmin((value1_lst + value2_lst)[items_in_solution] / (weight_lst[items_in_solution] + 1e-6))]\n            new_solution[item_to_remove] = 0\n            current_weight = np.sum(weight_lst * new_solution)\n            items_in_solution = np.where(new_solution == 1)[0]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 240,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidate_indices = [i for i, (sol, _) in enumerate(archive)\n                         if np.sum(sol * weight_lst) < 0.9 * capacity]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + value-based swap\n    # Step 1: Randomly flip a subset of items (with probability 0.3)\n    flip_mask = np.random.rand(len(new_solution)) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Ensure feasibility by removing excess items\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with the least value-to-weight ratio until feasible\n        while excess_weight > 0:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate value-to-weight ratio for both objectives\n            v1_ratio = value1_lst[included_items] / weight_lst[included_items]\n            v2_ratio = value2_lst[included_items] / weight_lst[included_items]\n            # Combine ratios to prioritize items that are less valuable in both objectives\n            combined_ratio = v1_ratio + v2_ratio\n            remove_idx = included_items[np.argmin(combined_ratio)]\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    # Step 3: Value-based swap to improve both objectives\n    # Find items not in the solution and calculate their potential contribution\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate potential value-to-weight ratio for excluded items\n        potential_v1_ratio = value1_lst[excluded_items] / weight_lst[excluded_items]\n        potential_v2_ratio = value2_lst[excluded_items] / weight_lst[excluded_items]\n        combined_potential = potential_v1_ratio + potential_v2_ratio\n\n        # Select top candidates based on potential\n        top_candidates = excluded_items[np.argsort(combined_potential)[-min(3, len(excluded_items)):]]\n        for candidate in top_candidates:\n            if weight_lst[candidate] <= capacity - np.sum(new_solution * weight_lst):\n                new_solution[candidate] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.36720008508256874,
            3.371855854988098
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    candidate_indices = [i for i, (sol, _) in enumerate(archive)\n                         if np.sum(sol * weight_lst) < 0.9 * capacity]\n    if not candidate_indices:\n        candidate_indices = list(range(len(archive)))\n\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random perturbation + value-based swap\n    # Step 1: Randomly flip a subset of items (with probability 0.3)\n    flip_mask = np.random.rand(len(new_solution)) < 0.3\n    new_solution[flip_mask] = 1 - new_solution[flip_mask]\n\n    # Step 2: Ensure feasibility by removing excess items\n    current_weight = np.sum(new_solution * weight_lst)\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with the least value-to-weight ratio until feasible\n        while excess_weight > 0:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate value-to-weight ratio for both objectives\n            v1_ratio = value1_lst[included_items] / weight_lst[included_items]\n            v2_ratio = value2_lst[included_items] / weight_lst[included_items]\n            # Combine ratios to prioritize items that are less valuable in both objectives\n            combined_ratio = v1_ratio + v2_ratio\n            remove_idx = included_items[np.argmin(combined_ratio)]\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    # Step 3: Value-based swap to improve both objectives\n    # Find items not in the solution and calculate their potential contribution\n    excluded_items = np.where(new_solution == 0)[0]\n    if len(excluded_items) > 0:\n        # Calculate potential value-to-weight ratio for excluded items\n        potential_v1_ratio = value1_lst[excluded_items] / weight_lst[excluded_items]\n        potential_v2_ratio = value2_lst[excluded_items] / weight_lst[excluded_items]\n        combined_potential = potential_v1_ratio + potential_v2_ratio\n\n        # Select top candidates based on potential\n        top_candidates = excluded_items[np.argsort(combined_potential)[-min(3, len(excluded_items)):]]\n        for candidate in top_candidates:\n            if weight_lst[candidate] <= capacity - np.sum(new_solution * weight_lst):\n                new_solution[candidate] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 241,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 to avoid always picking the best\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of bit-flip and swap\n    n_items = len(base_solution)\n\n    # Step 1: Bit-flip for a randomly selected item\n    flip_idx = random.randint(0, n_items - 1)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility after flip\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, remove the most expensive item (based on sum of values)\n        if new_solution[flip_idx] == 1:  # We added this item\n            new_solution[flip_idx] = 0\n        else:  # We removed this item, need to find another to remove\n            # Find items with highest value and remove one\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) > 0:\n                candidate_values = value1_lst[candidate_indices] + value2_lst[candidate_indices]\n                remove_idx = candidate_indices[np.argmax(candidate_values)]\n                new_solution[remove_idx] = 0\n\n    # Step 2: Perform a swap between two items if it improves both objectives\n    if random.random() < 0.5:  # 50% chance to perform swap\n        item1, item2 = random.sample(range(n_items), 2)\n        if new_solution[item1] != new_solution[item2]:\n            temp_solution = new_solution.copy()\n            temp_solution[item1], temp_solution[item2] = temp_solution[item2], temp_solution[item1]\n\n            # Check feasibility\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                # Evaluate improvement in both objectives\n                original_value1 = np.sum(value1_lst * new_solution)\n                original_value2 = np.sum(value2_lst * new_solution)\n                new_value1 = np.sum(value1_lst * temp_solution)\n                new_value2 = np.sum(value2_lst * temp_solution)\n\n                # Accept if both objectives improve or at least one improves\n                if (new_value1 > original_value1 and new_value2 > original_value2) or \\\n                   (new_value1 > original_value1) or (new_value2 > original_value2):\n                    new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8686651797487726,
            0.885138213634491
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = min(3, len(archive) - 1)  # Select from top 3 to avoid always picking the best\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of bit-flip and swap\n    n_items = len(base_solution)\n\n    # Step 1: Bit-flip for a randomly selected item\n    flip_idx = random.randint(0, n_items - 1)\n    new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Ensure feasibility after flip\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If infeasible, remove the most expensive item (based on sum of values)\n        if new_solution[flip_idx] == 1:  # We added this item\n            new_solution[flip_idx] = 0\n        else:  # We removed this item, need to find another to remove\n            # Find items with highest value and remove one\n            candidate_indices = np.where(new_solution == 1)[0]\n            if len(candidate_indices) > 0:\n                candidate_values = value1_lst[candidate_indices] + value2_lst[candidate_indices]\n                remove_idx = candidate_indices[np.argmax(candidate_values)]\n                new_solution[remove_idx] = 0\n\n    # Step 2: Perform a swap between two items if it improves both objectives\n    if random.random() < 0.5:  # 50% chance to perform swap\n        item1, item2 = random.sample(range(n_items), 2)\n        if new_solution[item1] != new_solution[item2]:\n            temp_solution = new_solution.copy()\n            temp_solution[item1], temp_solution[item2] = temp_solution[item2], temp_solution[item1]\n\n            # Check feasibility\n            temp_weight = np.sum(weight_lst * temp_solution)\n            if temp_weight <= capacity:\n                # Evaluate improvement in both objectives\n                original_value1 = np.sum(value1_lst * new_solution)\n                original_value2 = np.sum(value2_lst * new_solution)\n                new_value1 = np.sum(value1_lst * temp_solution)\n                new_value2 = np.sum(value2_lst * temp_solution)\n\n                # Accept if both objectives improve or at least one improves\n                if (new_value1 > original_value1 and new_value2 > original_value2) or \\\n                   (new_value1 > original_value1) or (new_value2 > original_value2):\n                    new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 242,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    weights = np.array([weight_lst[sol].sum() for sol in archive_solutions])\n    values1 = np.array([value1_lst[sol].sum() for sol in archive_solutions])\n    values2 = np.array([value2_lst[sol].sum() for sol in archive_solutions])\n\n    # Prioritize solutions near capacity but with high values\n    potential_scores = (values1 + values2) * (weights / capacity) ** 0.5\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: value-based flips and random swaps\n    n_items = len(weight_lst)\n    current_weight = weight_lst[new_solution].sum()\n\n    # Step 1: Flip items with highest marginal value improvement\n    for _ in range(3):  # Limit flips to avoid excessive computation\n        marginal_values1 = value1_lst * (1 - 2 * new_solution)  # Flip effect\n        marginal_values2 = value2_lst * (1 - 2 * new_solution)\n        combined_marginal = marginal_values1 + marginal_values2\n\n        # Prioritize flips that improve both objectives\n        candidate_flips = np.where((combined_marginal > 0) & (weight_lst <= (capacity - current_weight + weight_lst[new_solution])))[0]\n        if len(candidate_flips) > 0:\n            flip_idx = np.random.choice(candidate_flips)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            current_weight += weight_lst[flip_idx] * (1 - 2 * new_solution[flip_idx])\n\n    # Step 2: Random swaps to escape local optima\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        i, j = np.random.choice(swap_candidates, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if weight_lst[new_solution].sum() > capacity:\n        # Remove items randomly until feasible\n        while weight_lst[new_solution].sum() > capacity:\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break\n            remove_idx = np.random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9490227815823032,
            10.320697158575058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    weights = np.array([weight_lst[sol].sum() for sol in archive_solutions])\n    values1 = np.array([value1_lst[sol].sum() for sol in archive_solutions])\n    values2 = np.array([value2_lst[sol].sum() for sol in archive_solutions])\n\n    # Prioritize solutions near capacity but with high values\n    potential_scores = (values1 + values2) * (weights / capacity) ** 0.5\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: value-based flips and random swaps\n    n_items = len(weight_lst)\n    current_weight = weight_lst[new_solution].sum()\n\n    # Step 1: Flip items with highest marginal value improvement\n    for _ in range(3):  # Limit flips to avoid excessive computation\n        marginal_values1 = value1_lst * (1 - 2 * new_solution)  # Flip effect\n        marginal_values2 = value2_lst * (1 - 2 * new_solution)\n        combined_marginal = marginal_values1 + marginal_values2\n\n        # Prioritize flips that improve both objectives\n        candidate_flips = np.where((combined_marginal > 0) & (weight_lst <= (capacity - current_weight + weight_lst[new_solution])))[0]\n        if len(candidate_flips) > 0:\n            flip_idx = np.random.choice(candidate_flips)\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n            current_weight += weight_lst[flip_idx] * (1 - 2 * new_solution[flip_idx])\n\n    # Step 2: Random swaps to escape local optima\n    swap_candidates = np.where(new_solution == 1)[0]\n    if len(swap_candidates) >= 2:\n        i, j = np.random.choice(swap_candidates, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if weight_lst[new_solution].sum() > capacity:\n        # Remove items randomly until feasible\n        while weight_lst[new_solution].sum() > capacity:\n            remove_candidates = np.where(new_solution == 1)[0]\n            if len(remove_candidates) == 0:\n                break\n            remove_idx = np.random.choice(remove_candidates)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 243,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Generate candidate items to flip (either add or remove)\n    flip_candidates = []\n    for i in range(len(selected_solution)):\n        if selected_solution[i] == 1:\n            # Consider removing items that are not critical (weight < remaining_capacity)\n            if weight_lst[i] < remaining_capacity:\n                flip_candidates.append(i)\n        else:\n            # Consider adding items that fit within remaining capacity\n            if weight_lst[i] <= remaining_capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no candidates, perform a random flip to escape local optima\n        flip_candidates = list(range(len(selected_solution)))\n\n    # Evaluate flips for both objectives\n    best_flip = None\n    best_improvement = (-float('inf'), -float('inf'))\n\n    for i in flip_candidates:\n        new_solution = selected_solution.copy()\n        new_solution[i] = 1 - new_solution[i]  # Flip the item\n\n        # Calculate new weight and objectives\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            continue  # Skip infeasible solutions\n\n        new_value1 = np.sum(value1_lst * new_solution)\n        new_value2 = np.sum(value2_lst * new_solution)\n\n        # Calculate improvement (delta for both objectives)\n        delta1 = new_value1 - np.sum(value1_lst * selected_solution)\n        delta2 = new_value2 - np.sum(value2_lst * selected_solution)\n\n        # Prefer flips that improve both objectives\n        if delta1 > 0 and delta2 > 0:\n            if (delta1, delta2) > best_improvement:\n                best_improvement = (delta1, delta2)\n                best_flip = i\n\n    # If no improving flip found, perform a random flip\n    if best_flip is None:\n        best_flip = random.choice(flip_candidates)\n\n    # Apply the best flip\n    new_solution = selected_solution.copy()\n    new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Ensure feasibility (should not be needed due to earlier checks)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Fallback: remove the heaviest item if still infeasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            heaviest_item = np.argmax(weight_lst * new_solution)\n            new_solution[heaviest_item] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.4485900066250438,
            3.8934570848941803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to capacity)\n    selected_solution = random.choice(archive)[0].copy()\n    current_weight = np.sum(weight_lst * selected_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Generate candidate items to flip (either add or remove)\n    flip_candidates = []\n    for i in range(len(selected_solution)):\n        if selected_solution[i] == 1:\n            # Consider removing items that are not critical (weight < remaining_capacity)\n            if weight_lst[i] < remaining_capacity:\n                flip_candidates.append(i)\n        else:\n            # Consider adding items that fit within remaining capacity\n            if weight_lst[i] <= remaining_capacity:\n                flip_candidates.append(i)\n\n    if not flip_candidates:\n        # If no candidates, perform a random flip to escape local optima\n        flip_candidates = list(range(len(selected_solution)))\n\n    # Evaluate flips for both objectives\n    best_flip = None\n    best_improvement = (-float('inf'), -float('inf'))\n\n    for i in flip_candidates:\n        new_solution = selected_solution.copy()\n        new_solution[i] = 1 - new_solution[i]  # Flip the item\n\n        # Calculate new weight and objectives\n        new_weight = np.sum(weight_lst * new_solution)\n        if new_weight > capacity:\n            continue  # Skip infeasible solutions\n\n        new_value1 = np.sum(value1_lst * new_solution)\n        new_value2 = np.sum(value2_lst * new_solution)\n\n        # Calculate improvement (delta for both objectives)\n        delta1 = new_value1 - np.sum(value1_lst * selected_solution)\n        delta2 = new_value2 - np.sum(value2_lst * selected_solution)\n\n        # Prefer flips that improve both objectives\n        if delta1 > 0 and delta2 > 0:\n            if (delta1, delta2) > best_improvement:\n                best_improvement = (delta1, delta2)\n                best_flip = i\n\n    # If no improving flip found, perform a random flip\n    if best_flip is None:\n        best_flip = random.choice(flip_candidates)\n\n    # Apply the best flip\n    new_solution = selected_solution.copy()\n    new_solution[best_flip] = 1 - new_solution[best_flip]\n\n    # Ensure feasibility (should not be needed due to earlier checks)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Fallback: remove the heaviest item if still infeasible\n        while np.sum(weight_lst * new_solution) > capacity:\n            heaviest_item = np.argmax(weight_lst * new_solution)\n            new_solution[heaviest_item] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 244,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a base solution with a bias towards those with higher potential for improvement\n    # Potential is determined by the ratio of the sum of values to the capacity\n    potentials = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential = (obj[0] + obj[1]) / (total_weight + 1e-6)  # Avoid division by zero\n        potentials.append(potential)\n\n    # Select the solution with the highest potential for improvement\n    base_idx = np.argmax(potentials)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1-3 items)\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    temp_solution = new_solution.copy()\n\n    # 2. Flip the selected items and check feasibility\n    for idx in flip_indices:\n        temp_solution[idx] = 1 - temp_solution[idx]  # Flip the bit\n\n    # 3. If the flip makes the solution infeasible, undo the flip\n    total_weight = np.sum(weight_lst * temp_solution)\n    if total_weight <= capacity:\n        new_solution = temp_solution\n    else:\n        # If infeasible, try to make it feasible by removing items with the lowest value-to-weight ratio\n        while total_weight > capacity:\n            # Calculate value-to-weight ratios for included items\n            ratios = []\n            for i in range(len(new_solution)):\n                if new_solution[i] == 1:\n                    ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    ratios.append((ratio, i))\n            if not ratios:\n                break  # No items to remove, solution is infeasible and cannot be fixed\n            # Remove the item with the lowest ratio\n            _, remove_idx = min(ratios, key=lambda x: x[0])\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # 4. If no flips were made, perform a guided flip:\n    #    - Select the item with the highest value-to-weight ratio that is not in the solution\n    if np.array_equal(new_solution, base_solution):\n        # Calculate value-to-weight ratios for excluded items\n        ratios = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                ratios.append((ratio, i))\n        if ratios:\n            # Select the item with the highest ratio and add it if feasible\n            _, add_idx = max(ratios, key=lambda x: x[0])\n            if np.sum(weight_lst * new_solution) + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.31399341130736885,
            1.7039431929588318
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a base solution with a bias towards those with higher potential for improvement\n    # Potential is determined by the ratio of the sum of values to the capacity\n    potentials = []\n    for sol, obj in archive:\n        total_weight = np.sum(weight_lst * sol)\n        potential = (obj[0] + obj[1]) / (total_weight + 1e-6)  # Avoid division by zero\n        potentials.append(potential)\n\n    # Select the solution with the highest potential for improvement\n    base_idx = np.argmax(potentials)\n    base_solution, _ = archive[base_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1-3 items)\n    flip_indices = random.sample(range(len(new_solution)), min(3, len(new_solution)))\n    temp_solution = new_solution.copy()\n\n    # 2. Flip the selected items and check feasibility\n    for idx in flip_indices:\n        temp_solution[idx] = 1 - temp_solution[idx]  # Flip the bit\n\n    # 3. If the flip makes the solution infeasible, undo the flip\n    total_weight = np.sum(weight_lst * temp_solution)\n    if total_weight <= capacity:\n        new_solution = temp_solution\n    else:\n        # If infeasible, try to make it feasible by removing items with the lowest value-to-weight ratio\n        while total_weight > capacity:\n            # Calculate value-to-weight ratios for included items\n            ratios = []\n            for i in range(len(new_solution)):\n                if new_solution[i] == 1:\n                    ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                    ratios.append((ratio, i))\n            if not ratios:\n                break  # No items to remove, solution is infeasible and cannot be fixed\n            # Remove the item with the lowest ratio\n            _, remove_idx = min(ratios, key=lambda x: x[0])\n            new_solution[remove_idx] = 0\n            total_weight = np.sum(weight_lst * new_solution)\n\n    # 4. If no flips were made, perform a guided flip:\n    #    - Select the item with the highest value-to-weight ratio that is not in the solution\n    if np.array_equal(new_solution, base_solution):\n        # Calculate value-to-weight ratios for excluded items\n        ratios = []\n        for i in range(len(new_solution)):\n            if new_solution[i] == 0:\n                ratio = (value1_lst[i] + value2_lst[i]) / weight_lst[i]\n                ratios.append((ratio, i))\n        if ratios:\n            # Select the item with the highest ratio and add it if feasible\n            _, add_idx = max(ratios, key=lambda x: x[0])\n            if np.sum(weight_lst * new_solution) + weight_lst[add_idx] <= capacity:\n                new_solution[add_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 245,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, (current_val1, current_val2) = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that are currently in the knapsack\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of included items (with higher probability for items with low marginal contribution)\n    # 2. Randomly flip a subset of excluded items (with higher probability for items with high marginal contribution)\n\n    # Step 1: Process included items\n    if len(included_items) > 0:\n        # Calculate marginal ratios for included items\n        marginal_ratios = (value1_lst[included_items] / weight_lst[included_items] +\n                          value2_lst[included_items] / weight_lst[included_items]) / 2\n        # Probability of flipping is inversely proportional to marginal ratio\n        flip_probs = 1 / (marginal_ratios + 1e-6)  # avoid division by zero\n        flip_probs = flip_probs / np.sum(flip_probs)  # normalize\n\n        # Randomly select items to flip\n        num_flips = min(2, len(included_items))  # flip up to 2 items\n        items_to_flip = np.random.choice(included_items, size=num_flips, p=flip_probs, replace=False)\n\n        # Check if flipping would keep solution feasible\n        for item in items_to_flip:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Step 2: Process excluded items\n    if len(excluded_items) > 0:\n        # Calculate marginal ratios for excluded items\n        marginal_ratios = (value1_lst[excluded_items] / weight_lst[excluded_items] +\n                          value2_lst[excluded_items] / weight_lst[excluded_items]) / 2\n        # Probability of flipping is proportional to marginal ratio\n        flip_probs = marginal_ratios / np.sum(marginal_ratios)  # normalize\n\n        # Randomly select items to flip\n        num_flips = min(2, len(excluded_items))  # flip up to 2 items\n        items_to_flip = np.random.choice(excluded_items, size=num_flips, p=flip_probs, replace=False)\n\n        # Check if flipping would keep solution feasible\n        for item in items_to_flip:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.5134464220690238,
            2.3230648934841156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution, (current_val1, current_val2) = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items that are currently in the knapsack\n    included_items = np.where(new_solution == 1)[0]\n    excluded_items = np.where(new_solution == 0)[0]\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of included items (with higher probability for items with low marginal contribution)\n    # 2. Randomly flip a subset of excluded items (with higher probability for items with high marginal contribution)\n\n    # Step 1: Process included items\n    if len(included_items) > 0:\n        # Calculate marginal ratios for included items\n        marginal_ratios = (value1_lst[included_items] / weight_lst[included_items] +\n                          value2_lst[included_items] / weight_lst[included_items]) / 2\n        # Probability of flipping is inversely proportional to marginal ratio\n        flip_probs = 1 / (marginal_ratios + 1e-6)  # avoid division by zero\n        flip_probs = flip_probs / np.sum(flip_probs)  # normalize\n\n        # Randomly select items to flip\n        num_flips = min(2, len(included_items))  # flip up to 2 items\n        items_to_flip = np.random.choice(included_items, size=num_flips, p=flip_probs, replace=False)\n\n        # Check if flipping would keep solution feasible\n        for item in items_to_flip:\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n\n    # Step 2: Process excluded items\n    if len(excluded_items) > 0:\n        # Calculate marginal ratios for excluded items\n        marginal_ratios = (value1_lst[excluded_items] / weight_lst[excluded_items] +\n                          value2_lst[excluded_items] / weight_lst[excluded_items]) / 2\n        # Probability of flipping is proportional to marginal ratio\n        flip_probs = marginal_ratios / np.sum(marginal_ratios)  # normalize\n\n        # Randomly select items to flip\n        num_flips = min(2, len(excluded_items))  # flip up to 2 items\n        items_to_flip = np.random.choice(excluded_items, size=num_flips, p=flip_probs, replace=False)\n\n        # Check if flipping would keep solution feasible\n        for item in items_to_flip:\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 246,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly among top 20% by total value)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_idx = np.random.randint(0, len(selection_pool))\n    base_solution, _ = selection_pool[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random flip with guided improvement\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (up to 20% of the knapsack)\n    flip_indices = np.random.choice(n_items, size=min(n_items, max(1, n_items // 5)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Greedy improvement - add items with highest marginal ratio of total value to weight\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Calculate marginal value ratios for remaining items\n        marginal_ratios = (value1_lst[remaining_items] + value2_lst[remaining_items]) / weight_lst[remaining_items]\n        # Sort by highest ratio\n        sorted_indices = remaining_items[np.argsort(marginal_ratios)[::-1]]\n\n        for idx in sorted_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.34196459362620496,
            1.7249417304992676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (randomly among top 20% by total value)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n    selected_idx = np.random.randint(0, len(selection_pool))\n    base_solution, _ = selection_pool[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Random flip with guided improvement\n    n_items = len(new_solution)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Step 1: Randomly flip a subset of items (up to 20% of the knapsack)\n    flip_indices = np.random.choice(n_items, size=min(n_items, max(1, n_items // 5)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Greedy improvement - add items with highest marginal ratio of total value to weight\n    remaining_items = np.where(new_solution == 0)[0]\n    if len(remaining_items) > 0:\n        # Calculate marginal value ratios for remaining items\n        marginal_ratios = (value1_lst[remaining_items] + value2_lst[remaining_items]) / weight_lst[remaining_items]\n        # Sort by highest ratio\n        sorted_indices = remaining_items[np.argsort(marginal_ratios)[::-1]]\n\n        for idx in sorted_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 247,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on a weighted random choice\n    # Solutions with higher combined value are more likely to be selected\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    probabilities = combined_values / np.sum(combined_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search strategy\n    # (a) Randomly flip a subset of items (diversification)\n    flip_prob = 0.2  # Probability of flipping each item\n    flip_mask = np.random.random(len(new_solution)) < flip_prob\n\n    # (b) Value-weighted selection for flipping (intensification)\n    # Items with high combined value are more likely to be flipped\n    combined_item_values = value1_lst + value2_lst\n    value_weights = combined_item_values / np.sum(combined_item_values)\n    value_flip_mask = np.random.random(len(new_solution)) < value_weights\n\n    # Combine both strategies\n    final_flip_mask = np.logical_or(flip_mask, value_flip_mask)\n\n    # Flip the selected items\n    new_solution[final_flip_mask] = 1 - new_solution[final_flip_mask]\n\n    # Step 3: Ensure feasibility by removing excess weight\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest combined value until feasible\n        while current_weight > capacity:\n            # Identify items to potentially remove\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break  # No items to remove, solution is already minimal\n\n            # Select item with lowest combined value to remove\n            removable_values = combined_item_values[removable_items]\n            item_to_remove = removable_items[np.argmin(removable_values)]\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n",
        "score": [
            -0.41538656690779846,
            2.4533783197402954
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution based on a weighted random choice\n    # Solutions with higher combined value are more likely to be selected\n    objectives = np.array([obj for (sol, obj) in archive])\n    combined_values = objectives[:, 0] + objectives[:, 1]\n    probabilities = combined_values / np.sum(combined_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search strategy\n    # (a) Randomly flip a subset of items (diversification)\n    flip_prob = 0.2  # Probability of flipping each item\n    flip_mask = np.random.random(len(new_solution)) < flip_prob\n\n    # (b) Value-weighted selection for flipping (intensification)\n    # Items with high combined value are more likely to be flipped\n    combined_item_values = value1_lst + value2_lst\n    value_weights = combined_item_values / np.sum(combined_item_values)\n    value_flip_mask = np.random.random(len(new_solution)) < value_weights\n\n    # Combine both strategies\n    final_flip_mask = np.logical_or(flip_mask, value_flip_mask)\n\n    # Flip the selected items\n    new_solution[final_flip_mask] = 1 - new_solution[final_flip_mask]\n\n    # Step 3: Ensure feasibility by removing excess weight\n    current_weight = np.sum(weight_lst * new_solution)\n    if current_weight > capacity:\n        # Remove items with lowest combined value until feasible\n        while current_weight > capacity:\n            # Identify items to potentially remove\n            removable_items = np.where(new_solution == 1)[0]\n            if len(removable_items) == 0:\n                break  # No items to remove, solution is already minimal\n\n            # Select item with lowest combined value to remove\n            removable_values = combined_item_values[removable_items]\n            item_to_remove = removable_items[np.argmin(removable_values)]\n            new_solution[item_to_remove] = 0\n            current_weight -= weight_lst[item_to_remove]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 248,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine item swapping and flipping\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Swap two items in the knapsack\n        swap_indices = random.sample(list(candidate_indices), min(2, len(candidate_indices)))\n        if len(swap_indices) == 2:\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Step 2: Randomly flip a small number of items to explore neighborhood\n    flip_indices = random.sample(range(len(weight_lst)), min(3, len(weight_lst)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Greedy improvement for one objective while maintaining feasibility\n    # Choose objective to improve based on current solution's position in the archive\n    improve_obj1 = (selected_idx % 2 == 0)  # Alternate between objectives\n\n    if improve_obj1:\n        # Greedy improvement for value1\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate potential improvement\n                improvement = value1_lst[idx] / (weight_lst[idx] + 1e-6)  # Avoid division by zero\n                # Accept if improvement is positive\n                if improvement > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n    else:\n        # Greedy improvement for value2\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate potential improvement\n                improvement = value2_lst[idx] / (weight_lst[idx] + 1e-6)  # Avoid division by zero\n                # Accept if improvement is positive\n                if improvement > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.46465893597749514,
            2.0493638813495636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + i) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy: combine item swapping and flipping\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    candidate_indices = np.where(new_solution == 1)[0]\n    if len(candidate_indices) > 0:\n        # Swap two items in the knapsack\n        swap_indices = random.sample(list(candidate_indices), min(2, len(candidate_indices)))\n        if len(swap_indices) == 2:\n            new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    # Step 2: Randomly flip a small number of items to explore neighborhood\n    flip_indices = random.sample(range(len(weight_lst)), min(3, len(weight_lst)))\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Greedy improvement for one objective while maintaining feasibility\n    # Choose objective to improve based on current solution's position in the archive\n    improve_obj1 = (selected_idx % 2 == 0)  # Alternate between objectives\n\n    if improve_obj1:\n        # Greedy improvement for value1\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate potential improvement\n                improvement = value1_lst[idx] / (weight_lst[idx] + 1e-6)  # Avoid division by zero\n                # Accept if improvement is positive\n                if improvement > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n    else:\n        # Greedy improvement for value2\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate potential improvement\n                improvement = value2_lst[idx] / (weight_lst[idx] + 1e-6)  # Avoid division by zero\n                # Accept if improvement is positive\n                if improvement > 0:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 249,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the \"improvement potential\" for each solution (e.g., based on dominance score)\n    # Here, we use a simple metric: the sum of normalized distances to the current Pareto front\n    # This encourages selecting solutions that are not well-represented in the archive\n    improvement_potentials = []\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate the number of solutions in the archive that dominate this solution\n        dominated_count = sum(1 for other_obj in archive_objectives if other_obj[0] > obj[0] and other_obj[1] > obj[1])\n        improvement_potentials.append(dominated_count)\n\n    # Select a solution with higher potential for improvement (more dominated solutions)\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid approach:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Perform a value-driven swap to improve both objectives\n    new_solution = base_solution.copy()\n\n    # Step 1: Random perturbation (flip 1-3 random items)\n    num_flips = np.random.randint(1, 4)\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove excess items by removing the least valuable ones\n        excess_weight = total_weight - capacity\n        while excess_weight > 0:\n            # Find the item with the smallest sum of values\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            total_values = value1_lst[included_items] + value2_lst[included_items]\n            remove_idx = included_items[np.argmin(total_values)]\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    # Step 2: Value-driven swap to improve both objectives\n    # Find items not in the solution that could improve both objectives\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Calculate the potential improvement for each candidate\n        potential_improvements = []\n        for idx in candidate_items:\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate the improvement in both objectives\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                potential_improvements.append((improvement1 + improvement2, idx))\n        if potential_improvements:\n            # Select the item with the highest combined improvement\n            _, best_idx = max(potential_improvements)\n            new_solution[best_idx] = 1\n\n    # If no improvement possible, try removing the least valuable item\n    if np.array_equal(new_solution, base_solution):\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            total_values = value1_lst[included_items] + value2_lst[included_items]\n            remove_idx = included_items[np.argmin(total_values)]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.800830495586008,
            9.128424912691116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher potential for improvement\n    # We prioritize solutions that are not too close to the Pareto front\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the \"improvement potential\" for each solution (e.g., based on dominance score)\n    # Here, we use a simple metric: the sum of normalized distances to the current Pareto front\n    # This encourages selecting solutions that are not well-represented in the archive\n    improvement_potentials = []\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate the number of solutions in the archive that dominate this solution\n        dominated_count = sum(1 for other_obj in archive_objectives if other_obj[0] > obj[0] and other_obj[1] > obj[1])\n        improvement_potentials.append(dominated_count)\n\n    # Select a solution with higher potential for improvement (more dominated solutions)\n    selected_idx = np.argmax(improvement_potentials)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid approach:\n    # 1. Randomly flip a subset of items (perturbation)\n    # 2. Perform a value-driven swap to improve both objectives\n    new_solution = base_solution.copy()\n\n    # Step 1: Random perturbation (flip 1-3 random items)\n    num_flips = np.random.randint(1, 4)\n    flip_indices = np.random.choice(len(new_solution), size=num_flips, replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility after random flips\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove excess items by removing the least valuable ones\n        excess_weight = total_weight - capacity\n        while excess_weight > 0:\n            # Find the item with the smallest sum of values\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            total_values = value1_lst[included_items] + value2_lst[included_items]\n            remove_idx = included_items[np.argmin(total_values)]\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    # Step 2: Value-driven swap to improve both objectives\n    # Find items not in the solution that could improve both objectives\n    candidate_items = np.where(new_solution == 0)[0]\n    if len(candidate_items) > 0:\n        # Calculate the potential improvement for each candidate\n        potential_improvements = []\n        for idx in candidate_items:\n            new_weight = np.sum(weight_lst * new_solution) + weight_lst[idx]\n            if new_weight <= capacity:\n                # Calculate the improvement in both objectives\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                potential_improvements.append((improvement1 + improvement2, idx))\n        if potential_improvements:\n            # Select the item with the highest combined improvement\n            _, best_idx = max(potential_improvements)\n            new_solution[best_idx] = 1\n\n    # If no improvement possible, try removing the least valuable item\n    if np.array_equal(new_solution, base_solution):\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            total_values = value1_lst[included_items] + value2_lst[included_items]\n            remove_idx = included_items[np.argmin(total_values)]\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 250,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.argmax([sum(sol[0]) for sol in archive])  # Select the most packed solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine flip and swap operations\n    # Step 1: Randomly flip some bits (local improvement)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after flip\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove excess items by flipping back the heaviest items\n        excess_items = np.where(new_solution == 1)[0]\n        excess_weights = weight_lst[excess_items]\n        sorted_indices = np.argsort(excess_weights)[::-1]\n        for idx in sorted_indices:\n            if total_weight > capacity:\n                new_solution[excess_items[idx]] = 0\n                total_weight -= weight_lst[excess_items[idx]]\n\n    # Step 2: Randomly swap two items (diversification)\n    if len(new_solution) >= 2:\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n        # Ensure feasibility after swap\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove the heavier item if swap violates capacity\n            if weight_lst[swap_indices[0]] > weight_lst[swap_indices[1]]:\n                new_solution[swap_indices[0]] = 0\n            else:\n                new_solution[swap_indices[1]] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.30854878021797216,
            4.284081995487213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.argmax([sum(sol[0]) for sol in archive])  # Select the most packed solution\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine flip and swap operations\n    # Step 1: Randomly flip some bits (local improvement)\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility after flip\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove excess items by flipping back the heaviest items\n        excess_items = np.where(new_solution == 1)[0]\n        excess_weights = weight_lst[excess_items]\n        sorted_indices = np.argsort(excess_weights)[::-1]\n        for idx in sorted_indices:\n            if total_weight > capacity:\n                new_solution[excess_items[idx]] = 0\n                total_weight -= weight_lst[excess_items[idx]]\n\n    # Step 2: Randomly swap two items (diversification)\n    if len(new_solution) >= 2:\n        swap_indices = np.random.choice(len(new_solution), size=2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n        # Ensure feasibility after swap\n        total_weight = np.sum(weight_lst * new_solution)\n        if total_weight > capacity:\n            # Remove the heavier item if swap violates capacity\n            if weight_lst[swap_indices[0]] > weight_lst[swap_indices[1]]:\n                new_solution[swap_indices[0]] = 0\n            else:\n                new_solution[swap_indices[1]] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 251,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with higher potential for improvement (randomly weighted by objective values)\n    weights = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: flip items with high marginal value/weight ratio or random flips\n    for _ in range(3):  # Perform multiple iterations\n        # Calculate marginal ratios for all items\n        marginal_ratio1 = (value1_lst - current_value1) / (weight_lst + 1e-6)\n        marginal_ratio2 = (value2_lst - current_value2) / (weight_lst + 1e-6)\n\n        # Combine ratios with randomness for exploration\n        combined_ratio = 0.7 * (marginal_ratio1 + marginal_ratio2) + 0.3 * np.random.rand(len(weight_lst))\n\n        # Select top candidates (both high ratio and random)\n        candidates = np.argsort(-combined_ratio)[:max(1, len(weight_lst) // 5)]\n\n        # Randomly select one candidate to flip\n        if len(candidates) > 0:\n            flip_idx = random.choice(candidates)\n            if base_solution[flip_idx] == 0:\n                # Add item if feasible\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight += weight_lst[flip_idx]\n                    current_value1 += value1_lst[flip_idx]\n                    current_value2 += value2_lst[flip_idx]\n            else:\n                # Remove item\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n                current_value1 -= value1_lst[flip_idx]\n                current_value2 -= value2_lst[flip_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.6161276875125871,
            5.207719713449478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with higher potential for improvement (randomly weighted by objective values)\n    weights = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Hybrid local search: flip items with high marginal value/weight ratio or random flips\n    for _ in range(3):  # Perform multiple iterations\n        # Calculate marginal ratios for all items\n        marginal_ratio1 = (value1_lst - current_value1) / (weight_lst + 1e-6)\n        marginal_ratio2 = (value2_lst - current_value2) / (weight_lst + 1e-6)\n\n        # Combine ratios with randomness for exploration\n        combined_ratio = 0.7 * (marginal_ratio1 + marginal_ratio2) + 0.3 * np.random.rand(len(weight_lst))\n\n        # Select top candidates (both high ratio and random)\n        candidates = np.argsort(-combined_ratio)[:max(1, len(weight_lst) // 5)]\n\n        # Randomly select one candidate to flip\n        if len(candidates) > 0:\n            flip_idx = random.choice(candidates)\n            if base_solution[flip_idx] == 0:\n                # Add item if feasible\n                if current_weight + weight_lst[flip_idx] <= capacity:\n                    new_solution[flip_idx] = 1\n                    current_weight += weight_lst[flip_idx]\n                    current_value1 += value1_lst[flip_idx]\n                    current_value2 += value2_lst[flip_idx]\n            else:\n                # Remove item\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n                current_value1 -= value1_lst[flip_idx]\n                current_value2 -= value2_lst[flip_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 252,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Intelligently select a solution with high potential for improvement\n    # We prioritize solutions that are not too close to the boundary (i.e., not too close to capacity)\n    # and have a balance between the two objectives (not too dominated in either)\n    selected_idx = 0\n    max_potential = -float('inf')\n    for i, (solution, (val1, val2)) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        # Potential is a combination of how close to capacity and how balanced the objectives are\n        potential = (capacity - current_weight) / capacity * (1 - abs(val1 - val2) / (val1 + val2 + 1e-6))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # First, perform a random perturbation (flip a few bits)\n    n_items = len(weight_lst)\n    n_flips = min(3, n_items)  # Flip up to 3 items\n    flip_indices = np.random.choice(n_items, size=n_flips, replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing excess items if needed\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with the smallest ratio of (value1 + value2) / weight to minimize loss\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            removal_values = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            sorted_indices = np.argsort(removal_values)\n            for idx in sorted_indices:\n                if excess_weight <= 0:\n                    break\n                item_idx = included_items[idx]\n                new_solution[item_idx] = 0\n                excess_weight -= weight_lst[item_idx]\n\n    # Step 3: Apply a greedy improvement step\n    # Try adding items not in the solution that can improve at least one objective\n    excluded_items = np.where(new_solution == 0)[0]\n    for item in excluded_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves at least one objective\n            if (value1_lst[item] > 0) or (value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.4877579601400005,
            3.8067744076251984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Intelligently select a solution with high potential for improvement\n    # We prioritize solutions that are not too close to the boundary (i.e., not too close to capacity)\n    # and have a balance between the two objectives (not too dominated in either)\n    selected_idx = 0\n    max_potential = -float('inf')\n    for i, (solution, (val1, val2)) in enumerate(archive):\n        current_weight = np.sum(weight_lst[solution == 1])\n        # Potential is a combination of how close to capacity and how balanced the objectives are\n        potential = (capacity - current_weight) / capacity * (1 - abs(val1 - val2) / (val1 + val2 + 1e-6))\n        if potential > max_potential:\n            max_potential = potential\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # First, perform a random perturbation (flip a few bits)\n    n_items = len(weight_lst)\n    n_flips = min(3, n_items)  # Flip up to 3 items\n    flip_indices = np.random.choice(n_items, size=n_flips, replace=False)\n    new_solution[flip_indices] = 1 - new_solution[flip_indices]\n\n    # Ensure feasibility by removing excess items if needed\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        excess_weight = current_weight - capacity\n        # Remove items with the smallest ratio of (value1 + value2) / weight to minimize loss\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            removal_values = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            sorted_indices = np.argsort(removal_values)\n            for idx in sorted_indices:\n                if excess_weight <= 0:\n                    break\n                item_idx = included_items[idx]\n                new_solution[item_idx] = 0\n                excess_weight -= weight_lst[item_idx]\n\n    # Step 3: Apply a greedy improvement step\n    # Try adding items not in the solution that can improve at least one objective\n    excluded_items = np.where(new_solution == 0)[0]\n    for item in excluded_items:\n        if current_weight + weight_lst[item] <= capacity:\n            # Check if adding this item improves at least one objective\n            if (value1_lst[item] > 0) or (value2_lst[item] > 0):\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 253,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions that are not fully packed\n    base_solution, _ = random.choice(archive)\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify promising items to flip (add or remove)\n    candidate_indices = np.where(base_solution == 0)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 1)[0]\n\n    # Hybrid local search strategy: combination of value-based and weight-based selection\n    if random.random() < 0.7:  # 70% chance of value-based selection\n        # Select items with high marginal value-to-weight ratio\n        marginal_values1 = value1_lst / (weight_lst + 1e-6)\n        marginal_values2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal_values1 + marginal_values2\n        sorted_indices = np.argsort(combined_marginal)[::-1]\n        candidate_indices = sorted_indices[:min(10, len(sorted_indices))]\n    else:  # 30% chance of weight-based selection\n        # Select items with weights close to remaining capacity\n        weight_diffs = np.abs(weight_lst - remaining_capacity)\n        candidate_indices = np.argsort(weight_diffs)[:min(5, len(weight_lst))]\n\n    # Apply the flip operation\n    new_solution = base_solution.copy()\n    for idx in candidate_indices:\n        if base_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n        elif base_solution[idx] == 1:\n            new_solution[idx] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random items until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9165454138165999,
            0.8681552112102509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions that are not fully packed\n    base_solution, _ = random.choice(archive)\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify promising items to flip (add or remove)\n    candidate_indices = np.where(base_solution == 0)[0]\n    if len(candidate_indices) == 0:\n        candidate_indices = np.where(base_solution == 1)[0]\n\n    # Hybrid local search strategy: combination of value-based and weight-based selection\n    if random.random() < 0.7:  # 70% chance of value-based selection\n        # Select items with high marginal value-to-weight ratio\n        marginal_values1 = value1_lst / (weight_lst + 1e-6)\n        marginal_values2 = value2_lst / (weight_lst + 1e-6)\n        combined_marginal = marginal_values1 + marginal_values2\n        sorted_indices = np.argsort(combined_marginal)[::-1]\n        candidate_indices = sorted_indices[:min(10, len(sorted_indices))]\n    else:  # 30% chance of weight-based selection\n        # Select items with weights close to remaining capacity\n        weight_diffs = np.abs(weight_lst - remaining_capacity)\n        candidate_indices = np.argsort(weight_diffs)[:min(5, len(weight_lst))]\n\n    # Apply the flip operation\n    new_solution = base_solution.copy()\n    for idx in candidate_indices:\n        if base_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n        elif base_solution[idx] == 1:\n            new_solution[idx] = 0\n\n    # Ensure feasibility\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove random items until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 254,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with high total value in either objective\n    base_solution, (total_value1, total_value2) = random.choices(\n        archive,\n        weights=[max(v1, v2) for (_, (v1, v2)) in archive],\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: Randomly flip items with a bias towards those with high value-to-weight ratios\n    for _ in range(min(5, len(new_solution))):  # Limit the number of flips to avoid excessive computation\n        # Calculate value-to-weight ratios for all items\n        value_to_weight1 = value1_lst / (weight_lst + 1e-10)\n        value_to_weight2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine the ratios to prioritize items that are valuable in either objective\n        combined_ratio = np.maximum(value_to_weight1, value_to_weight2)\n\n        # Select items to flip based on combined ratio and current solution state\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) == 0:\n            flip_candidates = np.arange(len(new_solution))\n\n        # Randomly select an item to flip, with higher probability for items with high combined ratio\n        flip_prob = combined_ratio / (np.sum(combined_ratio) + 1e-10)\n        item_to_flip = random.choices(flip_candidates, weights=flip_prob[flip_candidates], k=1)[0]\n\n        # Flip the selected item and check feasibility\n        if new_solution[item_to_flip] == 1:\n            new_weight = current_weight - weight_lst[item_to_flip]\n            if new_weight <= capacity:\n                new_solution[item_to_flip] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item_to_flip]\n            if new_weight <= capacity:\n                new_solution[item_to_flip] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8527143127384882,
            2.0486145317554474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with high total value in either objective\n    base_solution, (total_value1, total_value2) = random.choices(\n        archive,\n        weights=[max(v1, v2) for (_, (v1, v2)) in archive],\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search: Randomly flip items with a bias towards those with high value-to-weight ratios\n    for _ in range(min(5, len(new_solution))):  # Limit the number of flips to avoid excessive computation\n        # Calculate value-to-weight ratios for all items\n        value_to_weight1 = value1_lst / (weight_lst + 1e-10)\n        value_to_weight2 = value2_lst / (weight_lst + 1e-10)\n\n        # Combine the ratios to prioritize items that are valuable in either objective\n        combined_ratio = np.maximum(value_to_weight1, value_to_weight2)\n\n        # Select items to flip based on combined ratio and current solution state\n        flip_candidates = np.where(new_solution == 1)[0]\n        if len(flip_candidates) == 0:\n            flip_candidates = np.arange(len(new_solution))\n\n        # Randomly select an item to flip, with higher probability for items with high combined ratio\n        flip_prob = combined_ratio / (np.sum(combined_ratio) + 1e-10)\n        item_to_flip = random.choices(flip_candidates, weights=flip_prob[flip_candidates], k=1)[0]\n\n        # Flip the selected item and check feasibility\n        if new_solution[item_to_flip] == 1:\n            new_weight = current_weight - weight_lst[item_to_flip]\n            if new_weight <= capacity:\n                new_solution[item_to_flip] = 0\n                current_weight = new_weight\n        else:\n            new_weight = current_weight + weight_lst[item_to_flip]\n            if new_weight <= capacity:\n                new_solution[item_to_flip] = 1\n                current_weight = new_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 255,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    # Calculate the \"improvement potential\" as the sum of marginal gains\n    potentials = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Calculate marginal gains for items not in the solution\n        marginal_gains = (value1_lst + value2_lst) * (1 - sol)\n        # Sort marginal gains in descending order\n        sorted_gains = np.sort(marginal_gains)[::-1]\n        # Calculate potential improvement by adding top items within remaining capacity\n        potential_improvement = 0.0\n        temp_weight = 0.0\n        for gain in sorted_gains:\n            if temp_weight + weight_lst[np.argmax(marginal_gains)] <= remaining_capacity:\n                potential_improvement += gain\n                temp_weight += weight_lst[np.argmax(marginal_gains)]\n                marginal_gains[np.argmax(marginal_gains)] = 0  # Mark as considered\n            else:\n                break\n        potentials.append(potential_improvement)\n\n    # Select the solution with highest potential for improvement\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1\u21920 or 0\u21921)\n    # 2. Apply a greedy improvement step to maximize the sum of marginal gains\n    # 3. Ensure feasibility by rejecting moves that exceed capacity\n\n    # Step 1: Random flip subset\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy improvement\n    current_weight = np.sum(weight_lst * new_solution)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Calculate marginal gains for all items\n        marginal_gains = (value1_lst + value2_lst) * (1 - 2 * new_solution)\n        # Find the item with highest marginal gain that doesn't violate capacity\n        best_idx = -1\n        best_gain = 0.0\n        for i in range(len(new_solution)):\n            if marginal_gains[i] > best_gain:\n                if (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity) or \\\n                   (new_solution[i] == 1 and current_weight - weight_lst[i] >= 0):\n                    best_idx = i\n                    best_gain = marginal_gains[i]\n\n        if best_idx != -1:\n            new_solution[best_idx] = 1 - new_solution[best_idx]\n            current_weight += weight_lst[best_idx] if new_solution[best_idx] == 1 else -weight_lst[best_idx]\n        else:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.2506642675761419,
            4.100309133529663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Intelligent selection: prioritize solutions with high potential for improvement\n    # Calculate the \"improvement potential\" as the sum of marginal gains\n    potentials = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - current_weight\n        # Calculate marginal gains for items not in the solution\n        marginal_gains = (value1_lst + value2_lst) * (1 - sol)\n        # Sort marginal gains in descending order\n        sorted_gains = np.sort(marginal_gains)[::-1]\n        # Calculate potential improvement by adding top items within remaining capacity\n        potential_improvement = 0.0\n        temp_weight = 0.0\n        for gain in sorted_gains:\n            if temp_weight + weight_lst[np.argmax(marginal_gains)] <= remaining_capacity:\n                potential_improvement += gain\n                temp_weight += weight_lst[np.argmax(marginal_gains)]\n                marginal_gains[np.argmax(marginal_gains)] = 0  # Mark as considered\n            else:\n                break\n        potentials.append(potential_improvement)\n\n    # Select the solution with highest potential for improvement\n    selected_idx = np.argmax(potentials)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (1\u21920 or 0\u21921)\n    # 2. Apply a greedy improvement step to maximize the sum of marginal gains\n    # 3. Ensure feasibility by rejecting moves that exceed capacity\n\n    # Step 1: Random flip subset\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy improvement\n    current_weight = np.sum(weight_lst * new_solution)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Calculate marginal gains for all items\n        marginal_gains = (value1_lst + value2_lst) * (1 - 2 * new_solution)\n        # Find the item with highest marginal gain that doesn't violate capacity\n        best_idx = -1\n        best_gain = 0.0\n        for i in range(len(new_solution)):\n            if marginal_gains[i] > best_gain:\n                if (new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity) or \\\n                   (new_solution[i] == 1 and current_weight - weight_lst[i] >= 0):\n                    best_idx = i\n                    best_gain = marginal_gains[i]\n\n        if best_idx != -1:\n            new_solution[best_idx] = 1 - new_solution[best_idx]\n            current_weight += weight_lst[best_idx] if new_solution[best_idx] == 1 else -weight_lst[best_idx]\n        else:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 256,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with preference for those with high potential for improvement\n    # (e.g., solutions near the Pareto front or with high objective diversity)\n    base_solution, _ = random.choices(\n        archive,\n        weights=[np.linalg.norm(obj) for _, obj in archive],  # Prefer solutions with higher combined objective values\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for swaps\n    num_items = len(weight_lst)\n    subset_size = min(10, num_items)  # Limit subset size for efficiency\n    candidate_indices = random.sample(range(num_items), subset_size)\n\n    # 2. For each candidate item, consider swapping it with another item in the subset\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, try to exclude it and include a better alternative\n            # Find the best alternative item to include (highest marginal value in both objectives)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            remaining_weight = capacity - current_weight + weight_lst[idx]\n\n            # Compute marginal values for all items not in the solution\n            marginal_value1 = value1_lst - np.sum(value1_lst[new_solution == 1]) + value1_lst[idx]\n            marginal_value2 = value2_lst - np.sum(value2_lst[new_solution == 1]) + value2_lst[idx]\n\n            # Normalize and combine marginal values for multi-objective selection\n            norm_marginal = (marginal_value1 / np.max(marginal_value1)) + (marginal_value2 / np.max(marginal_value2))\n            feasible_mask = (weight_lst <= remaining_weight) & (new_solution == 0)\n\n            if np.any(feasible_mask):\n                best_alternative = np.argmax(norm_marginal * feasible_mask)\n                # Swap: exclude idx, include best_alternative\n                new_solution[idx] = 0\n                new_solution[best_alternative] = 1\n        else:\n            # If the item is excluded, try to include it if it improves both objectives\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if weight_lst[idx] <= capacity - current_weight:\n                # Compute marginal improvement if this item is included\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n\n                # Include the item if it improves both objectives\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, remove the heaviest items until feasible\n        while total_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            # Remove the item with the lowest value density (value/weight)\n            value_density = (value1_lst + value2_lst) / weight_lst\n            worst_item = included_indices[np.argmin(value_density[included_indices])]\n            new_solution[worst_item] = 0\n            total_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n",
        "score": [
            -0.4090743436267031,
            5.622542172670364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with preference for those with high potential for improvement\n    # (e.g., solutions near the Pareto front or with high objective diversity)\n    base_solution, _ = random.choices(\n        archive,\n        weights=[np.linalg.norm(obj) for _, obj in archive],  # Prefer solutions with higher combined objective values\n        k=1\n    )[0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for swaps\n    num_items = len(weight_lst)\n    subset_size = min(10, num_items)  # Limit subset size for efficiency\n    candidate_indices = random.sample(range(num_items), subset_size)\n\n    # 2. For each candidate item, consider swapping it with another item in the subset\n    for idx in candidate_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, try to exclude it and include a better alternative\n            # Find the best alternative item to include (highest marginal value in both objectives)\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            remaining_weight = capacity - current_weight + weight_lst[idx]\n\n            # Compute marginal values for all items not in the solution\n            marginal_value1 = value1_lst - np.sum(value1_lst[new_solution == 1]) + value1_lst[idx]\n            marginal_value2 = value2_lst - np.sum(value2_lst[new_solution == 1]) + value2_lst[idx]\n\n            # Normalize and combine marginal values for multi-objective selection\n            norm_marginal = (marginal_value1 / np.max(marginal_value1)) + (marginal_value2 / np.max(marginal_value2))\n            feasible_mask = (weight_lst <= remaining_weight) & (new_solution == 0)\n\n            if np.any(feasible_mask):\n                best_alternative = np.argmax(norm_marginal * feasible_mask)\n                # Swap: exclude idx, include best_alternative\n                new_solution[idx] = 0\n                new_solution[best_alternative] = 1\n        else:\n            # If the item is excluded, try to include it if it improves both objectives\n            current_weight = np.sum(weight_lst[new_solution == 1])\n            if weight_lst[idx] <= capacity - current_weight:\n                # Compute marginal improvement if this item is included\n                marginal_value1 = value1_lst[idx]\n                marginal_value2 = value2_lst[idx]\n\n                # Include the item if it improves both objectives\n                if marginal_value1 > 0 and marginal_value2 > 0:\n                    new_solution[idx] = 1\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # If infeasible, remove the heaviest items until feasible\n        while total_weight > capacity:\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            # Remove the item with the lowest value density (value/weight)\n            value_density = (value1_lst + value2_lst) / weight_lst\n            worst_item = included_indices[np.argmin(value_density[included_indices])]\n            new_solution[worst_item] = 0\n            total_weight -= weight_lst[worst_item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 257,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high diversity or marginal gains)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with a bias towards those with high marginal gains)\n    # 2. Apply a greedy improvement step to ensure feasibility and quality\n\n    # Step 1: Random flip with bias\n    flip_prob = 0.3  # Probability of flipping an item\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Greedy improvement\n    # Sort items by the ratio of (value1 + value2) / weight to prioritize high-value items\n    item_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(item_ratios)[::-1]\n\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Try adding the highest-value item if it fits\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif new_solution[i] == 1:\n            # Try removing the lowest-value item to free up space\n            # (This is a simplified approach; a more sophisticated method could be used)\n            if np.sum(new_solution) > 1:  # Don't remove the last item\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.5099099577336605,
            4.556757807731628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high diversity or marginal gains)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (with a bias towards those with high marginal gains)\n    # 2. Apply a greedy improvement step to ensure feasibility and quality\n\n    # Step 1: Random flip with bias\n    flip_prob = 0.3  # Probability of flipping an item\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # Try removing the item\n                if current_weight - weight_lst[i] >= 0:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # Try adding the item\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # Step 2: Greedy improvement\n    # Sort items by the ratio of (value1 + value2) / weight to prioritize high-value items\n    item_ratios = (value1_lst + value2_lst) / weight_lst\n    sorted_indices = np.argsort(item_ratios)[::-1]\n\n    for i in sorted_indices:\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Try adding the highest-value item if it fits\n            new_solution[i] = 1\n            current_weight += weight_lst[i]\n        elif new_solution[i] == 1:\n            # Try removing the lowest-value item to free up space\n            # (This is a simplified approach; a more sophisticated method could be used)\n            if np.sum(new_solution) > 1:  # Don't remove the last item\n                new_solution[i] = 0\n                current_weight -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 258,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate a candidate solution by flipping a subset of items\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Determine the number of items to flip (between 1 and 5)\n    flip_count = random.randint(1, min(5, n_items))\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal contributions into a single score\n    marginal_score = marginal_value1 + marginal_value2\n\n    # Select items to flip based on marginal score and current inclusion status\n    candidate_indices = np.argsort(marginal_score)[::-1]  # Sort in descending order\n    flip_indices = []\n\n    for idx in candidate_indices:\n        if len(flip_indices) >= flip_count:\n            break\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it\n            if current_weight - weight_lst[idx] <= capacity:\n                flip_indices.append(idx)\n        else:\n            # If item is not included, consider adding it\n            if current_weight + weight_lst[idx] <= capacity:\n                flip_indices.append(idx)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure the solution is feasible (in case of rounding errors)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If not feasible, remove the heaviest items until feasible\n        heavy_indices = np.argsort(weight_lst * new_solution)[::-1]\n        for idx in heavy_indices:\n            if new_weight <= capacity:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                new_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.9192569476276387,
            1.0614906549453735
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution, _ = archive[selected_idx]\n    base_solution = selected_solution.copy()\n\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * base_solution)\n    current_value1 = np.sum(value1_lst * base_solution)\n    current_value2 = np.sum(value2_lst * base_solution)\n\n    # Generate a candidate solution by flipping a subset of items\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Determine the number of items to flip (between 1 and 5)\n    flip_count = random.randint(1, min(5, n_items))\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Combine marginal contributions into a single score\n    marginal_score = marginal_value1 + marginal_value2\n\n    # Select items to flip based on marginal score and current inclusion status\n    candidate_indices = np.argsort(marginal_score)[::-1]  # Sort in descending order\n    flip_indices = []\n\n    for idx in candidate_indices:\n        if len(flip_indices) >= flip_count:\n            break\n        if base_solution[idx] == 1:\n            # If item is included, consider removing it\n            if current_weight - weight_lst[idx] <= capacity:\n                flip_indices.append(idx)\n        else:\n            # If item is not included, consider adding it\n            if current_weight + weight_lst[idx] <= capacity:\n                flip_indices.append(idx)\n\n    # Flip the selected items\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure the solution is feasible (in case of rounding errors)\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If not feasible, remove the heaviest items until feasible\n        heavy_indices = np.argsort(weight_lst * new_solution)[::-1]\n        for idx in heavy_indices:\n            if new_weight <= capacity:\n                break\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                new_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 259,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution: prioritize those with high values but not too close to capacity\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, v1 + v2, total_weight))\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback to first solution if no valid candidates\n\n    # Sort candidates by combined value (v1 + v2) in descending order, then by weight proximity to capacity\n    candidates.sort(key=lambda x: (-x[1], abs(x[2] - capacity)))\n\n    # Select top 30% of candidates for further consideration\n    top_candidates = candidates[:max(1, int(len(candidates) * 0.3))]\n    selected_sol = random.choice(top_candidates)[0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Strategy 1: Random swaps (2-opt but with multiple swaps)\n    for _ in range(min(3, n_items // 2)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Targeted flips (flip items with high marginal gain)\n    marginal_gain1 = value1_lst - (value1_lst * new_solution)\n    marginal_gain2 = value2_lst - (value2_lst * new_solution)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain\n    sorted_indices = np.argsort(combined_gain)[::-1]\n    for idx in sorted_indices[:min(3, len(sorted_indices))]:\n        if new_solution[idx] == 0:\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                break\n\n    # Strategy 3: Weight-balanced perturbation (remove items to free up space for better items)\n    if np.sum(weight_lst * new_solution) > capacity * 0.9:\n        # Remove items with lowest combined value-to-weight ratio\n        value_to_weight = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_to_weight)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.43396804062711364,
            7.231894761323929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution: prioritize those with high values but not too close to capacity\n    candidates = []\n    for sol, (v1, v2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, v1 + v2, total_weight))\n\n    if not candidates:\n        return archive[0][0].copy()  # Fallback to first solution if no valid candidates\n\n    # Sort candidates by combined value (v1 + v2) in descending order, then by weight proximity to capacity\n    candidates.sort(key=lambda x: (-x[1], abs(x[2] - capacity)))\n\n    # Select top 30% of candidates for further consideration\n    top_candidates = candidates[:max(1, int(len(candidates) * 0.3))]\n    selected_sol = random.choice(top_candidates)[0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_sol.copy()\n    n_items = len(new_solution)\n\n    # Strategy 1: Random swaps (2-opt but with multiple swaps)\n    for _ in range(min(3, n_items // 2)):\n        i, j = random.sample(range(n_items), 2)\n        if new_solution[i] != new_solution[j]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Strategy 2: Targeted flips (flip items with high marginal gain)\n    marginal_gain1 = value1_lst - (value1_lst * new_solution)\n    marginal_gain2 = value2_lst - (value2_lst * new_solution)\n    combined_gain = marginal_gain1 + marginal_gain2\n\n    # Sort items by combined marginal gain\n    sorted_indices = np.argsort(combined_gain)[::-1]\n    for idx in sorted_indices[:min(3, len(sorted_indices))]:\n        if new_solution[idx] == 0:\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                break\n\n    # Strategy 3: Weight-balanced perturbation (remove items to free up space for better items)\n    if np.sum(weight_lst * new_solution) > capacity * 0.9:\n        # Remove items with lowest combined value-to-weight ratio\n        value_to_weight = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(value_to_weight)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 260,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Intelligently select a promising solution\n    # Prioritize solutions with high potential for improvement (e.g., solutions near the Pareto front)\n    # Here, we select the solution with the highest sum of normalized objective values\n    normalized_objectives = np.array([(v1 / np.max(value1_lst), v2 / np.max(value2_lst)) for _, (v1, v2) in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Hybrid of flip-based and swap-based moves to explore the search space more effectively\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Flip-based move: Randomly flip a subset of items\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Swap-based move: Randomly swap two items if feasible\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility of swap\n            current_weight = np.sum(new_solution * weight_lst)\n            delta_weight = (new_solution[j] - new_solution[i]) * (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Ensure feasibility (fallback to base solution if infeasible)\n    if np.sum(new_solution * weight_lst) > capacity:\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.32367333316955543,
            5.515802472829819
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Intelligently select a promising solution\n    # Prioritize solutions with high potential for improvement (e.g., solutions near the Pareto front)\n    # Here, we select the solution with the highest sum of normalized objective values\n    normalized_objectives = np.array([(v1 / np.max(value1_lst), v2 / np.max(value2_lst)) for _, (v1, v2) in archive])\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    # Hybrid of flip-based and swap-based moves to explore the search space more effectively\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n\n    # Flip-based move: Randomly flip a subset of items\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            if np.sum(new_solution * weight_lst) - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n        else:\n            if np.sum(new_solution * weight_lst) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Swap-based move: Randomly swap two items if feasible\n    if n_items >= 2:\n        i, j = np.random.choice(n_items, size=2, replace=False)\n        if new_solution[i] != new_solution[j]:\n            # Check feasibility of swap\n            current_weight = np.sum(new_solution * weight_lst)\n            delta_weight = (new_solution[j] - new_solution[i]) * (weight_lst[i] - weight_lst[j])\n            if current_weight + delta_weight <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Ensure feasibility (fallback to base solution if infeasible)\n    if np.sum(new_solution * weight_lst) > capacity:\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 261,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        ranks = [i for i in range(len(archive))]\n        selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a few bits (with probability inversely proportional to their weight)\n    flip_prob = 0.2\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # If item is included, try to remove it (if feasible)\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If item is excluded, try to include it (if feasible)\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # 2. Add high-value items that are not in the solution and fit within capacity\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value-to-weight ratios for objective 1 and 2\n        value1_ratio = value1_lst / (weight_lst + 1e-10)\n        value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios for multi-objective consideration\n        combined_ratio = value1_ratio + value2_ratio\n\n        # Create a list of candidate items to add\n        candidates = [(i, combined_ratio[i]) for i in range(len(new_solution)) if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity]\n        candidates.sort(key=lambda x: -x[1])  # Sort by descending ratio\n\n        # Add top candidates that fit\n        for i, _ in candidates:\n            if weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4110919980795083,
            1.90880486369133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        ranks = [i for i in range(len(archive))]\n        selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a few bits (with probability inversely proportional to their weight)\n    flip_prob = 0.2\n    for i in range(len(new_solution)):\n        if random.random() < flip_prob:\n            if new_solution[i] == 1:\n                # If item is included, try to remove it (if feasible)\n                if current_weight - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n                    current_weight -= weight_lst[i]\n            else:\n                # If item is excluded, try to include it (if feasible)\n                if current_weight + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n                    current_weight += weight_lst[i]\n\n    # 2. Add high-value items that are not in the solution and fit within capacity\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate value-to-weight ratios for objective 1 and 2\n        value1_ratio = value1_lst / (weight_lst + 1e-10)\n        value2_ratio = value2_lst / (weight_lst + 1e-10)\n\n        # Combine ratios for multi-objective consideration\n        combined_ratio = value1_ratio + value2_ratio\n\n        # Create a list of candidate items to add\n        candidates = [(i, combined_ratio[i]) for i in range(len(new_solution)) if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity]\n        candidates.sort(key=lambda x: -x[1])  # Sort by descending ratio\n\n        # Add top candidates that fit\n        for i, _ in candidates:\n            if weight_lst[i] <= remaining_capacity:\n                new_solution[i] = 1\n                remaining_capacity -= weight_lst[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 262,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with high potential for improvement\n    # We define potential as the solution being non-dominated and having some items that could be flipped\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity:\n            # Calculate potential by considering the number of items that could be added without exceeding capacity\n            remaining_capacity = capacity - current_weight\n            potential_items = (weight_lst <= remaining_capacity) & (sol == 0)\n            potential = np.sum(potential_items)\n            candidates.append((sol, potential))\n\n    if not candidates:\n        # If no candidates, randomly select a solution and try to fix it\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select the solution with the highest potential\n        base_solution, _ = max(candidates, key=lambda x: x[1])\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for flipping\n    # 2. For each selected item, decide to flip it based on a combination of:\n    #    - Its contribution to the objectives\n    #    - Its weight\n    #    - The current solution's objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Determine the number of items to consider for flipping\n    n_items = len(weight_lst)\n    n_flip_candidates = min(5, n_items)  # Consider up to 5 items to flip\n    flip_indices = np.random.choice(n_items, size=n_flip_candidates, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, consider removing it if it has low marginal contribution\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n            marginal_weight = weight_lst[idx]\n\n            # Decide to remove based on a combination of factors\n            remove_prob = 0.5 * (1 - marginal_value1 / (current_value1 + 1e-6)) + \\\n                         0.5 * (1 - marginal_value2 / (current_value2 + 1e-6))\n            if random.random() < remove_prob:\n                new_solution[idx] = 0\n                current_weight -= marginal_weight\n                current_value1 -= marginal_value1\n                current_value2 -= marginal_value2\n        else:\n            # If the item is not included, consider adding it if it fits and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity:\n                add_prob = 0.5 * (value1_lst[idx] / (current_value1 + 1e-6)) + \\\n                           0.5 * (value2_lst[idx] / (current_value2 + 1e-6))\n                if random.random() < add_prob:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_value1 += value1_lst[idx]\n                    current_value2 += value2_lst[idx]\n\n    # Ensure the solution is feasible (this is a safeguard)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, randomly remove items until it is feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = np.random.choice(included_items)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.766506699006235,
            3.8965564370155334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards those with high potential for improvement\n    # We define potential as the solution being non-dominated and having some items that could be flipped\n    candidates = []\n    for sol, _ in archive:\n        current_weight = np.sum(weight_lst * sol)\n        if current_weight < capacity:\n            # Calculate potential by considering the number of items that could be added without exceeding capacity\n            remaining_capacity = capacity - current_weight\n            potential_items = (weight_lst <= remaining_capacity) & (sol == 0)\n            potential = np.sum(potential_items)\n            candidates.append((sol, potential))\n\n    if not candidates:\n        # If no candidates, randomly select a solution and try to fix it\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Select the solution with the highest potential\n        base_solution, _ = max(candidates, key=lambda x: x[1])\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to consider for flipping\n    # 2. For each selected item, decide to flip it based on a combination of:\n    #    - Its contribution to the objectives\n    #    - Its weight\n    #    - The current solution's objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    current_value1 = np.sum(value1_lst * new_solution)\n    current_value2 = np.sum(value2_lst * new_solution)\n\n    # Determine the number of items to consider for flipping\n    n_items = len(weight_lst)\n    n_flip_candidates = min(5, n_items)  # Consider up to 5 items to flip\n    flip_indices = np.random.choice(n_items, size=n_flip_candidates, replace=False)\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If the item is included, consider removing it if it has low marginal contribution\n            marginal_value1 = value1_lst[idx]\n            marginal_value2 = value2_lst[idx]\n            marginal_weight = weight_lst[idx]\n\n            # Decide to remove based on a combination of factors\n            remove_prob = 0.5 * (1 - marginal_value1 / (current_value1 + 1e-6)) + \\\n                         0.5 * (1 - marginal_value2 / (current_value2 + 1e-6))\n            if random.random() < remove_prob:\n                new_solution[idx] = 0\n                current_weight -= marginal_weight\n                current_value1 -= marginal_value1\n                current_value2 -= marginal_value2\n        else:\n            # If the item is not included, consider adding it if it fits and improves both objectives\n            if current_weight + weight_lst[idx] <= capacity:\n                add_prob = 0.5 * (value1_lst[idx] / (current_value1 + 1e-6)) + \\\n                           0.5 * (value2_lst[idx] / (current_value2 + 1e-6))\n                if random.random() < add_prob:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_value1 += value1_lst[idx]\n                    current_value2 += value2_lst[idx]\n\n    # Ensure the solution is feasible (this is a safeguard)\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If not feasible, randomly remove items until it is feasible\n        excess = total_weight - capacity\n        while excess > 0:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            remove_idx = np.random.choice(included_items)\n            new_solution[remove_idx] = 0\n            excess -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 263,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            # Prefer solutions that are not fully packed\n            candidates.append(sol)\n\n    if not candidates:\n        # If no candidates, fall back to random selection\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip followed by objective-driven flip\n    n_items = len(base_solution)\n\n    # Step 1: Random flip to escape local optima\n    if n_items > 1:\n        flip_index = random.randint(0, n_items - 1)\n        new_solution[flip_index] = 1 - new_solution[flip_index]\n\n        # Ensure feasibility after random flip\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            # Remove an item to make it feasible\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) > 0:\n                remove_index = random.choice(items_in)\n                new_solution[remove_index] = 0\n\n    # Step 2: Objective-driven flip to improve both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate potential improvements\n    items_out = np.where(new_solution == 0)[0]\n    items_in = np.where(new_solution == 1)[0]\n\n    # Calculate potential additions (items not in the solution)\n    if len(items_out) > 0:\n        potential_additions = []\n        for idx in items_out:\n            if weight_lst[idx] <= remaining_capacity:\n                # Calculate improvement in both objectives\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                potential_additions.append((idx, improvement1, improvement2))\n\n        if potential_additions:\n            # Select the item that improves both objectives most\n            best_addition = max(potential_additions, key=lambda x: (x[1] + x[2]))\n            new_solution[best_addition[0]] = 1\n\n    # Calculate potential removals (items in the solution)\n    if len(items_in) > 0:\n        potential_removals = []\n        for idx in items_in:\n            # Calculate degradation in both objectives\n            degradation1 = value1_lst[idx]\n            degradation2 = value2_lst[idx]\n            potential_removals.append((idx, degradation1, degradation2))\n\n        # Select the item that degrades both objectives least\n        best_removal = min(potential_removals, key=lambda x: (x[1] + x[2]))\n        new_solution[best_removal[0]] = 0\n\n        # Ensure feasibility after removal\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            # Remove another item to make it feasible\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) > 0:\n                remove_index = random.choice(items_in)\n                new_solution[remove_index] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3716828043515498,
            2.0224741995334625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight < capacity:\n            # Prefer solutions that are not fully packed\n            candidates.append(sol)\n\n    if not candidates:\n        # If no candidates, fall back to random selection\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flip followed by objective-driven flip\n    n_items = len(base_solution)\n\n    # Step 1: Random flip to escape local optima\n    if n_items > 1:\n        flip_index = random.randint(0, n_items - 1)\n        new_solution[flip_index] = 1 - new_solution[flip_index]\n\n        # Ensure feasibility after random flip\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            # Remove an item to make it feasible\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) > 0:\n                remove_index = random.choice(items_in)\n                new_solution[remove_index] = 0\n\n    # Step 2: Objective-driven flip to improve both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate potential improvements\n    items_out = np.where(new_solution == 0)[0]\n    items_in = np.where(new_solution == 1)[0]\n\n    # Calculate potential additions (items not in the solution)\n    if len(items_out) > 0:\n        potential_additions = []\n        for idx in items_out:\n            if weight_lst[idx] <= remaining_capacity:\n                # Calculate improvement in both objectives\n                improvement1 = value1_lst[idx]\n                improvement2 = value2_lst[idx]\n                potential_additions.append((idx, improvement1, improvement2))\n\n        if potential_additions:\n            # Select the item that improves both objectives most\n            best_addition = max(potential_additions, key=lambda x: (x[1] + x[2]))\n            new_solution[best_addition[0]] = 1\n\n    # Calculate potential removals (items in the solution)\n    if len(items_in) > 0:\n        potential_removals = []\n        for idx in items_in:\n            # Calculate degradation in both objectives\n            degradation1 = value1_lst[idx]\n            degradation2 = value2_lst[idx]\n            potential_removals.append((idx, degradation1, degradation2))\n\n        # Select the item that degrades both objectives least\n        best_removal = min(potential_removals, key=lambda x: (x[1] + x[2]))\n        new_solution[best_removal[0]] = 0\n\n        # Ensure feasibility after removal\n        current_weight = np.sum(weight_lst * new_solution)\n        if current_weight > capacity:\n            # Remove another item to make it feasible\n            items_in = np.where(new_solution == 1)[0]\n            if len(items_in) > 0:\n                remove_index = random.choice(items_in)\n                new_solution[remove_index] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 264,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Rank solutions by their dominance and select a promising one\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine random swaps and value-based flips\n    new_solution = base_solution.copy()\n\n    # Random swap: exchange two items\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility after swap\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items with the smallest value-to-weight ratio until feasible\n        while new_weight > capacity:\n            item_indices = np.where(new_solution == 1)[0]\n            if len(item_indices) == 0:\n                break\n            # Calculate value-to-weight ratio for both objectives\n            v1_ratio = value1_lst[item_indices] / weight_lst[item_indices]\n            v2_ratio = value2_lst[item_indices] / weight_lst[item_indices]\n            combined_ratio = v1_ratio + v2_ratio  # Balance both objectives\n            remove_idx = item_indices[np.argmin(combined_ratio)]\n            new_solution[remove_idx] = 0\n            new_weight -= weight_lst[remove_idx]\n\n    # Value-based flip: flip items with high value-to-weight ratio if not included\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            # Calculate combined value-to-weight ratio\n            v1_ratio = value1_lst[i] / weight_lst[i]\n            v2_ratio = value2_lst[i] / weight_lst[i]\n            combined_ratio = v1_ratio + v2_ratio\n            if combined_ratio > random.uniform(0.5, 2.0):  # Threshold for inclusion\n                new_solution[i] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.6091810675188782,
            1.3832486271858215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Rank solutions by their dominance and select a promising one\n    selected_idx = random.choices(range(len(archive)), weights=[1 / (i + 1) for i in range(len(archive))], k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: combine random swaps and value-based flips\n    new_solution = base_solution.copy()\n\n    # Random swap: exchange two items\n    if len(new_solution) >= 2:\n        i, j = random.sample(range(len(new_solution)), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility after swap\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # Remove items with the smallest value-to-weight ratio until feasible\n        while new_weight > capacity:\n            item_indices = np.where(new_solution == 1)[0]\n            if len(item_indices) == 0:\n                break\n            # Calculate value-to-weight ratio for both objectives\n            v1_ratio = value1_lst[item_indices] / weight_lst[item_indices]\n            v2_ratio = value2_lst[item_indices] / weight_lst[item_indices]\n            combined_ratio = v1_ratio + v2_ratio  # Balance both objectives\n            remove_idx = item_indices[np.argmin(combined_ratio)]\n            new_solution[remove_idx] = 0\n            new_weight -= weight_lst[remove_idx]\n\n    # Value-based flip: flip items with high value-to-weight ratio if not included\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and (current_weight + weight_lst[i]) <= capacity:\n            # Calculate combined value-to-weight ratio\n            v1_ratio = value1_lst[i] / weight_lst[i]\n            v2_ratio = value2_lst[i] / weight_lst[i]\n            combined_ratio = v1_ratio + v2_ratio\n            if combined_ratio > random.uniform(0.5, 2.0):  # Threshold for inclusion\n                new_solution[i] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 265,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards higher objectives)\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        # Solutions with more room to add items are more promising\n        potential = (capacity - current_weight) / capacity\n        candidates.append((sol, obj, potential))\n\n    # Sort candidates by potential and randomly select a solution with bias towards higher potential\n    candidates.sort(key=lambda x: -x[2])\n    selected_idx = min(int(len(candidates) * 0.3), len(candidates) - 1)  # Top 30% or all if small\n    selected_sol = candidates[random.randint(0, selected_idx)][0]\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: combination of random flip and value-based flip\n    for _ in range(3):  # Perform 3 local search steps\n        # Random flip with probability based on potential\n        if random.random() < 0.7:  # Higher probability for more promising solutions\n            # Randomly select an item to flip\n            item_idx = random.randint(0, len(new_solution) - 1)\n            new_solution[item_idx] = 1 - new_solution[item_idx]\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight > capacity:\n                new_solution[item_idx] = 1 - new_solution[item_idx]  # Revert if infeasible\n        else:\n            # Value-based flip: flip items with high value-to-weight ratio\n            value_ratio1 = value1_lst / (weight_lst + 1e-6)\n            value_ratio2 = value2_lst / (weight_lst + 1e-6)\n            combined_ratio = value_ratio1 + value_ratio2\n\n            # Select top 20% items by combined ratio\n            top_items = np.argsort(combined_ratio)[-max(1, len(combined_ratio) // 5):]\n\n            for item in top_items:\n                if random.random() < 0.5:  # 50% chance to flip each top item\n                    new_solution[item] = 1 - new_solution[item]\n\n                    # Check feasibility\n                    current_weight = np.sum(weight_lst * new_solution)\n                    if current_weight > capacity:\n                        new_solution[item] = 1 - new_solution[item]  # Revert if infeasible\n\n    return new_solution\n\n",
        "score": [
            -0.3578104408683075,
            2.769418329000473
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards higher objectives)\n    candidates = []\n    for sol, obj in archive:\n        current_weight = np.sum(weight_lst * sol)\n        # Solutions with more room to add items are more promising\n        potential = (capacity - current_weight) / capacity\n        candidates.append((sol, obj, potential))\n\n    # Sort candidates by potential and randomly select a solution with bias towards higher potential\n    candidates.sort(key=lambda x: -x[2])\n    selected_idx = min(int(len(candidates) * 0.3), len(candidates) - 1)  # Top 30% or all if small\n    selected_sol = candidates[random.randint(0, selected_idx)][0]\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search: combination of random flip and value-based flip\n    for _ in range(3):  # Perform 3 local search steps\n        # Random flip with probability based on potential\n        if random.random() < 0.7:  # Higher probability for more promising solutions\n            # Randomly select an item to flip\n            item_idx = random.randint(0, len(new_solution) - 1)\n            new_solution[item_idx] = 1 - new_solution[item_idx]\n\n            # Check feasibility\n            current_weight = np.sum(weight_lst * new_solution)\n            if current_weight > capacity:\n                new_solution[item_idx] = 1 - new_solution[item_idx]  # Revert if infeasible\n        else:\n            # Value-based flip: flip items with high value-to-weight ratio\n            value_ratio1 = value1_lst / (weight_lst + 1e-6)\n            value_ratio2 = value2_lst / (weight_lst + 1e-6)\n            combined_ratio = value_ratio1 + value_ratio2\n\n            # Select top 20% items by combined ratio\n            top_items = np.argsort(combined_ratio)[-max(1, len(combined_ratio) // 5):]\n\n            for item in top_items:\n                if random.random() < 0.5:  # 50% chance to flip each top item\n                    new_solution[item] = 1 - new_solution[item]\n\n                    # Check feasibility\n                    current_weight = np.sum(weight_lst * new_solution)\n                    if current_weight > capacity:\n                        new_solution[item] = 1 - new_solution[item]  # Revert if infeasible\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 266,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution\n    # Prioritize solutions with low total weight or high marginal value\n    selected_idx = 0\n    min_weight = np.dot(archive[0][0], weight_lst)\n    max_marginal = (archive[0][1][0] + archive[0][1][1]) / np.sum(archive[0][0])\n\n    for i, (sol, obj) in enumerate(archive):\n        current_weight = np.dot(sol, weight_lst)\n        current_marginal = (obj[0] + obj[1]) / np.sum(sol)\n\n        if current_weight < min_weight or (current_weight == min_weight and current_marginal > max_marginal):\n            selected_idx = i\n            min_weight = current_weight\n            max_marginal = current_marginal\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Option 1: Flip a random item (add/remove)\n    if random.random() < 0.5:\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Option 2: Swap two items (if possible)\n    else:\n        item_indices = np.where(new_solution == 1)[0]\n        if len(item_indices) >= 2:\n            i, j = random.sample(list(item_indices), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply small perturbation (add/remove a random item)\n    if random.random() < 0.3:\n        perturb_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n\n        # Ensure feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.8735208400596961,
            2.6692625880241394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution\n    # Prioritize solutions with low total weight or high marginal value\n    selected_idx = 0\n    min_weight = np.dot(archive[0][0], weight_lst)\n    max_marginal = (archive[0][1][0] + archive[0][1][1]) / np.sum(archive[0][0])\n\n    for i, (sol, obj) in enumerate(archive):\n        current_weight = np.dot(sol, weight_lst)\n        current_marginal = (obj[0] + obj[1]) / np.sum(sol)\n\n        if current_weight < min_weight or (current_weight == min_weight and current_marginal > max_marginal):\n            selected_idx = i\n            min_weight = current_weight\n            max_marginal = current_marginal\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    # Option 1: Flip a random item (add/remove)\n    if random.random() < 0.5:\n        flip_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n        # Ensure feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            new_solution[flip_idx] = 1 - new_solution[flip_idx]\n\n    # Option 2: Swap two items (if possible)\n    else:\n        item_indices = np.where(new_solution == 1)[0]\n        if len(item_indices) >= 2:\n            i, j = random.sample(list(item_indices), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Apply small perturbation (add/remove a random item)\n    if random.random() < 0.3:\n        perturb_idx = random.randint(0, len(new_solution) - 1)\n        new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n\n        # Ensure feasibility\n        if np.dot(new_solution, weight_lst) > capacity:\n            new_solution[perturb_idx] = 1 - new_solution[perturb_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 267,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we prioritize solutions with high objective values but also consider diversity\n    candidates = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, val1, val2))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive.\")\n\n    # Select the solution with the highest combined objective value\n    selected = max(candidates, key=lambda x: x[1] + x[2])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: random swap + greedy improvement\n    new_solution = base_solution.copy()\n\n    # Random swap step: flip a random subset of items (up to 5)\n    num_items = len(weight_lst)\n    num_swaps = min(5, num_items)\n    if num_swaps > 0:\n        swap_indices = random.sample(range(num_items), num_swaps)\n        for idx in swap_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Greedy improvement step: add or remove items to improve both objectives\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_val1 = np.sum(value1_lst * new_solution)\n    current_val2 = np.sum(value2_lst * new_solution)\n\n    # Try to add items not in the solution\n    for i in range(num_items):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_weight = current_weight + weight_lst[i]\n            new_val1 = current_val1 + value1_lst[i]\n            new_val2 = current_val2 + value2_lst[i]\n\n            # Check if adding the item improves both objectives\n            if new_val1 > current_val1 and new_val2 > current_val2:\n                new_solution[i] = 1\n                current_weight = new_weight\n                current_val1 = new_val1\n                current_val2 = new_val2\n\n    # Try to remove items in the solution\n    for i in range(num_items):\n        if new_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n            new_val1 = current_val1 - value1_lst[i]\n            new_val2 = current_val2 - value2_lst[i]\n\n            # Check if removing the item doesn't worsen both objectives\n            if new_val1 >= current_val1 - value1_lst[i] and new_val2 >= current_val2 - value2_lst[i]:\n                new_solution[i] = 0\n                current_weight = new_weight\n                current_val1 = new_val1\n                current_val2 = new_val2\n\n    return new_solution\n\n",
        "score": [
            -0.8925489605708492,
            3.208579510450363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Here, we prioritize solutions with high objective values but also consider diversity\n    candidates = []\n    for sol, (val1, val2) in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight <= capacity:\n            candidates.append((sol, val1, val2))\n\n    if not candidates:\n        raise ValueError(\"No feasible solutions in archive.\")\n\n    # Select the solution with the highest combined objective value\n    selected = max(candidates, key=lambda x: x[1] + x[2])\n    base_solution = selected[0].copy()\n\n    # Hybrid local search: random swap + greedy improvement\n    new_solution = base_solution.copy()\n\n    # Random swap step: flip a random subset of items (up to 5)\n    num_items = len(weight_lst)\n    num_swaps = min(5, num_items)\n    if num_swaps > 0:\n        swap_indices = random.sample(range(num_items), num_swaps)\n        for idx in swap_indices:\n            new_solution[idx] = 1 - new_solution[idx]\n\n    # Greedy improvement step: add or remove items to improve both objectives\n    # Calculate current total weight and values\n    current_weight = np.sum(weight_lst * new_solution)\n    current_val1 = np.sum(value1_lst * new_solution)\n    current_val2 = np.sum(value2_lst * new_solution)\n\n    # Try to add items not in the solution\n    for i in range(num_items):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            new_weight = current_weight + weight_lst[i]\n            new_val1 = current_val1 + value1_lst[i]\n            new_val2 = current_val2 + value2_lst[i]\n\n            # Check if adding the item improves both objectives\n            if new_val1 > current_val1 and new_val2 > current_val2:\n                new_solution[i] = 1\n                current_weight = new_weight\n                current_val1 = new_val1\n                current_val2 = new_val2\n\n    # Try to remove items in the solution\n    for i in range(num_items):\n        if new_solution[i] == 1:\n            new_weight = current_weight - weight_lst[i]\n            new_val1 = current_val1 - value1_lst[i]\n            new_val2 = current_val2 - value2_lst[i]\n\n            # Check if removing the item doesn't worsen both objectives\n            if new_val1 >= current_val1 - value1_lst[i] and new_val2 >= current_val2 - value2_lst[i]:\n                new_solution[i] = 0\n                current_weight = new_weight\n                current_val1 = new_val1\n                current_val2 = new_val2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 268,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Criteria: solutions with items that have high marginal value-to-weight ratios in either objective\n    def potential_score(solution):\n        included = solution == 1\n        excluded = solution == 0\n        # Calculate marginal value-to-weight ratios for excluded items\n        if np.sum(excluded) == 0:\n            return 0\n        marginal_v1 = value1_lst[excluded] / weight_lst[excluded]\n        marginal_v2 = value2_lst[excluded] / weight_lst[excluded]\n        # Use both objectives to determine potential\n        return np.max(marginal_v1) + np.max(marginal_v2)\n\n    # Select top 3 solutions with highest potential\n    top_solutions = sorted(archive, key=lambda x: potential_score(x[0]), reverse=True)[:3]\n    if not top_solutions:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(top_solutions)[0].copy()\n\n    # Hybrid local search strategy: combination of flip, swap, and shift operations\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly choose one of the three operations\n    operation = random.choice(['flip', 'swap', 'shift'])\n\n    if operation == 'flip':\n        # Flip operation: randomly select an item to flip (include/exclude)\n        candidates = np.where(new_solution != selected_solution)[0]\n        if len(candidates) > 0:\n            idx = random.choice(candidates)\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    elif operation == 'swap':\n        # Swap operation: swap two items (one included, one excluded)\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operation == 'shift':\n        # Shift operation: move a subset of items between included and excluded\n        # Select a random contiguous block of items to flip\n        n = len(new_solution)\n        if n > 1:\n            start = random.randint(0, n-2)\n            end = random.randint(start+1, n-1)\n            block = new_solution[start:end+1]\n            block_weight = np.sum(weight_lst[start:end+1][block == 1])\n            block_weight_change = np.sum(weight_lst[start:end+1][block == 0]) - block_weight\n            if current_weight + block_weight_change <= capacity:\n                new_solution[start:end+1] = 1 - block\n\n    return new_solution\n\n",
        "score": [
            -0.7120191204162746,
            7.8800550401210785
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Criteria: solutions with items that have high marginal value-to-weight ratios in either objective\n    def potential_score(solution):\n        included = solution == 1\n        excluded = solution == 0\n        # Calculate marginal value-to-weight ratios for excluded items\n        if np.sum(excluded) == 0:\n            return 0\n        marginal_v1 = value1_lst[excluded] / weight_lst[excluded]\n        marginal_v2 = value2_lst[excluded] / weight_lst[excluded]\n        # Use both objectives to determine potential\n        return np.max(marginal_v1) + np.max(marginal_v2)\n\n    # Select top 3 solutions with highest potential\n    top_solutions = sorted(archive, key=lambda x: potential_score(x[0]), reverse=True)[:3]\n    if not top_solutions:\n        selected_solution = random.choice(archive)[0].copy()\n    else:\n        selected_solution = random.choice(top_solutions)[0].copy()\n\n    # Hybrid local search strategy: combination of flip, swap, and shift operations\n    new_solution = selected_solution.copy()\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Randomly choose one of the three operations\n    operation = random.choice(['flip', 'swap', 'shift'])\n\n    if operation == 'flip':\n        # Flip operation: randomly select an item to flip (include/exclude)\n        candidates = np.where(new_solution != selected_solution)[0]\n        if len(candidates) > 0:\n            idx = random.choice(candidates)\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n\n    elif operation == 'swap':\n        # Swap operation: swap two items (one included, one excluded)\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n        if len(included) > 0 and len(excluded) > 0:\n            i = random.choice(included)\n            j = random.choice(excluded)\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    elif operation == 'shift':\n        # Shift operation: move a subset of items between included and excluded\n        # Select a random contiguous block of items to flip\n        n = len(new_solution)\n        if n > 1:\n            start = random.randint(0, n-2)\n            end = random.randint(start+1, n-1)\n            block = new_solution[start:end+1]\n            block_weight = np.sum(weight_lst[start:end+1][block == 1])\n            block_weight_change = np.sum(weight_lst[start:end+1][block == 0]) - block_weight\n            if current_weight + block_weight_change <= capacity:\n                new_solution[start:end+1] = 1 - block\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 269,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too dense or too sparse)\n    current_weights = [np.sum(sol[0] * weight_lst) for sol in archive]\n    current_densities = [w / capacity for w in current_weights]\n    # Prioritize solutions with moderate density (not too full or too empty)\n    selected_idx = np.argmin(np.abs(np.array(current_densities) - 0.5))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a random subset of items\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items at random\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: try to add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n    for idx in remaining_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.48637988547522376,
            3.391282945871353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too dense or too sparse)\n    current_weights = [np.sum(sol[0] * weight_lst) for sol in archive]\n    current_densities = [w / capacity for w in current_weights]\n    # Prioritize solutions with moderate density (not too full or too empty)\n    selected_idx = np.argmin(np.abs(np.array(current_densities) - 0.5))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor by flipping a random subset of items\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n    flip_indices = random.sample(range(n_items), min(3, n_items))  # Flip up to 3 items at random\n\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            current_weight = np.sum(new_solution * weight_lst)\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n\n    # Greedy improvement: try to add items that improve both objectives\n    remaining_items = np.where(new_solution == 0)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n    for idx in remaining_items:\n        if current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 270,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on the highest sum of normalized objectives\n    normalized_scores = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / max(value1_lst.sum(), 1e-6), obj[1] / max(value2_lst.sum(), 1e-6))\n        normalized_scores.append(norm_obj[0] + norm_obj[1])\n\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items with high marginal value and ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n\n    # Identify items with high marginal value (normalized by weight)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value in descending order\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Try to flip top-k items to improve both objectives\n    k = min(5, len(sorted_indices))  # Limit the number of flips to avoid excessive changes\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                total_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                total_weight = new_weight\n\n    # Randomly flip one more item to ensure diversity\n    if len(sorted_indices) > k:\n        random_idx = np.random.choice(sorted_indices[k:])\n        if new_solution[random_idx] == 1:\n            new_weight = total_weight - weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            new_weight = total_weight + weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8223810894086712,
            1.7857257425785065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on the highest sum of normalized objectives\n    normalized_scores = []\n    for sol, obj in archive:\n        norm_obj = (obj[0] / max(value1_lst.sum(), 1e-6), obj[1] / max(value2_lst.sum(), 1e-6))\n        normalized_scores.append(norm_obj[0] + norm_obj[1])\n\n    selected_idx = np.argmax(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items with high marginal value and ensure feasibility\n    total_weight = np.dot(new_solution, weight_lst)\n\n    # Identify items with high marginal value (normalized by weight)\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n    combined_marginal = marginal_value1 + marginal_value2\n\n    # Sort items by combined marginal value in descending order\n    sorted_indices = np.argsort(-combined_marginal)\n\n    # Try to flip top-k items to improve both objectives\n    k = min(5, len(sorted_indices))  # Limit the number of flips to avoid excessive changes\n    for idx in sorted_indices[:k]:\n        if new_solution[idx] == 1:\n            # Try removing the item\n            new_weight = total_weight - weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 0\n                total_weight = new_weight\n        else:\n            # Try adding the item\n            new_weight = total_weight + weight_lst[idx]\n            if new_weight <= capacity:\n                new_solution[idx] = 1\n                total_weight = new_weight\n\n    # Randomly flip one more item to ensure diversity\n    if len(sorted_indices) > k:\n        random_idx = np.random.choice(sorted_indices[k:])\n        if new_solution[random_idx] == 1:\n            new_weight = total_weight - weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 0\n        else:\n            new_weight = total_weight + weight_lst[random_idx]\n            if new_weight <= capacity:\n                new_solution[random_idx] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 271,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to consider for swaps\n    num_items = len(weight_lst)\n    swap_candidates = np.random.choice(num_items, size=min(10, num_items), replace=False)\n\n    # Perform hybrid local search: objective-aware swaps and random flips\n    for item in swap_candidates:\n        # Objective-aware swap: prefer items that improve at least one objective\n        if np.random.rand() < 0.7:  # Higher probability for objective-aware swaps\n            if base_solution[item] == 1:\n                # Try to remove the item if it doesn't significantly degrade both objectives\n                if (current_value1 - value1_lst[item] > 0) or (current_value2 - value2_lst[item] > 0):\n                    new_solution[item] = 0\n                    current_value1 -= value1_lst[item]\n                    current_value2 -= value2_lst[item]\n            else:\n                # Try to add the item if it doesn't violate capacity and improves at least one objective\n                if (np.sum(new_solution * weight_lst) + weight_lst[item] <= capacity) and \\\n                   ((value1_lst[item] > 0) or (value2_lst[item] > 0)):\n                    new_solution[item] = 1\n                    current_value1 += value1_lst[item]\n                    current_value2 += value2_lst[item]\n        else:\n            # Random flip with probability based on current state\n            flip_prob = 0.3 if base_solution[item] == 1 else 0.5\n            if np.random.rand() < flip_prob:\n                if base_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_value1 -= value1_lst[item]\n                    current_value2 -= value2_lst[item]\n                else:\n                    if np.sum(new_solution * weight_lst) + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_value1 += value1_lst[item]\n                        current_value2 += value2_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.37230649241344427,
            1.3809540569782257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Initialize neighbor solution\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of items to consider for swaps\n    num_items = len(weight_lst)\n    swap_candidates = np.random.choice(num_items, size=min(10, num_items), replace=False)\n\n    # Perform hybrid local search: objective-aware swaps and random flips\n    for item in swap_candidates:\n        # Objective-aware swap: prefer items that improve at least one objective\n        if np.random.rand() < 0.7:  # Higher probability for objective-aware swaps\n            if base_solution[item] == 1:\n                # Try to remove the item if it doesn't significantly degrade both objectives\n                if (current_value1 - value1_lst[item] > 0) or (current_value2 - value2_lst[item] > 0):\n                    new_solution[item] = 0\n                    current_value1 -= value1_lst[item]\n                    current_value2 -= value2_lst[item]\n            else:\n                # Try to add the item if it doesn't violate capacity and improves at least one objective\n                if (np.sum(new_solution * weight_lst) + weight_lst[item] <= capacity) and \\\n                   ((value1_lst[item] > 0) or (value2_lst[item] > 0)):\n                    new_solution[item] = 1\n                    current_value1 += value1_lst[item]\n                    current_value2 += value2_lst[item]\n        else:\n            # Random flip with probability based on current state\n            flip_prob = 0.3 if base_solution[item] == 1 else 0.5\n            if np.random.rand() < flip_prob:\n                if base_solution[item] == 1:\n                    new_solution[item] = 0\n                    current_value1 -= value1_lst[item]\n                    current_value2 -= value2_lst[item]\n                else:\n                    if np.sum(new_solution * weight_lst) + weight_lst[item] <= capacity:\n                        new_solution[item] = 1\n                        current_value1 += value1_lst[item]\n                        current_value2 += value2_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 272,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 10% of solutions\n        top_percent = max(1, len(archive_sorted) // 10)\n        selected_solutions = archive_sorted[:top_percent]\n        # Randomly select one from the top solutions\n        base_solution, _ = random.choice(selected_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip, swap, and biased flip\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random flip with bias towards improving objectives\n    for _ in range(3):  # Try multiple flips\n        # Select a random item to flip\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, try to include it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Perform a swap operation if possible\n    if len(new_solution) > 1:\n        # Find two items to swap\n        indices = np.where(new_solution == 1)[0]\n        if len(indices) >= 2:\n            i, j = random.sample(list(indices), 2)\n            # Check if swap is feasible\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Biased flip: flip items with high marginal value ratios\n    if random.random() < 0.3:  # 30% chance of performing this operation\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(-value_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2750865450776676,
            1.5569219589233398
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives\n        archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n        # Select top 10% of solutions\n        top_percent = max(1, len(archive_sorted) // 10)\n        selected_solutions = archive_sorted[:top_percent]\n        # Randomly select one from the top solutions\n        base_solution, _ = random.choice(selected_solutions)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip, swap, and biased flip\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random flip with bias towards improving objectives\n    for _ in range(3):  # Try multiple flips\n        # Select a random item to flip\n        idx = random.randint(0, len(new_solution) - 1)\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, try to include it\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Perform a swap operation if possible\n    if len(new_solution) > 1:\n        # Find two items to swap\n        indices = np.where(new_solution == 1)[0]\n        if len(indices) >= 2:\n            i, j = random.sample(list(indices), 2)\n            # Check if swap is feasible\n            if current_weight - weight_lst[i] + weight_lst[j] <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Biased flip: flip items with high marginal value ratios\n    if random.random() < 0.3:  # 30% chance of performing this operation\n        value_ratios = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        sorted_indices = np.argsort(-value_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                if current_weight - weight_lst[idx] <= capacity:\n                    new_solution[idx] = 0\n                    current_weight -= weight_lst[idx]\n            else:\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 273,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Hybrid local search: combine random swaps with value-to-weight heuristic\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate potential changes in weight and value\n        delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] else (weight_lst[item1] - weight_lst[item2])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap if it improves at least one objective\n            delta_value1 = (value1_lst[item2] - value1_lst[item1]) if new_solution[item1] else (value1_lst[item1] - value1_lst[item2])\n            delta_value2 = (value2_lst[item2] - value2_lst[item1]) if new_solution[item1] else (value2_lst[item1] - value2_lst[item2])\n\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = new_weight\n\n    # Additional improvement: add/remove items based on value-to-weight ratios\n    for _ in range(5):\n        # Select an item to potentially add or remove\n        item = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[item]:\n            # Consider removing the item if it's not critical\n            if current_weight - weight_lst[item] >= 0:\n                # Remove if it's not in the top 20% of value-to-weight ratios for either objective\n                if (ratio1[item] < np.percentile(ratio1, 80) and ratio2[item] < np.percentile(ratio2, 80)):\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n        else:\n            # Consider adding the item if it fits\n            if current_weight + weight_lst[item] <= capacity:\n                # Add if it's in the top 20% of value-to-weight ratios for either objective\n                if (ratio1[item] >= np.percentile(ratio1, 80) or ratio2[item] >= np.percentile(ratio2, 80)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n",
        "score": [
            -0.3753380273164596,
            5.852149546146393
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst * base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Hybrid local search: combine random swaps with value-to-weight heuristic\n    for _ in range(10):  # Number of local search iterations\n        # Randomly select two items to swap\n        item1, item2 = random.sample(range(len(weight_lst)), 2)\n\n        # Calculate potential changes in weight and value\n        delta_weight = (weight_lst[item2] - weight_lst[item1]) if new_solution[item1] else (weight_lst[item1] - weight_lst[item2])\n        new_weight = current_weight + delta_weight\n\n        if new_weight <= capacity:\n            # Accept the swap if it improves at least one objective\n            delta_value1 = (value1_lst[item2] - value1_lst[item1]) if new_solution[item1] else (value1_lst[item1] - value1_lst[item2])\n            delta_value2 = (value2_lst[item2] - value2_lst[item1]) if new_solution[item1] else (value2_lst[item1] - value2_lst[item2])\n\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[item1], new_solution[item2] = new_solution[item2], new_solution[item1]\n                current_weight = new_weight\n\n    # Additional improvement: add/remove items based on value-to-weight ratios\n    for _ in range(5):\n        # Select an item to potentially add or remove\n        item = random.randint(0, len(weight_lst) - 1)\n\n        if new_solution[item]:\n            # Consider removing the item if it's not critical\n            if current_weight - weight_lst[item] >= 0:\n                # Remove if it's not in the top 20% of value-to-weight ratios for either objective\n                if (ratio1[item] < np.percentile(ratio1, 80) and ratio2[item] < np.percentile(ratio2, 80)):\n                    new_solution[item] = 0\n                    current_weight -= weight_lst[item]\n        else:\n            # Consider adding the item if it fits\n            if current_weight + weight_lst[item] <= capacity:\n                # Add if it's in the top 20% of value-to-weight ratios for either objective\n                if (ratio1[item] >= np.percentile(ratio1, 80) or ratio2[item] >= np.percentile(ratio2, 80)):\n                    new_solution[item] = 1\n                    current_weight += weight_lst[item]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 274,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards those with higher total value\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items based on a combination of randomness and objective-specific criteria\n    for _ in range(3):  # Number of flips per iteration\n        # Candidate items to flip: those with high value-to-weight ratio or low value-to-weight ratio\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        # Calculate value-to-weight ratios for both objectives\n        value1_ratio = value1_lst / weight_lst\n        value2_ratio = value2_lst / weight_lst\n\n        # Combine ratios with randomness to bias selection\n        combined_ratio = 0.6 * value1_ratio + 0.4 * value2_ratio\n        combined_ratio[excluded_items] *= 1.5  # Increase chance of including promising items\n\n        # Select items to flip based on combined ratio\n        flip_candidates = np.concatenate([included_items, excluded_items])\n        if len(flip_candidates) == 0:\n            break\n\n        # Normalize ratios for probability selection\n        flip_probs = combined_ratio[flip_candidates]\n        flip_probs = np.maximum(flip_probs, 0)  # Ensure non-negative\n        flip_probs = flip_probs / np.sum(flip_probs) if np.sum(flip_probs) > 0 else np.ones_like(flip_probs) / len(flip_probs)\n\n        # Randomly select an item to flip\n        item_to_flip = np.random.choice(flip_candidates, p=flip_probs)\n\n        # Flip the item if it keeps the solution feasible\n        if new_solution[item_to_flip] == 1:\n            if current_weight - weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 0\n                current_weight -= weight_lst[item_to_flip]\n        else:\n            if current_weight + weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 1\n                current_weight += weight_lst[item_to_flip]\n\n    return new_solution\n\n",
        "score": [
            -0.42922353080829423,
            3.0244066417217255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with a bias towards those with higher total value\n    total_values = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_weight = np.sum(weight_lst[base_solution == 1])\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip items based on a combination of randomness and objective-specific criteria\n    for _ in range(3):  # Number of flips per iteration\n        # Candidate items to flip: those with high value-to-weight ratio or low value-to-weight ratio\n        included_items = np.where(new_solution == 1)[0]\n        excluded_items = np.where(new_solution == 0)[0]\n\n        # Calculate value-to-weight ratios for both objectives\n        value1_ratio = value1_lst / weight_lst\n        value2_ratio = value2_lst / weight_lst\n\n        # Combine ratios with randomness to bias selection\n        combined_ratio = 0.6 * value1_ratio + 0.4 * value2_ratio\n        combined_ratio[excluded_items] *= 1.5  # Increase chance of including promising items\n\n        # Select items to flip based on combined ratio\n        flip_candidates = np.concatenate([included_items, excluded_items])\n        if len(flip_candidates) == 0:\n            break\n\n        # Normalize ratios for probability selection\n        flip_probs = combined_ratio[flip_candidates]\n        flip_probs = np.maximum(flip_probs, 0)  # Ensure non-negative\n        flip_probs = flip_probs / np.sum(flip_probs) if np.sum(flip_probs) > 0 else np.ones_like(flip_probs) / len(flip_probs)\n\n        # Randomly select an item to flip\n        item_to_flip = np.random.choice(flip_candidates, p=flip_probs)\n\n        # Flip the item if it keeps the solution feasible\n        if new_solution[item_to_flip] == 1:\n            if current_weight - weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 0\n                current_weight -= weight_lst[item_to_flip]\n        else:\n            if current_weight + weight_lst[item_to_flip] <= capacity:\n                new_solution[item_to_flip] = 1\n                current_weight += weight_lst[item_to_flip]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 275,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on potential for improvement\n    # Here, we select the solution with the highest combined value-to-weight ratio\n    ratios = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight == 0:\n            ratio = 0\n        else:\n            ratio = (obj[0] + obj[1]) / total_weight\n        ratios.append(ratio)\n\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # First, perform random flips (30% chance for each item)\n    for i in range(n_items):\n        if np.random.rand() < 0.3:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Then apply a value-to-weight ratio heuristic for local improvement\n    # Calculate current total weight\n    total_weight = np.sum(new_solution * weight_lst)\n\n    # If over capacity, remove items with lowest value-to-weight ratio\n    if total_weight > capacity:\n        # Calculate value-to-weight ratios for included items\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            # Sort by ratio and remove items with lowest ratio until feasible\n            sorted_indices = np.argsort(ratios)\n            for idx in sorted_indices:\n                item_idx = included_items[idx]\n                if total_weight > capacity:\n                    new_solution[item_idx] = 0\n                    total_weight -= weight_lst[item_idx]\n                else:\n                    break\n\n    # If under capacity, try to add items with highest value-to-weight ratio\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n            # Sort by ratio (descending) and add items until capacity is reached\n            sorted_indices = np.argsort(ratios)[::-1]\n            for idx in sorted_indices:\n                item_idx = excluded_items[idx]\n                if total_weight + weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 1\n                    total_weight += weight_lst[item_idx]\n                else:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.3606307522031791,
            2.032023787498474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution based on potential for improvement\n    # Here, we select the solution with the highest combined value-to-weight ratio\n    ratios = []\n    for sol, obj in archive:\n        total_weight = np.sum(sol * weight_lst)\n        if total_weight == 0:\n            ratio = 0\n        else:\n            ratio = (obj[0] + obj[1]) / total_weight\n        ratios.append(ratio)\n\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid strategy\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # First, perform random flips (30% chance for each item)\n    for i in range(n_items):\n        if np.random.rand() < 0.3:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Then apply a value-to-weight ratio heuristic for local improvement\n    # Calculate current total weight\n    total_weight = np.sum(new_solution * weight_lst)\n\n    # If over capacity, remove items with lowest value-to-weight ratio\n    if total_weight > capacity:\n        # Calculate value-to-weight ratios for included items\n        included_items = np.where(new_solution == 1)[0]\n        if len(included_items) > 0:\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            # Sort by ratio and remove items with lowest ratio until feasible\n            sorted_indices = np.argsort(ratios)\n            for idx in sorted_indices:\n                item_idx = included_items[idx]\n                if total_weight > capacity:\n                    new_solution[item_idx] = 0\n                    total_weight -= weight_lst[item_idx]\n                else:\n                    break\n\n    # If under capacity, try to add items with highest value-to-weight ratio\n    else:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n            # Sort by ratio (descending) and add items until capacity is reached\n            sorted_indices = np.argsort(ratios)[::-1]\n            for idx in sorted_indices:\n                item_idx = excluded_items[idx]\n                if total_weight + weight_lst[item_idx] <= capacity:\n                    new_solution[item_idx] = 1\n                    total_weight += weight_lst[item_idx]\n                else:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 276,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: sum(x[0] * (value1_lst + value2_lst)))\n\n    # Calculate current total weight and values\n    current_weight = np.sum(base_solution * weight_lst)\n    current_value1 = np.sum(base_solution * value1_lst)\n    current_value2 = np.sum(base_solution * value2_lst)\n\n    # Generate candidate neighbors using a hybrid strategy\n    candidates = []\n\n    # Strategy 1: Randomly flip a subset of items (similar to bit-flip mutation)\n    for _ in range(5):\n        candidate = base_solution.copy()\n        flip_indices = np.random.choice(len(candidate), size=min(3, len(candidate)), replace=False)\n        candidate[flip_indices] = 1 - candidate[flip_indices]\n\n        # Check feasibility\n        new_weight = np.sum(candidate * weight_lst)\n        if new_weight <= capacity:\n            candidates.append(candidate)\n\n    # Strategy 2: Greedily add items with highest marginal value-to-weight ratio\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate marginal ratios for items not in the solution\n        marginal_ratios = (value1_lst + value2_lst) / weight_lst\n        candidate = base_solution.copy()\n        available_items = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(available_items) > 0:\n            # Select top 2 items with highest marginal ratio\n            top_items = available_items[np.argsort(marginal_ratios[available_items])[-2:]]\n            candidate[top_items] = 1\n\n            # Check feasibility\n            new_weight = np.sum(candidate * weight_lst)\n            if new_weight <= capacity:\n                candidates.append(candidate)\n\n    # Strategy 3: Remove items with lowest marginal value-to-weight ratio\n    if current_weight > 0:\n        marginal_ratios = (value1_lst + value2_lst) / weight_lst\n        candidate = base_solution.copy()\n        selected_items = np.where(base_solution == 1)[0]\n\n        if len(selected_items) > 0:\n            # Select bottom 2 items with lowest marginal ratio\n            bottom_items = selected_items[np.argsort(marginal_ratios[selected_items])[:2]]\n            candidate[bottom_items] = 0\n\n            # Check feasibility\n            new_weight = np.sum(candidate * weight_lst)\n            if new_weight <= capacity:\n                candidates.append(candidate)\n\n    # If no candidates found, return the base solution\n    if not candidates:\n        return base_solution.copy()\n\n    # Select the best candidate based on combined objective values\n    best_candidate = max(candidates, key=lambda x: np.sum(x * (value1_lst + value2_lst)))\n\n    return best_candidate\n\n",
        "score": [
            -0.3119435157316578,
            4.246658980846405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a base solution with high potential for improvement\n    base_solution, _ = max(archive, key=lambda x: sum(x[0] * (value1_lst + value2_lst)))\n\n    # Calculate current total weight and values\n    current_weight = np.sum(base_solution * weight_lst)\n    current_value1 = np.sum(base_solution * value1_lst)\n    current_value2 = np.sum(base_solution * value2_lst)\n\n    # Generate candidate neighbors using a hybrid strategy\n    candidates = []\n\n    # Strategy 1: Randomly flip a subset of items (similar to bit-flip mutation)\n    for _ in range(5):\n        candidate = base_solution.copy()\n        flip_indices = np.random.choice(len(candidate), size=min(3, len(candidate)), replace=False)\n        candidate[flip_indices] = 1 - candidate[flip_indices]\n\n        # Check feasibility\n        new_weight = np.sum(candidate * weight_lst)\n        if new_weight <= capacity:\n            candidates.append(candidate)\n\n    # Strategy 2: Greedily add items with highest marginal value-to-weight ratio\n    remaining_capacity = capacity - current_weight\n    if remaining_capacity > 0:\n        # Calculate marginal ratios for items not in the solution\n        marginal_ratios = (value1_lst + value2_lst) / weight_lst\n        candidate = base_solution.copy()\n        available_items = np.where((base_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n        if len(available_items) > 0:\n            # Select top 2 items with highest marginal ratio\n            top_items = available_items[np.argsort(marginal_ratios[available_items])[-2:]]\n            candidate[top_items] = 1\n\n            # Check feasibility\n            new_weight = np.sum(candidate * weight_lst)\n            if new_weight <= capacity:\n                candidates.append(candidate)\n\n    # Strategy 3: Remove items with lowest marginal value-to-weight ratio\n    if current_weight > 0:\n        marginal_ratios = (value1_lst + value2_lst) / weight_lst\n        candidate = base_solution.copy()\n        selected_items = np.where(base_solution == 1)[0]\n\n        if len(selected_items) > 0:\n            # Select bottom 2 items with lowest marginal ratio\n            bottom_items = selected_items[np.argsort(marginal_ratios[selected_items])[:2]]\n            candidate[bottom_items] = 0\n\n            # Check feasibility\n            new_weight = np.sum(candidate * weight_lst)\n            if new_weight <= capacity:\n                candidates.append(candidate)\n\n    # If no candidates found, return the base solution\n    if not candidates:\n        return base_solution.copy()\n\n    # Select the best candidate based on combined objective values\n    best_candidate = max(candidates, key=lambda x: np.sum(x * (value1_lst + value2_lst)))\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 277,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate crowding distance to identify less crowded solutions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] - archive_objectives[sorted_indices[j-1]][i])\n\n    # Select solutions with high crowding distance (less explored)\n    selected_indices = np.where(crowding_distances > np.percentile(crowding_distances, 75))[0]\n    if len(selected_indices) == 0:\n        selected_indices = np.arange(len(archive))\n\n    selected_idx = random.choice(selected_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip random bits and perform objective-aware swaps\n    num_flips = random.randint(1, min(5, len(base_solution)))\n    flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # Perform objective-aware swaps (replace low-value items with high-value items)\n    if random.random() < 0.5:  # 50% chance to perform swaps\n        selected_items = np.where(new_solution == 1)[0]\n        if len(selected_items) > 0:\n            # Calculate \"value density\" for each objective\n            value_density1 = value1_lst / weight_lst\n            value_density2 = value2_lst / weight_lst\n\n            # Select items to potentially remove (low value density)\n            low_density_items = np.where((value_density1 < np.percentile(value_density1, 30)) |\n                                        (value_density2 < np.percentile(value_density2, 30)))[0]\n\n            # Select items to potentially add (high value density)\n            high_density_items = np.where((value_density1 > np.percentile(value_density1, 70)) &\n                                         (value_density2 > np.percentile(value_density2, 70)))[0]\n\n            # Perform swaps\n            for low_item in low_density_items:\n                if new_solution[low_item] == 1:\n                    for high_item in high_density_items:\n                        if new_solution[high_item] == 0:\n                            # Check if swap is feasible\n                            current_weight = np.sum(weight_lst[new_solution == 1])\n                            if (current_weight - weight_lst[low_item] + weight_lst[high_item]) <= capacity:\n                                new_solution[low_item] = 0\n                                new_solution[high_item] = 1\n                                break\n\n    return new_solution\n\n",
        "score": [
            -0.361352108462557,
            6.022485971450806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    archive_solutions = [s[0] for s in archive]\n    archive_objectives = [s[1] for s in archive]\n\n    # Calculate crowding distance to identify less crowded solutions\n    crowding_distances = np.zeros(len(archive))\n    for i in range(2):  # For each objective\n        sorted_indices = np.argsort([obj[i] for obj in archive_objectives])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        for j in range(1, len(archive) - 1):\n            crowding_distances[sorted_indices[j]] += (archive_objectives[sorted_indices[j+1]][i] - archive_objectives[sorted_indices[j-1]][i])\n\n    # Select solutions with high crowding distance (less explored)\n    selected_indices = np.where(crowding_distances > np.percentile(crowding_distances, 75))[0]\n    if len(selected_indices) == 0:\n        selected_indices = np.arange(len(archive))\n\n    selected_idx = random.choice(selected_indices)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: flip random bits and perform objective-aware swaps\n    num_flips = random.randint(1, min(5, len(base_solution)))\n    flip_indices = random.sample(range(len(base_solution)), num_flips)\n\n    for idx in flip_indices:\n        if base_solution[idx] == 1:\n            # Try to remove the item if it doesn't violate capacity\n            if (np.sum(weight_lst[new_solution == 1]) - weight_lst[idx]) <= capacity:\n                new_solution[idx] = 0\n        else:\n            # Try to add the item if it doesn't violate capacity\n            if (np.sum(weight_lst[new_solution == 1]) + weight_lst[idx]) <= capacity:\n                new_solution[idx] = 1\n\n    # Perform objective-aware swaps (replace low-value items with high-value items)\n    if random.random() < 0.5:  # 50% chance to perform swaps\n        selected_items = np.where(new_solution == 1)[0]\n        if len(selected_items) > 0:\n            # Calculate \"value density\" for each objective\n            value_density1 = value1_lst / weight_lst\n            value_density2 = value2_lst / weight_lst\n\n            # Select items to potentially remove (low value density)\n            low_density_items = np.where((value_density1 < np.percentile(value_density1, 30)) |\n                                        (value_density2 < np.percentile(value_density2, 30)))[0]\n\n            # Select items to potentially add (high value density)\n            high_density_items = np.where((value_density1 > np.percentile(value_density1, 70)) &\n                                         (value_density2 > np.percentile(value_density2, 70)))[0]\n\n            # Perform swaps\n            for low_item in low_density_items:\n                if new_solution[low_item] == 1:\n                    for high_item in high_density_items:\n                        if new_solution[high_item] == 0:\n                            # Check if swap is feasible\n                            current_weight = np.sum(weight_lst[new_solution == 1])\n                            if (current_weight - weight_lst[low_item] + weight_lst[high_item]) <= capacity:\n                                new_solution[low_item] = 0\n                                new_solution[high_item] = 1\n                                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 278,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate fitness scores for each solution in the archive\n    fitness_scores = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            fitness_scores.append(0)  # Penalize infeasible solutions\n        else:\n            # Fitness is a combination of both objectives (normalized)\n            total_value1 = np.sum(value1_lst * sol)\n            total_value2 = np.sum(value2_lst * sol)\n            fitness_scores.append(total_value1 + total_value2)\n\n    # Normalize fitness scores to create selection probabilities\n    if all(score == 0 for score in fitness_scores):\n        # If all solutions are infeasible, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        max_score = max(fitness_scores)\n        if max_score == 0:\n            # Avoid division by zero\n            probabilities = [1.0 / len(archive)] * len(archive)\n        else:\n            probabilities = [score / max_score for score in fitness_scores]\n        probabilities = [p / sum(probabilities) for p in probabilities]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a small number of items (exploration)\n    num_flips = min(3, len(new_solution))  # Flip up to 3 items\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate potential gains for each item not in the solution\n    potential_gains = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            gain1 = value1_lst[i]\n            gain2 = value2_lst[i]\n            # Combine gains to prioritize items that improve both objectives\n            combined_gain = gain1 + gain2\n            potential_gains.append((i, combined_gain))\n        else:\n            potential_gains.append((i, 0))\n\n    # Sort by combined gain and select the best item to add\n    potential_gains.sort(key=lambda x: x[1], reverse=True)\n    for idx, gain in potential_gains:\n        if gain > 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n            break\n\n    # Ensure the solution is feasible\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove items until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.34051182944597946,
            3.4352884590625763
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate fitness scores for each solution in the archive\n    fitness_scores = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if total_weight > capacity:\n            fitness_scores.append(0)  # Penalize infeasible solutions\n        else:\n            # Fitness is a combination of both objectives (normalized)\n            total_value1 = np.sum(value1_lst * sol)\n            total_value2 = np.sum(value2_lst * sol)\n            fitness_scores.append(total_value1 + total_value2)\n\n    # Normalize fitness scores to create selection probabilities\n    if all(score == 0 for score in fitness_scores):\n        # If all solutions are infeasible, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        max_score = max(fitness_scores)\n        if max_score == 0:\n            # Avoid division by zero\n            probabilities = [1.0 / len(archive)] * len(archive)\n        else:\n            probabilities = [score / max_score for score in fitness_scores]\n        probabilities = [p / sum(probabilities) for p in probabilities]\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n        base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor solution using a hybrid strategy\n    new_solution = base_solution.copy()\n\n    # Step 1: Randomly flip a small number of items (exploration)\n    num_flips = min(3, len(new_solution))  # Flip up to 3 items\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedy improvement - add items that improve both objectives\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate potential gains for each item not in the solution\n    potential_gains = []\n    for i in range(len(new_solution)):\n        if new_solution[i] == 0 and weight_lst[i] <= remaining_capacity:\n            gain1 = value1_lst[i]\n            gain2 = value2_lst[i]\n            # Combine gains to prioritize items that improve both objectives\n            combined_gain = gain1 + gain2\n            potential_gains.append((i, combined_gain))\n        else:\n            potential_gains.append((i, 0))\n\n    # Sort by combined gain and select the best item to add\n    potential_gains.sort(key=lambda x: x[1], reverse=True)\n    for idx, gain in potential_gains:\n        if gain > 0 and weight_lst[idx] <= remaining_capacity:\n            new_solution[idx] = 1\n            remaining_capacity -= weight_lst[idx]\n            break\n\n    # Ensure the solution is feasible\n    while np.sum(weight_lst * new_solution) > capacity:\n        # Remove items until feasible\n        excess_items = np.where(new_solution == 1)[0]\n        if len(excess_items) == 0:\n            break\n        remove_idx = random.choice(excess_items)\n        new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 279,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not fully packed\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # If no candidates, try removing items to free up space\n    if len(candidate_items) == 0:\n        # Remove items with the lowest marginal utility (value/weight ratio) for both objectives\n        marginal_utility1 = value1_lst / weight_lst\n        marginal_utility2 = value2_lst / weight_lst\n        marginal_utility = marginal_utility1 + marginal_utility2  # Combined utility\n\n        # Sort items in the solution by marginal utility and remove the least useful ones\n        items_in_solution = np.where(new_solution == 1)[0]\n        sorted_items = sorted(items_in_solution, key=lambda x: marginal_utility[x])\n        for item in sorted_items:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                remaining_capacity = capacity - current_weight\n                break\n\n        # Recompute candidate items after removal\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # Add a random candidate item if possible\n    if len(candidate_items) > 0:\n        item_to_add = random.choice(candidate_items)\n        new_solution[item_to_add] = 1\n\n    # Perform a local search to improve the solution\n    items_in_solution = np.where(new_solution == 1)[0]\n    for item in items_in_solution:\n        # Try swapping with an item not in the solution\n        candidate_swap_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity + weight_lst[item]))[0]\n        if len(candidate_swap_items) > 0:\n            swap_item = random.choice(candidate_swap_items)\n            # Check if swapping improves at least one objective\n            delta_value1 = value1_lst[swap_item] - value1_lst[item]\n            delta_value2 = value2_lst[swap_item] - value2_lst[item]\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[item] = 0\n                new_solution[swap_item] = 1\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.4800034804475205,
            0.7875851690769196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not fully packed\n    base_solution, _ = random.choice(archive)\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight and remaining capacity\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # If no candidates, try removing items to free up space\n    if len(candidate_items) == 0:\n        # Remove items with the lowest marginal utility (value/weight ratio) for both objectives\n        marginal_utility1 = value1_lst / weight_lst\n        marginal_utility2 = value2_lst / weight_lst\n        marginal_utility = marginal_utility1 + marginal_utility2  # Combined utility\n\n        # Sort items in the solution by marginal utility and remove the least useful ones\n        items_in_solution = np.where(new_solution == 1)[0]\n        sorted_items = sorted(items_in_solution, key=lambda x: marginal_utility[x])\n        for item in sorted_items:\n            if current_weight - weight_lst[item] >= 0:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                remaining_capacity = capacity - current_weight\n                break\n\n        # Recompute candidate items after removal\n        candidate_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity))[0]\n\n    # Add a random candidate item if possible\n    if len(candidate_items) > 0:\n        item_to_add = random.choice(candidate_items)\n        new_solution[item_to_add] = 1\n\n    # Perform a local search to improve the solution\n    items_in_solution = np.where(new_solution == 1)[0]\n    for item in items_in_solution:\n        # Try swapping with an item not in the solution\n        candidate_swap_items = np.where((new_solution == 0) & (weight_lst <= remaining_capacity + weight_lst[item]))[0]\n        if len(candidate_swap_items) > 0:\n            swap_item = random.choice(candidate_swap_items)\n            # Check if swapping improves at least one objective\n            delta_value1 = value1_lst[swap_item] - value1_lst[item]\n            delta_value2 = value2_lst[swap_item] - value2_lst[item]\n            if delta_value1 > 0 or delta_value2 > 0:\n                new_solution[item] = 0\n                new_solution[swap_item] = 1\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 280,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated and having potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid local search: combine random swaps with ratio-based selection\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(num_items), min(10, num_items))\n\n    for item in swap_candidates:\n        if base_solution[item] == 1:\n            # Option 1: Remove the item if it's in the solution\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            # Option 2: Add the item if it fits and improves at least one objective's ratio\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                # Decide whether to add based on both ratios\n                if (ratio1[item] > np.mean(ratio1[new_solution == 1]) or\n                    ratio2[item] > np.mean(ratio2[new_solution == 1])):\n                    new_solution[item] = 1\n\n    # Step 2: Apply a ratio-based hill-climbing step\n    for _ in range(3):  # Limit the number of iterations to prevent excessive computation\n        # Find the item with the highest combined ratio that fits\n        remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n        possible_items = np.where((weight_lst <= remaining_weight) & (new_solution == 0))[0]\n\n        if len(possible_items) > 0:\n            # Select items with top combined ratio\n            combined_ratio = ratio1 + ratio2\n            top_items = possible_items[np.argsort(-combined_ratio[possible_items])[:min(3, len(possible_items))]]\n\n            for item in top_items:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break  # Only add one item per iteration to maintain diversity\n\n    return new_solution\n\n",
        "score": [
            -0.2788108089050511,
            4.115210324525833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated and having potential for improvement\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_value1, current_value2 = archive[selected_idx][1]\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    ratio2 = value2_lst / (weight_lst + 1e-6)\n\n    # Hybrid local search: combine random swaps with ratio-based selection\n    new_solution = base_solution.copy()\n    num_items = len(weight_lst)\n\n    # Step 1: Randomly select a subset of items to consider for swapping\n    swap_candidates = random.sample(range(num_items), min(10, num_items))\n\n    for item in swap_candidates:\n        if base_solution[item] == 1:\n            # Option 1: Remove the item if it's in the solution\n            if np.sum(weight_lst[new_solution == 1]) - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n        else:\n            # Option 2: Add the item if it fits and improves at least one objective's ratio\n            if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                # Decide whether to add based on both ratios\n                if (ratio1[item] > np.mean(ratio1[new_solution == 1]) or\n                    ratio2[item] > np.mean(ratio2[new_solution == 1])):\n                    new_solution[item] = 1\n\n    # Step 2: Apply a ratio-based hill-climbing step\n    for _ in range(3):  # Limit the number of iterations to prevent excessive computation\n        # Find the item with the highest combined ratio that fits\n        remaining_weight = capacity - np.sum(weight_lst[new_solution == 1])\n        possible_items = np.where((weight_lst <= remaining_weight) & (new_solution == 0))[0]\n\n        if len(possible_items) > 0:\n            # Select items with top combined ratio\n            combined_ratio = ratio1 + ratio2\n            top_items = possible_items[np.argsort(-combined_ratio[possible_items])[:min(3, len(possible_items))]]\n\n            for item in top_items:\n                if np.sum(weight_lst[new_solution == 1]) + weight_lst[item] <= capacity:\n                    new_solution[item] = 1\n                    break  # Only add one item per iteration to maintain diversity\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 281,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher value ratios\n    values = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst[sol]) for sol, _ in archive])\n    ratios = values / np.maximum(weights, 1e-6)  # Avoid division by zero\n    probabilities = ratios / np.sum(ratios)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip items (with a bias towards improving both objectives)\n    # 2. Perform a weight-aware swap to balance the solution\n\n    # Step 1: Random flip with objective-aware selection\n    for _ in range(3):  # Number of flips\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        item_to_remove = random.choice(candidates)\n        new_weight = current_weight - weight_lst[item_to_remove]\n\n        # Check if removing this item would keep the solution feasible\n        if new_weight <= capacity:\n            new_solution[item_to_remove] = 0\n            current_weight = new_weight\n\n    # Step 2: Weight-aware swap to balance the solution\n    if np.random.rand() < 0.7:  # 70% chance to perform swap\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select an item to remove based on value density (weight/value)\n            value_density_included = (weight_lst[included] / (value1_lst[included] + value2_lst[included] + 1e-6))\n            item_to_remove = included[np.argmin(value_density_included)]\n\n            # Select an item to add based on value density\n            value_density_excluded = (weight_lst[excluded] / (value1_lst[excluded] + value2_lst[excluded] + 1e-6))\n            item_to_add = excluded[np.argmax(value_density_excluded)]\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n            if new_weight <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8797167320976563,
            2.337422341108322
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with higher value ratios\n    values = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = np.array([np.sum(weight_lst[sol]) for sol, _ in archive])\n    ratios = values / np.maximum(weights, 1e-6)  # Avoid division by zero\n    probabilities = ratios / np.sum(ratios)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip items (with a bias towards improving both objectives)\n    # 2. Perform a weight-aware swap to balance the solution\n\n    # Step 1: Random flip with objective-aware selection\n    for _ in range(3):  # Number of flips\n        candidates = np.where(new_solution == 1)[0]\n        if len(candidates) == 0:\n            break\n        item_to_remove = random.choice(candidates)\n        new_weight = current_weight - weight_lst[item_to_remove]\n\n        # Check if removing this item would keep the solution feasible\n        if new_weight <= capacity:\n            new_solution[item_to_remove] = 0\n            current_weight = new_weight\n\n    # Step 2: Weight-aware swap to balance the solution\n    if np.random.rand() < 0.7:  # 70% chance to perform swap\n        included = np.where(new_solution == 1)[0]\n        excluded = np.where(new_solution == 0)[0]\n\n        if len(included) > 0 and len(excluded) > 0:\n            # Select an item to remove based on value density (weight/value)\n            value_density_included = (weight_lst[included] / (value1_lst[included] + value2_lst[included] + 1e-6))\n            item_to_remove = included[np.argmin(value_density_included)]\n\n            # Select an item to add based on value density\n            value_density_excluded = (weight_lst[excluded] / (value1_lst[excluded] + value2_lst[excluded] + 1e-6))\n            item_to_add = excluded[np.argmax(value_density_excluded)]\n\n            # Check feasibility\n            new_weight = current_weight - weight_lst[item_to_remove] + weight_lst[item_to_add]\n            if new_weight <= capacity:\n                new_solution[item_to_remove] = 0\n                new_solution[item_to_add] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 282,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (higher first)\n    base_solution, _ = archive[0]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip a random subset of items based on their marginal contributions\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)  # Flip up to 3 items\n\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            # If item is included, consider removing it if it doesn't contribute significantly\n            marginal_contrib = value1_lst[i] + value2_lst[i]\n            if marginal_contrib < 0.1 * np.sum(value1_lst + value2_lst):\n                new_solution[i] = 0\n        else:\n            # If item is excluded, consider adding it if it fits and improves objectives\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If infeasible, remove the heaviest items until feasible\n        excess = new_weight - capacity\n        while excess > 0:\n            heavy_indices = np.where(new_solution == 1)[0]\n            if len(heavy_indices) == 0:\n                break\n            heaviest_idx = heavy_indices[np.argmax(weight_lst[heavy_indices])]\n            new_solution[heaviest_idx] = 0\n            excess -= weight_lst[heaviest_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.36121932108544974,
            7.228571146726608
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by sum of objectives (higher first)\n    base_solution, _ = archive[0]\n    current_weight = np.sum(weight_lst * base_solution)\n\n    # Hybrid local search: flip a random subset of items based on their marginal contributions\n    new_solution = base_solution.copy()\n    n_items = len(base_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)  # Flip up to 3 items\n\n    for i in flip_indices:\n        if new_solution[i] == 1:\n            # If item is included, consider removing it if it doesn't contribute significantly\n            marginal_contrib = value1_lst[i] + value2_lst[i]\n            if marginal_contrib < 0.1 * np.sum(value1_lst + value2_lst):\n                new_solution[i] = 0\n        else:\n            # If item is excluded, consider adding it if it fits and improves objectives\n            if current_weight + weight_lst[i] <= capacity:\n                new_solution[i] = 1\n\n    # Ensure feasibility\n    new_weight = np.sum(weight_lst * new_solution)\n    if new_weight > capacity:\n        # If infeasible, remove the heaviest items until feasible\n        excess = new_weight - capacity\n        while excess > 0:\n            heavy_indices = np.where(new_solution == 1)[0]\n            if len(heavy_indices) == 0:\n                break\n            heaviest_idx = heavy_indices[np.argmax(weight_lst[heavy_indices])]\n            new_solution[heaviest_idx] = 0\n            excess -= weight_lst[heaviest_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 283,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with the highest crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return np.zeros(len(solutions))\n        distances = np.zeros(len(solutions))\n        objectives = np.array([obj for _, obj in solutions])\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    continue\n                distances[sorted_idx[i]] += (sorted_obj[i + 1] - sorted_obj[i - 1]) / (sorted_obj[-1] - sorted_obj[0])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search - randomized swap based on marginal contribution\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items with high marginal contribution to both objectives\n    marginal_contribution = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    high_contrib_items = np.argsort(marginal_contribution)[-max(1, n_items // 5):]\n\n    # Randomly select items to swap (prioritize high-contrib items)\n    swap_candidates = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n    for item in swap_candidates:\n        if new_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    # Additional random perturbation for exploration\n    if np.random.rand() < 0.3:\n        random_item = np.random.randint(0, n_items)\n        if new_solution[random_item] == 1:\n            if current_weight - weight_lst[random_item] <= capacity:\n                new_solution[random_item] = 0\n        else:\n            if current_weight + weight_lst[random_item] <= capacity:\n                new_solution[random_item] = 1\n\n    return new_solution\n\n",
        "score": [
            -0.8493091641453853,
            1.9337038099765778
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a solution with the highest crowding distance (promising for improvement)\n    def crowding_distance(solutions):\n        if len(solutions) < 3:\n            return np.zeros(len(solutions))\n        distances = np.zeros(len(solutions))\n        objectives = np.array([obj for _, obj in solutions])\n        for m in range(objectives.shape[1]):\n            sorted_idx = np.argsort(objectives[:, m])\n            sorted_obj = objectives[sorted_idx, m]\n            distances[sorted_idx[0]] = np.inf\n            distances[sorted_idx[-1]] = np.inf\n            for i in range(1, len(solutions) - 1):\n                if sorted_obj[-1] == sorted_obj[0]:\n                    continue\n                distances[sorted_idx[i]] += (sorted_obj[i + 1] - sorted_obj[i - 1]) / (sorted_obj[-1] - sorted_obj[0])\n        return distances\n\n    distances = crowding_distance(archive)\n    selected_idx = np.argmax(distances)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search - randomized swap based on marginal contribution\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    current_value1 = np.sum(value1_lst[new_solution == 1])\n    current_value2 = np.sum(value2_lst[new_solution == 1])\n\n    # Identify items with high marginal contribution to both objectives\n    marginal_contribution = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n    high_contrib_items = np.argsort(marginal_contribution)[-max(1, n_items // 5):]\n\n    # Randomly select items to swap (prioritize high-contrib items)\n    swap_candidates = np.random.choice(high_contrib_items, size=min(3, len(high_contrib_items)), replace=False)\n    for item in swap_candidates:\n        if new_solution[item] == 1:\n            # Try removing the item\n            if current_weight - weight_lst[item] <= capacity:\n                new_solution[item] = 0\n                current_weight -= weight_lst[item]\n                current_value1 -= value1_lst[item]\n                current_value2 -= value2_lst[item]\n        else:\n            # Try adding the item\n            if current_weight + weight_lst[item] <= capacity:\n                new_solution[item] = 1\n                current_weight += weight_lst[item]\n                current_value1 += value1_lst[item]\n                current_value2 += value2_lst[item]\n\n    # Additional random perturbation for exploration\n    if np.random.rand() < 0.3:\n        random_item = np.random.randint(0, n_items)\n        if new_solution[random_item] == 1:\n            if current_weight - weight_lst[random_item] <= capacity:\n                new_solution[random_item] = 0\n        else:\n            if current_weight + weight_lst[random_item] <= capacity:\n                new_solution[random_item] = 1\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 284,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (promise of improvement)\n        normalized_solutions = []\n        for sol, obj in archive:\n            total_weight = np.sum(weight_lst * sol)\n            if total_weight > capacity:\n                continue  # Skip infeasible solutions\n            norm_obj = (obj[0] / np.sum(value1_lst), obj[1] / np.sum(value2_lst))\n            normalized_solutions.append((sol, obj, norm_obj))\n\n        if normalized_solutions:\n            # Select top 20% solutions with highest normalized objective sum\n            top_pct = max(1, len(normalized_solutions) // 5)\n            top_solutions = sorted(normalized_solutions, key=lambda x: -(x[2][0] + x[2][1]))[:top_pct]\n            selected = random.choice(top_solutions)[0]\n        else:\n            selected = random.choice(archive)[0]\n    else:\n        selected = archive[0][0]\n\n    # Step 2: Hybrid local search strategy\n    new_solution = selected.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Random flip with weight-based probability\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                # Remove item if it doesn't violate capacity\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Add item if it doesn't violate capacity\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Strategy 2: Greedy improvement for one objective\n    # Determine which objective to prioritize (alternate between them)\n    if random.random() < 0.5:\n        # Improve value1\n        for i in range(n_items):\n            if new_solution[i] == 0 and np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                # Check if adding this item improves value1\n                current_value1 = np.sum(value1_lst * new_solution)\n                new_value1 = current_value1 + value1_lst[i]\n                if new_value1 > current_value1:\n                    new_solution[i] = 1\n    else:\n        # Improve value2\n        for i in range(n_items):\n            if new_solution[i] == 0 and np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                # Check if adding this item improves value2\n                current_value2 = np.sum(value2_lst * new_solution)\n                new_value2 = current_value2 + value2_lst[i]\n                if new_value2 > current_value2:\n                    new_solution[i] = 1\n\n    # Strategy 3: Random swap of items to escape local optima\n    if random.random() < 0.3:  # 30% chance for swap\n        indices = np.where(new_solution == 1)[0]\n        if len(indices) >= 2:\n            i, j = random.sample(list(indices), 2)\n            # Check if swapping these items maintains feasibility\n            if (np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j]) <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.3989998572157502,
            8.141936928033829
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of normalized objectives (promise of improvement)\n        normalized_solutions = []\n        for sol, obj in archive:\n            total_weight = np.sum(weight_lst * sol)\n            if total_weight > capacity:\n                continue  # Skip infeasible solutions\n            norm_obj = (obj[0] / np.sum(value1_lst), obj[1] / np.sum(value2_lst))\n            normalized_solutions.append((sol, obj, norm_obj))\n\n        if normalized_solutions:\n            # Select top 20% solutions with highest normalized objective sum\n            top_pct = max(1, len(normalized_solutions) // 5)\n            top_solutions = sorted(normalized_solutions, key=lambda x: -(x[2][0] + x[2][1]))[:top_pct]\n            selected = random.choice(top_solutions)[0]\n        else:\n            selected = random.choice(archive)[0]\n    else:\n        selected = archive[0][0]\n\n    # Step 2: Hybrid local search strategy\n    new_solution = selected.copy()\n    n_items = len(weight_lst)\n\n    # Strategy 1: Random flip with weight-based probability\n    for i in range(n_items):\n        if random.random() < 0.1:  # 10% chance to flip each item\n            if new_solution[i] == 1:\n                # Remove item if it doesn't violate capacity\n                if np.sum(weight_lst * new_solution) - weight_lst[i] <= capacity:\n                    new_solution[i] = 0\n            else:\n                # Add item if it doesn't violate capacity\n                if np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                    new_solution[i] = 1\n\n    # Strategy 2: Greedy improvement for one objective\n    # Determine which objective to prioritize (alternate between them)\n    if random.random() < 0.5:\n        # Improve value1\n        for i in range(n_items):\n            if new_solution[i] == 0 and np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                # Check if adding this item improves value1\n                current_value1 = np.sum(value1_lst * new_solution)\n                new_value1 = current_value1 + value1_lst[i]\n                if new_value1 > current_value1:\n                    new_solution[i] = 1\n    else:\n        # Improve value2\n        for i in range(n_items):\n            if new_solution[i] == 0 and np.sum(weight_lst * new_solution) + weight_lst[i] <= capacity:\n                # Check if adding this item improves value2\n                current_value2 = np.sum(value2_lst * new_solution)\n                new_value2 = current_value2 + value2_lst[i]\n                if new_value2 > current_value2:\n                    new_solution[i] = 1\n\n    # Strategy 3: Random swap of items to escape local optima\n    if random.random() < 0.3:  # 30% chance for swap\n        indices = np.where(new_solution == 1)[0]\n        if len(indices) >= 2:\n            i, j = random.sample(list(indices), 2)\n            # Check if swapping these items maintains feasibility\n            if (np.sum(weight_lst * new_solution) - weight_lst[i] + weight_lst[j]) <= capacity:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 285,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto frontier)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flips with value-based selection\n    # Step 1: Randomly flip a subset of items (with probability proportional to their value)\n    flip_prob = 0.3\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Ensure feasibility by removing items if overweight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest value-to-weight ratio until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate value-to-weight ratio for each included item\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            # Remove the item with the lowest ratio\n            remove_idx = included_items[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Step 3: Randomly add items with high value-to-weight ratio if there's remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    if remaining_capacity > 0:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            # Calculate value-to-weight ratio for each excluded item\n            ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n            # Sort by ratio in descending order\n            sorted_indices = np.argsort(ratios)[::-1]\n            for i in sorted_indices:\n                if weight_lst[excluded_items[i]] <= remaining_capacity:\n                    new_solution[excluded_items[i]] = 1\n                    remaining_capacity -= weight_lst[excluded_items[i]]\n\n    return new_solution\n\n",
        "score": [
            -0.42442665208759217,
            4.21917450428009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto frontier)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.linspace(0.1, 1.0, len(archive)).sum())\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine random flips with value-based selection\n    # Step 1: Randomly flip a subset of items (with probability proportional to their value)\n    flip_prob = 0.3\n    for i in range(len(new_solution)):\n        if np.random.rand() < flip_prob:\n            new_solution[i] = 1 - new_solution[i]\n\n    # Step 2: Ensure feasibility by removing items if overweight\n    total_weight = np.sum(weight_lst[new_solution == 1])\n    if total_weight > capacity:\n        # Remove items with lowest value-to-weight ratio until feasible\n        while total_weight > capacity:\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate value-to-weight ratio for each included item\n            ratios = (value1_lst[included_items] + value2_lst[included_items]) / weight_lst[included_items]\n            # Remove the item with the lowest ratio\n            remove_idx = included_items[np.argmin(ratios)]\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    # Step 3: Randomly add items with high value-to-weight ratio if there's remaining capacity\n    remaining_capacity = capacity - np.sum(weight_lst[new_solution == 1])\n    if remaining_capacity > 0:\n        excluded_items = np.where(new_solution == 0)[0]\n        if len(excluded_items) > 0:\n            # Calculate value-to-weight ratio for each excluded item\n            ratios = (value1_lst[excluded_items] + value2_lst[excluded_items]) / weight_lst[excluded_items]\n            # Sort by ratio in descending order\n            sorted_indices = np.argsort(ratios)[::-1]\n            for i in sorted_indices:\n                if weight_lst[excluded_items[i]] <= remaining_capacity:\n                    new_solution[excluded_items[i]] = 1\n                    remaining_capacity -= weight_lst[excluded_items[i]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 286,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others in the archive)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: flip a subset of items based on their marginal contribution\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    flip_candidates = []\n\n    # Identify items that can be flipped (either included or excluded) without violating capacity\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Exclude item if it's currently included\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Include item if it's currently excluded and fits\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append((i, 1))  # 1 indicates inclusion\n\n    if not flip_candidates:\n        return new_solution  # No feasible flips possible\n\n    # Select a subset of items to flip based on marginal contribution (value1 + value2)\n    marginal_contributions = []\n    for i, flip_type in flip_candidates:\n        if flip_type == 1:\n            marginal_contributions.append(value1_lst[i] + value2_lst[i])\n        else:\n            marginal_contributions.append(-(value1_lst[i] + value2_lst[i]))\n\n    # Select top-k items with highest marginal contribution\n    k = min(3, len(flip_candidates))  # Flip at most 3 items to balance exploration and exploitation\n    top_indices = np.argsort(marginal_contributions)[-k:]\n\n    for idx in top_indices:\n        i, flip_type = flip_candidates[idx]\n        new_solution[i] = flip_type\n\n    return new_solution\n\n",
        "score": [
            -0.8590097095833127,
            2.1207041144371033
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others in the archive)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: flip a subset of items based on their marginal contribution\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    flip_candidates = []\n\n    # Identify items that can be flipped (either included or excluded) without violating capacity\n    for i in range(n_items):\n        if new_solution[i] == 1:\n            # Exclude item if it's currently included\n            new_weight = current_weight - weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append((i, -1))  # -1 indicates exclusion\n        else:\n            # Include item if it's currently excluded and fits\n            new_weight = current_weight + weight_lst[i]\n            if new_weight <= capacity:\n                flip_candidates.append((i, 1))  # 1 indicates inclusion\n\n    if not flip_candidates:\n        return new_solution  # No feasible flips possible\n\n    # Select a subset of items to flip based on marginal contribution (value1 + value2)\n    marginal_contributions = []\n    for i, flip_type in flip_candidates:\n        if flip_type == 1:\n            marginal_contributions.append(value1_lst[i] + value2_lst[i])\n        else:\n            marginal_contributions.append(-(value1_lst[i] + value2_lst[i]))\n\n    # Select top-k items with highest marginal contribution\n    k = min(3, len(flip_candidates))  # Flip at most 3 items to balance exploration and exploitation\n    top_indices = np.argsort(marginal_contributions)[-k:]\n\n    for idx in top_indices:\n        i, flip_type = flip_candidates[idx]\n        new_solution[i] = flip_type\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 287,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = None\n    max_potential = -1\n    for sol, obj in archive:\n        # Potential is inversely proportional to the sum of objectives (simplistic measure)\n        potential = 1.0 / (obj[0] + obj[1] + 1e-6)  # Avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items to explore the neighborhood\n    # 2. Apply a greedy improvement step to ensure feasibility\n    n_items = len(new_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)  # Flip up to 3 items\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Greedily remove items with the smallest ratio of (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.892714118042777,
            1.0238515436649323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    selected_solution = None\n    max_potential = -1\n    for sol, obj in archive:\n        # Potential is inversely proportional to the sum of objectives (simplistic measure)\n        potential = 1.0 / (obj[0] + obj[1] + 1e-6)  # Avoid division by zero\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol\n\n    if selected_solution is None:\n        selected_solution = archive[0][0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items to explore the neighborhood\n    # 2. Apply a greedy improvement step to ensure feasibility\n    n_items = len(new_solution)\n    flip_indices = np.random.choice(n_items, size=min(3, n_items), replace=False)  # Flip up to 3 items\n\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]  # Flip the bit\n\n    # Ensure feasibility by removing items that exceed capacity\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Greedily remove items with the smallest ratio of (value1 + value2) / weight\n        item_ratios = (value1_lst + value2_lst) / weight_lst\n        sorted_indices = np.argsort(item_ratios)\n        for idx in sorted_indices:\n            if new_solution[idx] == 1:\n                new_solution[idx] = 0\n                total_weight -= weight_lst[idx]\n                if total_weight <= capacity:\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 288,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        potential = remaining_capacity * np.mean(value1_lst + value2_lst)  # Heuristic for potential improvement\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combination of bit-flip and swap operations\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select operation (bit-flip or swap)\n    if np.random.rand() < 0.7:  # Higher probability for bit-flip\n        # Bit-flip operation\n        idx = np.random.randint(n_items)\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if np.sum(weight_lst * new_solution) - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n        else:\n            # Try to add item if feasible\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n    else:\n        # Swap operation\n        idx1, idx2 = np.random.choice(n_items, 2, replace=False)\n        if new_solution[idx1] != new_solution[idx2]:\n            # Check feasibility after swap\n            delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] == 1 else (weight_lst[idx1] - weight_lst[idx2])\n            if np.sum(weight_lst * new_solution) + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n",
        "score": [
            -0.615742747390826,
            8.04402232170105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = None\n    max_potential = -1\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        remaining_capacity = capacity - total_weight\n        potential = remaining_capacity * np.mean(value1_lst + value2_lst)  # Heuristic for potential improvement\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combination of bit-flip and swap operations\n    new_solution = selected_solution.copy()\n    n_items = len(new_solution)\n\n    # Randomly select operation (bit-flip or swap)\n    if np.random.rand() < 0.7:  # Higher probability for bit-flip\n        # Bit-flip operation\n        idx = np.random.randint(n_items)\n        if new_solution[idx] == 1:\n            # Try to remove item if feasible\n            if np.sum(weight_lst * new_solution) - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n        else:\n            # Try to add item if feasible\n            if np.sum(weight_lst * new_solution) + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n    else:\n        # Swap operation\n        idx1, idx2 = np.random.choice(n_items, 2, replace=False)\n        if new_solution[idx1] != new_solution[idx2]:\n            # Check feasibility after swap\n            delta_weight = (weight_lst[idx2] - weight_lst[idx1]) if new_solution[idx1] == 1 else (weight_lst[idx1] - weight_lst[idx2])\n            if np.sum(weight_lst * new_solution) + delta_weight <= capacity:\n                new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 289,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., near the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip and greedy improvement\n    # Step 1: Randomly flip a subset of items to escape local optima\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedily improve the solution by adding/removing items that increase both objectives\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Find items not in the solution and could be added without exceeding capacity\n    available_indices = np.where(new_solution == 0)[0]\n    if len(available_indices) > 0:\n        # Sort by the sum of normalized value1 and value2 (to balance both objectives)\n        value_sum = (value1_lst[available_indices] / np.max(value1_lst)) + (value2_lst[available_indices] / np.max(value2_lst))\n        sorted_indices = available_indices[np.argsort(value_sum)[::-1]]\n\n        for idx in sorted_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Optionally remove items to free up capacity for better items\n    included_indices = np.where(new_solution == 1)[0]\n    if len(included_indices) > 0:\n        # Sort by the sum of normalized value1 and value2 (ascending to remove least beneficial items first)\n        value_sum = (value1_lst[included_indices] / np.max(value1_lst)) + (value2_lst[included_indices] / np.max(value2_lst))\n        sorted_indices = included_indices[np.argsort(value_sum)]\n\n        for idx in sorted_indices:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.7902391304412579,
            2.123020201921463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., near the Pareto front)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of random flip and greedy improvement\n    # Step 1: Randomly flip a subset of items to escape local optima\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Step 2: Greedily improve the solution by adding/removing items that increase both objectives\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Find items not in the solution and could be added without exceeding capacity\n    available_indices = np.where(new_solution == 0)[0]\n    if len(available_indices) > 0:\n        # Sort by the sum of normalized value1 and value2 (to balance both objectives)\n        value_sum = (value1_lst[available_indices] / np.max(value1_lst)) + (value2_lst[available_indices] / np.max(value2_lst))\n        sorted_indices = available_indices[np.argsort(value_sum)[::-1]]\n\n        for idx in sorted_indices:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 3: Optionally remove items to free up capacity for better items\n    included_indices = np.where(new_solution == 1)[0]\n    if len(included_indices) > 0:\n        # Sort by the sum of normalized value1 and value2 (ascending to remove least beneficial items first)\n        value_sum = (value1_lst[included_indices] / np.max(value1_lst)) + (value2_lst[included_indices] / np.max(value2_lst))\n        sorted_indices = included_indices[np.argsort(value_sum)]\n\n        for idx in sorted_indices:\n            if current_weight - weight_lst[idx] >= 0:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 290,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a promising solution from the archive\n    # Prefer solutions that are not too close to the boundary or too sparse\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip a subset of items to explore the neighborhood\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, try to include it if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Value-based adjustment - flip items with high marginal value\n    # Calculate marginal value for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Select top 2 items with highest marginal value for each objective\n    top_indices1 = np.argsort(-marginal_value1)[:2]\n    top_indices2 = np.argsort(-marginal_value2)[:2]\n\n    for idx in np.concatenate([top_indices1, top_indices2]):\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Step 3: Weight-based adjustment - try to balance the weight distribution\n    # If current weight is below half capacity, try to add more items\n    if current_weight < capacity / 2:\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            # Select items with smallest weight to fill the capacity\n            sorted_indices = np.argsort(weight_lst[candidate_indices])\n            for i in sorted_indices:\n                idx = candidate_indices[i]\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                else:\n                    break\n\n    # Ensure the solution is feasible\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If still infeasible, remove items with lowest marginal value until feasible\n        while total_weight > capacity:\n            # Calculate marginal value for included items\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            marginal_values = (value1_lst[included_indices] + value2_lst[included_indices]) / (weight_lst[included_indices] + 1e-10)\n            worst_idx = included_indices[np.argmin(marginal_values)]\n            new_solution[worst_idx] = 0\n            total_weight -= weight_lst[worst_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3486891596662477,
            1.4357922971248627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Intelligently select a promising solution from the archive\n    # Prefer solutions that are not too close to the boundary or too sparse\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly flip a subset of items to explore the neighborhood\n    flip_indices = np.random.choice(len(new_solution), size=min(3, len(new_solution)), replace=False)\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            # If item is included, try to exclude it if it doesn't violate capacity\n            if current_weight - weight_lst[idx] <= capacity:\n                new_solution[idx] = 0\n                current_weight -= weight_lst[idx]\n        else:\n            # If item is excluded, try to include it if it doesn't violate capacity\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Value-based adjustment - flip items with high marginal value\n    # Calculate marginal value for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-10)\n    marginal_value2 = value2_lst / (weight_lst + 1e-10)\n\n    # Select top 2 items with highest marginal value for each objective\n    top_indices1 = np.argsort(-marginal_value1)[:2]\n    top_indices2 = np.argsort(-marginal_value2)[:2]\n\n    for idx in np.concatenate([top_indices1, top_indices2]):\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n\n    # Step 3: Weight-based adjustment - try to balance the weight distribution\n    # If current weight is below half capacity, try to add more items\n    if current_weight < capacity / 2:\n        candidate_indices = np.where(new_solution == 0)[0]\n        if len(candidate_indices) > 0:\n            # Select items with smallest weight to fill the capacity\n            sorted_indices = np.argsort(weight_lst[candidate_indices])\n            for i in sorted_indices:\n                idx = candidate_indices[i]\n                if current_weight + weight_lst[idx] <= capacity:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                else:\n                    break\n\n    # Ensure the solution is feasible\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # If still infeasible, remove items with lowest marginal value until feasible\n        while total_weight > capacity:\n            # Calculate marginal value for included items\n            included_indices = np.where(new_solution == 1)[0]\n            if len(included_indices) == 0:\n                break\n            marginal_values = (value1_lst[included_indices] + value2_lst[included_indices]) / (weight_lst[included_indices] + 1e-10)\n            worst_idx = included_indices[np.argmin(marginal_values)]\n            new_solution[worst_idx] = 0\n            total_weight -= weight_lst[worst_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 291,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a bias towards those with higher total value sums\n    total_values = np.array([sum(obj) for _, obj in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flips followed by greedy improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random flip phase: try to flip a small number of items randomly\n    for _ in range(min(3, n_items)):\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    # Greedy improvement phase: try to add items that improve at least one objective\n    for i in range(n_items):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Check if adding this item improves at least one objective\n            if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final check to ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items randomly until feasible\n        feasible_indices = np.where(new_solution == 1)[0]\n        if len(feasible_indices) > 0:\n            remove_idx = random.choice(feasible_indices)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.3415527203920381,
            3.1303781270980835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with a bias towards those with higher total value sums\n    total_values = np.array([sum(obj) for _, obj in archive])\n    probabilities = total_values / np.sum(total_values)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: random flips followed by greedy improvement\n    n_items = len(weight_lst)\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Random flip phase: try to flip a small number of items randomly\n    for _ in range(min(3, n_items)):\n        flip_idx = random.randint(0, n_items - 1)\n        if new_solution[flip_idx] == 1:\n            if current_weight - weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 0\n                current_weight -= weight_lst[flip_idx]\n        else:\n            if current_weight + weight_lst[flip_idx] <= capacity:\n                new_solution[flip_idx] = 1\n                current_weight += weight_lst[flip_idx]\n\n    # Greedy improvement phase: try to add items that improve at least one objective\n    for i in range(n_items):\n        if new_solution[i] == 0 and current_weight + weight_lst[i] <= capacity:\n            # Check if adding this item improves at least one objective\n            if (value1_lst[i] > 0) or (value2_lst[i] > 0):\n                new_solution[i] = 1\n                current_weight += weight_lst[i]\n\n    # Final check to ensure feasibility\n    while np.sum(weight_lst[new_solution == 1]) > capacity:\n        # Remove items randomly until feasible\n        feasible_indices = np.where(new_solution == 1)[0]\n        if len(feasible_indices) > 0:\n            remove_idx = random.choice(feasible_indices)\n            new_solution[remove_idx] = 0\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 292,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with high potential for improvement\n    # Here, we prioritize solutions that are close to the capacity but not fully packed\n    base_solution, _ = max(archive, key=lambda x: np.sum(weight_lst * x[0]) / capacity)\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to swap (exploration)\n    # 2. Apply a greedy improvement phase to maximize both objectives (exploitation)\n\n    # Step 1: Random swaps\n    num_swaps = min(3, len(new_solution) // 2)  # Limit the number of swaps to avoid excessive changes\n    for _ in range(num_swaps):\n        # Select two random items to swap\n        indices = random.sample(range(len(new_solution)), 2)\n        i, j = indices[0], indices[1]\n\n        # Calculate potential weight change\n        delta_weight = (weight_lst[j] - weight_lst[i]) * (new_solution[j] - new_solution[i])\n\n        # Only swap if it doesn't violate capacity\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    # Step 2: Greedy improvement phase\n    # Iterate through all items and flip them if it improves both objectives\n    for i in range(len(new_solution)):\n        # Calculate potential weight change\n        delta_weight = weight_lst[i] * (1 - 2 * new_solution[i])\n\n        if current_weight + delta_weight <= capacity:\n            # Calculate potential value changes\n            delta_value1 = value1_lst[i] * (1 - 2 * new_solution[i])\n            delta_value2 = value2_lst[i] * (1 - 2 * new_solution[i])\n\n            # Flip the item if it improves both objectives\n            if delta_value1 > 0 and delta_value2 > 0:\n                new_solution[i] = 1 - new_solution[i]\n                current_weight += delta_weight\n\n    return new_solution\n\n",
        "score": [
            -0.8046064638376431,
            3.5449845790863037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a bias towards solutions with high potential for improvement\n    # Here, we prioritize solutions that are close to the capacity but not fully packed\n    base_solution, _ = max(archive, key=lambda x: np.sum(weight_lst * x[0]) / capacity)\n\n    new_solution = base_solution.copy()\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to swap (exploration)\n    # 2. Apply a greedy improvement phase to maximize both objectives (exploitation)\n\n    # Step 1: Random swaps\n    num_swaps = min(3, len(new_solution) // 2)  # Limit the number of swaps to avoid excessive changes\n    for _ in range(num_swaps):\n        # Select two random items to swap\n        indices = random.sample(range(len(new_solution)), 2)\n        i, j = indices[0], indices[1]\n\n        # Calculate potential weight change\n        delta_weight = (weight_lst[j] - weight_lst[i]) * (new_solution[j] - new_solution[i])\n\n        # Only swap if it doesn't violate capacity\n        if current_weight + delta_weight <= capacity:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            current_weight += delta_weight\n\n    # Step 2: Greedy improvement phase\n    # Iterate through all items and flip them if it improves both objectives\n    for i in range(len(new_solution)):\n        # Calculate potential weight change\n        delta_weight = weight_lst[i] * (1 - 2 * new_solution[i])\n\n        if current_weight + delta_weight <= capacity:\n            # Calculate potential value changes\n            delta_value1 = value1_lst[i] * (1 - 2 * new_solution[i])\n            delta_value2 = value2_lst[i] * (1 - 2 * new_solution[i])\n\n            # Flip the item if it improves both objectives\n            if delta_value1 > 0 and delta_value2 > 0:\n                new_solution[i] = 1 - new_solution[i]\n                current_weight += delta_weight\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 293,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher combined value\n    weights = np.array([sol[1][0] + sol[1][1] for sol in archive])\n    weights = weights / np.sum(weights)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a random perturbation (flip a small number of bits)\n    new_solution = base_solution.copy()\n    num_flips = min(3, len(new_solution))  # Flip up to 3 bits\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by checking capacity\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # If infeasible, perform a greedy repair step\n        # Remove items with lowest (value1 + value2) / weight ratio until feasible\n        while total_weight > capacity:\n            # Calculate (value1 + value2) / weight for each item in the knapsack\n            item_ratios = (value1_lst + value2_lst) / weight_lst\n            # Find items in the knapsack with the lowest ratio\n            in_knapsack = np.where(new_solution == 1)[0]\n            if len(in_knapsack) == 0:\n                break  # No items left to remove\n            min_ratio_idx = in_knapsack[np.argmin(item_ratios[in_knapsack])]\n            new_solution[min_ratio_idx] = 0\n            total_weight = np.sum(new_solution * weight_lst)\n\n    # Perform a greedy improvement step\n    # Try to add items not in the knapsack that improve both objectives\n    not_in_knapsack = np.where(new_solution == 0)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n    for idx in not_in_knapsack:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves both objectives\n            if value1_lst[idx] > 0 and value2_lst[idx] > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.3723925804429613,
            2.948032647371292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with higher combined value\n    weights = np.array([sol[1][0] + sol[1][1] for sol in archive])\n    weights = weights / np.sum(weights)  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Perform a random perturbation (flip a small number of bits)\n    new_solution = base_solution.copy()\n    num_flips = min(3, len(new_solution))  # Flip up to 3 bits\n    flip_indices = random.sample(range(len(new_solution)), num_flips)\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # Ensure feasibility by checking capacity\n    total_weight = np.sum(new_solution * weight_lst)\n    if total_weight > capacity:\n        # If infeasible, perform a greedy repair step\n        # Remove items with lowest (value1 + value2) / weight ratio until feasible\n        while total_weight > capacity:\n            # Calculate (value1 + value2) / weight for each item in the knapsack\n            item_ratios = (value1_lst + value2_lst) / weight_lst\n            # Find items in the knapsack with the lowest ratio\n            in_knapsack = np.where(new_solution == 1)[0]\n            if len(in_knapsack) == 0:\n                break  # No items left to remove\n            min_ratio_idx = in_knapsack[np.argmin(item_ratios[in_knapsack])]\n            new_solution[min_ratio_idx] = 0\n            total_weight = np.sum(new_solution * weight_lst)\n\n    # Perform a greedy improvement step\n    # Try to add items not in the knapsack that improve both objectives\n    not_in_knapsack = np.where(new_solution == 0)[0]\n    current_weight = np.sum(new_solution * weight_lst)\n    for idx in not_in_knapsack:\n        if current_weight + weight_lst[idx] <= capacity:\n            # Check if adding this item improves both objectives\n            if value1_lst[idx] > 0 and value2_lst[idx] > 0:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 294,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    # Prioritize solutions that are not too close to the Pareto front or have high marginal contributions\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high marginal contributions\n    high_marginal_items = np.logical_or(\n        marginal_value1 > np.percentile(marginal_value1, 75),\n        marginal_value2 > np.percentile(marginal_value2, 75)\n    )\n\n    # Create a new solution by flipping a subset of items with high marginal contributions\n    new_solution = base_solution.copy()\n    flip_indices = np.where(high_marginal_items)[0]\n\n    # Randomly select a subset of items to flip (between 1 and min(5, len(flip_indices)))\n    if len(flip_indices) > 0:\n        num_flips = np.random.randint(1, min(5, len(flip_indices)) + 1)\n        flip_candidates = np.random.choice(flip_indices, size=num_flips, replace=False)\n        new_solution[flip_candidates] = 1 - new_solution[flip_candidates]\n\n    # Ensure feasibility by removing items that exceed capacity\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until the solution is feasible\n        excess_weight = current_weight - capacity\n        while excess_weight > 0:\n            # Select items to remove based on the smallest ratio of marginal contribution to weight\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate the ratio of marginal contribution to weight for each included item\n            marginal_ratios = (marginal_value1[included_items] + marginal_value2[included_items]) / (weight_lst[included_items] + 1e-6)\n            remove_idx = included_items[np.argmin(marginal_ratios)]\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.2751119158764973,
            2.9186343252658844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a promising solution with high potential for improvement\n    # Prioritize solutions that are not too close to the Pareto front or have high marginal contributions\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_value1, current_value2) = archive[selected_idx]\n\n    # Calculate marginal contributions for each item\n    marginal_value1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n    marginal_value2 = value2_lst / (weight_lst + 1e-6)\n\n    # Identify items with high marginal contributions\n    high_marginal_items = np.logical_or(\n        marginal_value1 > np.percentile(marginal_value1, 75),\n        marginal_value2 > np.percentile(marginal_value2, 75)\n    )\n\n    # Create a new solution by flipping a subset of items with high marginal contributions\n    new_solution = base_solution.copy()\n    flip_indices = np.where(high_marginal_items)[0]\n\n    # Randomly select a subset of items to flip (between 1 and min(5, len(flip_indices)))\n    if len(flip_indices) > 0:\n        num_flips = np.random.randint(1, min(5, len(flip_indices)) + 1)\n        flip_candidates = np.random.choice(flip_indices, size=num_flips, replace=False)\n        new_solution[flip_candidates] = 1 - new_solution[flip_candidates]\n\n    # Ensure feasibility by removing items that exceed capacity\n    current_weight = np.sum(weight_lst[new_solution == 1])\n    if current_weight > capacity:\n        # Remove items until the solution is feasible\n        excess_weight = current_weight - capacity\n        while excess_weight > 0:\n            # Select items to remove based on the smallest ratio of marginal contribution to weight\n            included_items = np.where(new_solution == 1)[0]\n            if len(included_items) == 0:\n                break\n            # Calculate the ratio of marginal contribution to weight for each included item\n            marginal_ratios = (marginal_value1[included_items] + marginal_value2[included_items]) / (weight_lst[included_items] + 1e-6)\n            remove_idx = included_items[np.argmin(marginal_ratios)]\n            new_solution[remove_idx] = 0\n            excess_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 295,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not too close to the boundary\n    base_solution, _ = random.choice(archive)\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Identify items that can be added without exceeding capacity\n    feasible_items = (weight_lst <= remaining_capacity) & (base_solution == 0)\n    feasible_indices = np.where(feasible_items)[0]\n\n    # If no items can be added, consider removing items with low value-to-weight ratios\n    if len(feasible_indices) == 0:\n        # Select items to remove based on the worst ratio in either objective\n        worst_ratio_indices = np.argsort(np.minimum(ratio1, ratio2))\n        worst_indices = worst_ratio_indices[base_solution[worst_ratio_indices] == 1]\n\n        if len(worst_indices) > 0:\n            # Remove one of the worst items\n            item_to_remove = random.choice(worst_indices)\n            new_solution = base_solution.copy()\n            new_solution[item_to_remove] = 0\n            return new_solution\n        else:\n            # If no items can be removed, return the base solution as is\n            return base_solution.copy()\n\n    # Otherwise, add one of the feasible items with high value-to-weight ratio\n    # Prefer items that have high ratios in both objectives\n    combined_ratio = ratio1 + ratio2\n    best_indices = feasible_indices[np.argsort(combined_ratio[feasible_indices])[-min(5, len(feasible_indices)):]]\n\n    if len(best_indices) > 0:\n        item_to_add = random.choice(best_indices)\n        new_solution = base_solution.copy()\n        new_solution[item_to_add] = 1\n        return new_solution\n\n    # Fallback: randomly flip one item if no better option is found\n    flip_index = random.choice(np.where(base_solution == 1)[0])\n    new_solution = base_solution.copy()\n    new_solution[flip_index] = 0\n    return new_solution\n\n",
        "score": [
            -0.9075683031037491,
            0.8445137739181519
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a base solution with a bias towards solutions that are not too close to the boundary\n    base_solution, _ = random.choice(archive)\n    current_weight = np.sum(weight_lst * base_solution)\n    remaining_capacity = capacity - current_weight\n\n    # Calculate value-to-weight ratios for both objectives\n    ratio1 = value1_lst / weight_lst\n    ratio2 = value2_lst / weight_lst\n\n    # Identify items that can be added without exceeding capacity\n    feasible_items = (weight_lst <= remaining_capacity) & (base_solution == 0)\n    feasible_indices = np.where(feasible_items)[0]\n\n    # If no items can be added, consider removing items with low value-to-weight ratios\n    if len(feasible_indices) == 0:\n        # Select items to remove based on the worst ratio in either objective\n        worst_ratio_indices = np.argsort(np.minimum(ratio1, ratio2))\n        worst_indices = worst_ratio_indices[base_solution[worst_ratio_indices] == 1]\n\n        if len(worst_indices) > 0:\n            # Remove one of the worst items\n            item_to_remove = random.choice(worst_indices)\n            new_solution = base_solution.copy()\n            new_solution[item_to_remove] = 0\n            return new_solution\n        else:\n            # If no items can be removed, return the base solution as is\n            return base_solution.copy()\n\n    # Otherwise, add one of the feasible items with high value-to-weight ratio\n    # Prefer items that have high ratios in both objectives\n    combined_ratio = ratio1 + ratio2\n    best_indices = feasible_indices[np.argsort(combined_ratio[feasible_indices])[-min(5, len(feasible_indices)):]]\n\n    if len(best_indices) > 0:\n        item_to_add = random.choice(best_indices)\n        new_solution = base_solution.copy()\n        new_solution[item_to_add] = 1\n        return new_solution\n\n    # Fallback: randomly flip one item if no better option is found\n    flip_index = random.choice(np.where(base_solution == 1)[0])\n    new_solution = base_solution.copy()\n    new_solution[flip_index] = 0\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 296,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Calculate the potential of each solution in the archive\n    potential_scores = []\n    for solution, _ in archive:\n        total_weight = np.sum(weight_lst * solution)\n        remaining_capacity = capacity - total_weight\n        # Calculate the sum of marginal values per unit weight for items not in the solution\n        marginal_values1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal_values2 = value2_lst / (weight_lst + 1e-6)\n        potential_score = np.sum(marginal_values1 * (1 - solution)) + np.sum(marginal_values2 * (1 - solution))\n        potential_scores.append(potential_score)\n\n    # Select the solution with the highest potential score\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine random flip with targeted flip based on marginal values\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    candidates = np.where((1 - new_solution) * (weight_lst <= (capacity - total_weight)))[0]\n\n    if len(candidates) > 0:\n        # Targeted flip: add the item with the highest marginal value (combined for both objectives)\n        marginal_values = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        best_candidate = candidates[np.argmax(marginal_values[candidates])]\n        new_solution[best_candidate] = 1\n    else:\n        # If no items can be added, try removing the item with the lowest marginal value (combined for both objectives)\n        if np.sum(new_solution) > 0:\n            marginal_values = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidates_to_remove = np.where(new_solution)[0]\n            worst_candidate = candidates_to_remove[np.argmin(marginal_values[candidates_to_remove])]\n            new_solution[worst_candidate] = 0\n\n    # Random flip: with a small probability, flip a random item to escape local optima\n    if random.random() < 0.1:\n        flip_candidate = random.choice(np.where(new_solution)[0] if np.sum(new_solution) > 0 else range(len(weight_lst)))\n        new_solution[flip_candidate] = 1 - new_solution[flip_candidate]\n        # Ensure feasibility after random flip\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[flip_candidate] = 1 - new_solution[flip_candidate]\n\n    return new_solution\n\n",
        "score": [
            -0.8048031895611091,
            4.665411621332169
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros(len(weight_lst), dtype=int)\n\n    # Calculate the potential of each solution in the archive\n    potential_scores = []\n    for solution, _ in archive:\n        total_weight = np.sum(weight_lst * solution)\n        remaining_capacity = capacity - total_weight\n        # Calculate the sum of marginal values per unit weight for items not in the solution\n        marginal_values1 = value1_lst / (weight_lst + 1e-6)  # Avoid division by zero\n        marginal_values2 = value2_lst / (weight_lst + 1e-6)\n        potential_score = np.sum(marginal_values1 * (1 - solution)) + np.sum(marginal_values2 * (1 - solution))\n        potential_scores.append(potential_score)\n\n    # Select the solution with the highest potential score\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine random flip with targeted flip based on marginal values\n    new_solution = base_solution.copy()\n    total_weight = np.sum(weight_lst * new_solution)\n\n    # Identify items not in the solution that can be added without exceeding capacity\n    candidates = np.where((1 - new_solution) * (weight_lst <= (capacity - total_weight)))[0]\n\n    if len(candidates) > 0:\n        # Targeted flip: add the item with the highest marginal value (combined for both objectives)\n        marginal_values = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n        best_candidate = candidates[np.argmax(marginal_values[candidates])]\n        new_solution[best_candidate] = 1\n    else:\n        # If no items can be added, try removing the item with the lowest marginal value (combined for both objectives)\n        if np.sum(new_solution) > 0:\n            marginal_values = (value1_lst + value2_lst) / (weight_lst + 1e-6)\n            candidates_to_remove = np.where(new_solution)[0]\n            worst_candidate = candidates_to_remove[np.argmin(marginal_values[candidates_to_remove])]\n            new_solution[worst_candidate] = 0\n\n    # Random flip: with a small probability, flip a random item to escape local optima\n    if random.random() < 0.1:\n        flip_candidate = random.choice(np.where(new_solution)[0] if np.sum(new_solution) > 0 else range(len(weight_lst)))\n        new_solution[flip_candidate] = 1 - new_solution[flip_candidate]\n        # Ensure feasibility after random flip\n        if np.sum(weight_lst * new_solution) > capacity:\n            new_solution[flip_candidate] = 1 - new_solution[flip_candidate]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 297,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (non-dominated set)\n        # Here, we randomly select among the middle 50% of solutions to encourage exploration\n        selected_idx = random.randint(len(archive) // 4, 3 * len(archive) // 4)\n        base_solution, _ = archive[selected_idx]\n    else:\n        base_solution, _ = archive[0]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small number of items (1-3)\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = np.random.choice(len(new_solution), num_flips, replace=False)\n\n    for idx in flip_indices:\n        # Flip the bit\n        new_solution[idx] = 1 - new_solution[idx]\n\n        # Check feasibility\n        if new_solution[idx] == 1:\n            current_weight += weight_lst[idx]\n        else:\n            current_weight -= weight_lst[idx]\n\n        # If exceeding capacity, revert the flip\n        if current_weight > capacity:\n            new_solution[idx] = 1 - new_solution[idx]\n            current_weight -= weight_lst[idx] if new_solution[idx] == 1 else -weight_lst[idx]\n\n    # 2. Apply value-based heuristic: flip items that improve both objectives\n    # Calculate marginal values for both objectives\n    marginal_value1 = value1_lst / weight_lst\n    marginal_value2 = value2_lst / weight_lst\n\n    # Sort items by their combined marginal value (weighted sum)\n    combined_marginal = marginal_value1 + marginal_value2\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Add item if it improves both objectives\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Remove item if it doesn't improve both objectives\n            # (This is a simplification - in practice you might want to check actual objective improvements)\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n",
        "score": [
            -0.4615880137005905,
            2.5263301134109497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their dominance (non-dominated set)\n        # Here, we randomly select among the middle 50% of solutions to encourage exploration\n        selected_idx = random.randint(len(archive) // 4, 3 * len(archive) // 4)\n        base_solution, _ = archive[selected_idx]\n    else:\n        base_solution, _ = archive[0]\n\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a small number of items (1-3)\n    num_flips = random.randint(1, min(3, len(new_solution)))\n    flip_indices = np.random.choice(len(new_solution), num_flips, replace=False)\n\n    for idx in flip_indices:\n        # Flip the bit\n        new_solution[idx] = 1 - new_solution[idx]\n\n        # Check feasibility\n        if new_solution[idx] == 1:\n            current_weight += weight_lst[idx]\n        else:\n            current_weight -= weight_lst[idx]\n\n        # If exceeding capacity, revert the flip\n        if current_weight > capacity:\n            new_solution[idx] = 1 - new_solution[idx]\n            current_weight -= weight_lst[idx] if new_solution[idx] == 1 else -weight_lst[idx]\n\n    # 2. Apply value-based heuristic: flip items that improve both objectives\n    # Calculate marginal values for both objectives\n    marginal_value1 = value1_lst / weight_lst\n    marginal_value2 = value2_lst / weight_lst\n\n    # Sort items by their combined marginal value (weighted sum)\n    combined_marginal = marginal_value1 + marginal_value2\n    sorted_indices = np.argsort(combined_marginal)[::-1]\n\n    for idx in sorted_indices:\n        if new_solution[idx] == 0 and current_weight + weight_lst[idx] <= capacity:\n            # Add item if it improves both objectives\n            new_solution[idx] = 1\n            current_weight += weight_lst[idx]\n        elif new_solution[idx] == 1:\n            # Remove item if it doesn't improve both objectives\n            # (This is a simplification - in practice you might want to check actual objective improvements)\n            new_solution[idx] = 0\n            current_weight -= weight_lst[idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 298,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with probability proportional to its normalized objective values\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    weights = np.sum(normalized, axis=1)\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Multi-dimensional flip: flip items based on both objectives\n    # 2. Weighted random selection of flip candidates\n    # 3. Iterative improvement with feasibility check\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine how many items to flip (1-3 items)\n    n_flips = min(3, max(1, np.random.randint(1, n_items // 2 + 1)))\n\n    for _ in range(n_flips):\n        # Calculate flip scores based on both objectives\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Weighted selection of items to flip out\n            out_weights = weight_lst[out_items]\n            out_values1 = value1_lst[out_items]\n            out_values2 = value2_lst[out_items]\n\n            # Normalized scores combining both objectives\n            norm_weights = out_weights / np.max(out_weights + 1e-10)\n            norm_values1 = out_values1 / (np.max(out_values1) + 1e-10)\n            norm_values2 = out_values2 / (np.max(out_values2) + 1e-10)\n\n            # Combined score (can be adjusted based on problem characteristics)\n            scores = 0.4 * (1 - norm_weights) + 0.3 * norm_values1 + 0.3 * norm_values2\n            scores = scores / np.sum(scores)  # Normalize to probabilities\n\n            # Select item to flip out\n            flip_out_idx = np.random.choice(len(out_items), p=scores)\n            item_out = out_items[flip_out_idx]\n\n            # Select item to flip in (prioritize high-value items)\n            in_weights = weight_lst[in_items]\n            in_values1 = value1_lst[in_items]\n            in_values2 = value2_lst[in_items]\n\n            # Check feasibility for each potential flip\n            feasible_in = []\n            for i, item_in in enumerate(in_items):\n                delta_weight = weight_lst[item_in] - weight_lst[item_out]\n                if current_weight + delta_weight <= capacity:\n                    feasible_in.append(i)\n\n            if feasible_in:\n                # Select from feasible items with preference for higher values\n                in_scores = 0.5 * in_values1[feasible_in] + 0.5 * in_values2[feasible_in]\n                in_scores = in_scores / np.sum(in_scores)\n\n                flip_in_idx = np.random.choice(len(feasible_in), p=in_scores)\n                item_in = in_items[feasible_in[flip_in_idx]]\n\n                # Perform the flip\n                new_solution[item_out] = 1\n                new_solution[item_in] = 0\n                current_weight += weight_lst[item_in] - weight_lst[item_out]\n\n    return new_solution\n\n",
        "score": [
            -0.37796713694543527,
            5.330749213695526
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with probability proportional to its normalized objective values\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized = objectives / (np.sum(objectives, axis=0) + 1e-10)  # Avoid division by zero\n    weights = np.sum(normalized, axis=1)\n    weights = weights / np.sum(weights)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Multi-dimensional flip: flip items based on both objectives\n    # 2. Weighted random selection of flip candidates\n    # 3. Iterative improvement with feasibility check\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst[new_solution == 1])\n\n    # Determine how many items to flip (1-3 items)\n    n_flips = min(3, max(1, np.random.randint(1, n_items // 2 + 1)))\n\n    for _ in range(n_flips):\n        # Calculate flip scores based on both objectives\n        in_items = np.where(new_solution == 1)[0]\n        out_items = np.where(new_solution == 0)[0]\n\n        if len(in_items) > 0 and len(out_items) > 0:\n            # Weighted selection of items to flip out\n            out_weights = weight_lst[out_items]\n            out_values1 = value1_lst[out_items]\n            out_values2 = value2_lst[out_items]\n\n            # Normalized scores combining both objectives\n            norm_weights = out_weights / np.max(out_weights + 1e-10)\n            norm_values1 = out_values1 / (np.max(out_values1) + 1e-10)\n            norm_values2 = out_values2 / (np.max(out_values2) + 1e-10)\n\n            # Combined score (can be adjusted based on problem characteristics)\n            scores = 0.4 * (1 - norm_weights) + 0.3 * norm_values1 + 0.3 * norm_values2\n            scores = scores / np.sum(scores)  # Normalize to probabilities\n\n            # Select item to flip out\n            flip_out_idx = np.random.choice(len(out_items), p=scores)\n            item_out = out_items[flip_out_idx]\n\n            # Select item to flip in (prioritize high-value items)\n            in_weights = weight_lst[in_items]\n            in_values1 = value1_lst[in_items]\n            in_values2 = value2_lst[in_items]\n\n            # Check feasibility for each potential flip\n            feasible_in = []\n            for i, item_in in enumerate(in_items):\n                delta_weight = weight_lst[item_in] - weight_lst[item_out]\n                if current_weight + delta_weight <= capacity:\n                    feasible_in.append(i)\n\n            if feasible_in:\n                # Select from feasible items with preference for higher values\n                in_scores = 0.5 * in_values1[feasible_in] + 0.5 * in_values2[feasible_in]\n                in_scores = in_scores / np.sum(in_scores)\n\n                flip_in_idx = np.random.choice(len(feasible_in), p=in_scores)\n                item_in = in_items[feasible_in[flip_in_idx]]\n\n                # Perform the flip\n                new_solution[item_out] = 1\n                new_solution[item_in] = 0\n                current_weight += weight_lst[item_in] - weight_lst[item_out]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 299,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Prioritize solutions that are not too close to the boundary (neither full nor empty)\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if 0.2 * capacity <= total_weight <= 0.8 * capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        # If no candidates, select the solution with the highest total value (sum of both objectives)\n        archive.sort(key=lambda x: x[1][0] + x[1][1], reverse=True)\n        base_solution = archive[0][0].copy()\n    else:\n        # Randomly select from candidates to introduce diversity\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (swap 0 and 1)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # 2. Greedily add items with high marginal value-to-weight ratios\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal value-to-weight ratios for both objectives\n        marginal_ratio1 = value1_lst / weight_lst\n        marginal_ratio2 = value2_lst / weight_lst\n        combined_ratio = marginal_ratio1 + marginal_ratio2  # Simple combination for multi-objective\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                if remaining_capacity <= 0:\n                    break\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            selected_indices = np.where(new_solution == 1)[0]\n            if len(selected_indices) == 0:\n                break\n            remove_idx = random.choice(selected_indices)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n",
        "score": [
            -0.31541692331740057,
            8.200765579938889
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution with high potential for improvement\n    # Prioritize solutions that are not too close to the boundary (neither full nor empty)\n    candidates = []\n    for sol, _ in archive:\n        total_weight = np.sum(weight_lst * sol)\n        if 0.2 * capacity <= total_weight <= 0.8 * capacity:\n            candidates.append(sol)\n\n    if not candidates:\n        # If no candidates, select the solution with the highest total value (sum of both objectives)\n        archive.sort(key=lambda x: x[1][0] + x[1][1], reverse=True)\n        base_solution = archive[0][0].copy()\n    else:\n        # Randomly select from candidates to introduce diversity\n        base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n_items = len(weight_lst)\n\n    # Hybrid local search strategy:\n    # 1. Randomly select a subset of items to flip (swap 0 and 1)\n    flip_indices = random.sample(range(n_items), min(3, n_items))\n    for idx in flip_indices:\n        new_solution[idx] = 1 - new_solution[idx]\n\n    # 2. Greedily add items with high marginal value-to-weight ratios\n    current_weight = np.sum(weight_lst * new_solution)\n    remaining_capacity = capacity - current_weight\n\n    if remaining_capacity > 0:\n        # Calculate marginal value-to-weight ratios for both objectives\n        marginal_ratio1 = value1_lst / weight_lst\n        marginal_ratio2 = value2_lst / weight_lst\n        combined_ratio = marginal_ratio1 + marginal_ratio2  # Simple combination for multi-objective\n\n        # Sort items by combined ratio in descending order\n        sorted_indices = np.argsort(-combined_ratio)\n\n        for idx in sorted_indices:\n            if new_solution[idx] == 0 and weight_lst[idx] <= remaining_capacity:\n                new_solution[idx] = 1\n                remaining_capacity -= weight_lst[idx]\n                if remaining_capacity <= 0:\n                    break\n\n    # Ensure feasibility\n    total_weight = np.sum(weight_lst * new_solution)\n    if total_weight > capacity:\n        # Remove items randomly until feasible\n        while total_weight > capacity:\n            selected_indices = np.where(new_solution == 1)[0]\n            if len(selected_indices) == 0:\n                break\n            remove_idx = random.choice(selected_indices)\n            new_solution[remove_idx] = 0\n            total_weight -= weight_lst[remove_idx]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Knapsack Problem (BI-KP), where each item has a weight and two profit values: value1 and value2. The goal is to select a subset of items such that the total weight does not exceed a given capacity, while simultaneously maximizing the total value in both objective spaces. Given an archive of non-dominated solutions, where each solution is a binary numpy array indicating item inclusion (1) or exclusion (0), and its corresponding objective is a tuple of two values (total value1, total value2), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it. Must always ensure that the generated neighbor solution remains feasible, i.e., the total weight must not exceed the knapsack capacity Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 300,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (intelligent selection)\n    # 2. If feasible, apply a greedy improvement step\n    # 3. If not feasible, apply a repair mechanism\n\n    # Step 1: Intelligent random flip\n    flip_indices = np.where(np.random.rand(len(new_solution)) < 0.2)[0]  # 20% chance to flip each item\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Greedy improvement (add items that improve both objectives)\n    for _ in range(3):  # Limit iterations to prevent excessive computation\n        improved = False\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate potential improvement\n                potential_val1 = current_val1 + value1_lst[idx]\n                potential_val2 = current_val2 + value2_lst[idx]\n\n                # Check if this addition improves both objectives\n                better_than_original = True\n                for sol, (val1, val2) in archive:\n                    if (val1 >= potential_val1 and val2 >= potential_val2) and (val1 > potential_val1 or val2 > potential_val2):\n                        better_than_original = False\n                        break\n\n                if better_than_original:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_val1 = potential_val1\n                    current_val2 = potential_val2\n                    improved = True\n                    break\n\n        if not improved:\n            break\n\n    # Step 3: Repair if still infeasible (remove items with lowest value ratio)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Calculate value ratios for items in solution\n        ratios = np.zeros_like(new_solution, dtype=float)\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            ratios[in_solution] = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n\n            # Sort items by value ratio and remove until feasible\n            sorted_indices = np.argsort(ratios[in_solution])\n            for i in sorted_indices:\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n                new_solution[in_solution[i]] = 0\n\n    return new_solution\n\n",
        "score": [
            -0.9093384444894721,
            1.1732750535011292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], weight_lst: np.ndarray, value1_lst: np.ndarray, value2_lst: np.ndarray, capacity: float) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a binary numpy array (0/1) of item selections.\n             Each objective is a tuple of two float values (total value1, total value2).\n    weight_lst: Numpy array of shape (N, ), item weights.\n    value1_lst: Numpy array of shape (N, ), item values for objective 1.\n    value2_lst: Numpy array of shape (N, ), item values for objective 2.\n    capacity: Maximum allowed total weight.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        return np.zeros_like(weight_lst, dtype=int)\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution, (current_val1, current_val2) = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Calculate current total weight\n    current_weight = np.sum(weight_lst * new_solution)\n\n    # Hybrid local search strategy:\n    # 1. Randomly flip a subset of items (intelligent selection)\n    # 2. If feasible, apply a greedy improvement step\n    # 3. If not feasible, apply a repair mechanism\n\n    # Step 1: Intelligent random flip\n    flip_indices = np.where(np.random.rand(len(new_solution)) < 0.2)[0]  # 20% chance to flip each item\n    for idx in flip_indices:\n        if new_solution[idx] == 1:\n            new_solution[idx] = 0\n        else:\n            if current_weight + weight_lst[idx] <= capacity:\n                new_solution[idx] = 1\n                current_weight += weight_lst[idx]\n\n    # Step 2: Greedy improvement (add items that improve both objectives)\n    for _ in range(3):  # Limit iterations to prevent excessive computation\n        improved = False\n        for idx in np.where(new_solution == 0)[0]:\n            if current_weight + weight_lst[idx] <= capacity:\n                # Calculate potential improvement\n                potential_val1 = current_val1 + value1_lst[idx]\n                potential_val2 = current_val2 + value2_lst[idx]\n\n                # Check if this addition improves both objectives\n                better_than_original = True\n                for sol, (val1, val2) in archive:\n                    if (val1 >= potential_val1 and val2 >= potential_val2) and (val1 > potential_val1 or val2 > potential_val2):\n                        better_than_original = False\n                        break\n\n                if better_than_original:\n                    new_solution[idx] = 1\n                    current_weight += weight_lst[idx]\n                    current_val1 = potential_val1\n                    current_val2 = potential_val2\n                    improved = True\n                    break\n\n        if not improved:\n            break\n\n    # Step 3: Repair if still infeasible (remove items with lowest value ratio)\n    if np.sum(weight_lst * new_solution) > capacity:\n        # Calculate value ratios for items in solution\n        ratios = np.zeros_like(new_solution, dtype=float)\n        in_solution = np.where(new_solution == 1)[0]\n        if len(in_solution) > 0:\n            ratios[in_solution] = (value1_lst[in_solution] + value2_lst[in_solution]) / weight_lst[in_solution]\n\n            # Sort items by value ratio and remove until feasible\n            sorted_indices = np.argsort(ratios[in_solution])\n            for i in sorted_indices:\n                if np.sum(weight_lst * new_solution) <= capacity:\n                    break\n                new_solution[in_solution[i]] = 0\n\n    return new_solution\n\n"
    }
]