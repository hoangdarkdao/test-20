[
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance or crowding distance\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it (edge insertion)\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Apply node relocation: move a random node to a different position\n    node_to_move = random.randint(0, n - 1)\n    new_position = random.randint(0, n - 1)\n    if node_to_move != new_position:\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        new_solution = np.insert(new_solution, new_position, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8731179384829828,
            1.7674221992492676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance or crowding distance\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it (edge insertion)\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Apply node relocation: move a random node to a different position\n    node_to_move = random.randint(0, n - 1)\n    new_position = random.randint(0, n - 1)\n    if node_to_move != new_position:\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        new_solution = np.insert(new_solution, new_position, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance or crowding distance\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it (edge insertion)\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Apply node relocation: move a random node to a different position\n    node_to_move = random.randint(0, n - 1)\n    new_position = random.randint(0, n - 1)\n    if node_to_move != new_position:\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        new_solution = np.insert(new_solution, new_position, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8731179384829828,
            1.7674221992492676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance or crowding distance\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it (edge insertion)\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Apply node relocation: move a random node to a different position\n    node_to_move = random.randint(0, n - 1)\n    new_position = random.randint(0, n - 1)\n    if node_to_move != new_position:\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        new_solution = np.insert(new_solution, new_position, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 1,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance or crowding distance\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it (edge insertion)\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Apply node relocation: move a random node to a different position\n    node_to_move = random.randint(0, n - 1)\n    new_position = random.randint(0, n - 1)\n    if node_to_move != new_position:\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        new_solution = np.insert(new_solution, new_position, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8731179384829828,
            1.7674221992492676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance or crowding distance\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Randomly select a segment to modify\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it (edge insertion)\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Apply node relocation: move a random node to a different position\n    node_to_move = random.randint(0, n - 1)\n    new_position = random.randint(0, n - 1)\n    if node_to_move != new_position:\n        node = new_solution[node_to_move]\n        new_solution = np.delete(new_solution, node_to_move)\n        new_solution = np.insert(new_solution, new_position, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 2,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or improving\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node insertion (move a node to a different position)\n    if n > 2:\n        node_idx = random.randint(0, n-1)\n        new_pos = random.randint(0, n-1)\n        if node_idx != new_pos:\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 3: Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # If duplicate nodes exist, repair by replacing duplicates with missing nodes\n        missing_nodes = set(range(n)) - set(new_solution)\n        duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            if missing_nodes:\n                replace_idx = np.where(new_solution == dup)[0][0]\n                new_solution[replace_idx] = missing_nodes.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.745279424976074,
            1.8752354383468628
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or improving\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = random.randint(0, min(2, len(archive_sorted) - 1))  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Node insertion (move a node to a different position)\n    if n > 2:\n        node_idx = random.randint(0, n-1)\n        new_pos = random.randint(0, n-1)\n        if node_idx != new_pos:\n            node = new_solution[node_idx]\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Step 3: Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        # If duplicate nodes exist, repair by replacing duplicates with missing nodes\n        missing_nodes = set(range(n)) - set(new_solution)\n        duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            if missing_nodes:\n                replace_idx = np.where(new_solution == dup)[0][0]\n                new_solution[replace_idx] = missing_nodes.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    # Here, we select the solution with the highest sum of objectives as a starting point\n    objectives = [obj for _, obj in archive]\n    max_sum = max(sum(obj) for obj in objectives)\n    candidates = [sol for sol, obj in archive if sum(obj) == max_sum]\n    base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    for _ in range(3):  # Repeat the process a few times for better exploration\n        # Randomly choose one of the three local search operators\n        operator = random.choice(['edge_insertion', 'segment_reversal', 'random_swap'])\n\n        if operator == 'edge_insertion':\n            # Edge insertion: remove a random edge and insert it elsewhere\n            i, j = sorted(random.sample(range(n), 2))\n            if i == 0 and j == n - 1:\n                continue  # Skip to avoid invalid tours\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n        elif operator == 'segment_reversal':\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            if i == 0 and j == n - 1:\n                continue  # Skip to avoid invalid tours\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'random_swap':\n            # Random swap: swap two random nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9580032609813398,
            2.219999372959137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    # Here, we select the solution with the highest sum of objectives as a starting point\n    objectives = [obj for _, obj in archive]\n    max_sum = max(sum(obj) for obj in objectives)\n    candidates = [sol for sol, obj in archive if sum(obj) == max_sum]\n    base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    for _ in range(3):  # Repeat the process a few times for better exploration\n        # Randomly choose one of the three local search operators\n        operator = random.choice(['edge_insertion', 'segment_reversal', 'random_swap'])\n\n        if operator == 'edge_insertion':\n            # Edge insertion: remove a random edge and insert it elsewhere\n            i, j = sorted(random.sample(range(n), 2))\n            if i == 0 and j == n - 1:\n                continue  # Skip to avoid invalid tours\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n        elif operator == 'segment_reversal':\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            if i == 0 and j == n - 1:\n                continue  # Skip to avoid invalid tours\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'random_swap':\n            # Random swap: swap two random nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 3,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    # Here, we select the solution with the highest sum of objectives as a starting point\n    objectives = [obj for _, obj in archive]\n    max_sum = max(sum(obj) for obj in objectives)\n    candidates = [sol for sol, obj in archive if sum(obj) == max_sum]\n    base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    for _ in range(3):  # Repeat the process a few times for better exploration\n        # Randomly choose one of the three local search operators\n        operator = random.choice(['edge_insertion', 'segment_reversal', 'random_swap'])\n\n        if operator == 'edge_insertion':\n            # Edge insertion: remove a random edge and insert it elsewhere\n            i, j = sorted(random.sample(range(n), 2))\n            if i == 0 and j == n - 1:\n                continue  # Skip to avoid invalid tours\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n        elif operator == 'segment_reversal':\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            if i == 0 and j == n - 1:\n                continue  # Skip to avoid invalid tours\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'random_swap':\n            # Random swap: swap two random nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9580032609813398,
            2.219999372959137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    # Here, we select the solution with the highest sum of objectives as a starting point\n    objectives = [obj for _, obj in archive]\n    max_sum = max(sum(obj) for obj in objectives)\n    candidates = [sol for sol, obj in archive if sum(obj) == max_sum]\n    base_solution = random.choice(candidates).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search\n    for _ in range(3):  # Repeat the process a few times for better exploration\n        # Randomly choose one of the three local search operators\n        operator = random.choice(['edge_insertion', 'segment_reversal', 'random_swap'])\n\n        if operator == 'edge_insertion':\n            # Edge insertion: remove a random edge and insert it elsewhere\n            i, j = sorted(random.sample(range(n), 2))\n            if i == 0 and j == n - 1:\n                continue  # Skip to avoid invalid tours\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], new_solution[i:j]])\n\n        elif operator == 'segment_reversal':\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            if i == 0 and j == n - 1:\n                continue  # Skip to avoid invalid tours\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        elif operator == 'random_swap':\n            # Random swap: swap two random nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 4,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized_obj1 = [obj[0] / max(obj[0] for _, obj in archive) for _, obj in archive]\n    normalized_obj2 = [obj[1] / max(obj[1] for _, obj in archive) for _, obj in archive]\n    combined_scores = [normalized_obj1[i] + normalized_obj2[i] for i in range(len(archive))]\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel edge swap based on distance in both objectives\n    if n >= 4:\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        m = (k + 1) % n\n\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[k], new_solution[l]] +\n                 distance_matrix_1[new_solution[m], new_solution[(k+3)%n]]) - \\\n                (distance_matrix_1[new_solution[k], new_solution[m]] +\n                 distance_matrix_1[new_solution[l], new_solution[(k+3)%n]])\n        delta2 = (distance_matrix_2[new_solution[k], new_solution[l]] +\n                 distance_matrix_2[new_solution[m], new_solution[(k+3)%n]]) - \\\n                (distance_matrix_2[new_solution[k], new_solution[m]] +\n                 distance_matrix_2[new_solution[l], new_solution[(k+3)%n]])\n\n        # If the swap improves both objectives, perform it\n        if delta1 < 0 and delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.6492242774556523,
            2.4453770518302917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    normalized_obj1 = [obj[0] / max(obj[0] for _, obj in archive) for _, obj in archive]\n    normalized_obj2 = [obj[1] / max(obj[1] for _, obj in archive) for _, obj in archive]\n    combined_scores = [normalized_obj1[i] + normalized_obj2[i] for i in range(len(archive))]\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel edge swap based on distance in both objectives\n    if n >= 4:\n        k = np.random.randint(0, n)\n        l = (k + 2) % n\n        m = (k + 1) % n\n\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[k], new_solution[l]] +\n                 distance_matrix_1[new_solution[m], new_solution[(k+3)%n]]) - \\\n                (distance_matrix_1[new_solution[k], new_solution[m]] +\n                 distance_matrix_1[new_solution[l], new_solution[(k+3)%n]])\n        delta2 = (distance_matrix_2[new_solution[k], new_solution[l]] +\n                 distance_matrix_2[new_solution[m], new_solution[(k+3)%n]]) - \\\n                (distance_matrix_2[new_solution[k], new_solution[m]] +\n                 distance_matrix_2[new_solution[l], new_solution[(k+3)%n]])\n\n        # If the swap improves both objectives, perform it\n        if delta1 < 0 and delta2 < 0:\n            new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 5,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from scipy.spatial.distance import euclidean\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    if len(archive) > 1:\n        # Calculate objective variance for each solution\n        objectives = np.array([obj for (sol, obj) in archive])\n        obj_variance = np.var(objectives, axis=0)\n        # Select solutions with high variance (potential for improvement)\n        candidate_indices = np.where(np.sum(objectives * obj_variance, axis=1) > np.percentile(np.sum(objectives * obj_variance, axis=1), 75))[0]\n        if len(candidate_indices) > 0:\n            selected_idx = random.choice(candidate_indices)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with insertion heuristic\n    # Step 1: 3-opt move to escape local optima\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    # Reconstruct with different segment orderings\n    new_segments = [segment1, segment2, segment3]\n    random.shuffle(new_segments)\n    new_solution[a:d] = np.concatenate(new_segments)\n\n    # Step 2: Insertion heuristic to refine the solution\n    for _ in range(3):  # Perform 3 random insertions\n        i, j = random.sample(range(n), 2)\n        if i < j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n        else:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7112664642756522,
            2.6667210459709167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    from scipy.spatial.distance import euclidean\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    if len(archive) > 1:\n        # Calculate objective variance for each solution\n        objectives = np.array([obj for (sol, obj) in archive])\n        obj_variance = np.var(objectives, axis=0)\n        # Select solutions with high variance (potential for improvement)\n        candidate_indices = np.where(np.sum(objectives * obj_variance, axis=1) > np.percentile(np.sum(objectives * obj_variance, axis=1), 75))[0]\n        if len(candidate_indices) > 0:\n            selected_idx = random.choice(candidate_indices)\n            base_solution = archive[selected_idx][0].copy()\n        else:\n            base_solution = random.choice(archive)[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with insertion heuristic\n    # Step 1: 3-opt move to escape local optima\n    a, b, c, d = sorted(random.sample(range(n), 4))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    # Reconstruct with different segment orderings\n    new_segments = [segment1, segment2, segment3]\n    random.shuffle(new_segments)\n    new_solution[a:d] = np.concatenate(new_segments)\n\n    # Step 2: Insertion heuristic to refine the solution\n    for _ in range(3):  # Perform 3 random insertions\n        i, j = random.sample(range(n), 2)\n        if i < j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n        else:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:i], new_solution[i+1:]])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply novel segment inversion: invert a segment with probability 0.5\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            # Insert missing nodes at random positions\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        # Remove duplicates while preserving order\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n",
        "score": [
            -0.8475319468123163,
            1.7390691637992859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply novel segment inversion: invert a segment with probability 0.5\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            # Insert missing nodes at random positions\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        # Remove duplicates while preserving order\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 6,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply novel segment inversion: invert a segment with probability 0.5\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            # Insert missing nodes at random positions\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        # Remove duplicates while preserving order\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n",
        "score": [
            -0.8475319468123163,
            1.7390691637992859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_objectives[:, 0] + normalized_objectives[:, 1] + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Apply novel segment inversion: invert a segment with probability 0.5\n    if random.random() < 0.5:\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = set(range(n)) - set(unique_nodes)\n        for node in missing_nodes:\n            # Insert missing nodes at random positions\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        # Remove duplicates while preserving order\n        _, idx = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(idx)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 7,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high objective values)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (like 2-opt)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Apply a novel edge-swapping strategy: swap edges between non-adjacent nodes\n    if j - i >= 2:\n        k = np.random.randint(i + 1, j)\n        new_solution[k], new_solution[j] = new_solution[j], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.9203655641587826,
            2.5437896251678467
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., high objective values)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swapping strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to perturb\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (like 2-opt)\n    new_solution[i:j+1] = segment[::-1]\n\n    # Apply a novel edge-swapping strategy: swap edges between non-adjacent nodes\n    if j - i >= 2:\n        k = np.random.randint(i + 1, j)\n        new_solution[k], new_solution[j] = new_solution[j], new_solution[k]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        new_solution = selected_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply novel segment swap: swap two random segments of different lengths\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != a and d != b:  # Ensure segments are distinct\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9836954784875866,
            1.0252130627632141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply novel segment swap: swap two random segments of different lengths\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != a and d != b:  # Ensure segments are distinct\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply novel segment swap: swap two random segments of different lengths\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != a and d != b:  # Ensure segments are distinct\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9836954784875866,
            1.0252130627632141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply novel segment swap: swap two random segments of different lengths\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != a and d != b:  # Ensure segments are distinct\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 8,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply novel segment swap: swap two random segments of different lengths\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != a and d != b:  # Ensure segments are distinct\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9836954784875866,
            1.0252130627632141
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on a random segment\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply novel segment swap: swap two random segments of different lengths\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    if c != a and d != b:  # Ensure segments are distinct\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 9,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 5)]\n    base_solution, _ = random.choice(candidate_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment relocation\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (swap two edges)\n    if j - i > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment relocation (move a segment to a different position)\n        segment_length = random.randint(2, min(5, n // 2))\n        segment = new_solution[i:i+segment_length]\n        remaining = np.concatenate([new_solution[:i], new_solution[i+segment_length:]])\n        insert_pos = random.randint(0, len(remaining) - segment_length)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.5962639262227662,
            1.9835177659988403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(archive) // 5)]\n    base_solution, _ = random.choice(candidate_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment relocation\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Edge exchange (swap two edges)\n    if j - i > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Segment relocation (move a segment to a different position)\n        segment_length = random.randint(2, min(5, n // 2))\n        segment = new_solution[i:i+segment_length]\n        remaining = np.concatenate([new_solution[:i], new_solution[i+segment_length:]])\n        insert_pos = random.randint(0, len(remaining) - segment_length)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 10,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # 3-opt move\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Novel segment reversal: reverse segments with a twist\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure the solution remains a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to a simple 2-opt move as fallback\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7939283030663639,
            3.392873466014862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high variance in objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    potential = np.std(normalized_objectives, axis=1)\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # 3-opt move\n        if np.random.rand() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Novel segment reversal: reverse segments with a twist\n            segment1 = new_solution[i:j]\n            segment2 = new_solution[j:k]\n            new_solution[i:k] = np.concatenate([segment2[::-1], segment1[::-1]])\n\n    # Ensure the solution remains a valid tour\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If invalid, revert to a simple 2-opt move as fallback\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 11,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Simple heuristic: prioritize solutions with lower combined cost\n        combined_cost = cost1 + cost2\n        candidates.append((sol, combined_cost))\n\n    # Sort by combined cost and pick the top 5 candidates\n    candidates.sort(key=lambda x: x[1])\n    top_candidates = [sol for sol, _ in candidates[:min(5, len(candidates))]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(top_candidates).copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply edge insertion with a probability of 0.6\n    if random.random() < 0.6:\n        # Select two random edges to disconnect\n        i, j = sorted(random.sample(range(n), 2))\n        # Remove the edges and insert the nodes in reverse order\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n    else:\n        # Apply node swap with a probability of 0.4\n        # Select two random nodes to swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8037674887609064,
            1.7727775573730469
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Simple heuristic: prioritize solutions with lower combined cost\n        combined_cost = cost1 + cost2\n        candidates.append((sol, combined_cost))\n\n    # Sort by combined cost and pick the top 5 candidates\n    candidates.sort(key=lambda x: x[1])\n    top_candidates = [sol for sol, _ in candidates[:min(5, len(candidates))]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(top_candidates).copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply edge insertion with a probability of 0.6\n    if random.random() < 0.6:\n        # Select two random edges to disconnect\n        i, j = sorted(random.sample(range(n), 2))\n        # Remove the edges and insert the nodes in reverse order\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]])\n    else:\n        # Apply node swap with a probability of 0.4\n        # Select two random nodes to swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 12,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three non-consecutive edges to apply 3-opt\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Edge insertion: try to insert a random node in a better position\n    if n > 3:\n        node_to_insert = random.choice(new_solution)\n        mask = new_solution != node_to_insert\n        remaining_nodes = new_solution[mask]\n        best_insertion_cost = float('inf')\n        best_insertion_pos = 0\n\n        for pos in range(len(remaining_nodes)):\n            # Create a candidate solution\n            candidate = np.insert(remaining_nodes, pos, node_to_insert)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_insertion_cost:\n                best_insertion_cost = total_cost\n                best_insertion_pos = pos\n\n        new_solution = np.insert(remaining_nodes, best_insertion_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.7707497638580194,
            12.826262414455414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt and edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three non-consecutive edges to apply 3-opt\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconnect segments in a new order\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Edge insertion: try to insert a random node in a better position\n    if n > 3:\n        node_to_insert = random.choice(new_solution)\n        mask = new_solution != node_to_insert\n        remaining_nodes = new_solution[mask]\n        best_insertion_cost = float('inf')\n        best_insertion_pos = 0\n\n        for pos in range(len(remaining_nodes)):\n            # Create a candidate solution\n            candidate = np.insert(remaining_nodes, pos, node_to_insert)\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_insertion_cost:\n                best_insertion_cost = total_cost\n                best_insertion_pos = pos\n\n        new_solution = np.insert(remaining_nodes, best_insertion_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 13,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    if total_cost == 0:\n        probabilities = [1.0 / len(archive) for _ in archive]\n    else:\n        probabilities = [1 - (c / total_cost) for c in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select segments to modify\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # 3-opt-like operation\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_order = np.concatenate([segment1, segment3, segment2])\n\n    # Novel segment swap with reversal\n    if random.random() > 0.5:\n        mid = len(new_order) // 2\n        new_order[mid:] = new_order[mid:][::-1]\n\n    new_solution[a:d] = new_order\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8558237119931091,
            2.181362569332123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    total_cost = sum(costs)\n    if total_cost == 0:\n        probabilities = [1.0 / len(archive) for _ in archive]\n    else:\n        probabilities = [1 - (c / total_cost) for c in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select segments to modify\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # 3-opt-like operation\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    new_order = np.concatenate([segment1, segment3, segment2])\n\n    # Novel segment swap with reversal\n    if random.random() > 0.5:\n        mid = len(new_order) // 2\n        new_order[mid:] = new_order[mid:][::-1]\n\n    new_solution[a:d] = new_order\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 14,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the best and worst solutions to encourage exploration\n        candidates = archive[1:-1]\n        selected = random.choice(candidates)\n    else:\n        selected = random.choice(archive)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge exchange and node insertion\n    n = len(new_solution)\n\n    # Edge exchange: swap two random edges\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion: move a random node to a new position\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility: check for duplicates or missing nodes\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simpler edge exchange if insertion causes issues\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9147282775224707,
            1.9267603158950806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the best and worst solutions to encourage exploration\n        candidates = archive[1:-1]\n        selected = random.choice(candidates)\n    else:\n        selected = random.choice(archive)\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge exchange and node insertion\n    n = len(new_solution)\n\n    # Edge exchange: swap two random edges\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Node insertion: move a random node to a new position\n    k = random.randint(0, n-1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = random.randint(0, n-2)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility: check for duplicates or missing nodes\n    if len(new_solution) != len(np.unique(new_solution)):\n        # Fallback to a simpler edge exchange if insertion causes issues\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 15,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by dominance and diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], random.random()))\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    i, j = sorted(random.sample(range(n), 2))\n    inserted_node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [inserted_node], new_solution[j:]])\n\n    # Step 2: Segment relocation (novel operator)\n    if n > 4:\n        # Select a random segment of 2-3 nodes\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, 3)\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.614057675082733,
            2.1489789485931396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by dominance and diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], random.random()))\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (for diversification)\n    i, j = sorted(random.sample(range(n), 2))\n    inserted_node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [inserted_node], new_solution[j:]])\n\n    # Step 2: Segment relocation (novel operator)\n    if n > 4:\n        # Select a random segment of 2-3 nodes\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, 3)\n        segment = new_solution[seg_start:seg_start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start+seg_length:]])\n\n        # Insert the segment at a new position\n        insert_pos = random.randint(0, len(new_solution)-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 16,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions or those with high variance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt with custom edge-swap\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between b and c\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Custom edge-swap: swap edges (a,b) and (c,d) if it improves both objectives\n    if a + 1 < b and c + 1 < n:\n        d = (c + 1) % n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        potential_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        potential_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n\n        # Apply swap if both objectives improve\n        if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.7667716392337486,
            1.9048818349838257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions or those with high variance)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt with custom edge-swap\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select 3 distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse the segment between b and c\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Custom edge-swap: swap edges (a,b) and (c,d) if it improves both objectives\n    if a + 1 < b and c + 1 < n:\n        d = (c + 1) % n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        potential_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n\n        current_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        potential_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n\n        # Apply swap if both objectives improve\n        if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 17,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = random.randint(0, n - 2)\n    segment_length = random.randint(2, min(5, n - segment_start))\n    segment_end = segment_start + segment_length\n\n    # Reverse the selected segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Randomly select two edges to insert\n    insert_pos1 = random.randint(0, n - 1)\n    insert_pos2 = random.randint(0, n - 1)\n    while insert_pos2 == insert_pos1:\n        insert_pos2 = random.randint(0, n - 1)\n\n    # Insert the edges at the selected positions\n    if insert_pos1 < insert_pos2:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos1],\n            new_solution[insert_pos1:insert_pos1+1],\n            new_solution[insert_pos2:insert_pos2+1],\n            new_solution[insert_pos1+1:insert_pos2],\n            new_solution[insert_pos2+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos2],\n            new_solution[insert_pos2:insert_pos2+1],\n            new_solution[insert_pos1:insert_pos1+1],\n            new_solution[insert_pos2+1:insert_pos1],\n            new_solution[insert_pos1+1:]\n        ])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7511840583616247,
            1.8185626864433289
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        probabilities = [cost / sum(normalized_costs) for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    segment_start = random.randint(0, n - 2)\n    segment_length = random.randint(2, min(5, n - segment_start))\n    segment_end = segment_start + segment_length\n\n    # Reverse the selected segment\n    new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Randomly select two edges to insert\n    insert_pos1 = random.randint(0, n - 1)\n    insert_pos2 = random.randint(0, n - 1)\n    while insert_pos2 == insert_pos1:\n        insert_pos2 = random.randint(0, n - 1)\n\n    # Insert the edges at the selected positions\n    if insert_pos1 < insert_pos2:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos1],\n            new_solution[insert_pos1:insert_pos1+1],\n            new_solution[insert_pos2:insert_pos2+1],\n            new_solution[insert_pos1+1:insert_pos2],\n            new_solution[insert_pos2+1:]\n        ])\n    else:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos2],\n            new_solution[insert_pos2:insert_pos2+1],\n            new_solution[insert_pos1:insert_pos1+1],\n            new_solution[insert_pos2+1:insert_pos1],\n            new_solution[insert_pos1+1:]\n        ])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 18,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    n = len(base_solution)\n    if n < 5:\n        # If the tour is too small, just perform a 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform a 3-opt move with a bias toward reducing both objectives\n        # Select three distinct edges to reverse\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate the cost change for both objectives\n        def cost_change(sol, i, j, k):\n            # Original edges\n            orig_edges = [\n                (sol[i-1], sol[i]),\n                (sol[j-1], sol[j]),\n                (sol[k-1], sol[k])\n            ]\n            # New edges after 3-opt\n            new_edges = [\n                (sol[i-1], sol[j]),\n                (sol[j-1], sol[k]),\n                (sol[k-1], sol[i])\n            ]\n            # Calculate cost difference\n            cost1_diff = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in orig_edges)\n            cost2_diff = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in orig_edges)\n            return cost1_diff, cost2_diff\n\n        # Try different orderings of the segments\n        options = [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]\n\n        best_cost1, best_cost2 = np.inf, np.inf\n        best_solution = None\n\n        for opt in options:\n            temp_sol = new_solution.copy()\n            # Reorder segments\n            a, b, c = opt\n            temp_sol[a:b+1] = temp_sol[a:b+1][::-1]\n            temp_sol[b:c+1] = temp_sol[b:c+1][::-1]\n            temp_sol[c:] = temp_sol[c:][::-1]\n\n            # Calculate cost\n            cost1_diff, cost2_diff = cost_change(new_solution, a, b, c)\n            total_cost1 = archive[selected_idx][1][0] + cost1_diff\n            total_cost2 = archive[selected_idx][1][1] + cost2_diff\n\n            # Select the best option that improves both objectives\n            if total_cost1 < best_cost1 and total_cost2 < best_cost2:\n                best_cost1, best_cost2 = total_cost1, total_cost2\n                best_solution = temp_sol.copy()\n\n        if best_solution is not None:\n            new_solution = best_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to a simple 2-opt if the solution is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7825264471635174,
            2.871843934059143
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (not just the first one)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    n = len(base_solution)\n    if n < 5:\n        # If the tour is too small, just perform a 2-opt\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Perform a 3-opt move with a bias toward reducing both objectives\n        # Select three distinct edges to reverse\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Calculate the cost change for both objectives\n        def cost_change(sol, i, j, k):\n            # Original edges\n            orig_edges = [\n                (sol[i-1], sol[i]),\n                (sol[j-1], sol[j]),\n                (sol[k-1], sol[k])\n            ]\n            # New edges after 3-opt\n            new_edges = [\n                (sol[i-1], sol[j]),\n                (sol[j-1], sol[k]),\n                (sol[k-1], sol[i])\n            ]\n            # Calculate cost difference\n            cost1_diff = sum(distance_matrix_1[a][b] for a, b in new_edges) - sum(distance_matrix_1[a][b] for a, b in orig_edges)\n            cost2_diff = sum(distance_matrix_2[a][b] for a, b in new_edges) - sum(distance_matrix_2[a][b] for a, b in orig_edges)\n            return cost1_diff, cost2_diff\n\n        # Try different orderings of the segments\n        options = [\n            (i, j, k),\n            (i, k, j),\n            (j, i, k),\n            (j, k, i),\n            (k, i, j),\n            (k, j, i)\n        ]\n\n        best_cost1, best_cost2 = np.inf, np.inf\n        best_solution = None\n\n        for opt in options:\n            temp_sol = new_solution.copy()\n            # Reorder segments\n            a, b, c = opt\n            temp_sol[a:b+1] = temp_sol[a:b+1][::-1]\n            temp_sol[b:c+1] = temp_sol[b:c+1][::-1]\n            temp_sol[c:] = temp_sol[c:][::-1]\n\n            # Calculate cost\n            cost1_diff, cost2_diff = cost_change(new_solution, a, b, c)\n            total_cost1 = archive[selected_idx][1][0] + cost1_diff\n            total_cost2 = archive[selected_idx][1][1] + cost2_diff\n\n            # Select the best option that improves both objectives\n            if total_cost1 < best_cost1 and total_cost2 < best_cost2:\n                best_cost1, best_cost2 = total_cost1, total_cost2\n                best_solution = temp_sol.copy()\n\n        if best_solution is not None:\n            new_solution = best_solution\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != len(new_solution):\n        # Fallback to a simple 2-opt if the solution is invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 19,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        top_n = max(1, int(0.3 * len(sorted_archive)))\n        selected_solution = random.choice(sorted_archive[:top_n])[0].copy()\n    else:\n        selected_solution = np.random.permutation(instance.shape[0])\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Determine the best way to reconnect the edges based on both objectives\n    candidates = [\n        (a, b, c),  # Original order\n        (a, c, b),  # Swap b and c\n        (b, a, c),  # Rotate\n        (b, c, a),  # Reverse\n        (c, a, b),  # Another rotation\n        (c, b, a)   # Reverse rotation\n    ]\n\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        i, j, k = candidate\n        # Create a new solution with the candidate edges\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = np.flip(temp_solution[i:j+1])\n        temp_solution[j:k+1] = np.flip(temp_solution[j:k+1])\n        temp_solution[k:] = np.flip(temp_solution[k:])\n\n        # Calculate the total cost for both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n))\n        total_cost = cost1 + cost2  # Combined score for selection\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate:\n        i, j, k = best_candidate\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n        new_solution[k:] = np.flip(new_solution[k:])\n\n    # Ensure the solution remains feasible\n    assert len(set(new_solution)) == len(instance), \"Generated solution is invalid (duplicate nodes)\"\n    assert len(new_solution) == len(instance), \"Generated solution is invalid (missing nodes)\"\n\n    return new_solution\n\n",
        "score": [
            -0.8692082272384809,
            4.111419379711151
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        top_n = max(1, int(0.3 * len(sorted_archive)))\n        selected_solution = random.choice(sorted_archive[:top_n])[0].copy()\n    else:\n        selected_solution = np.random.permutation(instance.shape[0])\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: 3-opt with objective-aware edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Determine the best way to reconnect the edges based on both objectives\n    candidates = [\n        (a, b, c),  # Original order\n        (a, c, b),  # Swap b and c\n        (b, a, c),  # Rotate\n        (b, c, a),  # Reverse\n        (c, a, b),  # Another rotation\n        (c, b, a)   # Reverse rotation\n    ]\n\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        i, j, k = candidate\n        # Create a new solution with the candidate edges\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = np.flip(temp_solution[i:j+1])\n        temp_solution[j:k+1] = np.flip(temp_solution[j:k+1])\n        temp_solution[k:] = np.flip(temp_solution[k:])\n\n        # Calculate the total cost for both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[l], temp_solution[(l+1)%n]] for l in range(n))\n        total_cost = cost1 + cost2  # Combined score for selection\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_candidate = candidate\n\n    if best_candidate:\n        i, j, k = best_candidate\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n        new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n        new_solution[k:] = np.flip(new_solution[k:])\n\n    # Ensure the solution remains feasible\n    assert len(set(new_solution)) == len(instance), \"Generated solution is invalid (duplicate nodes)\"\n    assert len(new_solution) == len(instance), \"Generated solution is invalid (missing nodes)\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 20,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% of solutions based on combined cost\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(sorted_archive) // 5)\n    candidates = sorted_archive[:top_k]\n\n    # Randomly select a candidate\n    selected = candidates[np.random.randint(0, len(candidates))][0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Perform segment reversal\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap with a random segment\n    if n > 2:\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Ensure the swap maintains feasibility\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = temp\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above causes duplicates\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6722194568039278,
            2.0812953114509583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 20% of solutions based on combined cost\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(sorted_archive) // 5)\n    candidates = sorted_archive[:top_k]\n\n    # Randomly select a candidate\n    selected = candidates[np.random.randint(0, len(candidates))][0].copy()\n\n    # Hybrid local search: segment reversal + node swap\n    n = len(selected)\n    new_solution = selected.copy()\n\n    # Perform segment reversal\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node swap with a random segment\n    if n > 2:\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        # Ensure the swap maintains feasibility\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = temp\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above causes duplicates\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 21,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution using quality and diversity metrics\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate solution quality scores (normalized)\n    obj1_scores = np.array([obj[0] for obj in objectives])\n    obj2_scores = np.array([obj[1] for obj in objectives])\n    obj1_scores = (obj1_scores - np.min(obj1_scores)) / (np.max(obj1_scores) - np.min(obj1_scores) + 1e-10)\n    obj2_scores = (obj2_scores - np.min(obj2_scores)) / (np.max(obj2_scores) - np.min(obj2_scores) + 1e-10)\n    quality_scores = 0.5 * obj1_scores + 0.5 * obj2_scores  # Equal weighting\n\n    # Calculate diversity scores (average distance to other solutions)\n    diversity_scores = np.zeros(len(solutions))\n    for i in range(len(solutions)):\n        dists = [np.sum(solutions[i] != solutions[j]) for j in range(len(solutions)) if j != i]\n        diversity_scores[i] = np.mean(dists) if dists else 1.0\n\n    # Combine quality and diversity for selection probability\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(solutions), p=selection_probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combines segment inversion with edge exchange\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Invert the first segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Exchange edges between segments\n        if random.random() < 0.5:\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple 2-opt as fallback\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7188698203497282,
            10.318026721477509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution using quality and diversity metrics\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate solution quality scores (normalized)\n    obj1_scores = np.array([obj[0] for obj in objectives])\n    obj2_scores = np.array([obj[1] for obj in objectives])\n    obj1_scores = (obj1_scores - np.min(obj1_scores)) / (np.max(obj1_scores) - np.min(obj1_scores) + 1e-10)\n    obj2_scores = (obj2_scores - np.min(obj2_scores)) / (np.max(obj2_scores) - np.min(obj2_scores) + 1e-10)\n    quality_scores = 0.5 * obj1_scores + 0.5 * obj2_scores  # Equal weighting\n\n    # Calculate diversity scores (average distance to other solutions)\n    diversity_scores = np.zeros(len(solutions))\n    for i in range(len(solutions)):\n        dists = [np.sum(solutions[i] != solutions[j]) for j in range(len(solutions)) if j != i]\n        diversity_scores[i] = np.mean(dists) if dists else 1.0\n\n    # Combine quality and diversity for selection probability\n    combined_scores = quality_scores * 0.7 + diversity_scores * 0.3\n    selection_probs = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(solutions), p=selection_probs)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: combines segment inversion with edge exchange\n    if n > 3:\n        # Select two random segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Invert the first segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n        # Exchange edges between segments\n        if random.random() < 0.5:\n            new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple 2-opt as fallback\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 22,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.abs(x[1][0] - x[1][1])))  # Balanced selection\n    base_solution = selected_solution[0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search operator: Edge Insertion + Segment Reversal\n    new_solution = base_solution.copy()\n\n    # Step 1: Edge Insertion (for one random edge)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Segment Reversal (for a random segment)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if feasibility is violated\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7050481317846102,
            2.548467218875885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + np.abs(x[1][0] - x[1][1])))  # Balanced selection\n    base_solution = selected_solution[0].copy()\n    n = len(base_solution)\n\n    # Hybrid local search operator: Edge Insertion + Segment Reversal\n    new_solution = base_solution.copy()\n\n    # Step 1: Edge Insertion (for one random edge)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Step 2: Segment Reversal (for a random segment)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if feasibility is violated\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 23,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1 + (obj[0] + obj[1])) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Then, perform a custom edge exchange based on both distance matrices\n    if random.random() < 0.5:  # 50% chance to apply the custom operator\n        # Find the best edge exchange considering both objectives\n        best_delta = float('inf')\n        best_i, best_j = -1, -1\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                # Current edges: (i, i+1) and (j, (j+1)%n)\n                # Proposed edges: (i, j) and (i+1, (j+1)%n)\n                delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                          distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                          distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                # Combine both deltas with equal weight\n                combined_delta = delta1 + delta2\n\n                if combined_delta < best_delta:\n                    best_delta = combined_delta\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            # Reverse the segment between best_i+1 and best_j\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8088066829461915,
            11.921044528484344
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1 + (obj[0] + obj[1])) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Then, perform a custom edge exchange based on both distance matrices\n    if random.random() < 0.5:  # 50% chance to apply the custom operator\n        # Find the best edge exchange considering both objectives\n        best_delta = float('inf')\n        best_i, best_j = -1, -1\n\n        for i in range(n):\n            for j in range(i + 2, n):\n                # Current edges: (i, i+1) and (j, (j+1)%n)\n                # Proposed edges: (i, j) and (i+1, (j+1)%n)\n                delta1 = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                          distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                          distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                          distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n                delta2 = (distance_matrix_2[new_solution[i], new_solution[j]] +\n                          distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]] -\n                          distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                          distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n                # Combine both deltas with equal weight\n                combined_delta = delta1 + delta2\n\n                if combined_delta < best_delta:\n                    best_delta = combined_delta\n                    best_i, best_j = i, j\n\n        if best_i != -1:\n            # Reverse the segment between best_i+1 and best_j\n            new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 24,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt-like move (reverse segments)\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment reversal: reverse a random segment and insert it elsewhere\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8679019649399579,
            2.608150005340576
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt-like move (reverse segments)\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Novel segment reversal: reverse a random segment and insert it elsewhere\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, fall back to a simple 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 25,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best solution)\n    # Here, we select a random solution from the top 30% of the archive\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_30_percent = sorted_archive[:max(1, int(0.3 * len(sorted_archive)))]\n    selected_idx = random.randint(0, len(top_30_percent) - 1)\n    base_solution, _ = top_30_percent[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a custom segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Custom segment reversal: reverse a segment and then rotate it\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(0, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment[::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "score": [
            -0.6671694163670892,
            1.62286776304245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best solution)\n    # Here, we select a random solution from the top 30% of the archive\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_30_percent = sorted_archive[:max(1, int(0.3 * len(sorted_archive)))]\n    selected_idx = random.randint(0, len(top_30_percent) - 1)\n    base_solution, _ = top_30_percent[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a custom segment reversal\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # Custom segment reversal: reverse a segment and then rotate it\n    segment = new_solution[i:j+1]\n    rotated_segment = np.roll(segment, random.randint(0, len(segment)-1))\n    new_solution[i:j+1] = rotated_segment[::-1]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 26,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine segment reversal and node insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Select a segment to reverse (2-opt like)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Insert a randomly selected node elsewhere (node insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: if invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7695888173136981,
            2.5898179411888123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (e.g., not dominated by others)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine segment reversal and node insertion\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Select a segment to reverse (2-opt like)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Insert a randomly selected node elsewhere (node insertion)\n    k = np.random.randint(0, n)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: if invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 27,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and solution quality\n    def solution_score(obj):\n        # Normalize objectives to avoid bias towards one objective\n        norm_obj1 = obj[0] / (sum(o[0] for _, o in archive) / len(archive))\n        norm_obj2 = obj[1] / (sum(o[1] for _, o in archive) / len(archive))\n        return 0.5 * norm_obj1 + 0.5 * norm_obj2\n\n    # Sort solutions by score and select from top 30% with probability proportional to rank\n    archive_sorted = sorted(archive, key=lambda x: solution_score(x[1]))\n    top_size = max(1, int(0.3 * len(archive_sorted)))\n    top_solutions = archive_sorted[:top_size]\n\n    # Select a solution with probability inversely proportional to its rank\n    ranks = np.arange(1, top_size + 1)\n    probs = 1 / ranks\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(top_size, p=probs)\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but more flexible)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation (novel operator)\n    if n > 4:\n        segment_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.setdiff1d(new_solution, segment)\n        insert_pos = random.randint(0, len(remaining) - segment_length)\n        new_solution = np.concatenate([\n            remaining[:insert_pos],\n            segment,\n            remaining[insert_pos:]\n        ])\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9049566350452096,
            5.987806677818298
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and solution quality\n    def solution_score(obj):\n        # Normalize objectives to avoid bias towards one objective\n        norm_obj1 = obj[0] / (sum(o[0] for _, o in archive) / len(archive))\n        norm_obj2 = obj[1] / (sum(o[1] for _, o in archive) / len(archive))\n        return 0.5 * norm_obj1 + 0.5 * norm_obj2\n\n    # Sort solutions by score and select from top 30% with probability proportional to rank\n    archive_sorted = sorted(archive, key=lambda x: solution_score(x[1]))\n    top_size = max(1, int(0.3 * len(archive_sorted)))\n    top_solutions = archive_sorted[:top_size]\n\n    # Select a solution with probability inversely proportional to its rank\n    ranks = np.arange(1, top_size + 1)\n    probs = 1 / ranks\n    probs = probs / probs.sum()\n    selected_idx = np.random.choice(top_size, p=probs)\n    base_solution = top_solutions[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but more flexible)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation (novel operator)\n    if n > 4:\n        segment_length = random.randint(2, min(4, n // 2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.setdiff1d(new_solution, segment)\n        insert_pos = random.randint(0, len(remaining) - segment_length)\n        new_solution = np.concatenate([\n            remaining[:insert_pos],\n            segment,\n            remaining[insert_pos:]\n        ])\n\n    # Ensure the solution is valid (visits all nodes exactly once)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 28,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    probabilities = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a novel segment reversal with a probabilistic twist\n    if random.random() < 0.5:  # 50% chance to apply the novel operator\n        k, l = sorted(random.sample(range(1, n), 2))\n        if k < l:\n            # Reverse the segment but also rotate the segment by a random amount\n            segment = new_solution[k:l]\n            rotation = random.randint(0, len(segment)-1)\n            rotated_segment = np.roll(segment, rotation)\n            new_solution[k:l] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.877356612413542,
            1.8220804333686829
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    probabilities = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a standard 2-opt move\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, apply a novel segment reversal with a probabilistic twist\n    if random.random() < 0.5:  # 50% chance to apply the novel operator\n        k, l = sorted(random.sample(range(1, n), 2))\n        if k < l:\n            # Reverse the segment but also rotate the segment by a random amount\n            segment = new_solution[k:l]\n            rotation = random.randint(0, len(segment)-1)\n            rotated_segment = np.roll(segment, rotation)\n            new_solution[k:l] = rotated_segment\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(new_solution) == len(np.unique(new_solution)), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Perform a segment reversal between a and b, then exchange edges between b and c\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        np.array([new_solution[d]]),\n        new_solution[c:d],\n        new_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j][::-1],\n            new_solution[j:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -1.0221957646131627,
            0.1847289800643921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Perform a segment reversal between a and b, then exchange edges between b and c\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        np.array([new_solution[d]]),\n        new_solution[c:d],\n        new_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j][::-1],\n            new_solution[j:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Perform a segment reversal between a and b, then exchange edges between b and c\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        np.array([new_solution[d]]),\n        new_solution[c:d],\n        new_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j][::-1],\n            new_solution[j:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -1.0221957646131627,
            0.1847289800643921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Perform a segment reversal between a and b, then exchange edges between b and c\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        np.array([new_solution[d]]),\n        new_solution[c:d],\n        new_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j][::-1],\n            new_solution[j:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 29,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Perform a segment reversal between a and b, then exchange edges between b and c\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        np.array([new_solution[d]]),\n        new_solution[c:d],\n        new_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j][::-1],\n            new_solution[j:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -1.0221957646131627,
            0.1847289800643921
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance in objectives)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator combining edge exchange and segment reversal\n    n = len(new_solution)\n    a, b, c, d = sorted(np.random.choice(n, size=4, replace=False))\n\n    # Perform a segment reversal between a and b, then exchange edges between b and c\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[a:b][::-1],\n        new_solution[b:c],\n        np.array([new_solution[d]]),\n        new_solution[c:d],\n        new_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[i:j][::-1],\n            new_solution[j:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 30,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a promising solution based on a combination of diversity and potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt followed by segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # 3-opt move: select 3 random edges and reconnect them in a different way\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Try all possible 3-opt reconnections\n    possible_reconnections = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Evaluate all possible reconnections and select the best one\n    best_reconnection = new_solution\n    min_cost = float('inf')\n    for reconnection in possible_reconnections:\n        cost1 = sum(distance_matrix_1[reconnection[i-1], reconnection[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[reconnection[i-1], reconnection[i]] for i in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_reconnection = reconnection\n\n    new_solution = best_reconnection.copy()\n\n    # Segment relocation: move a random segment to a different position\n    if n >= 5:\n        start, end = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8395275206258986,
            3.1220057010650635
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a promising solution based on a combination of diversity and potential for improvement\n    selected_idx = random.choices(\n        range(len(archive)),\n        weights=[1 / (1 + obj[0] + obj[1]) for _, obj in archive],\n        k=1\n    )[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt followed by segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # 3-opt move: select 3 random edges and reconnect them in a different way\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Try all possible 3-opt reconnections\n    possible_reconnections = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    ]\n\n    # Evaluate all possible reconnections and select the best one\n    best_reconnection = new_solution\n    min_cost = float('inf')\n    for reconnection in possible_reconnections:\n        cost1 = sum(distance_matrix_1[reconnection[i-1], reconnection[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[reconnection[i-1], reconnection[i]] for i in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_reconnection = reconnection\n\n    new_solution = best_reconnection.copy()\n\n    # Segment relocation: move a random segment to a different position\n    if n >= 5:\n        start, end = sorted(random.sample(range(1, n), 2))\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 31,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal or with high variance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel segment inversion\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between segments [a, b] and [c, d]\n    if a < c < b:\n        new_solution[c:b+1] = base_solution[c:b+1][::-1]\n    else:\n        # Segment inversion: reverse a segment and insert it elsewhere\n        segment = base_solution[a:b+1].copy()\n        new_solution = np.concatenate([base_solution[:a], base_solution[b+1:c], segment[::-1], base_solution[c:]])\n\n    # Ensure feasibility: check for duplicates or skipped nodes\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment inversion fails\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7546807760777169,
            0.9668569564819336
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal or with high variance)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel segment inversion\n    n = len(base_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Apply 2-opt between segments [a, b] and [c, d]\n    if a < c < b:\n        new_solution[c:b+1] = base_solution[c:b+1][::-1]\n    else:\n        # Segment inversion: reverse a segment and insert it elsewhere\n        segment = base_solution[a:b+1].copy()\n        new_solution = np.concatenate([base_solution[:a], base_solution[b+1:c], segment[::-1], base_solution[c:]])\n\n    # Ensure feasibility: check for duplicates or skipped nodes\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment inversion fails\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 32,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Calculate potential improvements in both objectives\n    def calculate_improvement(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    # Generate all possible 3-opt moves and evaluate them\n    candidates = []\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a != b:\n                temp_sol = new_solution.copy()\n                temp_sol[a:b] = temp_sol[a:b][::-1]  # Reverse segment\n                cost1, cost2 = calculate_improvement(temp_sol)\n                candidates.append((cost1, cost2, temp_sol))\n\n    # Select the move that improves the worst objective most (Pareto-like improvement)\n    if candidates:\n        best_move = min(candidates, key=lambda x: max(x[0], x[1]))\n        new_solution = best_move[2]\n\n    # Additional edge swap for further improvement\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n    temp_sol = new_solution.copy()\n    temp_sol[a:b+1] = temp_sol[a:b+1][::-1]  # Reverse segment\n    cost1, cost2 = calculate_improvement(temp_sol)\n    if max(cost1, cost2) < max(calculate_improvement(new_solution)):\n        new_solution = temp_sol\n\n    return new_solution\n\n",
        "score": [
            -0.746092696181754,
            4.56473171710968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify\n    i, j, k = np.random.choice(n, 3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Calculate potential improvements in both objectives\n    def calculate_improvement(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    # Generate all possible 3-opt moves and evaluate them\n    candidates = []\n    for a in [i, j, k]:\n        for b in [i, j, k]:\n            if a != b:\n                temp_sol = new_solution.copy()\n                temp_sol[a:b] = temp_sol[a:b][::-1]  # Reverse segment\n                cost1, cost2 = calculate_improvement(temp_sol)\n                candidates.append((cost1, cost2, temp_sol))\n\n    # Select the move that improves the worst objective most (Pareto-like improvement)\n    if candidates:\n        best_move = min(candidates, key=lambda x: max(x[0], x[1]))\n        new_solution = best_move[2]\n\n    # Additional edge swap for further improvement\n    a, b = np.random.choice(n, 2, replace=False)\n    if a > b:\n        a, b = b, a\n    temp_sol = new_solution.copy()\n    temp_sol[a:b+1] = temp_sol[a:b+1][::-1]  # Reverse segment\n    cost1, cost2 = calculate_improvement(temp_sol)\n    if max(cost1, cost2) < max(calculate_improvement(new_solution)):\n        new_solution = temp_sol\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 33,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 distinct indices for 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt move\n    if np.random.rand() < 0.5:\n        # Case 1: Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Case 2: Reverse segments between i and k, and j and k\n        new_solution[i:k+1] = np.concatenate([new_solution[j:k+1][::-1], new_solution[i:j]])\n\n    # Novel edge insertion heuristic: try to insert a random node in a better position\n    if np.random.rand() < 0.3:\n        node_to_insert = np.random.randint(0, n)\n        current_pos = np.where(new_solution == node_to_insert)[0][0]\n\n        # Evaluate possible insertion positions (skip adjacent positions)\n        possible_positions = [pos for pos in range(n) if pos not in [current_pos-1, current_pos, current_pos+1]]\n\n        if possible_positions:\n            # Evaluate insertion based on both distance matrices\n            best_pos = current_pos\n            best_score = float('inf')\n\n            for pos in possible_positions:\n                # Create temporary solution\n                temp_solution = new_solution.copy()\n                temp_solution = np.delete(temp_solution, current_pos)\n                temp_solution = np.insert(temp_solution, pos, node_to_insert)\n\n                # Calculate total cost for both objectives\n                cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n                total_cost = cost1 + cost2\n\n                if total_cost < best_score:\n                    best_score = total_cost\n                    best_pos = pos\n\n            # Apply the best insertion\n            if best_pos != current_pos:\n                new_solution = np.delete(new_solution, current_pos)\n                new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n",
        "score": [
            -0.6960460407369599,
            5.491500020027161
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., low objective values)\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select 3 distinct indices for 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Apply 3-opt move\n    if np.random.rand() < 0.5:\n        # Case 1: Reverse segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Case 2: Reverse segments between i and k, and j and k\n        new_solution[i:k+1] = np.concatenate([new_solution[j:k+1][::-1], new_solution[i:j]])\n\n    # Novel edge insertion heuristic: try to insert a random node in a better position\n    if np.random.rand() < 0.3:\n        node_to_insert = np.random.randint(0, n)\n        current_pos = np.where(new_solution == node_to_insert)[0][0]\n\n        # Evaluate possible insertion positions (skip adjacent positions)\n        possible_positions = [pos for pos in range(n) if pos not in [current_pos-1, current_pos, current_pos+1]]\n\n        if possible_positions:\n            # Evaluate insertion based on both distance matrices\n            best_pos = current_pos\n            best_score = float('inf')\n\n            for pos in possible_positions:\n                # Create temporary solution\n                temp_solution = new_solution.copy()\n                temp_solution = np.delete(temp_solution, current_pos)\n                temp_solution = np.insert(temp_solution, pos, node_to_insert)\n\n                # Calculate total cost for both objectives\n                cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n                total_cost = cost1 + cost2\n\n                if total_cost < best_score:\n                    best_score = total_cost\n                    best_pos = pos\n\n            # Apply the best insertion\n            if best_pos != current_pos:\n                new_solution = np.delete(new_solution, current_pos)\n                new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 34,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high probability if it has potential for improvement\n    # Here, we select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random segment inversion (novel operation)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Then, perform a random edge swap (standard operation)\n    if n > 2:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Check for duplicates and fix if necessary\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        # Reconstruct the solution to ensure all nodes are visited exactly once\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicate_nodes = new_solution[np.where(np.in1d(new_solution, unique_nodes, invert=True))[0]]\n\n        for d in duplicate_nodes:\n            if len(missing_nodes) > 0:\n                new_solution[np.where(new_solution == d)[0][0]] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.8882884744287036,
            2.3653761744499207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high probability if it has potential for improvement\n    # Here, we select the solution with the highest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.mean(axis=0)) / (objectives.std(axis=0) + 1e-8)\n    scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random segment inversion (novel operation)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Then, perform a random edge swap (standard operation)\n    if n > 2:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Check for duplicates and fix if necessary\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) < n:\n        # Reconstruct the solution to ensure all nodes are visited exactly once\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        duplicate_nodes = new_solution[np.where(np.in1d(new_solution, unique_nodes, invert=True))[0]]\n\n        for d in duplicate_nodes:\n            if len(missing_nodes) > 0:\n                new_solution[np.where(new_solution == d)[0][0]] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 35,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply edge swap and segment inversion\n    n = len(new_solution)\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Edge swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment inversion (novel operator)\n    if b - a > 2:\n        segment = new_solution[a+1:b]\n        new_solution[a+1:b] = segment[::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swap if inversion causes duplicates\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8864770277612255,
            4.354917347431183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([np.sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply edge swap and segment inversion\n    n = len(new_solution)\n    a, b = np.random.choice(n, 2, replace=False)\n    a, b = min(a, b), max(a, b)\n\n    # Edge swap\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Segment inversion (novel operator)\n    if b - a > 2:\n        segment = new_solution[a+1:b]\n        new_solution[a+1:b] = segment[::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to edge swap if inversion causes duplicates\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 36,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    def selection_score(solution, objective):\n        # Prefer solutions with lower objectives but also consider diversity\n        # Here, we use a simple weighted sum of objectives and a penalty for similarity to other solutions\n        cost1, cost2 = objective\n        diversity_penalty = 0\n        for other_sol, _ in archive:\n            if np.array_equal(solution, other_sol):\n                diversity_penalty += 1\n        return (cost1 + cost2) * (1 + diversity_penalty)\n\n    # Sort solutions by score and select top candidates\n    scored_solutions = [(sol, obj, selection_score(sol, obj)) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[2])\n    top_candidates = [sol for sol, _, _ in scored_solutions[:max(3, len(archive)//2)]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(top_candidates).copy()\n\n    # Hybrid local search: combine 3-opt with a novel \"objective-aware\" move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move (select 3 random edges and reconnect them)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create new segments by reversing and reconnecting\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1][::-1]\n        segment3 = new_solution[j+1:k+1][::-1]\n        segment4 = new_solution[k+1:]\n        new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n\n    # Then apply objective-aware move: identify the most \"imbalanced\" edge in both objectives\n    # and try to improve it by moving it to a better position\n    if n >= 2:\n        # Calculate edge costs in both objectives\n        edge_costs1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        edge_costs2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n        # Find the edge with the largest difference in costs between objectives\n        cost_diffs = [abs(c1 - c2) for c1, c2 in zip(edge_costs1, edge_costs2)]\n        worst_edge_idx = np.argmax(cost_diffs)\n\n        # Try to move this edge to a better position\n        if n >= 3:\n            # Find positions where inserting this edge would improve both objectives\n            candidate_positions = []\n            for pos in range(n):\n                if pos == worst_edge_idx or pos == (worst_edge_idx - 1) % n:\n                    continue\n                # Calculate potential new costs\n                prev_node = new_solution[pos]\n                next_node = new_solution[(pos+1)%n]\n                original_cost1 = distance_matrix_1[prev_node, next_node]\n                original_cost2 = distance_matrix_2[prev_node, next_node]\n\n                # The edge we're moving\n                edge_start = new_solution[worst_edge_idx]\n                edge_end = new_solution[(worst_edge_idx + 1) % n]\n\n                # New cost if we insert between pos and pos+1\n                new_cost1 = distance_matrix_1[prev_node, edge_start] + distance_matrix_1[edge_end, next_node]\n                new_cost2 = distance_matrix_2[prev_node, edge_start] + distance_matrix_2[edge_end, next_node]\n\n                # If both objectives improve, consider this position\n                if (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n                    candidate_positions.append(pos)\n\n            if candidate_positions:\n                # Choose the best position\n                best_pos = min(candidate_positions, key=lambda p: (distance_matrix_1[new_solution[p], new_solution[worst_edge_idx]] +\n                                                                   distance_matrix_2[new_solution[p], new_solution[worst_edge_idx]]))\n                # Perform the move\n                if worst_edge_idx < best_pos:\n                    segment = new_solution[worst_edge_idx:best_pos+1]\n                    new_solution = np.concatenate([new_solution[:worst_edge_idx], new_solution[best_pos+1:], segment])\n                else:\n                    segment = new_solution[worst_edge_idx:best_pos+1][::-1]\n                    new_solution = np.concatenate([new_solution[:best_pos+1], segment, new_solution[best_pos+1:worst_edge_idx]])\n\n    return new_solution\n\n",
        "score": [
            -0.8835854911484858,
            4.78565114736557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objectives and diversity\n    def selection_score(solution, objective):\n        # Prefer solutions with lower objectives but also consider diversity\n        # Here, we use a simple weighted sum of objectives and a penalty for similarity to other solutions\n        cost1, cost2 = objective\n        diversity_penalty = 0\n        for other_sol, _ in archive:\n            if np.array_equal(solution, other_sol):\n                diversity_penalty += 1\n        return (cost1 + cost2) * (1 + diversity_penalty)\n\n    # Sort solutions by score and select top candidates\n    scored_solutions = [(sol, obj, selection_score(sol, obj)) for sol, obj in archive]\n    scored_solutions.sort(key=lambda x: x[2])\n    top_candidates = [sol for sol, _, _ in scored_solutions[:max(3, len(archive)//2)]]\n\n    # Randomly select one of the top candidates\n    base_solution = random.choice(top_candidates).copy()\n\n    # Hybrid local search: combine 3-opt with a novel \"objective-aware\" move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move (select 3 random edges and reconnect them)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create new segments by reversing and reconnecting\n        segment1 = new_solution[:i+1]\n        segment2 = new_solution[i+1:j+1][::-1]\n        segment3 = new_solution[j+1:k+1][::-1]\n        segment4 = new_solution[k+1:]\n        new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n\n    # Then apply objective-aware move: identify the most \"imbalanced\" edge in both objectives\n    # and try to improve it by moving it to a better position\n    if n >= 2:\n        # Calculate edge costs in both objectives\n        edge_costs1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        edge_costs2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n        # Find the edge with the largest difference in costs between objectives\n        cost_diffs = [abs(c1 - c2) for c1, c2 in zip(edge_costs1, edge_costs2)]\n        worst_edge_idx = np.argmax(cost_diffs)\n\n        # Try to move this edge to a better position\n        if n >= 3:\n            # Find positions where inserting this edge would improve both objectives\n            candidate_positions = []\n            for pos in range(n):\n                if pos == worst_edge_idx or pos == (worst_edge_idx - 1) % n:\n                    continue\n                # Calculate potential new costs\n                prev_node = new_solution[pos]\n                next_node = new_solution[(pos+1)%n]\n                original_cost1 = distance_matrix_1[prev_node, next_node]\n                original_cost2 = distance_matrix_2[prev_node, next_node]\n\n                # The edge we're moving\n                edge_start = new_solution[worst_edge_idx]\n                edge_end = new_solution[(worst_edge_idx + 1) % n]\n\n                # New cost if we insert between pos and pos+1\n                new_cost1 = distance_matrix_1[prev_node, edge_start] + distance_matrix_1[edge_end, next_node]\n                new_cost2 = distance_matrix_2[prev_node, edge_start] + distance_matrix_2[edge_end, next_node]\n\n                # If both objectives improve, consider this position\n                if (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n                    candidate_positions.append(pos)\n\n            if candidate_positions:\n                # Choose the best position\n                best_pos = min(candidate_positions, key=lambda p: (distance_matrix_1[new_solution[p], new_solution[worst_edge_idx]] +\n                                                                   distance_matrix_2[new_solution[p], new_solution[worst_edge_idx]]))\n                # Perform the move\n                if worst_edge_idx < best_pos:\n                    segment = new_solution[worst_edge_idx:best_pos+1]\n                    new_solution = np.concatenate([new_solution[:worst_edge_idx], new_solution[best_pos+1:], segment])\n                else:\n                    segment = new_solution[worst_edge_idx:best_pos+1][::-1]\n                    new_solution = np.concatenate([new_solution[:best_pos+1], segment, new_solution[best_pos+1:worst_edge_idx]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 37,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (Pareto front approximation)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    # Step 1: Randomly select 3 distinct edges to modify\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Step 2: Apply 3-opt-like move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour in a different order\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n    new_solution = new_order\n\n    # Step 3: Apply custom edge-swap (swap edges if it improves both objectives)\n    for _ in range(3):  # Limit attempts to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a == 0 or b == 0:\n            continue  # Avoid modifying the starting node\n\n        # Calculate current and potential new costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept if both objectives improve\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6065798492889907,
            2.4790567755699158
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (Pareto front approximation)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(len(archive_sorted) // 4, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    # Step 1: Randomly select 3 distinct edges to modify\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n\n    # Step 2: Apply 3-opt-like move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour in a different order\n    new_order = np.concatenate([segment1, segment3, segment2, segment4])\n    new_solution = new_order\n\n    # Step 3: Apply custom edge-swap (swap edges if it improves both objectives)\n    for _ in range(3):  # Limit attempts to avoid excessive computation\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        if a == 0 or b == 0:\n            continue  # Avoid modifying the starting node\n\n        # Calculate current and potential new costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept if both objectives improve\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 38,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (can be replaced with other selection criteria)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom swap based on objective diversity\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n    new_solution[k:] = np.flip(new_solution[k:])\n\n    # Additional heuristic: if the new solution is worse in both objectives, apply a targeted swap\n    if (sum([distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)]) > sum([distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n)]) and\n        sum([distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)]) > sum([distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n)])):\n        # Swap nodes that are far in one space but close in the other\n        for _ in range(min(3, n//2)):\n            a, b = np.random.choice(n, 2, replace=False)\n            if (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] >\n                distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] and\n                distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] <\n                distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6227027952176452,
            3.0633941888809204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (can be replaced with other selection criteria)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom swap based on objective diversity\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n    new_solution[k:] = np.flip(new_solution[k:])\n\n    # Additional heuristic: if the new solution is worse in both objectives, apply a targeted swap\n    if (sum([distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)]) > sum([distance_matrix_1[selected_solution[i-1], selected_solution[i]] for i in range(n)]) and\n        sum([distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)]) > sum([distance_matrix_2[selected_solution[i-1], selected_solution[i]] for i in range(n)])):\n        # Swap nodes that are far in one space but close in the other\n        for _ in range(min(3, n//2)):\n            a, b = np.random.choice(n, 2, replace=False)\n            if (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]] >\n                distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]] and\n                distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]] <\n                distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 39,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    # Here we select a random solution from the top 30% of the archive based on combined objective values\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: 3-opt move (select three non-adjacent edges and reconnect them)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Ensure edges are not adjacent\n        while j == i + 1 or k == j + 1:\n            i, j, k = sorted(random.sample(range(n), 3))\n\n        # Perform 3-opt reconnection\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Step 2: Novel segment inversion (invert a random segment with probability 0.3)\n    if random.random() < 0.3 and n >= 2:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 3: Swap-based perturbation (swap two random nodes with probability 0.5)\n    if random.random() < 0.5 and n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (all nodes are visited exactly once)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8516351837852332,
            2.2898120880126953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    # Here we select a random solution from the top 30% of the archive based on combined objective values\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_solutions)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: 3-opt move (select three non-adjacent edges and reconnect them)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Ensure edges are not adjacent\n        while j == i + 1 or k == j + 1:\n            i, j, k = sorted(random.sample(range(n), 3))\n\n        # Perform 3-opt reconnection\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Step 2: Novel segment inversion (invert a random segment with probability 0.3)\n    if random.random() < 0.3 and n >= 2:\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 3: Swap-based perturbation (swap two random nodes with probability 0.5)\n    if random.random() < 0.5 and n >= 2:\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (all nodes are visited exactly once)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 40,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = base_solution[j-1:i-1:-1]\n    new_solution[j:k] = base_solution[k-1:j-1:-1]\n\n    # Edge-swap strategy: swap edges that improve both objectives\n    for _ in range(2):  # Limit iterations to maintain efficiency\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a == b:\n            continue\n\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept if both objectives improve\n        if new_dist1 < current_dist1 and new_dist2 < current_dist2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7484200544265454,
            2.3352327942848206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected = random.choice(archive)\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful operations\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = base_solution[j-1:i-1:-1]\n    new_solution[j:k] = base_solution[k-1:j-1:-1]\n\n    # Edge-swap strategy: swap edges that improve both objectives\n    for _ in range(2):  # Limit iterations to maintain efficiency\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a == b:\n            continue\n\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept if both objectives improve\n        if new_dist1 < current_dist1 and new_dist2 < current_dist2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 41,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)  # Higher weight for better solutions\n    weights = weights / weights.sum()  # Normalize to get probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(1, n-1), 3))  # Select three random positions\n\n    # 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel edge insertion: try to improve by inserting a random node at a better position\n    if random.random() < 0.5:  # 50% chance to apply this step\n        node_to_move = random.choice(new_solution[1:-1])  # Avoid start/end nodes\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(1, n-2)  # Random position excluding start/end\n\n        if current_pos != new_pos:\n            # Calculate cost change in both objectives\n            old_cost1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                        distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[current_pos-1], new_solution[(current_pos+1)%n]] + \\\n                        distance_matrix_1[new_solution[current_pos-1], node_to_move] + \\\n                        distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                        distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[current_pos-1], new_solution[(current_pos+1)%n]] + \\\n                        distance_matrix_2[new_solution[current_pos-1], node_to_move] + \\\n                        distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n            # If the move improves at least one objective, accept it\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                # Remove from current position\n                new_solution = np.delete(new_solution, current_pos)\n                # Insert at new position\n                new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8890325047300462,
            2.6114750504493713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)  # Higher weight for better solutions\n    weights = weights / weights.sum()  # Normalize to get probabilities\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(1, n-1), 3))  # Select three random positions\n\n    # 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Novel edge insertion: try to improve by inserting a random node at a better position\n    if random.random() < 0.5:  # 50% chance to apply this step\n        node_to_move = random.choice(new_solution[1:-1])  # Avoid start/end nodes\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n        new_pos = random.randint(1, n-2)  # Random position excluding start/end\n\n        if current_pos != new_pos:\n            # Calculate cost change in both objectives\n            old_cost1 = distance_matrix_1[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                        distance_matrix_1[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[current_pos-1], new_solution[(current_pos+1)%n]] + \\\n                        distance_matrix_1[new_solution[current_pos-1], node_to_move] + \\\n                        distance_matrix_1[node_to_move, new_solution[(current_pos+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[current_pos-1], new_solution[current_pos]] + \\\n                        distance_matrix_2[new_solution[current_pos], new_solution[(current_pos+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[current_pos-1], new_solution[(current_pos+1)%n]] + \\\n                        distance_matrix_2[new_solution[current_pos-1], node_to_move] + \\\n                        distance_matrix_2[node_to_move, new_solution[(current_pos+1)%n]]\n\n            # If the move improves at least one objective, accept it\n            if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n                # Remove from current position\n                new_solution = np.delete(new_solution, current_pos)\n                # Insert at new position\n                new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 42,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    # Here, we select a solution with the highest sum of objectives (can be adjusted)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to make selection more robust\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    normalized_objectives = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in archive_objectives]\n\n    # Select the solution with the highest normalized sum (most potential for improvement)\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_idx = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Step 2: Find the best insertion point for the segment\n    best_insertion_cost = float('inf')\n    best_insertion_pos = 0\n\n    for i in range(len(new_solution)):\n        # Try inserting the segment at position i\n        temp_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n        # Calculate the cost of the new solution in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Combine costs to evaluate the solution (can be adjusted)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_insertion_cost:\n            best_insertion_cost = total_cost\n            best_insertion_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insertion_pos], segment, new_solution[best_insertion_pos:]])\n\n    # Step 3: Apply edge insertion to further improve the solution\n    for _ in range(2):  # Limit the number of edge insertions for efficiency\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Try inserting node j after node i\n        temp_solution = new_solution.copy()\n        node = temp_solution[j]\n        temp_solution = np.concatenate([temp_solution[:j], temp_solution[j+1:]])\n        temp_solution = np.concatenate([temp_solution[:i+1], [node], temp_solution[i+1:]])\n\n        # Calculate the cost of the new solution\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # If the new solution is better, keep it\n        if (cost1 + cost2) < best_insertion_cost:\n            new_solution = temp_solution\n            best_insertion_cost = cost1 + cost2\n\n    return new_solution\n\n",
        "score": [
            -0.9692973102784901,
            11.80580586194992
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    # Here, we select a solution with the highest sum of objectives (can be adjusted)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to make selection more robust\n    max_obj1 = max(obj[0] for obj in archive_objectives)\n    max_obj2 = max(obj[1] for obj in archive_objectives)\n    normalized_objectives = [(obj[0]/max_obj1 + obj[1]/max_obj2) for obj in archive_objectives]\n\n    # Select the solution with the highest normalized sum (most potential for improvement)\n    selected_idx = np.argmax(normalized_objectives)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n//2))\n    start_idx = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Step 2: Find the best insertion point for the segment\n    best_insertion_cost = float('inf')\n    best_insertion_pos = 0\n\n    for i in range(len(new_solution)):\n        # Try inserting the segment at position i\n        temp_solution = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n        # Calculate the cost of the new solution in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[j+1]] for j in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[j+1]] for j in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Combine costs to evaluate the solution (can be adjusted)\n        total_cost = cost1 + cost2\n\n        if total_cost < best_insertion_cost:\n            best_insertion_cost = total_cost\n            best_insertion_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.concatenate([new_solution[:best_insertion_pos], segment, new_solution[best_insertion_pos:]])\n\n    # Step 3: Apply edge insertion to further improve the solution\n    for _ in range(2):  # Limit the number of edge insertions for efficiency\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Try inserting node j after node i\n        temp_solution = new_solution.copy()\n        node = temp_solution[j]\n        temp_solution = np.concatenate([temp_solution[:j], temp_solution[j+1:]])\n        temp_solution = np.concatenate([temp_solution[:i+1], [node], temp_solution[i+1:]])\n\n        # Calculate the cost of the new solution\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # If the new solution is better, keep it\n        if (cost1 + cost2) < best_insertion_cost:\n            new_solution = temp_solution\n            best_insertion_cost = cost1 + cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 43,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Edge insertion (insert a node in a different position)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Step 2: Biased random walk (move a node to a position likely to improve both objectives)\n    # Calculate potential improvement for each possible position\n    improvements = []\n    for pos in range(n):\n        if pos == i or pos == j:\n            continue\n        # Temporarily move the node\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node_to_move], temp_solution[pos:]])\n        # Calculate cost change in both objectives\n        cost_change_1 = (distance_matrix_1[temp_solution[pos-1], node_to_move] +\n                         distance_matrix_1[node_to_move, temp_solution[(pos+1)%n]] -\n                         distance_matrix_1[temp_solution[pos-1], temp_solution[(pos+1)%n]])\n        cost_change_2 = (distance_matrix_2[temp_solution[pos-1], node_to_move] +\n                         distance_matrix_2[node_to_move, temp_solution[(pos+1)%n]] -\n                         distance_matrix_2[temp_solution[pos-1], temp_solution[(pos+1)%n]])\n        improvements.append((cost_change_1 + cost_change_2, pos))\n\n    # Select the position with the most improvement\n    if improvements:\n        improvements.sort(key=lambda x: x[0])\n        best_pos = improvements[0][1]\n        new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9563638777932254,
            1.6700420379638672
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: edge insertion with biased random walk\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Step 1: Edge insertion (insert a node in a different position)\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Step 2: Biased random walk (move a node to a position likely to improve both objectives)\n    # Calculate potential improvement for each possible position\n    improvements = []\n    for pos in range(n):\n        if pos == i or pos == j:\n            continue\n        # Temporarily move the node\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node_to_move], temp_solution[pos:]])\n        # Calculate cost change in both objectives\n        cost_change_1 = (distance_matrix_1[temp_solution[pos-1], node_to_move] +\n                         distance_matrix_1[node_to_move, temp_solution[(pos+1)%n]] -\n                         distance_matrix_1[temp_solution[pos-1], temp_solution[(pos+1)%n]])\n        cost_change_2 = (distance_matrix_2[temp_solution[pos-1], node_to_move] +\n                         distance_matrix_2[node_to_move, temp_solution[(pos+1)%n]] -\n                         distance_matrix_2[temp_solution[pos-1], temp_solution[(pos+1)%n]])\n        improvements.append((cost_change_1 + cost_change_2, pos))\n\n    # Select the position with the most improvement\n    if improvements:\n        improvements.sort(key=lambda x: x[0])\n        best_pos = improvements[0][1]\n        new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 44,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_costs = [obj for sol, obj in archive]\n\n    # Calculate diversity-based selection probability\n    diversity_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate average distance to other solutions in the archive\n        avg_dist = 0.0\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j:\n                # Compute Hamming distance (number of differing positions)\n                hamming_dist = np.sum(sol != other_sol)\n                avg_dist += hamming_dist\n        avg_dist /= len(archive) - 1\n        diversity_scores.append(avg_dist)\n\n    # Normalize diversity scores\n    if max(diversity_scores) > 0:\n        diversity_scores = [d / max(diversity_scores) for d in diversity_scores]\n\n    # Select a solution with high diversity (potential for improvement)\n    selected_idx = np.random.choice(len(archive), p=np.array(diversity_scores)/sum(diversity_scores))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine path relinking with edge assembly crossover\n    n = len(base_solution)\n\n    # Step 1: Path relinking (move towards a reference solution)\n    if len(archive) > 1:\n        ref_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        ref_solution = archive_solutions[ref_idx]\n\n        # Find common edges between base and reference solutions\n        common_edges = set()\n        for i in range(n):\n            a, b = base_solution[i], base_solution[(i+1)%n]\n            for j in range(n):\n                c, d = ref_solution[j], ref_solution[(j+1)%n]\n                if (a == c and b == d) or (a == d and b == c):\n                    common_edges.add((min(a, b), max(a, b)))\n\n        # Try to preserve common edges while making changes\n        for _ in range(2):  # Limit the number of relinking steps\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n\n            # Check if the edges can be swapped without breaking common edges\n            a, b = base_solution[i], base_solution[(i+1)%n]\n            c, d = base_solution[j], base_solution[(j+1)%n]\n\n            edge1 = (min(a, b), max(a, b))\n            edge2 = (min(c, d), max(c, d))\n\n            if edge1 in common_edges or edge2 in common_edges:\n                continue\n\n            # Perform the swap\n            new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    # Step 2: Edge assembly crossover (EA) inspired operator\n    # Select a random segment and try to find a better arrangement\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = base_solution[i:j+1]\n\n        # Try to insert the segment in a different position\n        k = random.randint(0, n-1)\n        if k < i or k > j:\n            # Create a new solution by removing the segment and inserting it at k\n            temp = np.concatenate([\n                base_solution[:i],\n                base_solution[j+1:k+1],\n                segment,\n                base_solution[k+1:]\n            ])\n            # Verify the new solution is valid (visits all nodes exactly once)\n            if len(np.unique(temp)) == n:\n                new_solution = temp.copy()\n\n    # Step 3: Local improvement using a custom operator\n    # Try to find a better 2-node swap that improves both objectives\n    improved = False\n    for _ in range(10):  # Limit the number of attempts\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Current edges\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        # Potential new edges\n        new_a, new_b = new_solution[i], new_solution[j]\n        new_c, new_d = new_solution[(i+1)%n], new_solution[(j+1)%n]\n\n        # Calculate cost change\n        old_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n        new_cost1 = distance_matrix_1[new_a, new_b] + distance_matrix_1[new_c, new_d]\n\n        old_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n        new_cost2 = distance_matrix_2[new_a, new_b] + distance_matrix_2[new_c, new_d]\n\n        # Accept if both objectives improve or at least one improves\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement found, try a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8002924260234345,
            13.898245215415955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, obj in archive]\n    archive_costs = [obj for sol, obj in archive]\n\n    # Calculate diversity-based selection probability\n    diversity_scores = []\n    for i, (sol, obj) in enumerate(archive):\n        # Calculate average distance to other solutions in the archive\n        avg_dist = 0.0\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j:\n                # Compute Hamming distance (number of differing positions)\n                hamming_dist = np.sum(sol != other_sol)\n                avg_dist += hamming_dist\n        avg_dist /= len(archive) - 1\n        diversity_scores.append(avg_dist)\n\n    # Normalize diversity scores\n    if max(diversity_scores) > 0:\n        diversity_scores = [d / max(diversity_scores) for d in diversity_scores]\n\n    # Select a solution with high diversity (potential for improvement)\n    selected_idx = np.random.choice(len(archive), p=np.array(diversity_scores)/sum(diversity_scores))\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine path relinking with edge assembly crossover\n    n = len(base_solution)\n\n    # Step 1: Path relinking (move towards a reference solution)\n    if len(archive) > 1:\n        ref_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        ref_solution = archive_solutions[ref_idx]\n\n        # Find common edges between base and reference solutions\n        common_edges = set()\n        for i in range(n):\n            a, b = base_solution[i], base_solution[(i+1)%n]\n            for j in range(n):\n                c, d = ref_solution[j], ref_solution[(j+1)%n]\n                if (a == c and b == d) or (a == d and b == c):\n                    common_edges.add((min(a, b), max(a, b)))\n\n        # Try to preserve common edges while making changes\n        for _ in range(2):  # Limit the number of relinking steps\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n\n            # Check if the edges can be swapped without breaking common edges\n            a, b = base_solution[i], base_solution[(i+1)%n]\n            c, d = base_solution[j], base_solution[(j+1)%n]\n\n            edge1 = (min(a, b), max(a, b))\n            edge2 = (min(c, d), max(c, d))\n\n            if edge1 in common_edges or edge2 in common_edges:\n                continue\n\n            # Perform the swap\n            new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    # Step 2: Edge assembly crossover (EA) inspired operator\n    # Select a random segment and try to find a better arrangement\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = base_solution[i:j+1]\n\n        # Try to insert the segment in a different position\n        k = random.randint(0, n-1)\n        if k < i or k > j:\n            # Create a new solution by removing the segment and inserting it at k\n            temp = np.concatenate([\n                base_solution[:i],\n                base_solution[j+1:k+1],\n                segment,\n                base_solution[k+1:]\n            ])\n            # Verify the new solution is valid (visits all nodes exactly once)\n            if len(np.unique(temp)) == n:\n                new_solution = temp.copy()\n\n    # Step 3: Local improvement using a custom operator\n    # Try to find a better 2-node swap that improves both objectives\n    improved = False\n    for _ in range(10):  # Limit the number of attempts\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Current edges\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        # Potential new edges\n        new_a, new_b = new_solution[i], new_solution[j]\n        new_c, new_d = new_solution[(i+1)%n], new_solution[(j+1)%n]\n\n        # Calculate cost change\n        old_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n        new_cost1 = distance_matrix_1[new_a, new_b] + distance_matrix_1[new_c, new_d]\n\n        old_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n        new_cost2 = distance_matrix_2[new_a, new_b] + distance_matrix_2[new_c, new_d]\n\n        # Accept if both objectives improve or at least one improves\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            # Perform the swap\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n            improved = True\n            break\n\n    if not improved:\n        # If no improvement found, try a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 45,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good, not too bad)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Compute the normalized objectives (assuming minimization)\n    objectives = np.array(archive_objectives)\n    if len(objectives) > 0:\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        # Select solutions that are neither too good nor too bad (middle region)\n        middle_region = (normalized_obj > 0.3) & (normalized_obj < 0.7)\n        candidates = [i for i in range(len(archive)) if np.all(middle_region[i])]\n    else:\n        candidates = list(range(len(archive)))\n\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify (3-opt)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_segment = np.concatenate([segment2, segment1])\n\n    new_solution[i:k] = new_segment\n\n    # Apply edge exchange (swap two edges)\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7148550453943676,
            3.2329142689704895
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too good, not too bad)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Compute the normalized objectives (assuming minimization)\n    objectives = np.array(archive_objectives)\n    if len(objectives) > 0:\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        # Select solutions that are neither too good nor too bad (middle region)\n        middle_region = (normalized_obj > 0.3) & (normalized_obj < 0.7)\n        candidates = [i for i in range(len(archive)) if np.all(middle_region[i])]\n    else:\n        candidates = list(range(len(archive)))\n\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and edge exchange\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select a segment to modify (3-opt)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_segment = np.concatenate([segment2, segment1])\n\n    new_solution[i:k] = new_segment\n\n    # Apply edge exchange (swap two edges)\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 46,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its diversity or dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate diversity scores (normalized sum of distances in both spaces)\n    diversity_scores = []\n    for sol in solutions:\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        diversity_scores.append(cost1 + cost2)\n\n    # Normalize diversity scores\n    min_div = min(diversity_scores)\n    max_div = max(diversity_scores)\n    if max_div == min_div:\n        normalized_scores = [1.0 for _ in diversity_scores]\n    else:\n        normalized_scores = [(d - min_div) / (max_div - min_div) for d in diversity_scores]\n\n    # Select a solution with probability proportional to its diversity\n    selected_idx = random.choices(range(len(solutions)), weights=normalized_scores, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform a segment reversal (similar to 2-opt but more disruptive)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Perform an edge insertion (move a random segment elsewhere)\n    if n > 3:\n        k = random.randint(1, min(3, n-2))  # Insertion segment length\n        l = random.randint(0, n-1)          # Position to insert\n        if l >= k:\n            segment = new_solution[l-k:l]\n            new_solution = np.concatenate([new_solution[:l-k], new_solution[l:], segment])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the above operations cause duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.746268989242231,
            10.764819622039795
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its diversity or dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate diversity scores (normalized sum of distances in both spaces)\n    diversity_scores = []\n    for sol in solutions:\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        diversity_scores.append(cost1 + cost2)\n\n    # Normalize diversity scores\n    min_div = min(diversity_scores)\n    max_div = max(diversity_scores)\n    if max_div == min_div:\n        normalized_scores = [1.0 for _ in diversity_scores]\n    else:\n        normalized_scores = [(d - min_div) / (max_div - min_div) for d in diversity_scores]\n\n    # Select a solution with probability proportional to its diversity\n    selected_idx = random.choices(range(len(solutions)), weights=normalized_scores, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform a segment reversal (similar to 2-opt but more disruptive)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Perform an edge insertion (move a random segment elsewhere)\n    if n > 3:\n        k = random.randint(1, min(3, n-2))  # Insertion segment length\n        l = random.randint(0, n-1)          # Position to insert\n        if l >= k:\n            segment = new_solution[l-k:l]\n            new_solution = np.concatenate([new_solution[:l-k], new_solution[l:], segment])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple swap if the above operations cause duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 47,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    total_objectives = np.sum(normalized_objectives, axis=1)\n    probabilities = 1 / (total_objectives + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            # Avoid reversing the entire tour\n            i, j = 1, 2\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply novel edge-swap strategy: swap edges between two random nodes\n        k, l = sorted(random.sample(range(n), 2))\n        if k == 0 and l == n-1:\n            k, l = 1, 2\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8417183471768734,
            2.6213150024414062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.max(objectives, axis=0)\n    total_objectives = np.sum(normalized_objectives, axis=1)\n    probabilities = 1 / (total_objectives + 1e-10)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two random edges\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            # Avoid reversing the entire tour\n            i, j = 1, 2\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply novel edge-swap strategy: swap edges between two random nodes\n        k, l = sorted(random.sample(range(n), 2))\n        if k == 0 and l == n-1:\n            k, l = 1, 2\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 48,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_idx = np.random.randint(0, len(candidate_solutions))\n    base_solution = candidate_solutions[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three non-consecutive edges to modify\n    a, b, c = sorted(np.random.choice(np.arange(1, n-1), 3, replace=False))\n\n    # Step 2: Apply a novel 3-opt-like operation with segment reversal\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reverse segments with probability 0.5 to introduce diversity\n    if np.random.rand() < 0.5:\n        segment1 = segment1[::-1]\n    if np.random.rand() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([new_solution[:a], segment1, segment2, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    if len(unique_nodes) != n:\n        # If duplicates exist, perform a greedy repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Insert missing node in the first gap where it doesn't create duplicates\n            for i in range(1, n):\n                if new_solution[i] != node and new_solution[i-1] != node:\n                    new_solution = np.insert(new_solution, i, node)\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.8204517697827797,
            2.7271512150764465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n    selected_idx = np.random.randint(0, len(candidate_solutions))\n    base_solution = candidate_solutions[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select three non-consecutive edges to modify\n    a, b, c = sorted(np.random.choice(np.arange(1, n-1), 3, replace=False))\n\n    # Step 2: Apply a novel 3-opt-like operation with segment reversal\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reverse segments with probability 0.5 to introduce diversity\n    if np.random.rand() < 0.5:\n        segment1 = segment1[::-1]\n    if np.random.rand() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([new_solution[:a], segment1, segment2, segment3])\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    unique_nodes, counts = np.unique(new_solution, return_counts=True)\n    if len(unique_nodes) != n:\n        # If duplicates exist, perform a greedy repair\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for node in missing_nodes:\n            # Insert missing node in the first gap where it doesn't create duplicates\n            for i in range(1, n):\n                if new_solution[i] != node and new_solution[i-1] != node:\n                    new_solution = np.insert(new_solution, i, node)\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 49,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Randomly select a segment to reverse (segment reversal)\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Randomly select an edge to insert elsewhere (edge insertion)\n        edge_pos = random.randint(0, n - 1)\n        edge_node = new_solution[edge_pos]\n        new_solution = np.delete(new_solution, edge_pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n        # Ensure the solution remains a valid tour\n        if not (len(new_solution) == n and len(np.unique(new_solution)) == n):\n            new_solution = solution.copy()  # Revert to original if invalid\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Optional: Apply additional local search steps if time permits\n    if random.random() < 0.3:  # 30% chance for additional improvement\n        new_solution = hybrid_local_search(new_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7592157389411366,
            2.0005772709846497
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    def hybrid_local_search(solution):\n        n = len(solution)\n        new_solution = solution.copy()\n\n        # Randomly select a segment to reverse (segment reversal)\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Randomly select an edge to insert elsewhere (edge insertion)\n        edge_pos = random.randint(0, n - 1)\n        edge_node = new_solution[edge_pos]\n        new_solution = np.delete(new_solution, edge_pos)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, edge_node)\n\n        # Ensure the solution remains a valid tour\n        if not (len(new_solution) == n and len(np.unique(new_solution)) == n):\n            new_solution = solution.copy()  # Revert to original if invalid\n\n        return new_solution\n\n    new_solution = hybrid_local_search(selected_solution)\n\n    # Optional: Apply additional local search steps if time permits\n    if random.random() < 0.3:  # 30% chance for additional improvement\n        new_solution = hybrid_local_search(new_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 50,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 30% solutions based on Pareto dominance\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    top_k = max(1, int(len(archive_sorted) * 0.3))\n    candidates = archive_sorted[:top_k]\n\n    # Select a random solution from candidates\n    base_solution, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try all possible 3-opt moves\n        options = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j][::-1], new_solution[k+1:]])\n        ]\n\n        # Evaluate all options\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            costs.append((cost1, cost2))\n\n        # Select the best option\n        best_idx = min(range(len(options)), key=lambda x: sum(costs[x]))\n        new_solution = options[best_idx]\n\n    # Apply biased random walk\n    if random.random() < 0.3:  # 30% chance to apply random walk\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    return new_solution\n\n",
        "score": [
            -0.7355002391851946,
            12.748085260391235
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 30% solutions based on Pareto dominance\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    top_k = max(1, int(len(archive_sorted) * 0.3))\n    candidates = archive_sorted[:top_k]\n\n    # Select a random solution from candidates\n    base_solution, _ = random.choice(candidates)\n    new_solution = base_solution.copy()\n\n    # Apply 3-opt local search\n    n = len(new_solution)\n    for _ in range(10):  # Number of iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Try all possible 3-opt moves\n        options = [\n            new_solution.copy(),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]]),\n            np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j][::-1], new_solution[k+1:]])\n        ]\n\n        # Evaluate all options\n        costs = []\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_1[opt[-1], opt[0]]\n            cost2 = sum(distance_matrix_2[opt[i], opt[i+1]] for i in range(n-1)) + distance_matrix_2[opt[-1], opt[0]]\n            costs.append((cost1, cost2))\n\n        # Select the best option\n        best_idx = min(range(len(options)), key=lambda x: sum(costs[x]))\n        new_solution = options[best_idx]\n\n    # Apply biased random walk\n    if random.random() < 0.3:  # 30% chance to apply random walk\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 51,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reversing segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply novel segment reversal: reverse a random segment between i and k\n    if random.random() < 0.5:  # 50% chance to apply this\n        l, m = sorted(random.sample(range(i, k+1), 2))\n        new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8114156644106179,
            1.9203911423683167
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt by reversing segments\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply novel segment reversal: reverse a random segment between i and k\n    if random.random() < 0.5:  # 50% chance to apply this\n        l, m = sorted(random.sample(range(i, k+1), 2))\n        new_solution[l:m+1] = new_solution[l:m+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 52,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple edge swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a combination of operators\n        operator = random.choice(['edge_exchange', 'segment_relocation', 'double_bridge'])\n\n        if operator == 'edge_exchange':\n            # Random edge exchange\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'segment_relocation':\n            # Relocate a random segment to a new position\n            start, end = sorted(random.sample(range(n), 2))\n            segment = new_solution[start:end]\n            remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        elif operator == 'double_bridge':\n            # Double bridge move (more sophisticated than 2-opt)\n            cut_points = sorted(random.sample(range(1, n-1), 4))\n            a, b, c, d = cut_points\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[c:d], new_solution[b:c],\n                new_solution[a:b], new_solution[d:]\n            ])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8623391084069711,
            2.2436012029647827
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, perform a simple edge swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger instances, use a combination of operators\n        operator = random.choice(['edge_exchange', 'segment_relocation', 'double_bridge'])\n\n        if operator == 'edge_exchange':\n            # Random edge exchange\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif operator == 'segment_relocation':\n            # Relocate a random segment to a new position\n            start, end = sorted(random.sample(range(n), 2))\n            segment = new_solution[start:end]\n            remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n        elif operator == 'double_bridge':\n            # Double bridge move (more sophisticated than 2-opt)\n            cut_points = sorted(random.sample(range(1, n-1), 4))\n            a, b, c, d = cut_points\n            new_solution = np.concatenate([\n                new_solution[:a], new_solution[c:d], new_solution[b:c],\n                new_solution[a:b], new_solution[d:]\n            ])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 53,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select a solution that is not already in the Pareto front (if we had one)\n    # For simplicity, we randomly select among the top 30% solutions by objective\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    base_solution = random.choice(candidate_solutions)[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Perform 3-opt (select three random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Try all possible 3-opt reconnections\n    possible_reconnections = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    # Evaluate all possible reconnections based on both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    best_reconnection = new_solution\n    best_cost1 = current_cost1\n    best_cost2 = current_cost2\n\n    for reconnection in possible_reconnections:\n        # Calculate cost for this reconnection\n        cost1 = sum(distance_matrix_1[reconnection[i-1], reconnection[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[reconnection[i-1], reconnection[i]] for i in range(n))\n\n        # Use a weighted sum to balance both objectives\n        if (0.5 * cost1 + 0.5 * cost2) < (0.5 * best_cost1 + 0.5 * best_cost2):\n            best_reconnection = reconnection\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n    new_solution = best_reconnection.copy()\n\n    # Step 2: Apply edge-swap heuristic to further improve the solution\n    # Select two random edges and swap them if it improves both objectives\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        # Create the new solution by swapping the edges\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n\n        # Calculate cost for the swapped solution\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Accept if both objectives are improved or at least one is improved\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.5634207978532394,
            5.160850942134857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select a solution that is not already in the Pareto front (if we had one)\n    # For simplicity, we randomly select among the top 30% solutions by objective\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    base_solution = random.choice(candidate_solutions)[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Perform 3-opt (select three random edges and reconnect them)\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Try all possible 3-opt reconnections\n    possible_reconnections = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    ]\n\n    # Evaluate all possible reconnections based on both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    best_reconnection = new_solution\n    best_cost1 = current_cost1\n    best_cost2 = current_cost2\n\n    for reconnection in possible_reconnections:\n        # Calculate cost for this reconnection\n        cost1 = sum(distance_matrix_1[reconnection[i-1], reconnection[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[reconnection[i-1], reconnection[i]] for i in range(n))\n\n        # Use a weighted sum to balance both objectives\n        if (0.5 * cost1 + 0.5 * cost2) < (0.5 * best_cost1 + 0.5 * best_cost2):\n            best_reconnection = reconnection\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n    new_solution = best_reconnection.copy()\n\n    # Step 2: Apply edge-swap heuristic to further improve the solution\n    # Select two random edges and swap them if it improves both objectives\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        # Create the new solution by swapping the edges\n        temp_solution = new_solution.copy()\n        temp_solution[a:b] = temp_solution[a:b][::-1]\n\n        # Calculate cost for the swapped solution\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Accept if both objectives are improved or at least one is improved\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 54,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Edge insertion with path relinking\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relink\n    segment_length = random.randint(2, min(5, N // 2))\n    start_idx = random.randint(0, N - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Find the best insertion point for the segment (path relinking)\n    min_cost = float('inf')\n    best_insert_pos = -1\n\n    for i in range(N - segment_length + 1):\n        if i == start_idx:\n            continue  # Skip the original position\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n        # Calculate cost of inserting the segment at position i\n        cost = 0\n        prev_node = temp_solution[i - 1] if i > 0 else temp_solution[-1]\n        next_node = temp_solution[i] if i < len(temp_solution) else temp_solution[0]\n\n        # Cost of connecting the segment to the rest of the tour\n        cost += distance_matrix_1[prev_node, segment[0]] + distance_matrix_2[prev_node, segment[0]]\n        cost += distance_matrix_1[segment[-1], next_node] + distance_matrix_2[segment[-1], next_node]\n\n        # Cost of the segment itself\n        for j in range(segment_length - 1):\n            cost += distance_matrix_1[segment[j], segment[j + 1]] + distance_matrix_2[segment[j], segment[j + 1]]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_insert_pos = i\n\n    # Perform the insertion\n    if best_insert_pos != -1:\n        temp_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n        new_solution = np.concatenate([\n            temp_solution[:best_insert_pos],\n            segment,\n            temp_solution[best_insert_pos:]\n        ])\n\n    # Additional edge insertion to further improve the solution\n    for _ in range(2):  # Perform a few edge insertions\n        i, j = random.sample(range(N), 2)\n        if abs(i - j) < 2:\n            continue  # Skip if too close\n\n        # Create a new solution by inserting node j after node i\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([\n            temp_solution[:i + 1],\n            [temp_solution[j]],\n            temp_solution[i + 1:j],\n            temp_solution[j + 1:]\n        ])\n\n        # Check if the new solution is better (simplified for this example)\n        # In practice, you would evaluate the full cost\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7954690455917156,
            1.834517002105713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search: Edge insertion with path relinking\n    N = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to relink\n    segment_length = random.randint(2, min(5, N // 2))\n    start_idx = random.randint(0, N - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Find the best insertion point for the segment (path relinking)\n    min_cost = float('inf')\n    best_insert_pos = -1\n\n    for i in range(N - segment_length + 1):\n        if i == start_idx:\n            continue  # Skip the original position\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n        # Calculate cost of inserting the segment at position i\n        cost = 0\n        prev_node = temp_solution[i - 1] if i > 0 else temp_solution[-1]\n        next_node = temp_solution[i] if i < len(temp_solution) else temp_solution[0]\n\n        # Cost of connecting the segment to the rest of the tour\n        cost += distance_matrix_1[prev_node, segment[0]] + distance_matrix_2[prev_node, segment[0]]\n        cost += distance_matrix_1[segment[-1], next_node] + distance_matrix_2[segment[-1], next_node]\n\n        # Cost of the segment itself\n        for j in range(segment_length - 1):\n            cost += distance_matrix_1[segment[j], segment[j + 1]] + distance_matrix_2[segment[j], segment[j + 1]]\n\n        if cost < min_cost:\n            min_cost = cost\n            best_insert_pos = i\n\n    # Perform the insertion\n    if best_insert_pos != -1:\n        temp_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n        new_solution = np.concatenate([\n            temp_solution[:best_insert_pos],\n            segment,\n            temp_solution[best_insert_pos:]\n        ])\n\n    # Additional edge insertion to further improve the solution\n    for _ in range(2):  # Perform a few edge insertions\n        i, j = random.sample(range(N), 2)\n        if abs(i - j) < 2:\n            continue  # Skip if too close\n\n        # Create a new solution by inserting node j after node i\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([\n            temp_solution[:i + 1],\n            [temp_solution[j]],\n            temp_solution[i + 1:j],\n            temp_solution[j + 1:]\n        ])\n\n        # Check if the new solution is better (simplified for this example)\n        # In practice, you would evaluate the full cost\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 55,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    if n > 3:\n        # Randomly select a segment of 2-3 nodes to relocate\n        segment_length = random.randint(2, min(3, n-1))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from the tour\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Find the best insertion point for the segment\n        best_cost = float('inf')\n        best_pos = 0\n\n        for i in range(len(new_solution)):\n            # Try inserting the segment at position i\n            candidate = np.insert(new_solution, i, segment)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n        # Additional edge insertion for further improvement\n        for _ in range(2):  # Perform 2 edge insertions\n            u, v = random.sample(range(n), 2)\n            if abs(u - v) > 1:  # Ensure we're not just swapping adjacent nodes\n                # Remove edges (u-1, u) and (v-1, v)\n                # Insert edges (u-1, v) and (u, v-1)\n                if u > v:\n                    u, v = v, u\n                segment = new_solution[u:v]\n                new_solution = np.concatenate([new_solution[:u], new_solution[v:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.8600559593414134,
            13.613400995731354
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: segment relocation with edge insertion\n    if n > 3:\n        # Randomly select a segment of 2-3 nodes to relocate\n        segment_length = random.randint(2, min(3, n-1))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Remove the segment from the tour\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n\n        # Find the best insertion point for the segment\n        best_cost = float('inf')\n        best_pos = 0\n\n        for i in range(len(new_solution)):\n            # Try inserting the segment at position i\n            candidate = np.insert(new_solution, i, segment)\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the segment at the best position\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n        # Additional edge insertion for further improvement\n        for _ in range(2):  # Perform 2 edge insertions\n            u, v = random.sample(range(n), 2)\n            if abs(u - v) > 1:  # Ensure we're not just swapping adjacent nodes\n                # Remove edges (u-1, u) and (v-1, v)\n                # Insert edges (u-1, v) and (u, v-1)\n                if u > v:\n                    u, v = v, u\n                segment = new_solution[u:v]\n                new_solution = np.concatenate([new_solution[:u], new_solution[v:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 56,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = [sum(obj) for _, obj in archive]\n    min_cost, max_cost = min(costs), max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply either edge exchange or segment relocation\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but with a twist)\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Additional twist: swap two edges\n        if j - i > 1 and random.random() < 0.3:\n            k = random.randint(i, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n    else:\n        # Segment relocation (novel heuristic)\n        n = len(new_solution)\n        # Select a random segment to relocate\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n        segment = new_solution[seg_start:seg_end+1]\n        # Insert the segment at a new random position\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:]\n        ])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7472795521147347,
            2.078702747821808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = [sum(obj) for _, obj in archive]\n    min_cost, max_cost = min(costs), max(costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply either edge exchange or segment relocation\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but with a twist)\n        n = len(new_solution)\n        i, j = sorted(random.sample(range(n), 2))\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Additional twist: swap two edges\n        if j - i > 1 and random.random() < 0.3:\n            k = random.randint(i, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n    else:\n        # Segment relocation (novel heuristic)\n        n = len(new_solution)\n        # Select a random segment to relocate\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+1, min(seg_start+3, n-1))\n        segment = new_solution[seg_start:seg_end+1]\n        # Insert the segment at a new random position\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end+1:]\n        ])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 57,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    # Solutions with lower costs are more likely to be selected\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    min_cost = min(costs)\n    weights = [1.0 / (cost - min_cost + 1e-6) for cost in costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge swaps and node insertions\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly choose between edge swap or node insertion\n    operation = random.choice(['edge_swap', 'node_insertion'])\n\n    if operation == 'edge_swap':\n        # Perform a 2-opt-like edge swap but with a twist\n        i, j = sorted(random.sample(range(1, n), 2))\n        if j - i > 1:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion: move a node to a different position\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5840883756347948,
            2.447531521320343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    # Solutions with lower costs are more likely to be selected\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    min_cost = min(costs)\n    weights = [1.0 / (cost - min_cost + 1e-6) for cost in costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge swaps and node insertions\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly choose between edge swap or node insertion\n    operation = random.choice(['edge_swap', 'node_insertion'])\n\n    if operation == 'edge_swap':\n        # Perform a 2-opt-like edge swap but with a twist\n        i, j = sorted(random.sample(range(1, n), 2))\n        if j - i > 1:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Node insertion: move a node to a different position\n        i = random.randint(1, n-1)\n        j = random.randint(1, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains valid (no duplicates, all nodes included)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 58,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel swap-based operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Novel swap-based operator: swap nodes in a way that preserves feasibility\n    if np.random.rand() < 0.5:  # 50% chance to apply the swap\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9665087756497954,
            2.452316105365753
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel swap-based operator\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct positions for 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse the segment between i and j, then between j and k\n    new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Novel swap-based operator: swap nodes in a way that preserves feasibility\n    if np.random.rand() < 0.5:  # 50% chance to apply the swap\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 59,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., among the top 30% of non-dominated solutions)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n    selected_solution = random.choice(selection_pool)[0].copy()\n\n    # Hybrid local search: edge swap with probabilistic node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform edge swap between two random segments\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform probabilistic node insertion to refine the solution\n    for _ in range(2):  # Limit the number of insertions to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(selected_solution)):\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6824666967364118,
            2.44599312543869
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., among the top 30% of non-dominated solutions)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selection_pool = sorted_archive[:max(1, len(archive) // 3)]\n    selected_solution = random.choice(selection_pool)[0].copy()\n\n    # Hybrid local search: edge swap with probabilistic node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform edge swap between two random segments\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Perform probabilistic node insertion to refine the solution\n    for _ in range(2):  # Limit the number of insertions to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.sort(selected_solution)):\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 60,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    sorted_archive = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Hybrid of 3-opt and insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 3-opt-like operation with probabilistic insertion\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # With 50% probability, reverse one of the segments\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n        else:\n            segment2 = segment2[::-1]\n\n        # Reconstruct the solution with the modified segments\n        new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n        # With 20% probability, perform an insertion of a random node\n        if random.random() < 0.2:\n            node_to_insert = random.choice(new_solution)\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_insert)), pos, node_to_insert)\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n    assert len(new_solution) == len(base_solution), \"Solution length changed\"\n\n    return new_solution\n\n",
        "score": [
            -0.8501036165710905,
            2.161888599395752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    sorted_archive = sorted(archive, key=lambda x: min(x[1]))\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Hybrid of 3-opt and insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform a 3-opt-like operation with probabilistic insertion\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # With 50% probability, reverse one of the segments\n        if random.random() < 0.5:\n            segment1 = segment1[::-1]\n        else:\n            segment2 = segment2[::-1]\n\n        # Reconstruct the solution with the modified segments\n        new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n        # With 20% probability, perform an insertion of a random node\n        if random.random() < 0.2:\n            node_to_insert = random.choice(new_solution)\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(np.delete(new_solution, np.where(new_solution == node_to_insert)), pos, node_to_insert)\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n    assert len(new_solution) == len(base_solution), \"Solution length changed\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 61,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    # Criteria: solutions with higher total distance in either objective space\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    total_distances = [sum(obj) for obj in objectives]\n\n    # Normalize distances to avoid bias towards one objective\n    max_distance = max(total_distances) if total_distances else 1.0\n    normalized_distances = [d / max_distance for d in total_distances]\n\n    # Select solutions with top 30% normalized distances\n    threshold = np.percentile(normalized_distances, 70)\n    promising_indices = [i for i, d in enumerate(normalized_distances) if d >= threshold]\n\n    if not promising_indices:\n        promising_indices = [0]  # Fallback to first solution if no promising ones found\n\n    selected_idx = random.choice(promising_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply edge insertion\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Insert segment1 after position l\n    new_solution = np.concatenate([new_solution[:l], segment1, new_solution[l:]])\n\n    # Insert segment2 after position j (adjusted for previous insertion)\n    new_solution = np.concatenate([new_solution[:j], segment2, new_solution[j:]])\n\n    # Remove duplicates while preserving order\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Ensure all nodes are visited exactly once\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8705071351802798,
            2.5220600962638855
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with high potential for improvement\n    # Criteria: solutions with higher total distance in either objective space\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    total_distances = [sum(obj) for obj in objectives]\n\n    # Normalize distances to avoid bias towards one objective\n    max_distance = max(total_distances) if total_distances else 1.0\n    normalized_distances = [d / max_distance for d in total_distances]\n\n    # Select solutions with top 30% normalized distances\n    threshold = np.percentile(normalized_distances, 70)\n    promising_indices = [i for i, d in enumerate(normalized_distances) if d >= threshold]\n\n    if not promising_indices:\n        promising_indices = [0]  # Fallback to first solution if no promising ones found\n\n    selected_idx = random.choice(promising_indices)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Apply edge insertion\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[k:l]\n\n    # Insert segment1 after position l\n    new_solution = np.concatenate([new_solution[:l], segment1, new_solution[l:]])\n\n    # Insert segment2 after position j (adjusted for previous insertion)\n    new_solution = np.concatenate([new_solution[:j], segment2, new_solution[j:]])\n\n    # Remove duplicates while preserving order\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    # Ensure all nodes are visited exactly once\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        # Insert missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 62,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank in the archive\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(base_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # Segment reversal (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    else:\n        # Node insertion (similar to 3-opt but simpler)\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7358368817363516,
            2.2083821892738342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank in the archive\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of segment reversal and node insertion\n    n = len(base_solution)\n    if n < 2:\n        return new_solution\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # Segment reversal (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n    else:\n        # Node insertion (similar to 3-opt but simpler)\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 63,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge-swapping strategy\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Edge-swapping strategy: swap edges between segments to improve both objectives\n    if random.random() < 0.5:  # 50% chance to apply edge swapping\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by inserting missing nodes in random positions\n        missing_nodes = list(set(range(n)) - set(unique))\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        # Trim to original length if necessary\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8131129497886704,
            1.7239043712615967
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = random.choice(archive)[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge-swapping strategy\n    n = len(new_solution)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # 3-opt move: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[k:] = new_solution[k:][::-1]\n\n    # Edge-swapping strategy: swap edges between segments to improve both objectives\n    if random.random() < 0.5:  # 50% chance to apply edge swapping\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure feasibility by checking for duplicates and fixing if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n:\n        # If duplicates exist, repair by inserting missing nodes in random positions\n        missing_nodes = list(set(range(n)) - set(unique))\n        for node in missing_nodes:\n            pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n        # Trim to original length if necessary\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 64,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple heuristic: select solution with average cost\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Edge insertion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment relocation (move a random segment to a new position)\n    seg_start, seg_end = sorted(random.sample(range(n), 2))\n    while seg_end - seg_start < 2:  # Ensure segment is at least 2 nodes\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[seg_start:seg_end]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:], segment])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8609179148165657,
            1.939501702785492
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple heuristic: select solution with average cost\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge insertion and segment relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Edge insertion (similar to 2-opt but more flexible)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Segment relocation (move a random segment to a new position)\n    seg_start, seg_end = sorted(random.sample(range(n), 2))\n    while seg_end - seg_start < 2:  # Ensure segment is at least 2 nodes\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[seg_start:seg_end]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:], segment])\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 65,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high diversity or Pareto-frontier candidates)\n    # Here, we randomly select among the top 20% of the archive based on some heuristic (e.g., low cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    top_k = max(1, len(archive) // 5)\n    candidates = archive_sorted[:top_k]\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: combine edge insertion with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of the tour\n    segment_start = random.randint(0, n - 2)\n    segment_end = random.randint(segment_start + 1, min(segment_start + 5, n - 1))\n    segment = new_solution[segment_start:segment_end]\n\n    # Step 2: Remove the segment and reinsert it in a different position\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply a novel move: reverse a random segment and reinsert it\n    reverse_start = random.randint(0, n - 2)\n    reverse_end = random.randint(reverse_start + 1, min(reverse_start + 5, n - 1))\n    reversed_segment = new_solution[reverse_start:reverse_end][::-1]\n\n    new_solution = np.concatenate([new_solution[:reverse_start], new_solution[reverse_end:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], reversed_segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler move if the new solution is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.37168675462490214,
            2.3479813933372498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high diversity or Pareto-frontier candidates)\n    # Here, we randomly select among the top 20% of the archive based on some heuristic (e.g., low cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    top_k = max(1, len(archive) // 5)\n    candidates = archive_sorted[:top_k]\n    selected = random.choice(candidates)\n    base_solution = selected[0].copy()\n\n    # Hybrid local search strategy: combine edge insertion with a novel move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of the tour\n    segment_start = random.randint(0, n - 2)\n    segment_end = random.randint(segment_start + 1, min(segment_start + 5, n - 1))\n    segment = new_solution[segment_start:segment_end]\n\n    # Step 2: Remove the segment and reinsert it in a different position\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply a novel move: reverse a random segment and reinsert it\n    reverse_start = random.randint(0, n - 2)\n    reverse_end = random.randint(reverse_start + 1, min(reverse_start + 5, n - 1))\n    reversed_segment = new_solution[reverse_start:reverse_end][::-1]\n\n    new_solution = np.concatenate([new_solution[:reverse_start], new_solution[reverse_end:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], reversed_segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler move if the new solution is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 66,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (randomly among top 30% solutions by objective values)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_candidates)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Segment reversal with variable length + segment insertion\n    if n > 3:\n        # Randomly select a segment length (at least 2 nodes)\n        segment_length = random.randint(2, min(5, n // 2))\n\n        # Randomly select a starting index for the segment\n        start_idx = random.randint(0, n - segment_length)\n\n        # Reverse the segment\n        new_solution[start_idx:start_idx + segment_length] = new_solution[start_idx:start_idx + segment_length][::-1]\n\n        # Randomly select another position to insert the segment (ensuring feasibility)\n        if n > segment_length:\n            insert_pos = random.randint(0, n - segment_length)\n            if insert_pos != start_idx:\n                # Remove the segment from its current position\n                segment = new_solution[start_idx:start_idx + segment_length]\n                new_solution = np.concatenate([\n                    new_solution[:start_idx],\n                    new_solution[start_idx + segment_length:]\n                ])\n\n                # Insert the segment at the new position\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n\n    # Ensure the solution remains a valid TSP tour (no duplicates, all nodes visited)\n    if not (np.unique(new_solution).size == n and np.all(np.isin(new_solution, selected_solution))):\n        # Fallback to a simple 2-opt move if the hybrid operator fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.780095656059556,
            2.0456038117408752
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (randomly among top 30% solutions by objective values)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    top_candidates = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    selected_solution = random.choice(top_candidates)[0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Segment reversal with variable length + segment insertion\n    if n > 3:\n        # Randomly select a segment length (at least 2 nodes)\n        segment_length = random.randint(2, min(5, n // 2))\n\n        # Randomly select a starting index for the segment\n        start_idx = random.randint(0, n - segment_length)\n\n        # Reverse the segment\n        new_solution[start_idx:start_idx + segment_length] = new_solution[start_idx:start_idx + segment_length][::-1]\n\n        # Randomly select another position to insert the segment (ensuring feasibility)\n        if n > segment_length:\n            insert_pos = random.randint(0, n - segment_length)\n            if insert_pos != start_idx:\n                # Remove the segment from its current position\n                segment = new_solution[start_idx:start_idx + segment_length]\n                new_solution = np.concatenate([\n                    new_solution[:start_idx],\n                    new_solution[start_idx + segment_length:]\n                ])\n\n                # Insert the segment at the new position\n                new_solution = np.concatenate([\n                    new_solution[:insert_pos],\n                    segment,\n                    new_solution[insert_pos:]\n                ])\n\n    # Ensure the solution remains a valid TSP tour (no duplicates, all nodes visited)\n    if not (np.unique(new_solution).size == n and np.all(np.isin(new_solution, selected_solution))):\n        # Fallback to a simple 2-opt move if the hybrid operator fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 67,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Rank solutions based on their potential (e.g., solutions with higher total cost)\n    total_costs = [sum(obj) for obj in objectives]\n    ranked_indices = np.argsort(total_costs)[::-1]  # Descending order\n\n    # Intelligently select a solution (e.g., top 20% or random from top half)\n    selected_idx = random.choice(ranked_indices[:max(1, len(ranked_indices) // 2)])\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of edge insertion and relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Find the best insertion point for the segment in both objective spaces\n    best_insert_pos = 0\n    best_improvement = 0\n\n    for pos in range(len(new_solution)):\n        # Insert segment at position 'pos'\n        candidate = np.insert(new_solution, pos, segment)\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Calculate improvement (negative means better)\n        improvement = (cost1 + cost2) - (sum(objectives[selected_idx]))\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8490149520033109,
            9.286156475543976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Rank solutions based on their potential (e.g., solutions with higher total cost)\n    total_costs = [sum(obj) for obj in objectives]\n    ranked_indices = np.argsort(total_costs)[::-1]  # Descending order\n\n    # Intelligently select a solution (e.g., top 20% or random from top half)\n    selected_idx = random.choice(ranked_indices[:max(1, len(ranked_indices) // 2)])\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of edge insertion and relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Find the best insertion point for the segment in both objective spaces\n    best_insert_pos = 0\n    best_improvement = 0\n\n    for pos in range(len(new_solution)):\n        # Insert segment at position 'pos'\n        candidate = np.insert(new_solution, pos, segment)\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Calculate improvement (negative means better)\n        improvement = (cost1 + cost2) - (sum(objectives[selected_idx]))\n\n        if improvement < best_improvement:\n            best_improvement = improvement\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 68,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    objectives = [obj for _, obj in archive]\n    combined_scores = [weights[0] * obj[0] + weights[1] * obj[1] for obj in objectives]\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move with probability 0.7, otherwise do a biased random walk\n    if np.random.rand() < 0.7:\n        # 3-opt move: reverse segments between i-j, j-k, or i-k\n        move_type = np.random.randint(3)\n        if move_type == 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif move_type == 1:\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            new_solution[i:k] = new_solution[i:k][::-1]\n    else:\n        # Biased random walk: move a segment to a nearby position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        insert_pos = np.random.randint(0, n - segment_length)\n\n        # Extract segment and remove it from the solution\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6160148039086976,
            3.451042592525482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    objectives = [obj for _, obj in archive]\n    combined_scores = [weights[0] * obj[0] + weights[1] * obj[1] for obj in objectives]\n    best_idx = np.argmin(combined_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move with probability 0.7, otherwise do a biased random walk\n    if np.random.rand() < 0.7:\n        # 3-opt move: reverse segments between i-j, j-k, or i-k\n        move_type = np.random.randint(3)\n        if move_type == 0:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif move_type == 1:\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:\n            new_solution[i:k] = new_solution[i:k][::-1]\n    else:\n        # Biased random walk: move a segment to a nearby position\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        insert_pos = np.random.randint(0, n - segment_length)\n\n        # Extract segment and remove it from the solution\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 69,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = max_obj - objectives\n    weights = np.sum(normalized_obj, axis=1) + 1e-6  # Add small epsilon to avoid division by zero\n    probabilities = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge swap and segment reversal\n    if random.random() < 0.7:  # 70% chance for edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains a valid tour\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains a valid tour\n        if j - i > 1:\n            segment = new_solution[i:j]\n            new_solution[i:j] = segment[::-1]\n\n    # Additional improvement: check if the new solution is better in either objective\n    # If not, perform a random swap to ensure diversity\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9106561987966574,
            2.544262945652008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = max_obj - objectives\n    weights = np.sum(normalized_obj, axis=1) + 1e-6  # Add small epsilon to avoid division by zero\n    probabilities = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of edge swap and segment reversal\n    if random.random() < 0.7:  # 70% chance for edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains a valid tour\n        if j - i > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:  # 30% chance for segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains a valid tour\n        if j - i > 1:\n            segment = new_solution[i:j]\n            new_solution[i:j] = segment[::-1]\n\n    # Additional improvement: check if the new solution is better in either objective\n    # If not, perform a random swap to ensure diversity\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 70,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to calculate potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate improvement potential (inverse of normalized objective values)\n    improvement_potential = 1 - normalized_obj.mean(axis=1)\n    probabilities = improvement_potential / improvement_potential.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with edge insertion\n    if n > 3:\n        # Select a segment to reverse\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Edge insertion: move a random node to another position\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8734918096740203,
            2.3897926807403564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to calculate potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate improvement potential (inverse of normalized objective values)\n    improvement_potential = 1 - normalized_obj.mean(axis=1)\n    probabilities = improvement_potential / improvement_potential.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal with edge insertion\n    if n > 3:\n        # Select a segment to reverse\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution[i:j+1] = reversed_segment\n\n        # Edge insertion: move a random node to another position\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 71,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability based on its rank in the archive\n    # Higher-ranked solutions (better objectives) have a higher chance of being selected\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    weights = [1.0 / (i + 1) for i in range(len(archive_sorted))]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(archive_sorted), p=normalized_weights)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to the first objective space\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion to the second objective space\n    # Select a random edge and try to insert it in a different position\n    if n > 3:\n        k = random.randint(0, n-1)\n        l = (k + random.randint(1, n-2)) % n\n\n        # Calculate the change in cost for both objectives\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n        # Try inserting the edge in a new position\n        new_pos = random.randint(0, n-1)\n        if new_pos != k and new_pos != l:\n            new_solution = np.insert(new_solution, new_pos, new_solution[k])\n            new_solution = np.delete(new_solution, k if k < new_pos else k+1)\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                return new_solution\n\n    # Fallback to 2-opt if edge insertion fails\n    return new_solution\n\n",
        "score": [
            -0.8956164240186691,
            2.5735891461372375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability based on its rank in the archive\n    # Higher-ranked solutions (better objectives) have a higher chance of being selected\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    weights = [1.0 / (i + 1) for i in range(len(archive_sorted))]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n\n    selected_idx = np.random.choice(len(archive_sorted), p=normalized_weights)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to the first objective space\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply edge insertion to the second objective space\n    # Select a random edge and try to insert it in a different position\n    if n > 3:\n        k = random.randint(0, n-1)\n        l = (k + random.randint(1, n-2)) % n\n\n        # Calculate the change in cost for both objectives\n        current_cost1 = distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_1[new_solution[l-1], new_solution[l]]\n        current_cost2 = distance_matrix_2[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[l-1], new_solution[l]]\n\n        # Try inserting the edge in a new position\n        new_pos = random.randint(0, n-1)\n        if new_pos != k and new_pos != l:\n            new_solution = np.insert(new_solution, new_pos, new_solution[k])\n            new_solution = np.delete(new_solution, k if k < new_pos else k+1)\n\n            # Ensure the solution remains a valid tour\n            if len(np.unique(new_solution)) == n:\n                return new_solution\n\n    # Fallback to 2-opt if edge insertion fails\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 72,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of normalized objectives to identify promising candidates\n    normalized_objectives = []\n    for sol, obj in archive:\n        cost1, cost2 = obj\n        # Normalize objectives (simple min-max scaling)\n        min_cost1 = min(o[0] for _, o in archive)\n        max_cost1 = max(o[0] for _, o in archive)\n        min_cost2 = min(o[1] for _, o in archive)\n        max_cost2 = max(o[1] for _, o in archive)\n\n        if max_cost1 != min_cost1:\n            norm_cost1 = (cost1 - min_cost1) / (max_cost1 - min_cost1)\n        else:\n            norm_cost1 = 0.0\n\n        if max_cost2 != min_cost2:\n            norm_cost2 = (cost2 - min_cost2) / (max_cost2 - min_cost2)\n        else:\n            norm_cost2 = 0.0\n\n        normalized_objectives.append((sol, obj, norm_cost1 + norm_cost2))\n\n    # Select the solution with the lowest normalized sum (most promising)\n    selected = min(normalized_objectives, key=lambda x: x[2])[0]\n    base_solution = selected.copy()\n\n    # Hybrid local search: combine 2-opt with a novel crossover-like operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to the first half of the tour\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a novel crossover-like operator to the second half\n    # Split the tour into two segments and recombine them in a non-standard way\n    split_point = n // 2\n    segment1 = new_solution[:split_point]\n    segment2 = new_solution[split_point:]\n\n    # Recombine segments with a random shift\n    shift = random.randint(1, len(segment1) - 1)\n    new_segment1 = np.roll(segment1, shift)\n    new_solution = np.concatenate([new_segment1, segment2])\n\n    # Ensure validity (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.660340322371898,
            2.6480071544647217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of normalized objectives to identify promising candidates\n    normalized_objectives = []\n    for sol, obj in archive:\n        cost1, cost2 = obj\n        # Normalize objectives (simple min-max scaling)\n        min_cost1 = min(o[0] for _, o in archive)\n        max_cost1 = max(o[0] for _, o in archive)\n        min_cost2 = min(o[1] for _, o in archive)\n        max_cost2 = max(o[1] for _, o in archive)\n\n        if max_cost1 != min_cost1:\n            norm_cost1 = (cost1 - min_cost1) / (max_cost1 - min_cost1)\n        else:\n            norm_cost1 = 0.0\n\n        if max_cost2 != min_cost2:\n            norm_cost2 = (cost2 - min_cost2) / (max_cost2 - min_cost2)\n        else:\n            norm_cost2 = 0.0\n\n        normalized_objectives.append((sol, obj, norm_cost1 + norm_cost2))\n\n    # Select the solution with the lowest normalized sum (most promising)\n    selected = min(normalized_objectives, key=lambda x: x[2])[0]\n    base_solution = selected.copy()\n\n    # Hybrid local search: combine 2-opt with a novel crossover-like operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply 2-opt to the first half of the tour\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply a novel crossover-like operator to the second half\n    # Split the tour into two segments and recombine them in a non-standard way\n    split_point = n // 2\n    segment1 = new_solution[:split_point]\n    segment2 = new_solution[split_point:]\n\n    # Recombine segments with a random shift\n    shift = random.randint(1, len(segment1) - 1)\n    new_segment1 = np.roll(segment1, shift)\n    new_solution = np.concatenate([new_segment1, segment2])\n\n    # Ensure validity (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 73,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but not already optimal)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -len(set(x[0]))))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a biased random walk\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to break\n        i, j, k = sorted(np.random.choice(range(1, n), size=3, replace=False))\n\n        # Create a new candidate solution by reversing segments between selected edges\n        candidate = new_solution.copy()\n        candidate[i:j] = new_solution[i:j][::-1]\n        candidate[j:k] = new_solution[j:k][::-1]\n\n        # Evaluate the candidate in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Accept the candidate if it improves at least one objective\n        if (cost1 < sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) or\n            cost2 < sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))):\n            new_solution = candidate\n\n    # Apply a biased random walk to escape local optima\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j] = new_solution[i:j][::-1]\n\n        # Accept with a probability based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or\n            np.random.random() < 0.3):  # 30% chance to accept even if no improvement\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.7233005241969978,
            8.260530471801758
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest cost but not already optimal)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -len(set(x[0]))))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a biased random walk\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to break\n        i, j, k = sorted(np.random.choice(range(1, n), size=3, replace=False))\n\n        # Create a new candidate solution by reversing segments between selected edges\n        candidate = new_solution.copy()\n        candidate[i:j] = new_solution[i:j][::-1]\n        candidate[j:k] = new_solution[j:k][::-1]\n\n        # Evaluate the candidate in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Accept the candidate if it improves at least one objective\n        if (cost1 < sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) or\n            cost2 < sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))):\n            new_solution = candidate\n\n    # Apply a biased random walk to escape local optima\n    for _ in range(3):\n        i, j = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j] = new_solution[i:j][::-1]\n\n        # Accept with a probability based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2 or\n            np.random.random() < 0.3):  # 30% chance to accept even if no improvement\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 74,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Choose a random segment and apply a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 2-opt with segment inversion and relocation\n    for _ in range(3):  # Number of attempts to improve\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Apply 2-opt between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply segment inversion and relocation\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment[::-1]])\n\n        # Ensure the solution remains a valid tour\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.8212464414951648,
            1.947984755039215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n\n    # Choose a random segment and apply a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: 2-opt with segment inversion and relocation\n    for _ in range(3):  # Number of attempts to improve\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Apply 2-opt between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Apply segment inversion and relocation\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment[::-1]])\n\n        # Ensure the solution remains a valid tour\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 75,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))  # Simple heuristic: select solution with highest combined cost\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Randomly select 3 distinct edges to modify (3-opt)\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    remaining = np.concatenate([new_solution[:i], new_solution[k:]])\n\n    # Reconstruct the tour with the segments reversed\n    new_solution = np.concatenate([remaining, segment1[::-1], segment2[::-1]])\n\n    # Step 2: Apply a custom edge swap to further improve the solution\n    # Select two random edges and swap their endpoints if it improves both objectives\n    a, b = sorted(random.sample(range(n), 2))\n    if a + 1 < n and b + 1 < n:\n        # Check if swapping nodes a+1 and b+1 improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n        original_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[b+1]] + distance_matrix_1[new_solution[b], new_solution[a+1]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[b+1]] + distance_matrix_2[new_solution[b], new_solution[a+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:  # Allow some exploration\n            new_solution[a+1], new_solution[b+1] = new_solution[b+1], new_solution[a+1]\n\n    return new_solution\n\n",
        "score": [
            -0.8349035553320665,
            1.6955447793006897
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high variance in objectives)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]))  # Simple heuristic: select solution with highest combined cost\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Step 1: Randomly select 3 distinct edges to modify (3-opt)\n    i, j, k = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    remaining = np.concatenate([new_solution[:i], new_solution[k:]])\n\n    # Reconstruct the tour with the segments reversed\n    new_solution = np.concatenate([remaining, segment1[::-1], segment2[::-1]])\n\n    # Step 2: Apply a custom edge swap to further improve the solution\n    # Select two random edges and swap their endpoints if it improves both objectives\n    a, b = sorted(random.sample(range(n), 2))\n    if a + 1 < n and b + 1 < n:\n        # Check if swapping nodes a+1 and b+1 improves both objectives\n        original_cost1 = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n        original_cost2 = distance_matrix_2[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[b+1]] + distance_matrix_1[new_solution[b], new_solution[a+1]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[b+1]] + distance_matrix_2[new_solution[b], new_solution[a+1]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or random.random() < 0.3:  # Allow some exploration\n            new_solution[a+1], new_solution[b+1] = new_solution[b+1], new_solution[a+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 76,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation with edge insertion\n    if n > 3:\n        # Randomly select a segment of length 2-3\n        segment_length = random.randint(2, min(3, n // 2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Find the best insertion point for the segment\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution) - segment_length + 1):\n            # Insert segment at position 'pos'\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Use a weighted sum of objectives as selection criterion\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Additional edge swap for further improvement\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Swap edges (i, i+1) and (j, j+1)\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -1.0016597972175743,
            10.298251807689667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation with edge insertion\n    if n > 3:\n        # Randomly select a segment of length 2-3\n        segment_length = random.randint(2, min(3, n // 2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start + segment_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n        # Find the best insertion point for the segment\n        best_pos = -1\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution) - segment_length + 1):\n            # Insert segment at position 'pos'\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n            # Use a weighted sum of objectives as selection criterion\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Additional edge swap for further improvement\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Swap edges (i, i+1) and (j, j+1)\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 77,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_objectives = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three non-consecutive edges to perform a 3-opt move\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Step 2: Custom edge swap based on the distance matrices\n    # Select two random edges and swap their positions if it improves the combined cost\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]]\n    potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]]\n\n    if (potential_cost1 + potential_cost2) < (current_cost1 + current_cost2):\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n        new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6122765578097449,
            2.3766412138938904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_objectives = normalized_objectives.sum(axis=1)\n    best_idx = np.argmin(combined_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Step 1: Randomly select three non-consecutive edges to perform a 3-opt move\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Step 2: Custom edge swap based on the distance matrices\n    # Select two random edges and swap their positions if it improves the combined cost\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    potential_cost1 = distance_matrix_1[new_solution[a-1], new_solution[c]] + distance_matrix_1[new_solution[b-1], new_solution[d]]\n    potential_cost2 = distance_matrix_2[new_solution[a-1], new_solution[c]] + distance_matrix_2[new_solution[b-1], new_solution[d]]\n\n    if (potential_cost1 + potential_cost2) < (current_cost1 + current_cost2):\n        new_solution[a], new_solution[c] = new_solution[c], new_solution[a]\n        new_solution[b], new_solution[d] = new_solution[d], new_solution[b]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(len(new_solution))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 78,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability based on its rank in the archive (higher probability for better solutions)\n    ranks = np.argsort([obj[0] + obj[1] for _, obj in archive])  # Simple ranking based on sum of objectives\n    selected_idx = random.choices(range(len(archive)), weights=[1/(rank + 1) for rank in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge insertion: remove a random edge and reinsert it in a different position\n    if n > 3:\n        k = random.randint(1, n-2)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(set(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base solution if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.7973214425646113,
            2.5406094193458557
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability based on its rank in the archive (higher probability for better solutions)\n    ranks = np.argsort([obj[0] + obj[1] for _, obj in archive])  # Simple ranking based on sum of objectives\n    selected_idx = random.choices(range(len(archive)), weights=[1/(rank + 1) for rank in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 2-opt with edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Perform edge insertion: remove a random edge and reinsert it in a different position\n    if n > 3:\n        k = random.randint(1, n-2)\n        node = new_solution[k]\n        new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(set(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to base solution if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 79,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by sum of objectives (ascending) to prioritize less dominant solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle (not too good, not too bad)\n        base_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge exchange: select two non-adjacent edges and swap their endpoints\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n        k = random.randint(j+1, n-1)\n\n        # Swap segments to create a new tour\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n        # Optionally reverse a segment to explore more neighbors\n        if random.random() < 0.5:\n            rev_start = random.randint(0, n-2)\n            rev_end = random.randint(rev_start+1, n-1)\n            new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8091848221178423,
            1.9719197750091553
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by sum of objectives (ascending) to prioritize less dominant solutions\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the middle (not too good, not too bad)\n        base_solution = archive_sorted[len(archive_sorted) // 2][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge exchange: select two non-adjacent edges and swap their endpoints\n        i = random.randint(0, n-4)\n        j = random.randint(i+2, n-2)\n        k = random.randint(j+1, n-1)\n\n        # Swap segments to create a new tour\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n\n        # Optionally reverse a segment to explore more neighbors\n        if random.random() < 0.5:\n            rev_start = random.randint(0, n-2)\n            rev_end = random.randint(rev_start+1, n-1)\n            new_solution[rev_start:rev_end] = new_solution[rev_start:rev_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 80,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its dominance (lower costs are better)\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Edge exchange with segment relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n - 1:\n        return new_solution  # Avoid full reversal to maintain feasibility\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation (novel addition)\n    # Select a random segment and relocate it to a different position\n    seg_start, seg_end = sorted(random.sample(range(n), 2))\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7940562747998103,
            1.9227328300476074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its dominance (lower costs are better)\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Edge exchange with segment relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n - 1:\n        return new_solution  # Avoid full reversal to maintain feasibility\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation (novel addition)\n    # Select a random segment and relocate it to a different position\n    seg_start, seg_end = sorted(random.sample(range(n), 2))\n    segment = new_solution[seg_start:seg_end+1]\n    new_solution = np.concatenate([\n        new_solution[:seg_start],\n        new_solution[seg_end+1:],\n        segment\n    ])\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 81,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible with small tours\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]  # Reverse segment i to j\n    new_solution[j:k+1] = base_solution[j:k+1][::-1]  # Reverse segment j to k\n\n    # Custom move: swap a segment with another segment in reverse order\n    if random.random() < 0.3:  # 30% chance to apply custom move\n        l, m = sorted(random.sample(range(n), 2))\n        new_solution[l:m+1] = base_solution[l:m+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7867700938521126,
            4.009128153324127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # No improvement possible with small tours\n\n    # Randomly select 3 distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform a 3-opt move\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]  # Reverse segment i to j\n    new_solution[j:k+1] = base_solution[j:k+1][::-1]  # Reverse segment j to k\n\n    # Custom move: swap a segment with another segment in reverse order\n    if random.random() < 0.3:  # 30% chance to apply custom move\n        l, m = sorted(random.sample(range(n), 2))\n        new_solution[l:m+1] = base_solution[l:m+1][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 82,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Extract the selected segment\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (like in 2-opt but more flexible)\n    segment_reversed = segment[::-1]\n\n    # Try inserting the reversed segment in a different position\n    # Find the best insertion point to minimize both objectives\n    best_cost = float('inf')\n    best_insert_pos = i\n\n    for pos in range(n - (j - i)):\n        if pos == i:\n            continue  # Skip the original position\n\n        # Create a temporary solution with the segment inserted at pos\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            segment_reversed,\n            new_solution[pos:]\n        ])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1))\n        cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]  # Close the tour\n\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1))\n        cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_insert_pos],\n        segment_reversed,\n        new_solution[best_insert_pos:]\n    ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8661472773010946,
            6.0588396191596985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: combine edge insertion and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Extract the selected segment\n    segment = new_solution[i:j+1]\n\n    # Reverse the segment (like in 2-opt but more flexible)\n    segment_reversed = segment[::-1]\n\n    # Try inserting the reversed segment in a different position\n    # Find the best insertion point to minimize both objectives\n    best_cost = float('inf')\n    best_insert_pos = i\n\n    for pos in range(n - (j - i)):\n        if pos == i:\n            continue  # Skip the original position\n\n        # Create a temporary solution with the segment inserted at pos\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            segment_reversed,\n            new_solution[pos:]\n        ])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1))\n        cost1 += distance_matrix_1[temp_solution[-1], temp_solution[0]]  # Close the tour\n\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1))\n        cost2 += distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.concatenate([\n        new_solution[:best_insert_pos],\n        segment_reversed,\n        new_solution[best_insert_pos:]\n    ])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 83,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = [obj for _, obj in archive]\n    total_cost = sum(obj[0] + obj[1] for obj in objectives)\n    probabilities = [(total_cost - (obj[0] + obj[1])) / total_cost for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search operator: Segmented Reversal with Adaptive Segment Length\n    n = len(base_solution)\n    segment_length = min(4, n // 2)  # Adaptive segment length\n    a = random.randint(0, n - segment_length - 1)\n    b = a + segment_length\n\n    new_solution = base_solution.copy()\n    new_solution[a:b] = base_solution[a:b][::-1]  # Reverse the segment\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If the reversal caused duplicates, perform a different move\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8647630353704119,
            1.4989089369773865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = [obj for _, obj in archive]\n    total_cost = sum(obj[0] + obj[1] for obj in objectives)\n    probabilities = [(total_cost - (obj[0] + obj[1])) / total_cost for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search operator: Segmented Reversal with Adaptive Segment Length\n    n = len(base_solution)\n    segment_length = min(4, n // 2)  # Adaptive segment length\n    a = random.randint(0, n - segment_length - 1)\n    b = a + segment_length\n\n    new_solution = base_solution.copy()\n    new_solution[a:b] = base_solution[a:b][::-1]  # Reverse the segment\n\n    # Check feasibility and repair if necessary\n    if len(np.unique(new_solution)) != n:\n        # If the reversal caused duplicates, perform a different move\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 84,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search: combine 3-opt with a biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt move\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Apply a biased random walk to escape local optima\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.rand() < 0.7:  # Higher probability to accept if improvement is likely\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not a valid tour.\"\n\n    return new_solution\n\n",
        "score": [
            -0.8499406126684382,
            2.4585716128349304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search: combine 3-opt with a biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt move\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Apply a biased random walk to escape local optima\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, size=2, replace=False))\n        if np.random.rand() < 0.7:  # Higher probability to accept if improvement is likely\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is not a valid tour.\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 85,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a preference for those with lower total cost\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)  # Select from top 20% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: choose between edge insertion and node swap with probability\n    if random.random() < 0.7:  # 70% chance for edge insertion\n        # Edge insertion: remove a random edge and insert it in another position\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = random.randint(0, n - 1)\n\n        # Perform edge insertion\n        edge_start = i\n        edge_end = (i + 1) % n\n        new_solution = np.roll(new_solution, -edge_start)\n        new_solution = np.concatenate([new_solution[:1], new_solution[edge_end:j+1], new_solution[1:edge_end], new_solution[j+1:]])\n        new_solution = np.roll(new_solution, edge_start)\n    else:  # 30% chance for node swap\n        # Node swap: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8660977897032811,
            1.0833539366722107
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a preference for those with lower total cost\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(int(len(archive) * 0.2), len(archive) - 1)  # Select from top 20% of solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: choose between edge insertion and node swap with probability\n    if random.random() < 0.7:  # 70% chance for edge insertion\n        # Edge insertion: remove a random edge and insert it in another position\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while i == j or (i + 1) % n == j or (j + 1) % n == i:\n            j = random.randint(0, n - 1)\n\n        # Perform edge insertion\n        edge_start = i\n        edge_end = (i + 1) % n\n        new_solution = np.roll(new_solution, -edge_start)\n        new_solution = np.concatenate([new_solution[:1], new_solution[edge_end:j+1], new_solution[1:edge_end], new_solution[j+1:]])\n        new_solution = np.roll(new_solution, edge_start)\n    else:  # 30% chance for node swap\n        # Node swap: swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 86,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for simplicity\n    objectives = np.array([obj for _, obj in archive])\n    scores = objectives @ weights\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: 3-opt local search (select three random edges and reconnect them)\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Create all possible 3-opt moves and evaluate them\n    candidates = []\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n        candidate[b:c] = candidate[b:c][::-1]\n        candidate[a:c] = candidate[a:c][::-1]\n        candidates.append(candidate)\n\n    # Evaluate candidates based on both objectives\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return (cost1, cost2)\n\n    # Select the best candidate (Pareto dominance or weighted sum)\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1, cost2 = evaluate(candidate)\n        score = weights[0] * cost1 + weights[1] * cost2\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n\n    # Step 2: Novel segment inversion heuristic (invert a random segment with probability)\n    if np.random.rand() < 0.3:  # 30% chance to apply\n        start, end = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6529689449769877,
            4.376288175582886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for simplicity\n    objectives = np.array([obj for _, obj in archive])\n    scores = objectives @ weights\n    best_idx = np.argmin(scores)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: 3-opt local search (select three random edges and reconnect them)\n    i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Create all possible 3-opt moves and evaluate them\n    candidates = []\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        candidate = new_solution.copy()\n        candidate[a:b] = candidate[a:b][::-1]\n        candidate[b:c] = candidate[b:c][::-1]\n        candidate[a:c] = candidate[a:c][::-1]\n        candidates.append(candidate)\n\n    # Evaluate candidates based on both objectives\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i-1], sol[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i-1], sol[i]] for i in range(n))\n        return (cost1, cost2)\n\n    # Select the best candidate (Pareto dominance or weighted sum)\n    best_candidate = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1, cost2 = evaluate(candidate)\n        score = weights[0] * cost1 + weights[1] * cost2\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate.copy()\n\n    # Step 2: Novel segment inversion heuristic (invert a random segment with probability)\n    if np.random.rand() < 0.3:  # 30% chance to apply\n        start, end = sorted(np.random.choice(range(1, n), size=2, replace=False))\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure the solution remains feasible (no duplicates)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 87,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not already optimal)\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    new_solution[i:j] = selected_solution[i:j][::-1]\n    new_solution[j:k] = selected_solution[j:k][::-1]\n\n    # Apply custom edge-swap heuristic: swap edges if it reduces both objectives\n    for _ in range(min(3, n // 2)):\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]]\n\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            # Perform the swap if it improves both objectives\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8727154397053898,
            2.180511772632599
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not already optimal)\n    selected_solution = max(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    new_solution[i:j] = selected_solution[i:j][::-1]\n    new_solution[j:k] = selected_solution[j:k][::-1]\n\n    # Apply custom edge-swap heuristic: swap edges if it reduces both objectives\n    for _ in range(min(3, n // 2)):\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]]\n\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            # Perform the swap if it improves both objectives\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 88,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge-swapping and segment-reversal\n    if random.random() < 0.7:  # 70% chance for edge-swapping\n        # Edge-swapping: select two non-adjacent edges and swap their nodes\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i + 1 != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for segment-reversal\n        # Segment-reversal: reverse a random segment of the tour\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7498814202663919,
            2.224323093891144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: alternate between edge-swapping and segment-reversal\n    if random.random() < 0.7:  # 70% chance for edge-swapping\n        # Edge-swapping: select two non-adjacent edges and swap their nodes\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        if i + 1 != j:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for segment-reversal\n        # Segment-reversal: reverse a random segment of the tour\n        a, b = sorted(random.sample(range(1, n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 89,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    selected_obj = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            selected_obj = obj\n            break\n\n    if selected_solution is None:\n        # If all solutions are dominated, pick a random one\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to invert (novel segment inversion)\n    if n >= 4:\n        start = random.randint(0, n - 4)\n        end = random.randint(start + 2, min(start + 6, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply 3-opt to further improve the solution\n    if n >= 6:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt moves and keep the best\n        best_solution = new_solution.copy()\n        best_cost = (sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) +\n                     sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)))\n\n        # Try reversing segments between i, j, k\n        for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            temp_sol = new_solution.copy()\n            temp_sol[a:b+1] = temp_sol[a:b+1][::-1]\n            temp_sol[b:c+1] = temp_sol[b:c+1][::-1]\n            temp_cost = (sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n)) +\n                         sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n)))\n            if temp_cost < best_cost:\n                best_solution = temp_sol.copy()\n                best_cost = temp_cost\n\n        new_solution = best_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8293702237776688,
            3.4913986325263977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    selected_obj = None\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            selected_obj = obj\n            break\n\n    if selected_solution is None:\n        # If all solutions are dominated, pick a random one\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to invert (novel segment inversion)\n    if n >= 4:\n        start = random.randint(0, n - 4)\n        end = random.randint(start + 2, min(start + 6, n - 1))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply 3-opt to further improve the solution\n    if n >= 6:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt moves and keep the best\n        best_solution = new_solution.copy()\n        best_cost = (sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) +\n                     sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)))\n\n        # Try reversing segments between i, j, k\n        for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            temp_sol = new_solution.copy()\n            temp_sol[a:b+1] = temp_sol[a:b+1][::-1]\n            temp_sol[b:c+1] = temp_sol[b:c+1][::-1]\n            temp_cost = (sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(n)) +\n                         sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(n)))\n            if temp_cost < best_cost:\n                best_solution = temp_sol.copy()\n                best_cost = temp_cost\n\n        new_solution = best_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 90,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs]\n        sum_costs = sum(normalized_costs)\n        probabilities = [cost / sum_costs for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Choose between edge swap or segment reversal with equal probability\n    if random.random() < 0.5:\n        # Edge swap operator (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Novel segment reversal operator: reverse a segment and insert it elsewhere\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    return new_solution\n\n",
        "score": [
            -0.8062722439853962,
            2.3923174142837524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    if min_cost == max_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs]\n        sum_costs = sum(normalized_costs)\n        probabilities = [cost / sum_costs for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Choose between edge swap or segment reversal with equal probability\n    if random.random() < 0.5:\n        # Edge swap operator (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Novel segment reversal operator: reverse a segment and insert it elsewhere\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 91,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge insertion and node reallocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Remove the segment and find the best insertion point\n    remaining = np.setdiff1d(new_solution, segment)\n    best_insertion_cost = float('inf')\n    best_insertion_point = 0\n\n    for i in range(len(remaining)):\n        # Try inserting the segment at position i\n        candidate = np.insert(remaining, i, segment)\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_insertion_cost:\n            best_insertion_cost = total_cost\n            best_insertion_point = i\n\n    # Step 3: Insert the segment at the best position\n    new_solution = np.insert(remaining, best_insertion_point, segment)\n\n    # Step 4: Apply a node reallocation to further improve the solution\n    for _ in range(2):  # Limit the number of reallocations to prevent excessive computation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Swap nodes i and j\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            # Check if this swap improves the solution\n            cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_total_cost = cost1 + cost2\n\n            # If not improved, revert the swap\n            if new_total_cost > best_insertion_cost:\n                new_solution[j] = new_solution[i]\n                new_solution[i] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.5923968725239077,
            13.84583294391632
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge insertion and node reallocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to modify\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(5, n - segment_start - 1))\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Remove the segment and find the best insertion point\n    remaining = np.setdiff1d(new_solution, segment)\n    best_insertion_cost = float('inf')\n    best_insertion_point = 0\n\n    for i in range(len(remaining)):\n        # Try inserting the segment at position i\n        candidate = np.insert(remaining, i, segment)\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_insertion_cost:\n            best_insertion_cost = total_cost\n            best_insertion_point = i\n\n    # Step 3: Insert the segment at the best position\n    new_solution = np.insert(remaining, best_insertion_point, segment)\n\n    # Step 4: Apply a node reallocation to further improve the solution\n    for _ in range(2):  # Limit the number of reallocations to prevent excessive computation\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Swap nodes i and j\n            temp = new_solution[i]\n            new_solution[i] = new_solution[j]\n            new_solution[j] = temp\n\n            # Check if this swap improves the solution\n            cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n            new_total_cost = cost1 + cost2\n\n            # If not improved, revert the swap\n            if new_total_cost > best_insertion_cost:\n                new_solution[j] = new_solution[i]\n                new_solution[i] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 92,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (e.g., distance from Pareto front)\n    if len(archive) > 1:\n        # Simple heuristic: select a solution that is not dominated by others\n        non_dominated_indices = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and archive_objectives[j][0] <= archive_objectives[i][0] and archive_objectives[j][1] <= archive_objectives[i][1] and (archive_objectives[j][0] < archive_objectives[i][0] or archive_objectives[j][1] < archive_objectives[i][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated_indices.append(i)\n\n        if non_dominated_indices:\n            selected_idx = np.random.choice(non_dominated_indices)\n            base_solution = archive_solutions[selected_idx].copy()\n        else:\n            # If all solutions are non-dominated, select randomly\n            selected_idx = np.random.randint(0, len(archive))\n            base_solution = archive_solutions[selected_idx].copy()\n    else:\n        base_solution = archive_solutions[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment reversal\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge exchange: swap edges (a,b) and (c,d) with (a,c) and (b,d)\n    if a != c and b != d:\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Segment reversal: reverse a segment between two random points\n    if a != b:\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != len(base_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8433210078813276,
            2.6409398317337036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (e.g., distance from Pareto front)\n    if len(archive) > 1:\n        # Simple heuristic: select a solution that is not dominated by others\n        non_dominated_indices = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and archive_objectives[j][0] <= archive_objectives[i][0] and archive_objectives[j][1] <= archive_objectives[i][1] and (archive_objectives[j][0] < archive_objectives[i][0] or archive_objectives[j][1] < archive_objectives[i][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated_indices.append(i)\n\n        if non_dominated_indices:\n            selected_idx = np.random.choice(non_dominated_indices)\n            base_solution = archive_solutions[selected_idx].copy()\n        else:\n            # If all solutions are non-dominated, select randomly\n            selected_idx = np.random.randint(0, len(archive))\n            base_solution = archive_solutions[selected_idx].copy()\n    else:\n        base_solution = archive_solutions[0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment reversal\n    n = len(new_solution)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge exchange: swap edges (a,b) and (c,d) with (a,c) and (b,d)\n    if a != c and b != d:\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    # Segment reversal: reverse a segment between two random points\n    if a != b:\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(set(new_solution)) != len(base_solution):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 93,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge swaps\n    n = len(base_solution)\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select 3 distinct edges\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        # Create candidate solutions by rearranging the selected edges\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c+1], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[a:b], new_solution[b:c+1][::-1], new_solution[c+1:]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = new_solution\n        best_score = float('inf')\n        for candidate in candidates:\n            # Calculate objective values\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            # Use a weighted sum to balance both objectives\n            score = 0.5 * cost1 + 0.5 * cost2\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        new_solution = best_candidate\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.9112383079266176,
            7.147750556468964
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with objective-aware edge swaps\n    n = len(base_solution)\n    for _ in range(5):  # Perform multiple iterations\n        # Randomly select 3 distinct edges\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        # Create candidate solutions by rearranging the selected edges\n        candidates = [\n            np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[a:b][::-1], new_solution[b:c+1], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a], new_solution[a:b], new_solution[b:c+1][::-1], new_solution[c+1:]])\n        ]\n\n        # Evaluate candidates based on both objectives\n        best_candidate = new_solution\n        best_score = float('inf')\n        for candidate in candidates:\n            # Calculate objective values\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            # Use a weighted sum to balance both objectives\n            score = 0.5 * cost1 + 0.5 * cost2\n            if score < best_score:\n                best_score = score\n                best_candidate = candidate\n\n        new_solution = best_candidate\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 94,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a promising solution from the archive (e.g., one with non-dominated objectives)\n    # Here, we select a random solution from the top 30% of the archive based on a combined objective score\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a combined objective score for each solution (sum of normalized objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n\n    # Select the top 30% of solutions\n    top_indices = np.argsort(combined_scores)[:max(1, len(archive) // 3)]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Edge exchange followed by node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but more aggressive)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion (relocate a node to a new position)\n    node_to_move = random.choice(new_solution[1:-1])  # Exclude start/end nodes\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    possible_positions = [pos for pos in range(n) if pos != current_pos and pos != (current_pos + 1) % n]\n    new_pos = random.choice(possible_positions)\n\n    # Perform the move\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.90035355234157,
            2.618940055370331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a promising solution from the archive (e.g., one with non-dominated objectives)\n    # Here, we select a random solution from the top 30% of the archive based on a combined objective score\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a combined objective score for each solution (sum of normalized objectives)\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n\n    # Select the top 30% of solutions\n    top_indices = np.argsort(combined_scores)[:max(1, len(archive) // 3)]\n    selected_idx = random.choice(top_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Edge exchange followed by node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but more aggressive)\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion (relocate a node to a new position)\n    node_to_move = random.choice(new_solution[1:-1])  # Exclude start/end nodes\n    current_pos = np.where(new_solution == node_to_move)[0][0]\n    possible_positions = [pos for pos in range(n) if pos != current_pos and pos != (current_pos + 1) % n]\n    new_pos = random.choice(possible_positions)\n\n    # Perform the move\n    new_solution = np.delete(new_solution, current_pos)\n    new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == n, \"Invalid solution length\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 95,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated solutions)\n    # Here, we select the solution with the highest sum of objectives as it likely has room for improvement\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Perform 3-opt on a random segment\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the middle part of the segment\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Edge-swap heuristic considering both objectives\n    # Find edges that could be swapped to improve both objectives\n    for _ in range(10):  # Limit the number of attempts\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the cost before swap\n        cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Perform the swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate the cost after swap\n        cost1_after = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        cost2_after = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # If the swap doesn't improve both objectives, revert\n        if not (cost1_after < cost1_before and cost2_after < cost2_before):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7001772719747179,
            2.2073923349380493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated solutions)\n    # Here, we select the solution with the highest sum of objectives as it likely has room for improvement\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Perform 3-opt on a random segment\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Reverse the middle part of the segment\n    new_solution[i:j+1] = segment[::-1]\n\n    # Step 2: Edge-swap heuristic considering both objectives\n    # Find edges that could be swapped to improve both objectives\n    for _ in range(10):  # Limit the number of attempts\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the cost before swap\n        cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # Perform the swap\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Calculate the cost after swap\n        cost1_after = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        cost2_after = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        # If the swap doesn't improve both objectives, revert\n        if not (cost1_after < cost1_before and cost2_after < cost2_before):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 96,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(np.unique(costs)) == 1:\n        # If all costs are equal, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to create a probability distribution\n        min_cost = np.min(costs)\n        max_cost = np.max(costs)\n        if max_cost == min_cost:\n            normalized_costs = np.ones_like(costs)\n        else:\n            normalized_costs = (max_cost - costs) / (max_cost - min_cost)\n        probabilities = normalized_costs / np.sum(normalized_costs)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and node insertion\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of the tour\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 10, n - 1))  # Limit segment size for efficiency\n\n    # Step 2: Reverse the selected segment (similar to 2-opt but more flexible)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 3: Evaluate the new solution's quality in both objectives\n    def calculate_tour_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    cost1_new = calculate_tour_cost(new_solution, distance_matrix_1)\n    cost2_new = calculate_tour_cost(new_solution, distance_matrix_2)\n\n    # If the new solution is worse in both objectives, try node insertion\n    if (cost1_new > objectives[selected_idx][0] and cost2_new > objectives[selected_idx][1]):\n        # Step 4: Node insertion - move a random node to a new position\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node and insert it in a random position\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6939196777510489,
            2.8784168362617493
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    costs = np.array([sum(obj) for obj in objectives])\n    if len(np.unique(costs)) == 1:\n        # If all costs are equal, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to create a probability distribution\n        min_cost = np.min(costs)\n        max_cost = np.max(costs)\n        if max_cost == min_cost:\n            normalized_costs = np.ones_like(costs)\n        else:\n            normalized_costs = (max_cost - costs) / (max_cost - min_cost)\n        probabilities = normalized_costs / np.sum(normalized_costs)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and node insertion\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment of the tour\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + 10, n - 1))  # Limit segment size for efficiency\n\n    # Step 2: Reverse the selected segment (similar to 2-opt but more flexible)\n    segment = new_solution[start:end+1]\n    new_solution[start:end+1] = segment[::-1]\n\n    # Step 3: Evaluate the new solution's quality in both objectives\n    def calculate_tour_cost(solution, distance_matrix):\n        cost = 0\n        for i in range(len(solution)):\n            cost += distance_matrix[solution[i-1], solution[i]]\n        return cost\n\n    cost1_new = calculate_tour_cost(new_solution, distance_matrix_1)\n    cost2_new = calculate_tour_cost(new_solution, distance_matrix_2)\n\n    # If the new solution is worse in both objectives, try node insertion\n    if (cost1_new > objectives[selected_idx][0] and cost2_new > objectives[selected_idx][1]):\n        # Step 4: Node insertion - move a random node to a new position\n        node_idx = random.randint(0, n - 1)\n        node = new_solution[node_idx]\n\n        # Remove the node and insert it in a random position\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 97,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (lower rank is better)\n    dominance_ranks = []\n    for i, (sol, _) in enumerate(archive):\n        cost1 = sum(distance_matrix_1[sol[j], sol[(j+1)%len(sol)]] for j in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[j], sol[(j+1)%len(sol)]] for j in range(len(sol)))\n        dominance = sum(1 for (_, (c1, c2)) in archive if (c1 <= cost1 and c2 < cost2) or (c1 < cost1 and c2 <= cost2))\n        dominance_ranks.append(dominance)\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    total_rank = sum(dominance_ranks)\n    probabilities = [1 - (rank / total_rank) if total_rank > 0 else 1.0/len(archive) for rank in dominance_ranks]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, try a 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create new segments\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        # Reverse segments\n        new_solution[i:j] = segment1[::-1]\n        new_solution[j:k] = segment2[::-1]\n\n    # Then, try a novel edge-swap strategy that considers both objectives\n    if n >= 3:\n        a, b, c = random.sample(range(n), 3)\n        # Calculate current and potential costs for both objectives\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]])\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Try swapping nodes a and b\n        temp = new_solution.copy()\n        temp[a], temp[b] = temp[b], temp[a]\n        new_cost1 = (distance_matrix_1[temp[a-1], temp[a]] +\n                     distance_matrix_1[temp[b-1], temp[b]] +\n                     distance_matrix_1[temp[c-1], temp[c]])\n        new_cost2 = (distance_matrix_2[temp[a-1], temp[a]] +\n                     distance_matrix_2[temp[b-1], temp[b]] +\n                     distance_matrix_2[temp[c-1], temp[c]])\n\n        # If the swap improves both objectives, accept it\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n            new_solution = temp.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7530137786835098,
            5.755882382392883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (lower rank is better)\n    dominance_ranks = []\n    for i, (sol, _) in enumerate(archive):\n        cost1 = sum(distance_matrix_1[sol[j], sol[(j+1)%len(sol)]] for j in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[j], sol[(j+1)%len(sol)]] for j in range(len(sol)))\n        dominance = sum(1 for (_, (c1, c2)) in archive if (c1 <= cost1 and c2 < cost2) or (c1 < cost1 and c2 <= cost2))\n        dominance_ranks.append(dominance)\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    total_rank = sum(dominance_ranks)\n    probabilities = [1 - (rank / total_rank) if total_rank > 0 else 1.0/len(archive) for rank in dominance_ranks]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, try a 3-opt move\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Create new segments\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        # Reverse segments\n        new_solution[i:j] = segment1[::-1]\n        new_solution[j:k] = segment2[::-1]\n\n    # Then, try a novel edge-swap strategy that considers both objectives\n    if n >= 3:\n        a, b, c = random.sample(range(n), 3)\n        # Calculate current and potential costs for both objectives\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[c-1], new_solution[c]])\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Try swapping nodes a and b\n        temp = new_solution.copy()\n        temp[a], temp[b] = temp[b], temp[a]\n        new_cost1 = (distance_matrix_1[temp[a-1], temp[a]] +\n                     distance_matrix_1[temp[b-1], temp[b]] +\n                     distance_matrix_1[temp[c-1], temp[c]])\n        new_cost2 = (distance_matrix_2[temp[a-1], temp[a]] +\n                     distance_matrix_2[temp[b-1], temp[b]] +\n                     distance_matrix_2[temp[c-1], temp[c]])\n\n        # If the swap improves both objectives, accept it\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2):\n            new_solution = temp.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 98,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel swap-based operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Apply 2-opt on the first objective space\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate the 2-opt move\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a novel swap-based operator on the second objective space\n    for _ in range(10):  # Limit iterations\n        i, j = np.random.choice(range(1, n-1), 2, replace=False)\n        if i == j:\n            continue\n\n        # Evaluate the swap move\n        old_cost = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7429737933221285,
            3.661447584629059
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel swap-based operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Apply 2-opt on the first objective space\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if i == j:\n            continue\n\n        # Evaluate the 2-opt move\n        old_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a novel swap-based operator on the second objective space\n    for _ in range(10):  # Limit iterations\n        i, j = np.random.choice(range(1, n-1), 2, replace=False)\n        if i == j:\n            continue\n\n        # Evaluate the swap move\n        old_cost = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                    distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                    distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                    distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if new_cost < old_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 99,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly choose a segment of the tour to modify\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n\n    # Extract the segment and reverse it (segment reversal)\n    segment = new_solution[segment_start:segment_start + segment_length]\n    reversed_segment = segment[::-1]\n    new_solution[segment_start:segment_start + segment_length] = reversed_segment\n\n    # Optionally, perform a random edge exchange between two non-adjacent segments\n    if random.random() < 0.5 and n >= 6:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:  # Ensure they are not adjacent\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9060369640690614,
            2.2606441974639893
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: apply a combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly choose a segment of the tour to modify\n    segment_start = random.randint(0, n - 4)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n\n    # Extract the segment and reverse it (segment reversal)\n    segment = new_solution[segment_start:segment_start + segment_length]\n    reversed_segment = segment[::-1]\n    new_solution[segment_start:segment_start + segment_length] = reversed_segment\n\n    # Optionally, perform a random edge exchange between two non-adjacent segments\n    if random.random() < 0.5 and n >= 6:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:  # Ensure they are not adjacent\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 100,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    # Here we prioritize solutions with high combined cost\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by descending total cost\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with biased randomness\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for 3-opt\n\n    # Select three distinct random indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Validate the solution (ensure no duplicates and all nodes are present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if 3-opt fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8846370577939338,
            1.9410289525985718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    # Here we prioritize solutions with high combined cost\n    archive.sort(key=lambda x: -(x[1][0] + x[1][1]))  # Sort by descending total cost\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with biased randomness\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Not enough nodes for 3-opt\n\n    # Select three distinct random indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse segments between i, j, and k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n    new_solution[i:k] = new_solution[i:k][::-1]\n\n    # Validate the solution (ensure no duplicates and all nodes are present)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple 2-opt if 3-opt fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 101,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Edge insertion: Insert node j between i and k\n    if i < j < k:\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:k], new_solution[k:]])\n    else:\n        # Node relocation: Move node j to position i\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # 3-opt-like move: Reorder a segment to minimize both objectives\n    segment = new_solution[i:k+1]\n    segment_cost_1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost_2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Try reversing the segment if it improves both objectives\n    reversed_segment = segment[::-1]\n    reversed_cost_1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost_2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    if (reversed_cost_1 < segment_cost_1) and (reversed_cost_2 < segment_cost_2):\n        new_solution[i:k+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8330313043117422,
            1.5661256909370422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high variance)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Edge insertion: Insert node j between i and k\n    if i < j < k:\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:k], new_solution[k:]])\n    else:\n        # Node relocation: Move node j to position i\n        new_solution = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n\n    # 3-opt-like move: Reorder a segment to minimize both objectives\n    segment = new_solution[i:k+1]\n    segment_cost_1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost_2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Try reversing the segment if it improves both objectives\n    reversed_segment = segment[::-1]\n    reversed_cost_1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost_2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    if (reversed_cost_1 < segment_cost_1) and (reversed_cost_2 < segment_cost_2):\n        new_solution[i:k+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 102,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its current cost\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    if all(c == 0 for c in costs):\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [1.0 / (c + 1e-6) for c in costs]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n    base_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and node swap\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Edge insertion: remove segment between i and j, then reinsert\n        segment = new_solution[i:j+1]\n        remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        k = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n        # Node swap: swap two nodes to explore different neighborhoods\n        if len(new_solution) >= 2:\n            a, b = random.sample(range(len(new_solution)), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If invalid, perform a simple 2-opt as fallback\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.86620040475407,
            4.477769374847412
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its current cost\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    if all(c == 0 for c in costs):\n        weights = [1.0 / len(archive)] * len(archive)\n    else:\n        weights = [1.0 / (c + 1e-6) for c in costs]\n    total_weight = sum(weights)\n    weights = [w / total_weight for w in weights]\n    base_solution = random.choices(archive, weights=weights, k=1)[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge insertion and node swap\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct positions\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Edge insertion: remove segment between i and j, then reinsert\n        segment = new_solution[i:j+1]\n        remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        k = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n        # Node swap: swap two nodes to explore different neighborhoods\n        if len(new_solution) >= 2:\n            a, b = random.sample(range(len(new_solution)), 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If invalid, perform a simple 2-opt as fallback\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 103,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Solutions with higher potential (lower cost) are more likely to be selected\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (1 / (costs + 1e-10))  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: 3-opt with segment inversion\n    if n >= 4:\n        # Randomly select 4 distinct indices\n        indices = sorted(random.sample(range(n), 4))\n        i, j, k, l = indices[0], indices[1], indices[2], indices[3]\n\n        # Apply 3-opt move\n        # Create new segments by reconnecting the nodes in different orders\n        segments = [\n            new_solution[:i],\n            new_solution[i:j],\n            new_solution[j:k],\n            new_solution[k:l],\n            new_solution[l:]\n        ]\n\n        # Try all possible 3-opt configurations\n        configurations = [\n            np.concatenate([segments[0], segments[1], segments[2], segments[3], segments[4]]),\n            np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n            np.concatenate([segments[0], segments[2], segments[3], segments[1], segments[4]]),\n            np.concatenate([segments[0], segments[3], segments[1], segments[2], segments[4]]),\n            np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n        ]\n\n        # Evaluate all configurations using both objectives\n        best_config = new_solution.copy()\n        best_cost = np.inf\n\n        for config in configurations:\n            cost1 = sum(distance_matrix_1[config[i], config[i+1]] for i in range(n-1)) + distance_matrix_1[config[-1], config[0]]\n            cost2 = sum(distance_matrix_2[config[i], config[i+1]] for i in range(n-1)) + distance_matrix_2[config[-1], config[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_config = config.copy()\n\n        new_solution = best_config\n\n        # Apply segment inversion with a certain probability\n        if random.random() < 0.3:\n            # Select a random segment to invert\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8080166055868144,
            7.165767788887024
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Solutions with higher potential (lower cost) are more likely to be selected\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (1 / (costs + 1e-10))  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: 3-opt with segment inversion\n    if n >= 4:\n        # Randomly select 4 distinct indices\n        indices = sorted(random.sample(range(n), 4))\n        i, j, k, l = indices[0], indices[1], indices[2], indices[3]\n\n        # Apply 3-opt move\n        # Create new segments by reconnecting the nodes in different orders\n        segments = [\n            new_solution[:i],\n            new_solution[i:j],\n            new_solution[j:k],\n            new_solution[k:l],\n            new_solution[l:]\n        ]\n\n        # Try all possible 3-opt configurations\n        configurations = [\n            np.concatenate([segments[0], segments[1], segments[2], segments[3], segments[4]]),\n            np.concatenate([segments[0], segments[1], segments[3], segments[2], segments[4]]),\n            np.concatenate([segments[0], segments[2], segments[1], segments[3], segments[4]]),\n            np.concatenate([segments[0], segments[2], segments[3], segments[1], segments[4]]),\n            np.concatenate([segments[0], segments[3], segments[1], segments[2], segments[4]]),\n            np.concatenate([segments[0], segments[3], segments[2], segments[1], segments[4]])\n        ]\n\n        # Evaluate all configurations using both objectives\n        best_config = new_solution.copy()\n        best_cost = np.inf\n\n        for config in configurations:\n            cost1 = sum(distance_matrix_1[config[i], config[i+1]] for i in range(n-1)) + distance_matrix_1[config[-1], config[0]]\n            cost2 = sum(distance_matrix_2[config[i], config[i+1]] for i in range(n-1)) + distance_matrix_2[config[-1], config[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_config = config.copy()\n\n        new_solution = best_config\n\n        # Apply segment inversion with a certain probability\n        if random.random() < 0.3:\n            # Select a random segment to invert\n            seg_start = random.randint(0, n-2)\n            seg_end = random.randint(seg_start+1, n-1)\n            new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 104,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its dominance rank (simplified)\n    # Here, we prioritize solutions with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select three random edges and reconnect them optimally)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Try all possible reconnections\n        options = [\n            np.concatenate([new_solution[:i], segment1[::-1], segment2, new_solution[k:]]),\n            np.concatenate([new_solution[:i], segment2, segment1[::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], segment1, segment2[::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]])\n        ]\n\n        # Evaluate all options using both objectives\n        best_option = new_solution\n        best_cost = (float('inf'), float('inf'))\n\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[opt[i], opt[(i+1)%n]] for i in range(n))\n            if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n                best_cost = (cost1, cost2)\n                best_option = opt\n\n        new_solution = best_option\n\n    # Additional custom edge-swap heuristic\n    if n >= 2:\n        # Randomly select two edges to swap\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:  # Ensure we're not selecting adjacent edges\n            # Create a new candidate solution by swapping the two edges\n            candidate = new_solution.copy()\n            candidate[a+1:b] = new_solution[a+1:b][::-1]\n\n            # Evaluate the candidate\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Accept the candidate if it improves either objective\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            if cost1 < current_cost1 or cost2 < current_cost2:\n                new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.8513388850770439,
            3.3378064036369324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its dominance rank (simplified)\n    # Here, we prioritize solutions with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a 3-opt move (select three random edges and reconnect them optimally)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n\n        # Try all possible reconnections\n        options = [\n            np.concatenate([new_solution[:i], segment1[::-1], segment2, new_solution[k:]]),\n            np.concatenate([new_solution[:i], segment2, segment1[::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], segment1, segment2[::-1], new_solution[k:]]),\n            np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]])\n        ]\n\n        # Evaluate all options using both objectives\n        best_option = new_solution\n        best_cost = (float('inf'), float('inf'))\n\n        for opt in options:\n            cost1 = sum(distance_matrix_1[opt[i], opt[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[opt[i], opt[(i+1)%n]] for i in range(n))\n            if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n                best_cost = (cost1, cost2)\n                best_option = opt\n\n        new_solution = best_option\n\n    # Additional custom edge-swap heuristic\n    if n >= 2:\n        # Randomly select two edges to swap\n        a, b = sorted(random.sample(range(n), 2))\n        if b - a > 1:  # Ensure we're not selecting adjacent edges\n            # Create a new candidate solution by swapping the two edges\n            candidate = new_solution.copy()\n            candidate[a+1:b] = new_solution[a+1:b][::-1]\n\n            # Evaluate the candidate\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n            # Accept the candidate if it improves either objective\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            if cost1 < current_cost1 or cost2 < current_cost2:\n                new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 105,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower costs\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = np.exp(-costs / np.sum(costs))  # Softmax-like selection\n    probabilities /= np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge exchange and biased random walk\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct edges to exchange\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform edge exchange (similar to 2-opt but more flexible)\n        if i != j and k != l:\n            # Create a new segment by reversing a part of the tour\n            segment = new_solution[i:j+1]\n            new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n            new_solution[i:j+1] = new_segment\n\n            # Check if the exchange improves the solution in either objective\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost1 < old_cost1:\n                continue  # Accept if improvement in first objective\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost2 < old_cost2:\n                continue  # Accept if improvement in second objective\n\n            # If no improvement, revert with some probability to allow exploration\n            if random.random() < 0.3:\n                new_solution[i:j+1] = segment  # Revert\n\n    return new_solution\n\n",
        "score": [
            -0.8183148903143289,
            2.8197739124298096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower costs\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = np.exp(-costs / np.sum(costs))  # Softmax-like selection\n    probabilities /= np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combination of edge exchange and biased random walk\n    for _ in range(10):  # Number of iterations\n        # Randomly select two distinct edges to exchange\n        i, j = sorted(random.sample(range(n), 2))\n        k, l = sorted(random.sample(range(n), 2))\n\n        # Perform edge exchange (similar to 2-opt but more flexible)\n        if i != j and k != l:\n            # Create a new segment by reversing a part of the tour\n            segment = new_solution[i:j+1]\n            new_segment = np.concatenate([segment[:1], segment[1:][::-1]])\n            new_solution[i:j+1] = new_segment\n\n            # Check if the exchange improves the solution in either objective\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost1 < old_cost1:\n                continue  # Accept if improvement in first objective\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n            if new_cost2 < old_cost2:\n                continue  # Accept if improvement in second objective\n\n            # If no improvement, revert with some probability to allow exploration\n            if random.random() < 0.3:\n                new_solution[i:j+1] = segment  # Revert\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 106,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment inversion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to invert (novel segment inversion)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping and valid\n    if i < j < k < l:\n        # Invert the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Invert the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply 2-opt to further improve the solution\n    a, b = sorted(random.sample(range(n), 2))\n    if a < b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if inversion causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8392159323616335,
            1.732000470161438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-frontier solutions)\n    selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: Combine 2-opt with a novel segment inversion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments to invert (novel segment inversion)\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping and valid\n    if i < j < k < l:\n        # Invert the first segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        # Invert the second segment\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Apply 2-opt to further improve the solution\n    a, b = sorted(random.sample(range(n), 2))\n    if a < b:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if inversion causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 107,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node swap\n    n = len(new_solution)\n    if n < 4:\n        # If the solution is too small, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion: remove a random edge and insert it in a different position\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            # Remove edge between i and i+1\n            removed_node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:]])\n            # Insert the removed node at a random position\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n        # Node swap: swap two non-adjacent nodes to explore different neighborhoods\n        if n > 3:\n            a, b = random.sample(range(1, n-1), 2)\n            if abs(a - b) > 1:  # Ensure nodes are not adjacent\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.45583688221973395,
            2.1830519437789917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1][0], x[1][1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and node swap\n    n = len(new_solution)\n    if n < 4:\n        # If the solution is too small, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion: remove a random edge and insert it in a different position\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            # Remove edge between i and i+1\n            removed_node = new_solution[i+1]\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:]])\n            # Insert the removed node at a random position\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, removed_node)\n\n        # Node swap: swap two non-adjacent nodes to explore different neighborhoods\n        if n > 3:\n            a, b = random.sample(range(1, n-1), 2)\n            if abs(a - b) > 1:  # Ensure nodes are not adjacent\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 108,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_n = max(1, len(archive) // 3)\n    selected_solutions = sorted_archive[:top_n]\n    selected_idx = random.randint(0, len(selected_solutions) - 1)\n    base_solution = selected_solutions[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge insertion: insert a random node in a new position to diversify\n    if n > 3:\n        node_to_move = random.choice(new_solution)\n        new_pos = random.randint(0, n-1)\n        new_solution = np.roll(new_solution, -new_solution.tolist().index(node_to_move))\n        new_solution = np.concatenate([new_solution[:new_pos], [node_to_move], new_solution[new_pos:]])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(set(new_solution)) == n, \"Invalid solution: duplicate nodes or missing nodes\"\n\n    return new_solution\n\n",
        "score": [
            -0.8960722392261248,
            0.41107606887817383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_n = max(1, len(archive) // 3)\n    selected_solutions = sorted_archive[:top_n]\n    selected_idx = random.randint(0, len(selected_solutions) - 1)\n    base_solution = selected_solutions[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel edge insertion strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge insertion: insert a random node in a new position to diversify\n    if n > 3:\n        node_to_move = random.choice(new_solution)\n        new_pos = random.randint(0, n-1)\n        new_solution = np.roll(new_solution, -new_solution.tolist().index(node_to_move))\n        new_solution = np.concatenate([new_solution[:new_pos], [node_to_move], new_solution[new_pos:]])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(set(new_solution)) == n, \"Invalid solution: duplicate nodes or missing nodes\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 109,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:\n        # 3-opt move (randomly select 3 edges and reconnect them)\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect the segments in a different order\n        new_order = [segment1, segment3, segment2, segment4]\n        new_solution = np.concatenate(new_order)\n    else:\n        # Novel edge-swap mechanism: swap two non-adjacent edges\n        i = random.randint(1, n-3)\n        j = random.randint(i+2, n-1)\n\n        # Ensure we don't swap adjacent edges\n        if i + 1 == j:\n            j += 1\n\n        # Perform the swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.5677537324409343,
            2.1103328466415405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_idx = min(int(len(archive_sorted) * 0.2), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:\n        # 3-opt move (randomly select 3 edges and reconnect them)\n        i, j, k = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect the segments in a different order\n        new_order = [segment1, segment3, segment2, segment4]\n        new_solution = np.concatenate(new_order)\n    else:\n        # Novel edge-swap mechanism: swap two non-adjacent edges\n        i = random.randint(1, n-3)\n        j = random.randint(i+2, n-1)\n\n        # Ensure we don't swap adjacent edges\n        if i + 1 == j:\n            j += 1\n\n        # Perform the swap\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 110,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.sum(objectives, axis=0)\n    scores = np.prod(1 - normalized_obj, axis=1)  # Higher score means more potential\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Combine edge exchange with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select two non-adjacent edges to swap (similar to 2-opt but more flexible)\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Step 2: Perform edge exchange\n    new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    # Step 3: Path relinking - partially align with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find segments that could be improved\n        for _ in range(min(3, n//2)):\n            k = random.randint(0, n-1)\n            if new_solution[k] != other_solution[k]:\n                # Find position of other_solution[k] in new_solution\n                pos = np.where(new_solution == other_solution[k])[0][0]\n                if pos != k:\n                    # Swap to bring closer to other solution\n                    new_solution[k], new_solution[pos] = new_solution[pos], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.7936027299024838,
            1.3968445658683777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / np.sum(objectives, axis=0)\n    scores = np.prod(1 - normalized_obj, axis=1)  # Higher score means more potential\n    selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Combine edge exchange with path relinking\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Randomly select two non-adjacent edges to swap (similar to 2-opt but more flexible)\n    i = random.randint(0, n-4)\n    j = random.randint(i+2, n-2)\n\n    # Step 2: Perform edge exchange\n    new_solution[i+1:j+1] = base_solution[j:i:-1]\n\n    # Step 3: Path relinking - partially align with another solution\n    if len(archive) > 1:\n        other_idx = random.choice([idx for idx in range(len(archive)) if idx != selected_idx])\n        other_solution = archive[other_idx][0]\n\n        # Find segments that could be improved\n        for _ in range(min(3, n//2)):\n            k = random.randint(0, n-1)\n            if new_solution[k] != other_solution[k]:\n                # Find position of other_solution[k] in new_solution\n                pos = np.where(new_solution == other_solution[k])[0][0]\n                if pos != k:\n                    # Swap to bring closer to other solution\n                    new_solution[k], new_solution[pos] = new_solution[pos], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 111,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select a solution that is not the best in either objective\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for sol2, obj2 in archive:\n            if (obj2[0] <= obj[0] and obj2[1] <= obj[1]) and (obj2[0] < obj[0] or obj2[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are non-dominated, select randomly\n        selected_sol = random.choice(archive)[0].copy()\n    else:\n        # Select a solution with high potential (e.g., not the best in either objective)\n        selected_sol = random.choice(non_dominated)[0].copy()\n\n    # Apply a hybrid local search operator: combination of edge insertion and segment reversal\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l:\n        # Remove two edges and reinsert them\n        removed = np.delete(new_solution, [k, l])\n        new_solution = np.insert(removed, k, [new_solution[l], new_solution[k]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9736309150451695,
            2.5830309987068176
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    # Here, we select a solution that is not the best in either objective\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for sol2, obj2 in archive:\n            if (obj2[0] <= obj[0] and obj2[1] <= obj[1]) and (obj2[0] < obj[0] or obj2[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are non-dominated, select randomly\n        selected_sol = random.choice(archive)[0].copy()\n    else:\n        # Select a solution with high potential (e.g., not the best in either objective)\n        selected_sol = random.choice(non_dominated)[0].copy()\n\n    # Apply a hybrid local search operator: combination of edge insertion and segment reversal\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to insert\n    k, l = sorted(random.sample(range(n), 2))\n    if k != l:\n        # Remove two edges and reinsert them\n        removed = np.delete(new_solution, [k, l])\n        new_solution = np.insert(removed, k, [new_solution[l], new_solution[k]])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_sol.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 112,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Perform a novel edge swap: swap two non-adjacent edges\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if i != j and j != i+1:\n            # Swap edges (i,i+1) and (j,j+1) with (i,j) and (i+1,j+1)\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n",
        "score": [
            -0.4092472519590269,
            2.5258665084838867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge swap\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 2-opt move\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Perform a novel edge swap: swap two non-adjacent edges\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        if i != j and j != i+1:\n            # Swap edges (i,i+1) and (j,j+1) with (i,j) and (i+1,j+1)\n            new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 113,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score (weighted sum of both objectives)\n    weights = np.random.uniform(0.3, 0.7)  # Randomly weigh the objectives\n    best_idx = np.argmin([weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Random edge swap (standard local search)\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Adaptive segment reversal (novel local search)\n    segment_length = max(2, min(5, n // 4))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]  # Reverse segment\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7243446273896164,
            1.6802854537963867
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective score (weighted sum of both objectives)\n    weights = np.random.uniform(0.3, 0.7)  # Randomly weigh the objectives\n    best_idx = np.argmin([weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # 1. Random edge swap (standard local search)\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # 2. Adaptive segment reversal (novel local search)\n    segment_length = max(2, min(5, n // 4))  # Adaptive segment length\n    start = np.random.randint(0, n - segment_length + 1)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]  # Reverse segment\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 114,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective value (sum of both objectives)\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n\n    # Select top 20% of solutions for random selection\n    top_k = max(1, int(len(sorted_archive) * 0.2))\n    selected_solution = random.choice(sorted_archive[:top_k])[0].copy()\n\n    # Hybrid local search: combination of 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with probability 0.7\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion with probability 0.5\n    if random.random() < 0.5:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure solution remains valid (no duplicates, all nodes present)\n    if len(new_solution) != len(instance) or len(set(new_solution)) != len(instance):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9640433489080578,
            2.192047119140625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective value (sum of both objectives)\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n\n    # Select top 20% of solutions for random selection\n    top_k = max(1, int(len(sorted_archive) * 0.2))\n    selected_solution = random.choice(sorted_archive[:top_k])[0].copy()\n\n    # Hybrid local search: combination of 2-opt and node insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt swap with probability 0.7\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Perform node insertion with probability 0.5\n    if random.random() < 0.5:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure solution remains valid (no duplicates, all nodes present)\n    if len(new_solution) != len(instance) or len(set(new_solution)) != len(instance):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 115,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment\n    new_solution[b:c] = new_solution[b:c][::-1]  # Reverse another segment\n\n    # Custom edge swap to improve both objectives\n    for _ in range(2):  # Perform a few edge swaps\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:  # Ensure non-adjacent nodes\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + \\\n                        distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + \\\n                        distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                        distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                        distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept if both objectives improve\n            if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7054380103817297,
            1.9688923954963684
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (non-dominated or diverse)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select 3 distinct positions to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    new_solution[a:b] = new_solution[a:b][::-1]  # Reverse segment\n    new_solution[b:c] = new_solution[b:c][::-1]  # Reverse another segment\n\n    # Custom edge swap to improve both objectives\n    for _ in range(2):  # Perform a few edge swaps\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:  # Ensure non-adjacent nodes\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + \\\n                        distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + \\\n                        distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + \\\n                        distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + \\\n                        distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept if both objectives improve\n            if (new_cost1 < old_cost1) and (new_cost2 < old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 116,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]  # Reverse segment between b and c\n\n    # Check if the move is feasible (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n\n    # If not feasible, revert to 2-opt move\n    new_solution = base_solution.copy()\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7008410087178312,
            2.45848286151886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    selected_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search: 3-opt with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Perform 3-opt move\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]  # Reverse segment between b and c\n\n    # Check if the move is feasible (no duplicates)\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n\n    # If not feasible, revert to 2-opt move\n    new_solution = base_solution.copy()\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 117,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost\n    selected_solution = None\n    min_cost = float('inf')\n    max_diversity = -1\n\n    for sol, obj in archive:\n        cost = sum(obj)\n        diversity = np.sum(np.abs(sol[:-1] - sol[1:]))  # Simple diversity measure\n\n        if cost < min_cost or (cost == min_cost and diversity > max_diversity):\n            min_cost = cost\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: combination of edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to reinsert\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        # Ensure we're not creating duplicates\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    # Validate the solution remains feasible (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.5909235383650925,
            2.232888638973236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity or low cost\n    selected_solution = None\n    min_cost = float('inf')\n    max_diversity = -1\n\n    for sol, obj in archive:\n        cost = sum(obj)\n        diversity = np.sum(np.abs(sol[:-1] - sol[1:]))  # Simple diversity measure\n\n        if cost < min_cost or (cost == min_cost and diversity > max_diversity):\n            min_cost = cost\n            max_diversity = diversity\n            selected_solution = sol.copy()\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Apply hybrid local search: combination of edge insertion and segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, n-1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly select two edges to reinsert\n    k = random.randint(0, n-1)\n    l = random.randint(0, n-1)\n    if k != l:\n        # Ensure we're not creating duplicates\n        temp = new_solution[k]\n        new_solution[k] = new_solution[l]\n        new_solution[l] = temp\n\n    # Validate the solution remains feasible (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 118,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    # Here, we select a solution with the highest sum of objectives (can be replaced with other criteria)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply a custom operator: reverse the segment between i and j, then insert k after j\n    segment = new_solution[i:j+1][::-1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = np.where(remaining == k)[0][0] if k in remaining else np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, [k], remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler operator if the above fails\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[j-1:i-1:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8590691620913304,
            0.5766562223434448
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    # Here, we select a solution with the highest sum of objectives (can be replaced with other criteria)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply a custom operator: reverse the segment between i and j, then insert k after j\n    segment = new_solution[i:j+1][::-1]\n    remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    insert_pos = np.where(remaining == k)[0][0] if k in remaining else np.random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, [k], remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler operator if the above fails\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[j-1:i-1:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 119,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability weighted by its dominance rank (higher rank = more promising)\n    weights = [1 / (i + 1) for i in range(len(archive))]  # Higher rank solutions get higher weights\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(3):  # Perform 3 local search steps\n        # Randomly choose one of three local search strategies\n        strategy = random.choice(['edge_insertion', 'node_swap', 'segment_reversal'])\n\n        if strategy == 'edge_insertion':\n            # Edge insertion: remove a random edge and reinsert it\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], new_solution[j:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif strategy == 'node_swap':\n            # Node swap: swap two non-consecutive nodes\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            if abs(i - j) > 1:  # Ensure non-consecutive\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif strategy == 'segment_reversal':\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8649036355135098,
            1.9712506532669067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability weighted by its dominance rank (higher rank = more promising)\n    weights = [1 / (i + 1) for i in range(len(archive))]  # Higher rank solutions get higher weights\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Hybrid local search operator\n    for _ in range(3):  # Perform 3 local search steps\n        # Randomly choose one of three local search strategies\n        strategy = random.choice(['edge_insertion', 'node_swap', 'segment_reversal'])\n\n        if strategy == 'edge_insertion':\n            # Edge insertion: remove a random edge and reinsert it\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], new_solution[j:]])\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        elif strategy == 'node_swap':\n            # Node swap: swap two non-consecutive nodes\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            if abs(i - j) > 1:  # Ensure non-consecutive\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        elif strategy == 'segment_reversal':\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n_nodes), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 120,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives to create a selection probability distribution\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = objectives / np.sum(objectives, axis=0, keepdims=True)\n        weights = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-6)  # Avoid division by zero\n        weights /= np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operation = random.choice(['edge_exchange', 'node_reinsertion'])\n\n    if operation == 'edge_exchange':\n        # Perform a modified edge exchange (similar to 2-opt but with a twist)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure at least one node in between\n            # Reverse segment between i+1 and j-1\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        # Novel node reinsertion strategy\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove node and reinsert at a different position\n        new_solution = np.delete(new_solution, i)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8646020753385086,
            2.450154960155487
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives to create a selection probability distribution\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = objectives / np.sum(objectives, axis=0, keepdims=True)\n        weights = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-6)  # Avoid division by zero\n        weights /= np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(new_solution)\n    operation = random.choice(['edge_exchange', 'node_reinsertion'])\n\n    if operation == 'edge_exchange':\n        # Perform a modified edge exchange (similar to 2-opt but with a twist)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure at least one node in between\n            # Reverse segment between i+1 and j-1\n            new_solution[i+1:j] = new_solution[i+1:j][::-1]\n    else:\n        # Novel node reinsertion strategy\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        # Remove node and reinsert at a different position\n        new_solution = np.delete(new_solution, i)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 121,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    # Here, we select the solution with the highest sum of objectives (can be adjusted)\n    selected_idx = np.argmax([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select three distinct segments to modify (3-opt)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n\n    # Recombine segments in a different order\n    new_segments = [segment1, segment2, segment3]\n    np.random.shuffle(new_segments)\n    new_solution[a:d] = np.concatenate(new_segments)\n\n    # Custom edge-swap heuristic: swap edges that improve both objectives\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Current edges: (i-1, i), (i, i+1), (j-1, j), (j, j+1)\n        # Proposed edges: (i-1, j), (j, i+1), (i, j-1), (i, i+1)\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2):  # Random acceptance for exploration\n            # Perform the swap\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                # Handle circular case\n                temp = np.concatenate([new_solution[i:], new_solution[:j]])\n                temp = temp[::-1]\n                new_solution[i:] = temp[:n-i]\n                new_solution[:j] = temp[n-i:]\n\n    return new_solution\n\n",
        "score": [
            -0.8574594808079168,
            2.445437490940094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto front solutions)\n    # Here, we select the solution with the highest sum of objectives (can be adjusted)\n    selected_idx = np.argmax([obj1 + obj2 for (sol, (obj1, obj2)) in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap heuristic\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select three distinct segments to modify (3-opt)\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n\n    # Recombine segments in a different order\n    new_segments = [segment1, segment2, segment3]\n    np.random.shuffle(new_segments)\n    new_solution[a:d] = np.concatenate(new_segments)\n\n    # Custom edge-swap heuristic: swap edges that improve both objectives\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if i == j or j == (i + 1) % n:\n            continue\n\n        # Current edges: (i-1, i), (i, i+1), (j-1, j), (j, j+1)\n        # Proposed edges: (i-1, j), (j, i+1), (i, j-1), (i, i+1)\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2):  # Random acceptance for exploration\n            # Perform the swap\n            if i < j:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                # Handle circular case\n                temp = np.concatenate([new_solution[i:], new_solution[:j]])\n                temp = temp[::-1]\n                new_solution[i:] = temp[:n-i]\n                new_solution[:j] = temp[n-i:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 122,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    probabilities = [(min_cost / cost) for cost in total_costs]\n    total_prob = sum(probabilities)\n    probabilities = [p / total_prob for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of segment reversal and insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, min(start + 8, n - 1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly choose a node to insert elsewhere\n    insert_pos = random.randint(0, n - 1)\n    node_to_move = new_solution[insert_pos]\n    new_solution = np.delete(new_solution, insert_pos)\n    insert_pos_new = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos_new, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8206628486591616,
            2.667780101299286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its total cost\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    probabilities = [(min_cost / cost) for cost in total_costs]\n    total_prob = sum(probabilities)\n    probabilities = [p / total_prob for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of segment reversal and insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose a segment to reverse\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, min(start + 8, n - 1))\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly choose a node to insert elsewhere\n    insert_pos = random.randint(0, n - 1)\n    node_to_move = new_solution[insert_pos]\n    new_solution = np.delete(new_solution, insert_pos)\n    insert_pos_new = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos_new, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 123,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher costs)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    if a < c < b < d:\n        # Reverse the middle segment and insert it between the other two\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d:]])\n    else:\n        # Perform a 3-opt move if segments overlap or are not in order\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8861405504589647,
            2.082089841365814
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with higher costs)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    if a < c < b < d:\n        # Reverse the middle segment and insert it between the other two\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[d:]])\n    else:\n        # Perform a 3-opt move if segments overlap or are not in order\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n\n    # Ensure the solution remains a valid tour\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 124,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best combined objective values (Pareto front approximation)\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Randomly select a solution from the Pareto front\n    selected_sol, _ = random.choice(pareto_front)\n    new_solution = selected_sol.copy()\n\n    # Apply hybrid local search: segment relocation with edge inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Ensure segments are distinct and valid\n    if a == c and b == d:\n        return new_solution\n\n    # Relocate segment [a:b] to position after c\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:]])\n\n    # Invert a random edge if the segment relocation didn't help\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.9113154598740626,
            2.440982162952423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with the best combined objective values (Pareto front approximation)\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Randomly select a solution from the Pareto front\n    selected_sol, _ = random.choice(pareto_front)\n    new_solution = selected_sol.copy()\n\n    # Apply hybrid local search: segment relocation with edge inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two distinct segments\n    a, b = sorted(random.sample(range(1, n), 2))\n    c, d = sorted(random.sample(range(1, n), 2))\n\n    # Ensure segments are distinct and valid\n    if a == c and b == d:\n        return new_solution\n\n    # Relocate segment [a:b] to position after c\n    segment = new_solution[a:b]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n    new_solution = np.concatenate([new_solution[:c+1], segment, new_solution[c+1:]])\n\n    # Invert a random edge if the segment relocation didn't help\n    if random.random() < 0.3:\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(set(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 125,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, _ in archive:\n        dominated = False\n        for _, (obj1, obj2) in archive:\n            if (obj1 < sol[0] and obj2 < sol[1]) and (obj1, obj2) != (sol[0], sol[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (reverse segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge insertion: move a random edge to a new position\n    if n > 3:\n        k = random.randint(0, n-1)\n        if k != i and k != j:\n            # Insert the edge (k, k+1) at position i\n            edge = new_solution[k:(k+2)]\n            new_solution = np.concatenate([new_solution[:i], edge, new_solution[i:k], new_solution[k+2:]])\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if the novel move causes duplicates\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8772776933164775,
            1.2146317958831787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, _ in archive:\n        dominated = False\n        for _, (obj1, obj2) in archive:\n            if (obj1 < sol[0] and obj2 < sol[1]) and (obj1, obj2) != (sol[0], sol[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge insertion\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (reverse segment between i and j)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge insertion: move a random edge to a new position\n    if n > 3:\n        k = random.randint(0, n-1)\n        if k != i and k != j:\n            # Insert the edge (k, k+1) at position i\n            edge = new_solution[k:(k+2)]\n            new_solution = np.concatenate([new_solution[:i], edge, new_solution[i:k], new_solution[k+2:]])\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if the novel move causes duplicates\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 126,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(1, len(archive_sorted) // 3 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # Edge swap operator (similar to 2-opt but with additional checks)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment reversal operator with variable segment size\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.582507021645026,
            2.25810968875885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their combined objective values (ascending)\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution from the top 30% of the archive\n        selected_idx = random.randint(0, max(1, len(archive_sorted) // 3 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # Edge swap operator (similar to 2-opt but with additional checks)\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment reversal operator with variable segment size\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        new_solution[start:start+segment_size] = new_solution[start:start+segment_size][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 127,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) > 2:\n        # Skip the best and worst solutions to focus on middle-ground solutions\n        selected_sol = random.choice(archive_solutions[1:-1])\n    else:\n        selected_sol = random.choice(archive_solutions)\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:\n        # Edge swap (like 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment relocation (novel strategy)\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n    return new_solution\n\n",
        "score": [
            -0.8790202270536904,
            2.187742590904236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    archive_solutions = [sol for sol, _ in archive]\n    if len(archive_solutions) > 2:\n        # Skip the best and worst solutions to focus on middle-ground solutions\n        selected_sol = random.choice(archive_solutions[1:-1])\n    else:\n        selected_sol = random.choice(archive_solutions)\n\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.5:\n        # Edge swap (like 2-opt but more flexible)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Segment relocation (novel strategy)\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n        insert_pos = random.randint(0, len(remaining) - 1)\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 128,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select solutions with the highest sum of objectives (indicating room for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    scores = objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    # Step 1: Randomly select three non-consecutive edges to break\n    a, b, c = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n    while b - a == 1 or c - b == 1:  # Ensure non-consecutive\n        a, b, c = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Step 2: Apply a custom move that considers both objectives\n    # We'll try to improve the solution by considering both distance matrices\n    # Create a candidate by reversing segments between a-b and b-c\n    candidate = new_solution.copy()\n    candidate[a:b] = candidate[a:b][::-1]\n    candidate[b:c] = candidate[b:c][::-1]\n\n    # Evaluate the candidate's quality using both distance matrices\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    current_cost = evaluate(new_solution)\n    candidate_cost = evaluate(candidate)\n\n    # Accept the candidate if it improves at least one objective\n    if (candidate_cost[0] < current_cost[0] or candidate_cost[1] < current_cost[1]):\n        new_solution = candidate\n    else:\n        # If no improvement, try a different move: swap two segments\n        # Select two random segments and swap them\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n        candidate_cost = evaluate(candidate)\n\n        if (candidate_cost[0] < current_cost[0] or candidate_cost[1] < current_cost[1]):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            -0.9227720441977341,
            2.287508964538574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Intelligent selection: choose a solution with high potential for improvement\n    # Here, we select solutions with the highest sum of objectives (indicating room for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    scores = objectives.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a custom move\n    # Step 1: Randomly select three non-consecutive edges to break\n    a, b, c = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n    while b - a == 1 or c - b == 1:  # Ensure non-consecutive\n        a, b, c = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Step 2: Apply a custom move that considers both objectives\n    # We'll try to improve the solution by considering both distance matrices\n    # Create a candidate by reversing segments between a-b and b-c\n    candidate = new_solution.copy()\n    candidate[a:b] = candidate[a:b][::-1]\n    candidate[b:c] = candidate[b:c][::-1]\n\n    # Evaluate the candidate's quality using both distance matrices\n    def evaluate(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    current_cost = evaluate(new_solution)\n    candidate_cost = evaluate(candidate)\n\n    # Accept the candidate if it improves at least one objective\n    if (candidate_cost[0] < current_cost[0] or candidate_cost[1] < current_cost[1]):\n        new_solution = candidate\n    else:\n        # If no improvement, try a different move: swap two segments\n        # Select two random segments and swap them\n        i, j = sorted(np.random.choice(range(1, n), 2, replace=False))\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n        candidate_cost = evaluate(candidate)\n\n        if (candidate_cost[0] < current_cost[0] or candidate_cost[1] < current_cost[1]):\n            new_solution = candidate\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment inversion (novel operator)\n    k = np.random.randint(1, n // 2)\n    segment = new_solution[i:i+k]\n    new_solution[i:i+k] = segment[::-1]\n\n    # Ensure the solution remains feasible (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -1.0390797091128543,
            1.5444191098213196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment inversion (novel operator)\n    k = np.random.randint(1, n // 2)\n    segment = new_solution[i:i+k]\n    new_solution[i:i+k] = segment[::-1]\n\n    # Ensure the solution remains feasible (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 129,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment inversion (novel operator)\n    k = np.random.randint(1, n // 2)\n    segment = new_solution[i:i+k]\n    new_solution[i:i+k] = segment[::-1]\n\n    # Ensure the solution remains feasible (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -1.0390797091128543,
            1.5444191098213196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel segment inversion\n    n = len(new_solution)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Apply 2-opt (swap edges)\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply segment inversion (novel operator)\n    k = np.random.randint(1, n // 2)\n    segment = new_solution[i:i+k]\n    new_solution[i:i+k] = segment[::-1]\n\n    # Ensure the solution remains feasible (no duplicates or skips)\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 130,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal or with high cost)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt with random segment selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n    new_solution[k:] = np.flip(new_solution[k:])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.9824991158864651,
            2.0364789962768555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal or with high cost)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (1 + obj[0] + obj[1]) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: 3-opt with random segment selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt: reverse segments between i-j, j-k, and k-i\n    new_solution[i:j] = np.flip(new_solution[i:j])\n    new_solution[j:k] = np.flip(new_solution[j:k])\n    new_solution[k:] = np.flip(new_solution[k:])\n\n    # Ensure the solution remains feasible (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 131,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, _ in archive:\n        # Calculate the total cost of the current solution\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n\n        # Score is inversely proportional to the cost (higher score for better solutions)\n        scores.append(1.0 / (cost1 + cost2 + 1e-6))\n\n    # Normalize scores to create a probability distribution\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n\n    # Select a solution with weighted random choice\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply novel local search operator: k-swap with k=3\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select 3 distinct random indices\n    i, j, k = random.sample(range(n), 3)\n    i, j, k = sorted([i, j, k])  # Ensure order for consistent swapping\n\n    # Perform the 3-swap operation\n    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7880982182754418,
            5.599681913852692
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential improvement scores for each solution\n    scores = []\n    for sol, _ in archive:\n        # Calculate the total cost of the current solution\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n\n        # Score is inversely proportional to the cost (higher score for better solutions)\n        scores.append(1.0 / (cost1 + cost2 + 1e-6))\n\n    # Normalize scores to create a probability distribution\n    total_score = sum(scores)\n    probabilities = [score / total_score for score in scores]\n\n    # Select a solution with weighted random choice\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply novel local search operator: k-swap with k=3\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select 3 distinct random indices\n    i, j, k = random.sample(range(n), 3)\n    i, j, k = sorted([i, j, k])  # Ensure order for consistent swapping\n\n    # Perform the 3-swap operation\n    new_solution[i], new_solution[j], new_solution[k] = new_solution[j], new_solution[k], new_solution[i]\n\n    # Ensure the solution remains valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 132,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower is better)\n    normalized_costs = np.array([(cost1 / np.max(distance_matrix_1), cost2 / np.max(distance_matrix_2)) for cost1, cost2 in objectives])\n    potential = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (potential + 1e-8)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    # Select a solution with weighted random choice\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Custom move: swap two non-adjacent segments\n    if n > 4:\n        d, e = sorted(random.sample(range(n), 2))\n        if d != e and abs(d - e) > 1:\n            new_solution[d:e] = np.flip(new_solution[d:e])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # Fallback to a valid permutation if invalid\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n",
        "score": [
            -0.8428583101220932,
            3.4343334436416626
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower is better)\n    normalized_costs = np.array([(cost1 / np.max(distance_matrix_1), cost2 / np.max(distance_matrix_2)) for cost1, cost2 in objectives])\n    potential = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (potential + 1e-8)  # Avoid division by zero\n    probabilities = probabilities / np.sum(probabilities)\n\n    # Select a solution with weighted random choice\n    selected_idx = np.random.choice(len(solutions), p=probabilities)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a custom move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[a:b] = np.flip(new_solution[a:b])\n    new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Custom move: swap two non-adjacent segments\n    if n > 4:\n        d, e = sorted(random.sample(range(n), 2))\n        if d != e and abs(d - e) > 1:\n            new_solution[d:e] = np.flip(new_solution[d:e])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # Fallback to a valid permutation if invalid\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 133,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives (can be replaced with dominance-based selection)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge exchange strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel edge exchange based on distance improvement\n    for _ in range(3):  # Limit the number of attempts to prevent excessive computation\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential distances\n        current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        potential_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if potential_dist < current_dist:\n            # Perform the exchange if it improves both objectives\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.5813432996580123,
            2.401929497718811
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of objectives (can be replaced with dominance-based selection)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge exchange strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Then, perform a novel edge exchange based on distance improvement\n    for _ in range(3):  # Limit the number of attempts to prevent excessive computation\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and potential distances\n        current_dist = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        potential_dist = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if potential_dist < current_dist:\n            # Perform the exchange if it improves both objectives\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 134,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine edge exchange and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Segment reversal (for diversification)\n    if np.random.rand() < 0.3:\n        start, end = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original with a small perturbation\n        new_solution = selected_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8427533701897487,
            4.674759268760681
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_solution = max(archive, key=lambda x: np.sum(x[1]))[0].copy()\n\n    # Hybrid local search strategy: combine edge exchange and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Edge exchange\n    a, b, c, d = np.random.choice(n, size=4, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n    new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    # Segment reversal (for diversification)\n    if np.random.rand() < 0.3:\n        start, end = sorted(np.random.choice(n, size=2, replace=False))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original with a small perturbation\n        new_solution = selected_solution.copy()\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 135,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        top_20_percent = max(1, int(len(archive_sorted) * 0.2))\n        selected_idx = random.randint(0, top_20_percent - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Apply segmented 3-opt local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Recombine segments in different orders\n    if random.random() < 0.5:\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n    else:\n        new_solution[a:c] = np.concatenate([np.flip(segment1), np.flip(segment2)])\n\n    # Verify and fix if the solution is invalid\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8370691013918861,
            1.7325651049613953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance (simplified approach)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        top_20_percent = max(1, int(len(archive_sorted) * 0.2))\n        selected_idx = random.randint(0, top_20_percent - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    # Step 2: Apply segmented 3-opt local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n\n    # Recombine segments in different orders\n    if random.random() < 0.5:\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n    else:\n        new_solution[a:c] = np.concatenate([np.flip(segment1), np.flip(segment2)])\n\n    # Verify and fix if the solution is invalid\n    if len(np.unique(new_solution)) != n:\n        # If duplicates exist, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 136,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_objective = archive[selected_idx][1]\n\n    # Hybrid local search: apply edge exchange followed by node insertion\n    new_solution = base_solution.copy()\n\n    # Edge exchange: swap two non-adjacent edges\n    n = len(new_solution)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Perform edge exchange\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Node insertion: move a node to a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 2)\n    if l >= k:\n        l += 1\n\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.9059942422354874,
            2.071161150932312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on Pareto dominance and objective values\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_objective = archive[selected_idx][1]\n\n    # Hybrid local search: apply edge exchange followed by node insertion\n    new_solution = base_solution.copy()\n\n    # Edge exchange: swap two non-adjacent edges\n    n = len(new_solution)\n    i = random.randint(0, n - 4)\n    j = random.randint(i + 2, n - 2)\n\n    # Perform edge exchange\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Node insertion: move a node to a different position\n    k = random.randint(0, n - 1)\n    l = random.randint(0, n - 2)\n    if l >= k:\n        l += 1\n\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 137,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not pareto-optimal or with high cost)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt segment reversal\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-swap: swap two non-adjacent edges if it reduces both objectives\n    if j - i > 1 and np.random.rand() < 0.5:\n        k = np.random.randint(i + 1, j)\n        # Ensure the swap maintains feasibility\n        if k < n - 1:\n            # Calculate cost before swap\n            cost1_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[k-1], new_solution[k]])\n            cost2_before = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n            # Perform swap\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n            # Calculate cost after swap\n            cost1_after = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n            cost2_after = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n            # Revert if no improvement in both objectives\n            if not (cost1_after < cost1_before and cost2_after < cost2_before):\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8686401266157202,
            1.9752708673477173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not pareto-optimal or with high cost)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # 2-opt segment reversal\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-swap: swap two non-adjacent edges if it reduces both objectives\n    if j - i > 1 and np.random.rand() < 0.5:\n        k = np.random.randint(i + 1, j)\n        # Ensure the swap maintains feasibility\n        if k < n - 1:\n            # Calculate cost before swap\n            cost1_before = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[k-1], new_solution[k]])\n            cost2_before = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                            distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n            # Perform swap\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n            # Calculate cost after swap\n            cost1_after = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_1[new_solution[k-1], new_solution[k]])\n            cost2_after = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                          distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                          distance_matrix_2[new_solution[k-1], new_solution[k]])\n\n            # Revert if no improvement in both objectives\n            if not (cost1_after < cost1_before and cost2_after < cost2_before):\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 138,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selection_probs = 1 - normalized_costs.mean(axis=1)  # Higher probability for solutions with worse mean normalized costs\n    selection_probs = selection_probs / selection_probs.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (swap edges)\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-swap mechanism: swap edges between non-adjacent segments\n    if n > 4:\n        k, l = sorted(random.sample(range(n), 2))\n        if abs(k - l) > 1 and abs(i - k) > 1 and abs(j - l) > 1:\n            # Ensure the swap maintains feasibility\n            if random.random() < 0.5:\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            else:\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Ensure the solution remains a valid tour\n    if not (len(new_solution) == len(set(new_solution)) == n):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7699754502806467,
            2.2102245092391968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    selection_probs = 1 - normalized_costs.mean(axis=1)  # Higher probability for solutions with worse mean normalized costs\n    selection_probs = selection_probs / selection_probs.sum()\n\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # 2-opt move (swap edges)\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-swap mechanism: swap edges between non-adjacent segments\n    if n > 4:\n        k, l = sorted(random.sample(range(n), 2))\n        if abs(k - l) > 1 and abs(i - k) > 1 and abs(j - l) > 1:\n            # Ensure the swap maintains feasibility\n            if random.random() < 0.5:\n                new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n            else:\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    # Ensure the solution remains a valid tour\n    if not (len(new_solution) == len(set(new_solution)) == n):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 139,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% by objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_candidates = archive_sorted[:max(1, len(archive) // 5)]\n    selected_solution, _ = random.choice(top_candidates)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select three random indices ensuring they are distinct\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge swap: swap edges (i,j) and (j,k) with (i,k) and (j,j)\n    # This is a more aggressive move than standard 2-opt\n    if random.random() < 0.5:\n        temp = new_solution[i]\n        new_solution[i] = new_solution[k]\n        new_solution[k] = temp\n\n    # Verify the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the move is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8278674711153249,
            1.5451403856277466
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% by objective values)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_candidates = archive_sorted[:max(1, len(archive) // 5)]\n    selected_solution, _ = random.choice(top_candidates)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Select three random indices ensuring they are distinct\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Custom edge swap: swap edges (i,j) and (j,k) with (i,k) and (j,j)\n    # This is a more aggressive move than standard 2-opt\n    if random.random() < 0.5:\n        temp = new_solution[i]\n        new_solution[i] = new_solution[k]\n        new_solution[k] = temp\n\n    # Verify the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to a simple 2-opt if the move is invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 140,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    normalized_costs = [(max_cost - cost + 1) / (max_cost - min_cost + 1) for cost in costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=normalized_costs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with edge swap and biased random selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse the middle segment and swap edges\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Optionally swap two edges with a probability to explore more neighbors\n    if random.random() < 0.3:\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d], new_solution[e] = new_solution[e], new_solution[d]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7030625434230243,
            2.3651461601257324
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    normalized_costs = [(max_cost - cost + 1) / (max_cost - min_cost + 1) for cost in costs]  # Avoid division by zero\n    selected_idx = random.choices(range(len(archive)), weights=normalized_costs, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with edge swap and biased random selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select three random edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse the middle segment and swap edges\n    new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Optionally swap two edges with a probability to explore more neighbors\n    if random.random() < 0.3:\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d], new_solution[e] = new_solution[e], new_solution[d]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 141,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge swap (like 2-opt but more disruptive)\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Path relinking-inspired operator (mix with another solution)\n    if len(archive) > 1:\n        other_solution = random.choice(archive[1:])[0]\n        # Identify common segments and extend them\n        for i in range(n):\n            if new_solution[i] in other_solution:\n                pos_in_other = np.where(other_solution == new_solution[i])[0][0]\n                # Try to align segments\n                for k in range(1, min(n-i, len(other_solution)-pos_in_other)):\n                    if new_solution[i+k] == other_solution[pos_in_other+k]:\n                        # Found matching segment, extend it\n                        segment = other_solution[pos_in_other:pos_in_other+k+1]\n                        new_solution[i:i+k+1] = segment\n                        break\n\n    # Step 3: Random segment inversion (diversification)\n    if n > 3:\n        seg_start = random.randint(0, n-4)\n        seg_end = random.randint(seg_start+2, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original with a small perturbation\n        new_solution = selected_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.785118855800455,
            3.7080923318862915
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge swap (like 2-opt but more disruptive)\n    if n > 2:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Path relinking-inspired operator (mix with another solution)\n    if len(archive) > 1:\n        other_solution = random.choice(archive[1:])[0]\n        # Identify common segments and extend them\n        for i in range(n):\n            if new_solution[i] in other_solution:\n                pos_in_other = np.where(other_solution == new_solution[i])[0][0]\n                # Try to align segments\n                for k in range(1, min(n-i, len(other_solution)-pos_in_other)):\n                    if new_solution[i+k] == other_solution[pos_in_other+k]:\n                        # Found matching segment, extend it\n                        segment = other_solution[pos_in_other:pos_in_other+k+1]\n                        new_solution[i:i+k+1] = segment\n                        break\n\n    # Step 3: Random segment inversion (diversification)\n    if n > 3:\n        seg_start = random.randint(0, n-4)\n        seg_end = random.randint(seg_start+2, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Ensure validity (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original with a small perturbation\n        new_solution = selected_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 142,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified for this heuristic)\n    dominance_ranks = []\n    for sol, _ in archive:\n        # Calculate total cost in both spaces\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        dominance_ranks.append(cost1 + cost2)\n\n    # Normalize ranks to get selection probabilities\n    total_rank = sum(dominance_ranks)\n    probabilities = [1.0 - (rank / total_rank) for rank in dominance_ranks]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    # Select a solution\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Edge insertion (insert a random node in a random position)\n        node_to_insert = new_solution[random.randint(0, n-1)]\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0] if len(np.where(new_solution == node_to_insert)[0]) > 1 else -1)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If duplicates exist, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8440910532027733,
            6.482374370098114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate dominance ranks (simplified for this heuristic)\n    dominance_ranks = []\n    for sol, _ in archive:\n        # Calculate total cost in both spaces\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        dominance_ranks.append(cost1 + cost2)\n\n    # Normalize ranks to get selection probabilities\n    total_rank = sum(dominance_ranks)\n    probabilities = [1.0 - (rank / total_rank) for rank in dominance_ranks]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    # Select a solution\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Edge insertion (insert a random node in a random position)\n        node_to_insert = new_solution[random.randint(0, n-1)]\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node_to_insert)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_insert)[0][0] if len(np.where(new_solution == node_to_insert)[0]) > 1 else -1)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != len(base_solution):\n        # If duplicates exist, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 143,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest cost solutions)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Perform a 3-opt move\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[j:k] = base_solution[j:k][::-1]\n\n    # Apply a custom edge swap to further improve the solution\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = np.random.choice(range(1, n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7506321009935102,
            3.287953197956085
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with the highest potential for improvement (lowest cost solutions)\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Perform a 3-opt move\n    i, j, k = sorted(np.random.choice(range(1, n), 3, replace=False))\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[j:k] = base_solution[j:k][::-1]\n\n    # Apply a custom edge swap to further improve the solution\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = np.random.choice(range(1, n), 2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 144,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high crowding distance)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: 3-opt followed by edge-swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 3-opt\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Perform edge-swap\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if edge-swap causes duplicates\n        k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8910857685502879,
            1.9823939800262451
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high crowding distance)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: 3-opt followed by edge-swap\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 3-opt\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Perform edge-swap\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if edge-swap causes duplicates\n        k, l = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[k:l] = new_solution[k:l][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 145,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objective values)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Edge swap operation\n        if np.random.rand() < 0.7:  # Higher probability for edge swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal operation (novel operator)\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n        # Check feasibility (all nodes are visited exactly once)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.9048715064190648,
            2.7081257700920105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objective values)\n    objectives = np.array([obj for _, obj in archive])\n    objective_variance = np.var(objectives, axis=0)\n    weighted_scores = np.sum(objectives * objective_variance, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct positions\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Edge swap operation\n        if np.random.rand() < 0.7:  # Higher probability for edge swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        else:\n            # Segment reversal operation (novel operator)\n            segment = new_solution[i:j+1]\n            new_solution[i:j+1] = segment[::-1]\n\n        # Check feasibility (all nodes are visited exactly once)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 146,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        # Randomly select from top 20% of solutions\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt combined with edge-swap\n    n = len(new_solution)\n    if n >= 4:\n        # 3-opt move: randomly select 3 edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reconnect the edges to form a new tour\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment between i and j\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment between j and k\n\n    # Edge-swap heuristic: swap a pair of edges if it improves both objectives\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        # Ensure edges are not adjacent and form a valid swap\n        if abs(a - b) > 1 and abs(c - d) > 1:\n            # Calculate current and new distances for both objectives\n            current_dist1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_dist1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n            current_dist2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_dist2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            # Perform swap if it improves both objectives\n            if (new_dist1 < current_dist1) and (new_dist2 < current_dist2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9095518318877647,
            2.4209450483322144
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of their objectives (higher sum indicates potential for improvement)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1], reverse=True)\n        # Randomly select from top 20% of solutions\n        selection_pool = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        base_solution, _ = random.choice(selection_pool)\n    else:\n        base_solution = archive[0][0]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt combined with edge-swap\n    n = len(new_solution)\n    if n >= 4:\n        # 3-opt move: randomly select 3 edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Reconnect the edges to form a new tour\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment between i and j\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment between j and k\n\n    # Edge-swap heuristic: swap a pair of edges if it improves both objectives\n    if n >= 4:\n        a, b = sorted(random.sample(range(n), 2))\n        c, d = sorted(random.sample(range(n), 2))\n        # Ensure edges are not adjacent and form a valid swap\n        if abs(a - b) > 1 and abs(c - d) > 1:\n            # Calculate current and new distances for both objectives\n            current_dist1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_1[new_solution[b-1], new_solution[b]])\n            new_dist1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[a]])\n\n            current_dist2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                            distance_matrix_2[new_solution[b-1], new_solution[b]])\n            new_dist2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n            # Perform swap if it improves both objectives\n            if (new_dist1 < current_dist1) and (new_dist2 < current_dist2):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 147,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its Pareto dominance\n    # Solutions with better objective values have higher selection probability\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    # Normalize objectives to [0, 1] range\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    weights = 1 / (scores + 1e-10)  # Inverse to prefer worse solutions (more room for improvement)\n    weights = weights / np.sum(weights)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (randomly insert a node elsewhere)\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 2: Node relocation (move a random node to a better position)\n    if n > 2:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n        # Find best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            candidate = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Step 3: Novel segment inversion operator (invert a random segment)\n    if n > 4:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n\n        if end - start >= 2:\n            segment = new_solution[start:end+1]\n            inverted_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8133180025391985,
            13.96854168176651
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its Pareto dominance\n    # Solutions with better objective values have higher selection probability\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n\n    # Normalize objectives to [0, 1] range\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    weights = 1 / (scores + 1e-10)  # Inverse to prefer worse solutions (more room for improvement)\n    weights = weights / np.sum(weights)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search strategy\n    n = len(new_solution)\n\n    # Step 1: Edge insertion (randomly insert a node elsewhere)\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = random.randint(0, n-1)\n\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 2: Node relocation (move a random node to a better position)\n    if n > 2:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n        # Find best insertion position based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            candidate = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Step 3: Novel segment inversion operator (invert a random segment)\n    if n > 4:\n        start = random.randint(0, n-3)\n        end = random.randint(start+1, n-1)\n\n        if end - start >= 2:\n            segment = new_solution[start:end+1]\n            inverted_segment = segment[::-1]\n            new_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 148,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # Here, we approximate dominance rank by the sum of normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    ranks = normalized.sum(axis=1)\n    probs = 1 / (ranks + 1e-10)\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: random segment reversal + edge insertion\n    if n > 3:\n        # Random segment reversal (like 2-opt but for a random segment)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Edge insertion to further perturb the solution\n        if n > 4:\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            if k != l:\n                # Remove node at position k and insert it after position l\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = (l + 1) % (n-1)\n                new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.9330029687513403,
            2.6593690514564514
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # Here, we approximate dominance rank by the sum of normalized objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    ranks = normalized.sum(axis=1)\n    probs = 1 / (ranks + 1e-10)\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: random segment reversal + edge insertion\n    if n > 3:\n        # Random segment reversal (like 2-opt but for a random segment)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # Edge insertion to further perturb the solution\n        if n > 4:\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            if k != l:\n                # Remove node at position k and insert it after position l\n                node = new_solution[k]\n                new_solution = np.concatenate([new_solution[:k], new_solution[k+1:]])\n                insert_pos = (l + 1) % (n-1)\n                new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 149,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank in the archive\n    # This favors solutions that are less explored or have higher potential\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: modified 3-opt with randomized edge insertion\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Apply a modified 3-opt move\n        if np.random.rand() < 0.5:\n            # Case 1: Reverse the segment between j and k\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            # Case 2: Rotate the segment between j and k\n            segment = new_solution[j:k+1]\n            shift = np.random.randint(1, len(segment))\n            new_solution[j:k+1] = np.roll(segment, shift)\n\n        # Randomly insert a node in a different position to increase diversity\n        if np.random.rand() < 0.3:\n            node_to_move = new_solution[np.random.randint(n)]\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n            insert_pos = np.random.randint(n-1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains feasible (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
        "score": [
            -0.9479147697005809,
            3.0697317123413086
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank in the archive\n    # This favors solutions that are less explored or have higher potential\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: modified 3-opt with randomized edge insertion\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n        # Apply a modified 3-opt move\n        if np.random.rand() < 0.5:\n            # Case 1: Reverse the segment between j and k\n            new_solution[j:k+1] = new_solution[j:k+1][::-1]\n        else:\n            # Case 2: Rotate the segment between j and k\n            segment = new_solution[j:k+1]\n            shift = np.random.randint(1, len(segment))\n            new_solution[j:k+1] = np.roll(segment, shift)\n\n        # Randomly insert a node in a different position to increase diversity\n        if np.random.rand() < 0.3:\n            node_to_move = new_solution[np.random.randint(n)]\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move))\n            insert_pos = np.random.randint(n-1)\n            new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains feasible (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not feasible\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 150,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weighted_scores = [sum(obj) for _, obj in archive]\n    best_idx = np.argmin(weighted_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: segment relocation with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of nodes to relocate\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n // 2))\n    seg_end = (seg_start + seg_length) % n\n\n    if seg_end < seg_start:\n        # Handle circular segment\n        segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n    else:\n        segment = new_solution[seg_start:seg_end]\n\n    # Remove the segment from the solution\n    if seg_end < seg_start:\n        new_solution = np.concatenate([new_solution[seg_end:seg_start], new_solution[seg_end+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n    # Find the best insertion point for the segment\n    best_insert_pos = 0\n    min_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        # Try inserting the segment at position i\n        candidate = np.insert(new_solution, i, segment)\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    # Additional edge insertion for further improvement\n    for _ in range(2):  # Limit the number of edge insertions\n        i, j = np.random.randint(0, n, size=2)\n        if i == j:\n            continue\n        new_solution = np.roll(new_solution, -i)\n        new_solution[1] = new_solution[j]\n        new_solution = np.roll(new_solution, i)\n\n    return new_solution\n\n",
        "score": [
            -0.8714155364454017,
            12.875142335891724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (weighted sum)\n    weighted_scores = [sum(obj) for _, obj in archive]\n    best_idx = np.argmin(weighted_scores)\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: segment relocation with edge insertion\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of nodes to relocate\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n // 2))\n    seg_end = (seg_start + seg_length) % n\n\n    if seg_end < seg_start:\n        # Handle circular segment\n        segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n    else:\n        segment = new_solution[seg_start:seg_end]\n\n    # Remove the segment from the solution\n    if seg_end < seg_start:\n        new_solution = np.concatenate([new_solution[seg_end:seg_start], new_solution[seg_end+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end:]])\n\n    # Find the best insertion point for the segment\n    best_insert_pos = 0\n    min_cost = float('inf')\n\n    for i in range(len(new_solution)):\n        # Try inserting the segment at position i\n        candidate = np.insert(new_solution, i, segment)\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = i\n\n    # Insert the segment at the best position\n    new_solution = np.insert(new_solution, best_insert_pos, segment)\n\n    # Additional edge insertion for further improvement\n    for _ in range(2):  # Limit the number of edge insertions\n        i, j = np.random.randint(0, n, size=2)\n        if i == j:\n            continue\n        new_solution = np.roll(new_solution, -i)\n        new_solution[1] = new_solution[j]\n        new_solution = np.roll(new_solution, i)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 151,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values (encourages exploration)\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic edge insertion + node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Probabilistic edge insertion (inspired by Lin-Kernighan)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = base_solution[i:j+1]\n    remaining = np.concatenate([base_solution[:i], base_solution[j+1:]])\n    np.random.shuffle(segment)\n    new_solution = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n    # Step 2: Node relocation (inspired by variable neighborhood search)\n    if np.random.rand() > 0.5:  # 50% chance to apply relocation\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l:\n            new_solution = np.insert(np.delete(new_solution, k), l, new_solution[k])\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback to a simple swap if feasibility is violated\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.792627075318176,
            2.157852590084076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability inversely proportional to its objective values (encourages exploration)\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic edge insertion + node relocation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Probabilistic edge insertion (inspired by Lin-Kernighan)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = base_solution[i:j+1]\n    remaining = np.concatenate([base_solution[:i], base_solution[j+1:]])\n    np.random.shuffle(segment)\n    new_solution = np.concatenate([remaining[:i], segment, remaining[i:]])\n\n    # Step 2: Node relocation (inspired by variable neighborhood search)\n    if np.random.rand() > 0.5:  # 50% chance to apply relocation\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        if k != l:\n            new_solution = np.insert(np.delete(new_solution, k), l, new_solution[k])\n\n    # Ensure feasibility (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback to a simple swap if feasibility is violated\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 152,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Example selection criterion\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 3)\n    end = np.random.randint(start + 2, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    node_idx = np.random.randint(1, n - 1)  # Avoid start/end to maintain feasibility\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.randint(1, n - 1)  # Insert between nodes to avoid start/end\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8871665142712801,
            2.6287810802459717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Example selection criterion\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine segment reversal and node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Randomly select a segment to reverse\n    start = np.random.randint(0, n - 3)\n    end = np.random.randint(start + 2, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert elsewhere\n    node_idx = np.random.randint(1, n - 1)  # Avoid start/end to maintain feasibility\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    insert_pos = np.random.randint(1, n - 1)  # Insert between nodes to avoid start/end\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 153,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objectives (e.g., lexicographical order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine segment inversion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert (similar to 2-opt but more flexible)\n    if n >= 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly relocate a node to a new position (ensures feasibility)\n    if n >= 2:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains a valid TSP tour (no duplicates, all nodes included)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8186891355659541,
            2.1199544072151184
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combination of objectives (e.g., lexicographical order)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0], x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine segment inversion and node relocation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert (similar to 2-opt but more flexible)\n    if n >= 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Randomly relocate a node to a new position (ensures feasibility)\n    if n >= 2:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains a valid TSP tour (no duplicates, all nodes included)\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 154,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank (better solutions more likely)\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange followed by a rotation-based operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge exchange (similar to 2-opt but with a twist)\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            # Standard edge exchange\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Novel rotation-based operator: rotate a segment\n            k = random.randint(1, j-i)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.roll(segment, k)\n            new_solution[i:j+1] = rotated_segment\n\n        # Additional local improvement: check if swapping two random edges improves both objectives\n        for _ in range(2):\n            a, b = sorted(random.sample(range(n), 2))\n            c, d = sorted(random.sample(range(n), 2))\n\n            # Calculate current and new costs\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n\n            # Create a temporary solution with the swap\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n            temp_solution[c], temp_solution[d] = temp_solution[d], temp_solution[c]\n\n            new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7786572974357624,
            2.77138614654541
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its rank (better solutions more likely)\n    ranks = [i for i in range(len(archive))]\n    selected_idx = random.choices(ranks, weights=[1/(i+1) for i in ranks], k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange followed by a rotation-based operator\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge exchange (similar to 2-opt but with a twist)\n        i, j = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            # Standard edge exchange\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            # Novel rotation-based operator: rotate a segment\n            k = random.randint(1, j-i)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.roll(segment, k)\n            new_solution[i:j+1] = rotated_segment\n\n        # Additional local improvement: check if swapping two random edges improves both objectives\n        for _ in range(2):\n            a, b = sorted(random.sample(range(n), 2))\n            c, d = sorted(random.sample(range(n), 2))\n\n            # Calculate current and new costs\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n                cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n                return cost1, cost2\n\n            current_cost1, current_cost2 = calculate_cost(new_solution)\n\n            # Create a temporary solution with the swap\n            temp_solution = new_solution.copy()\n            temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n            temp_solution[c], temp_solution[d] = temp_solution[d], temp_solution[c]\n\n            new_cost1, new_cost2 = calculate_cost(temp_solution)\n\n            # Accept if both objectives improve or one improves significantly\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (new_cost1 < current_cost1 * 0.95 and new_cost2 < current_cost2 * 0.95):\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 155,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    if n < 4:\n        # Fallback to 2-opt if solution is too small\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: select three random edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Novel edge-swap: swap edges between non-adjacent nodes to diversify\n        if random.random() < 0.5:\n            a, b = sorted(random.sample(range(n), 2))\n            if abs(a - b) > 1:  # Ensure non-adjacent nodes\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7695406290384799,
            1.2198793292045593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(base_solution)\n    if n < 4:\n        # Fallback to 2-opt if solution is too small\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # 3-opt: select three random edges and reconnect them\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n        # Novel edge-swap: swap edges between non-adjacent nodes to diversify\n        if random.random() < 0.5:\n            a, b = sorted(random.sample(range(n), 2))\n            if abs(a - b) > 1:  # Ensure non-adjacent nodes\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 156,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # We use a biased selection: solutions with lower total cost (sum of both objectives) are more likely to be selected\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    if min_cost == max_cost:\n        # If all costs are equal, select uniformly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to [0, 1] and use inverse to bias selection towards lower costs\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs]\n        selected_idx = random.choices(range(len(archive)), weights=normalized_costs, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a novel local search operator\n    # Hybrid operator: combines edge exchange and node insertion based on objective dominance\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly select two segments of the tour\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Determine which objective to prioritize for the exchange\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if obj1_cost < obj2_cost:\n        # Prioritize improving the first objective\n        # Exchange segments a-b and c-d if it improves the first objective\n        new_segment = np.concatenate((new_solution[a:b+1], new_solution[c:d+1]))\n        np.random.shuffle(new_segment)\n        new_solution[a:b+1] = new_segment[:b-a+1]\n        new_solution[c:d+1] = new_segment[b-a+1:]\n    else:\n        # Prioritize improving the second objective\n        # Reverse segments a-b and c-d if it improves the second objective\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for node in duplicates:\n        # Find all occurrences of the duplicate node\n        indices = np.where(new_solution == node)[0]\n        # Replace duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing_nodes) > 0:\n            for idx in indices[1:]:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n",
        "score": [
            -0.6531385676694721,
            2.167702317237854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # We use a biased selection: solutions with lower total cost (sum of both objectives) are more likely to be selected\n    total_costs = [sum(obj) for _, obj in archive]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n    if min_cost == max_cost:\n        # If all costs are equal, select uniformly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to [0, 1] and use inverse to bias selection towards lower costs\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs]\n        selected_idx = random.choices(range(len(archive)), weights=normalized_costs, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a novel local search operator\n    # Hybrid operator: combines edge exchange and node insertion based on objective dominance\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly select two segments of the tour\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Determine which objective to prioritize for the exchange\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if obj1_cost < obj2_cost:\n        # Prioritize improving the first objective\n        # Exchange segments a-b and c-d if it improves the first objective\n        new_segment = np.concatenate((new_solution[a:b+1], new_solution[c:d+1]))\n        np.random.shuffle(new_segment)\n        new_solution[a:b+1] = new_segment[:b-a+1]\n        new_solution[c:d+1] = new_segment[b-a+1:]\n    else:\n        # Prioritize improving the second objective\n        # Reverse segments a-b and c-d if it improves the second objective\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    # Check for duplicates and fix if necessary\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n    for node in duplicates:\n        # Find all occurrences of the duplicate node\n        indices = np.where(new_solution == node)[0]\n        # Replace duplicates with missing nodes\n        missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing_nodes) > 0:\n            for idx in indices[1:]:\n                new_solution[idx] = missing_nodes[0]\n                missing_nodes = missing_nodes[1:]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 157,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment inversion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and invert one of them\n    a, b = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select two edges and swap them if beneficial\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j and i != (j - 1) % n and i != (j + 1) % n:\n        # Try both possible swaps\n        swap1 = new_solution.copy()\n        swap1[i], swap1[j] = swap1[j], swap1[i]\n\n        swap2 = new_solution.copy()\n        swap2[i], swap2[(j + 1) % n] = swap2[(j + 1) % n], swap2[i]\n\n        # Evaluate both swaps in both objective spaces\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[k], sol[(k + 1) % n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k], sol[(k + 1) % n]] for k in range(n))\n            return (cost1, cost2)\n\n        current_cost = evaluate(new_solution)\n        swap1_cost = evaluate(swap1)\n        swap2_cost = evaluate(swap2)\n\n        # Choose the best improvement\n        if (swap1_cost[0] < current_cost[0] and swap1_cost[1] <= current_cost[1]) or \\\n           (swap1_cost[1] < current_cost[1] and swap1_cost[0] <= current_cost[0]):\n            new_solution = swap1\n        elif (swap2_cost[0] < current_cost[0] and swap2_cost[1] <= current_cost[1]) or \\\n             (swap2_cost[1] < current_cost[1] and swap2_cost[0] <= current_cost[0]):\n            new_solution = swap2\n\n    return new_solution\n\n",
        "score": [
            -0.7097153246533427,
            3.2551732063293457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on dominance and diversity\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine segment inversion and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments and invert one of them\n    a, b = sorted(random.sample(range(n), 2))\n    if random.random() < 0.5:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Randomly select two edges and swap them if beneficial\n    i, j = sorted(random.sample(range(n), 2))\n    if i != j and i != (j - 1) % n and i != (j + 1) % n:\n        # Try both possible swaps\n        swap1 = new_solution.copy()\n        swap1[i], swap1[j] = swap1[j], swap1[i]\n\n        swap2 = new_solution.copy()\n        swap2[i], swap2[(j + 1) % n] = swap2[(j + 1) % n], swap2[i]\n\n        # Evaluate both swaps in both objective spaces\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[k], sol[(k + 1) % n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k], sol[(k + 1) % n]] for k in range(n))\n            return (cost1, cost2)\n\n        current_cost = evaluate(new_solution)\n        swap1_cost = evaluate(swap1)\n        swap2_cost = evaluate(swap2)\n\n        # Choose the best improvement\n        if (swap1_cost[0] < current_cost[0] and swap1_cost[1] <= current_cost[1]) or \\\n           (swap1_cost[1] < current_cost[1] and swap1_cost[0] <= current_cost[0]):\n            new_solution = swap1\n        elif (swap2_cost[0] < current_cost[0] and swap2_cost[1] <= current_cost[1]) or \\\n             (swap2_cost[1] < current_cost[1] and swap2_cost[0] <= current_cost[0]):\n            new_solution = swap2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 158,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    fitness = np.sum(normalized_costs, axis=1)\n    probabilities = fitness / np.sum(fitness)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but with a twist)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n        # Randomly swap two edges within the segment\n        if j - i > 2:\n            k = random.randint(i, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n    else:\n        # Segment relocation with objective-aware selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        # Insert segment at position k\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the solution becomes invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7785831153683236,
            2.427391231060028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    fitness = np.sum(normalized_costs, axis=1)\n    probabilities = fitness / np.sum(fitness)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange and segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two local search operators\n    if random.random() < 0.5:\n        # Edge exchange (similar to 2-opt but with a twist)\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n        # Randomly swap two edges within the segment\n        if j - i > 2:\n            k = random.randint(i, j-1)\n            new_solution[k], new_solution[k+1] = new_solution[k+1], new_solution[k]\n    else:\n        # Segment relocation with objective-aware selection\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment = new_solution[i:j+1]\n        # Insert segment at position k\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the solution becomes invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 159,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with lower costs but not already fully optimized\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to exchange\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge exchange: swap edges (i,i+1) and (j,j+1)\n    if j - i > 1:\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Segment reversal: reverse a random segment\n    k, l = np.random.choice(n, size=2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.807281722341496,
            2.2999768257141113
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: prioritize those with lower costs but not already fully optimized\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct edges to exchange\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Edge exchange: swap edges (i,i+1) and (j,j+1)\n    if j - i > 1:\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Segment reversal: reverse a random segment\n    k, l = np.random.choice(n, size=2, replace=False)\n    if k > l:\n        k, l = l, k\n    new_solution[k:l+1] = np.flip(new_solution[k:l+1])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 160,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select promising solutions (top 30% non-dominated)\n    objectives = np.array([obj for _, obj in archive])\n    dominated_counts = np.sum((objectives[:, None, :] <= objectives).all(axis=2), axis=1)\n    non_dominated_indices = np.where(dominated_counts == 1)[0]  # Non-dominated solutions\n\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    top_n = max(1, int(0.3 * len(non_dominated_indices)))\n    selected_indices = np.random.choice(non_dominated_indices, size=min(top_n, len(non_dominated_indices)), replace=False)\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    # Randomly select a base solution\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate potential edge changes\n    def calculate_delta(a, b, c, d):\n        # Calculate change in both objectives\n        delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d] -\n                  distance_matrix_1[a, c] - distance_matrix_1[b, d])\n        delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d] -\n                  distance_matrix_2[a, c] - distance_matrix_2[b, d])\n        return (delta1, delta2)\n\n    # Evaluate all possible 3-opt moves\n    candidates = [\n        (i, j, k), (i, k, j),\n        (new_solution[i], new_solution[j], new_solution[k]),\n        (new_solution[i], new_solution[k], new_solution[j])\n    ]\n\n    # Select the move that improves at least one objective\n    best_move = None\n    best_improvement = (0, 0)\n\n    for a, b, c in candidates:\n        delta1, delta2 = calculate_delta(a, b, c, new_solution[(i+1)%n])\n        if delta1 < 0 or delta2 < 0:\n            if abs(delta1) + abs(delta2) > abs(best_improvement[0]) + abs(best_improvement[1]):\n                best_move = (a, b, c)\n                best_improvement = (delta1, delta2)\n\n    if best_move:\n        # Apply the 3-opt move\n        a, b, c = best_move\n        new_solution[i] = a\n        new_solution[j] = b\n        new_solution[k] = c\n    else:\n        # If no improvement, apply perturbation\n        # Reverse a random segment\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9642677750392161,
            3.2688355445861816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select promising solutions (top 30% non-dominated)\n    objectives = np.array([obj for _, obj in archive])\n    dominated_counts = np.sum((objectives[:, None, :] <= objectives).all(axis=2), axis=1)\n    non_dominated_indices = np.where(dominated_counts == 1)[0]  # Non-dominated solutions\n\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n\n    top_n = max(1, int(0.3 * len(non_dominated_indices)))\n    selected_indices = np.random.choice(non_dominated_indices, size=min(top_n, len(non_dominated_indices)), replace=False)\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    # Randomly select a base solution\n    base_solution = random.choice(selected_solutions).copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Calculate potential edge changes\n    def calculate_delta(a, b, c, d):\n        # Calculate change in both objectives\n        delta1 = (distance_matrix_1[a, b] + distance_matrix_1[c, d] -\n                  distance_matrix_1[a, c] - distance_matrix_1[b, d])\n        delta2 = (distance_matrix_2[a, b] + distance_matrix_2[c, d] -\n                  distance_matrix_2[a, c] - distance_matrix_2[b, d])\n        return (delta1, delta2)\n\n    # Evaluate all possible 3-opt moves\n    candidates = [\n        (i, j, k), (i, k, j),\n        (new_solution[i], new_solution[j], new_solution[k]),\n        (new_solution[i], new_solution[k], new_solution[j])\n    ]\n\n    # Select the move that improves at least one objective\n    best_move = None\n    best_improvement = (0, 0)\n\n    for a, b, c in candidates:\n        delta1, delta2 = calculate_delta(a, b, c, new_solution[(i+1)%n])\n        if delta1 < 0 or delta2 < 0:\n            if abs(delta1) + abs(delta2) > abs(best_improvement[0]) + abs(best_improvement[1]):\n                best_move = (a, b, c)\n                best_improvement = (delta1, delta2)\n\n    if best_move:\n        # Apply the 3-opt move\n        a, b, c = best_move\n        new_solution[i] = a\n        new_solution[j] = b\n        new_solution[k] = c\n    else:\n        # If no improvement, apply perturbation\n        # Reverse a random segment\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 161,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    n = len(selected_solution)\n\n    # Hybrid local search: first apply 2-opt, then apply a novel edge-swap\n    new_solution = selected_solution.copy()\n\n    # 2-opt step: select two random non-adjacent edges and reverse the segment between them\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        pass  # Avoid reversing the entire tour (which is equivalent to reversing the entire solution)\n    else:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-swap step: swap two random edges that are not adjacent\n    a, b = sorted(random.sample(range(n), 2))\n    if a == b or (a + 1) % n == b or (b + 1) % n == a:\n        pass  # Skip if edges are adjacent or the same\n    else:\n        # Swap edges (a, a+1) and (b, b+1)\n        new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to 2-opt only\n        new_solution = selected_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            pass\n        else:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6734802579938088,
            1.8077145218849182
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    n = len(selected_solution)\n\n    # Hybrid local search: first apply 2-opt, then apply a novel edge-swap\n    new_solution = selected_solution.copy()\n\n    # 2-opt step: select two random non-adjacent edges and reverse the segment between them\n    i, j = sorted(random.sample(range(n), 2))\n    if i == 0 and j == n-1:\n        pass  # Avoid reversing the entire tour (which is equivalent to reversing the entire solution)\n    else:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Novel edge-swap step: swap two random edges that are not adjacent\n    a, b = sorted(random.sample(range(n), 2))\n    if a == b or (a + 1) % n == b or (b + 1) % n == a:\n        pass  # Skip if edges are adjacent or the same\n    else:\n        # Swap edges (a, a+1) and (b, b+1)\n        new_solution[a+1], new_solution[b] = new_solution[b], new_solution[a+1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to 2-opt only\n        new_solution = selected_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        if i == 0 and j == n-1:\n            pass\n        else:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 162,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: one with the best trade-off between the two objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to avoid bias towards larger scales\n    obj1 = np.array([obj[0] for obj in objectives])\n    obj2 = np.array([obj[1] for obj in objectives])\n\n    min_obj1, max_obj1 = np.min(obj1), np.max(obj1)\n    min_obj2, max_obj2 = np.min(obj2), np.max(obj2)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        # If all objectives are the same, pick a random solution\n        base_solution = np.random.choice(solutions)\n    else:\n        # Normalize and compute trade-off scores\n        normalized_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n        normalized_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n        trade_off_scores = normalized_obj1 + normalized_obj2\n\n        # Select the solution with the best trade-off (lowest score)\n        best_idx = np.argmin(trade_off_scores)\n        base_solution = solutions[best_idx]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel \"swap-and-reverse\" operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose three distinct indices to perform 3-opt\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply swap-and-reverse: swap two nodes and reverse a segment\n    if n > 4:\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Randomly select a segment to reverse\n        l, m = np.random.choice(n, size=2, replace=False)\n        l, m = sorted([l, m])\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7706638599385784,
            2.693748652935028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution: one with the best trade-off between the two objectives\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to avoid bias towards larger scales\n    obj1 = np.array([obj[0] for obj in objectives])\n    obj2 = np.array([obj[1] for obj in objectives])\n\n    min_obj1, max_obj1 = np.min(obj1), np.max(obj1)\n    min_obj2, max_obj2 = np.min(obj2), np.max(obj2)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        # If all objectives are the same, pick a random solution\n        base_solution = np.random.choice(solutions)\n    else:\n        # Normalize and compute trade-off scores\n        normalized_obj1 = (obj1 - min_obj1) / (max_obj1 - min_obj1)\n        normalized_obj2 = (obj2 - min_obj2) / (max_obj2 - min_obj2)\n        trade_off_scores = normalized_obj1 + normalized_obj2\n\n        # Select the solution with the best trade-off (lowest score)\n        best_idx = np.argmin(trade_off_scores)\n        base_solution = solutions[best_idx]\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel \"swap-and-reverse\" operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose three distinct indices to perform 3-opt\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse the middle segment\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Apply swap-and-reverse: swap two nodes and reverse a segment\n    if n > 4:\n        a, b = np.random.choice(n, size=2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Randomly select a segment to reverse\n        l, m = np.random.choice(n, size=2, replace=False)\n        l, m = sorted([l, m])\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 163,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Prioritize solutions that have a high total cost in either objective space\n    archive_sorted = sorted(archive, key=lambda x: -max(x[1][0], x[1][1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge exchange with segment rotation\n    if n > 3:\n        # 1. Perform edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # 2. Perform segment rotation (novel operator)\n        if n > 4:\n            k = random.randint(2, n-2)\n            segment = new_solution[i:i+k]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:i+k] = rotated_segment\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.8909602446137255,
            2.642883598804474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Prioritize solutions that have a high total cost in either objective space\n    archive_sorted = sorted(archive, key=lambda x: -max(x[1][0], x[1][1]))\n    selected_idx = min(int(len(archive_sorted) * 0.3), len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge exchange with segment rotation\n    if n > 3:\n        # 1. Perform edge exchange (similar to 2-opt but more flexible)\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n        # 2. Perform segment rotation (novel operator)\n        if n > 4:\n            k = random.randint(2, n-2)\n            segment = new_solution[i:i+k]\n            rotated_segment = np.roll(segment, random.randint(1, len(segment)-1))\n            new_solution[i:i+k] = rotated_segment\n\n    # Ensure the solution remains feasible\n    assert len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 164,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Sort solutions by the sum of their objectives (prioritizing those with higher total cost)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    segment_length = random.randint(3, min(10, n // 2))\n    start = random.randint(0, n - segment_length)\n\n    # Apply segment inversion (novel local search operator)\n    segment = new_solution[start:start+segment_length]\n    new_solution[start:start+segment_length] = segment[::-1]\n\n    # Randomly decide whether to apply 3-opt or not\n    if random.random() < 0.5 and n >= 3:\n        # Select three random edges to reconnect\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        # Reconnect the edges in a different order\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Verify no duplicates and all nodes are present\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9601741561443173,
            2.486963391304016
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Sort solutions by the sum of their objectives (prioritizing those with higher total cost)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selected_idx = min(int(len(sorted_archive) * 0.3), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Choose a random segment to modify\n    segment_length = random.randint(3, min(10, n // 2))\n    start = random.randint(0, n - segment_length)\n\n    # Apply segment inversion (novel local search operator)\n    segment = new_solution[start:start+segment_length]\n    new_solution[start:start+segment_length] = segment[::-1]\n\n    # Randomly decide whether to apply 3-opt or not\n    if random.random() < 0.5 and n >= 3:\n        # Select three random edges to reconnect\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        # Reconnect the edges in a different order\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    # Verify no duplicates and all nodes are present\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 165,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select two distinct segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8329631850364912,
            2.0760899782180786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution, _ = archive[selected_idx]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combine edge swaps and segment reversals\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible for small tours\n\n    # Randomly select two distinct segments and reverse them\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 166,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0)\n    weights = 1 - np.mean(normalized_objectives, axis=1)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 3-opt move\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Then, perform a custom edge swap based on the distance matrices\n    # Select two edges (i, j) and (k, l) and swap them\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains feasibility\n    if j != k and i != l:\n        # Calculate the change in both objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]])\n        delta_obj2 = (distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]])\n\n        # If the swap improves both objectives, apply it\n        if delta_obj1 <= 0 and delta_obj2 <= 0:\n            new_solution[[i, k]] = new_solution[[k, i]]\n            new_solution[[j, l]] = new_solution[[l, j]]\n\n    return new_solution\n\n",
        "score": [
            -0.9279489921993791,
            2.454978048801422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / np.sum(objectives, axis=0)\n    weights = 1 - np.mean(normalized_objectives, axis=1)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 3-opt move\n    i, j, k = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Then, perform a custom edge swap based on the distance matrices\n    # Select two edges (i, j) and (k, l) and swap them\n    i, j = sorted(random.sample(range(n), 2))\n    k, l = sorted(random.sample(range(n), 2))\n\n    # Ensure the swap maintains feasibility\n    if j != k and i != l:\n        # Calculate the change in both objectives\n        delta_obj1 = (distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]) - \\\n                     (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[k], new_solution[l]])\n        delta_obj2 = (distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]) - \\\n                     (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[k], new_solution[l]])\n\n        # If the swap improves both objectives, apply it\n        if delta_obj1 <= 0 and delta_obj2 <= 0:\n            new_solution[[i, k]] = new_solution[[k, i]]\n            new_solution[[j, l]] = new_solution[[l, j]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 167,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(cost[0] + cost[1] for _, cost in archive)\n    probabilities = [(cost[0] + cost[1]) / total_cost for _, cost in archive]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            segment = new_solution[min(i, j)+1:max(i, j)]\n            new_solution = np.concatenate([new_solution[:min(i, j)+1], segment[::-1], new_solution[max(i, j):]])\n\n        # Segment reversal with cost consideration\n        if random.random() < 0.3:  # 30% chance to apply segment reversal\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n\n            # Calculate cost difference\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                        distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                        distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]])\n\n            if new_cost <= old_cost:  # Only accept if improvement or equal\n                new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9232902155312094,
            3.6062435507774353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_cost = sum(cost[0] + cost[1] for _, cost in archive)\n    probabilities = [(cost[0] + cost[1]) / total_cost for _, cost in archive]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge insertion\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            segment = new_solution[min(i, j)+1:max(i, j)]\n            new_solution = np.concatenate([new_solution[:min(i, j)+1], segment[::-1], new_solution[max(i, j):]])\n\n        # Segment reversal with cost consideration\n        if random.random() < 0.3:  # 30% chance to apply segment reversal\n            a, b = sorted(random.sample(range(n), 2))\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n\n            # Calculate cost difference\n            old_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[a-1], reversed_segment[0]] +\n                        distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]] +\n                        distance_matrix_2[new_solution[a-1], reversed_segment[0]] +\n                        distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]])\n\n            if new_cost <= old_cost:  # Only accept if improvement or equal\n                new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 168,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    probabilities = np.array(costs) / sum(costs)\n    probabilities = 1 - probabilities  # Invert to favor lower-cost solutions\n    probabilities = probabilities / sum(probabilities)  # Normalize\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with biased randomness\n    if n > 3:\n        # Select two non-adjacent edges to break\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if i > 0 or j < n-1:  # Ensure we don't select the entire tour\n            # Break the edges and reconnect\n            segment = new_solution[i:j+1]\n            remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n            # Insert the segment at a random position\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution is valid (no duplicates, all nodes included)\n    assert len(new_solution) == len(base_solution) and np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n",
        "score": [
            -0.84412181534959,
            5.517049849033356
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = [sum(obj) for _, obj in archive]\n    probabilities = np.array(costs) / sum(costs)\n    probabilities = 1 - probabilities  # Invert to favor lower-cost solutions\n    probabilities = probabilities / sum(probabilities)  # Normalize\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: edge insertion with biased randomness\n    if n > 3:\n        # Select two non-adjacent edges to break\n        i = random.randint(0, n-2)\n        j = random.randint(i+1, n-1)\n        if i > 0 or j < n-1:  # Ensure we don't select the entire tour\n            # Break the edges and reconnect\n            segment = new_solution[i:j+1]\n            remaining = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n            # Insert the segment at a random position\n            insert_pos = random.randint(0, len(remaining))\n            new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Ensure the solution is valid (no duplicates, all nodes included)\n    assert len(new_solution) == len(base_solution) and np.array_equal(np.sort(new_solution), np.sort(base_solution))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 169,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards lower costs\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 3-opt with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt on a random segment\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # With probability 0.3, perform a biased random walk\n        if random.random() < 0.3:\n            # Randomly select two indices and swap them\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    assert len(set(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8143370342437958,
            3.266026198863983
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards lower costs\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply hybrid local search: 3-opt with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt on a random segment\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # With probability 0.3, perform a biased random walk\n        if random.random() < 0.3:\n            # Randomly select two indices and swap them\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    assert len(set(new_solution)) == len(base_solution), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 170,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on both objectives alternately\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Novel edge-swap: swap edges between two random nodes\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Ensure the swap maintains feasibility\n        if a < b < n-1:\n            new_solution[a], new_solution[b+1] = new_solution[b+1], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9120356892959808,
            2.731736719608307
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Perform 2-opt on both objectives alternately\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Novel edge-swap: swap edges between two random nodes\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Ensure the swap maintains feasibility\n        if a < b < n-1:\n            new_solution[a], new_solution[b+1] = new_solution[b+1], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 171,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their objective values (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to reverse (novel operator)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping and not adjacent\n    if b < c or d < a:\n        # Reverse the first segment (a to b)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        # Reverse the second segment (c to d)\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Edge insertion: randomly insert a node at a new position\n    if n > 2:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n",
        "score": [
            -0.7453149242904901,
            2.396377444267273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their objective values (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: combine edge insertion with a novel segment reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two distinct segments to reverse (novel operator)\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping and not adjacent\n    if b < c or d < a:\n        # Reverse the first segment (a to b)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        # Reverse the second segment (c to d)\n        new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    # Edge insertion: randomly insert a node at a new position\n    if n > 2:\n        node_to_move = random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0][0])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid (duplicate nodes)\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 172,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    total_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1.0 / (1.0 + total_costs)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Select a random segment to move\n    start = random.randint(0, n-2)\n    length = random.randint(2, min(5, n-start))\n    end = start + length\n\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Step 2: Insert the segment at a new position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Evaluate the move in both objective spaces\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]  # Return to start\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    original_cost = calculate_cost(base_solution)\n    new_cost = calculate_cost(new_solution)\n\n    # Step 4: Accept the move if it doesn't worsen both objectives\n    if not (new_cost[0] > original_cost[0] and new_cost[1] > original_cost[1]):\n        return new_solution\n    else:\n        # If move is bad, try a different operation (edge exchange)\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        return new_solution\n\n",
        "score": [
            -0.7995915344641048,
            2.2650270462036133
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    total_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1.0 / (1.0 + total_costs)\n    probabilities /= probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful operations\n\n    # Step 1: Select a random segment to move\n    start = random.randint(0, n-2)\n    length = random.randint(2, min(5, n-start))\n    end = start + length\n\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Step 2: Insert the segment at a new position\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Evaluate the move in both objective spaces\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1))\n        cost1 += distance_matrix_1[solution[-1], solution[0]]  # Return to start\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1))\n        cost2 += distance_matrix_2[solution[-1], solution[0]]\n        return (cost1, cost2)\n\n    original_cost = calculate_cost(base_solution)\n    new_cost = calculate_cost(new_solution)\n\n    # Step 4: Accept the move if it doesn't worsen both objectives\n    if not (new_cost[0] > original_cost[0] and new_cost[1] > original_cost[1]):\n        return new_solution\n    else:\n        # If move is bad, try a different operation (edge exchange)\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 173,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # (simplified: here we select randomly but prioritize solutions with lower combined cost)\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose one of three local search operators with equal probability\n        operator = random.choice(['edge_insertion', 'segment_reversal', 'random_swap'])\n\n        if operator == 'edge_insertion':\n            # Edge insertion: move a random edge to a different position\n            i = random.randint(0, n - 2)\n            j = random.randint(0, n - 1)\n            while j == i or j == i + 1:\n                j = random.randint(0, n - 1)\n            # Remove edge i-i+1 and insert it after j\n            edge = [new_solution[i], new_solution[i + 1]]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i + 2:]])\n            insert_pos = j if j < i else j - 1\n            new_solution = np.insert(new_solution, insert_pos, edge)\n\n        elif operator == 'segment_reversal':\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == 'random_swap':\n            # Random swap: swap two random nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7181940505093689,
            2.0524538159370422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability inversely proportional to its dominance rank\n    # (simplified: here we select randomly but prioritize solutions with lower combined cost)\n    costs = [sum(obj) for _, obj in archive]\n    min_cost = min(costs)\n    max_cost = max(costs)\n    if max_cost == min_cost:\n        probabilities = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        total = sum(normalized_costs)\n        probabilities = [cost / total for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Choose one of three local search operators with equal probability\n        operator = random.choice(['edge_insertion', 'segment_reversal', 'random_swap'])\n\n        if operator == 'edge_insertion':\n            # Edge insertion: move a random edge to a different position\n            i = random.randint(0, n - 2)\n            j = random.randint(0, n - 1)\n            while j == i or j == i + 1:\n                j = random.randint(0, n - 1)\n            # Remove edge i-i+1 and insert it after j\n            edge = [new_solution[i], new_solution[i + 1]]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i + 2:]])\n            insert_pos = j if j < i else j - 1\n            new_solution = np.insert(new_solution, insert_pos, edge)\n\n        elif operator == 'segment_reversal':\n            # Segment reversal: reverse a random segment of the tour\n            i, j = sorted(random.sample(range(n), 2))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        elif operator == 'random_swap':\n            # Random swap: swap two random nodes\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 174,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Edge removal and insertion with novel edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify edges with high potential for improvement\n    edge_scores = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        # Score based on distance in both objectives and their weighted combination\n        score = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) + 0.5 * (distance_matrix_1[u, v] + distance_matrix_2[u, v])\n        edge_scores.append((score, i))\n\n    # Step 2: Select the worst edge to remove (highest score)\n    edge_scores.sort(reverse=True)\n    worst_edge_idx = edge_scores[0][1]\n\n    # Step 3: Remove the worst edge\n    u = new_solution[worst_edge_idx]\n    v = new_solution[(worst_edge_idx + 1) % n]\n    removed_segment = new_solution[worst_edge_idx + 1: (worst_edge_idx + 1) % n + 1]\n    new_solution = np.delete(new_solution, worst_edge_idx + 1)\n\n    # Step 4: Find the best insertion point for the removed segment\n    best_insertion = -1\n    best_score = float('inf')\n\n    for i in range(len(new_solution)):\n        # Insert after i\n        candidate = np.insert(new_solution, i + 1, removed_segment)\n\n        # Calculate total cost of the candidate solution\n        total_cost = 0\n        for j in range(len(candidate)):\n            u = candidate[j]\n            v = candidate[(j + 1) % len(candidate)]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_insertion = i\n\n    # Step 5: Insert the segment at the best position\n    if best_insertion != -1:\n        new_solution = np.insert(new_solution, best_insertion + 1, removed_segment)\n\n    return new_solution\n\n",
        "score": [
            -0.93424053676607,
            11.484289586544037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (lowest combined cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select among top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Hybrid local search strategy: Edge removal and insertion with novel edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify edges with high potential for improvement\n    edge_scores = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n        # Score based on distance in both objectives and their weighted combination\n        score = (distance_matrix_1[u, v] + distance_matrix_2[u, v]) + 0.5 * (distance_matrix_1[u, v] + distance_matrix_2[u, v])\n        edge_scores.append((score, i))\n\n    # Step 2: Select the worst edge to remove (highest score)\n    edge_scores.sort(reverse=True)\n    worst_edge_idx = edge_scores[0][1]\n\n    # Step 3: Remove the worst edge\n    u = new_solution[worst_edge_idx]\n    v = new_solution[(worst_edge_idx + 1) % n]\n    removed_segment = new_solution[worst_edge_idx + 1: (worst_edge_idx + 1) % n + 1]\n    new_solution = np.delete(new_solution, worst_edge_idx + 1)\n\n    # Step 4: Find the best insertion point for the removed segment\n    best_insertion = -1\n    best_score = float('inf')\n\n    for i in range(len(new_solution)):\n        # Insert after i\n        candidate = np.insert(new_solution, i + 1, removed_segment)\n\n        # Calculate total cost of the candidate solution\n        total_cost = 0\n        for j in range(len(candidate)):\n            u = candidate[j]\n            v = candidate[(j + 1) % len(candidate)]\n            total_cost += distance_matrix_1[u, v] + distance_matrix_2[u, v]\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_insertion = i\n\n    # Step 5: Insert the segment at the best position\n    if best_insertion != -1:\n        new_solution = np.insert(new_solution, best_insertion + 1, removed_segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 175,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a solution with a high probability of being non-dominated or having high potential\n    # Here, we prioritize solutions with lower combined cost\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or fewer\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    # Step 1: Randomly select a segment and invert it (novel segment inversion)\n    if n > 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge exchange (2-opt-like but with a twist)\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Instead of simple edge exchange, we perform a more complex rearrangement\n            segment = new_solution[i:j]\n            new_solution[i:j] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above operations cause issues\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8122773259968495,
            1.8521845936775208
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty. Cannot select a neighbor.\")\n\n    # Select a solution with a high probability of being non-dominated or having high potential\n    # Here, we prioritize solutions with lower combined cost\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive) - 1)  # Select among top 3 or fewer\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply a hybrid local search strategy\n    # Step 1: Randomly select a segment and invert it (novel segment inversion)\n    if n > 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Apply edge exchange (2-opt-like but with a twist)\n    if n > 4:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            # Instead of simple edge exchange, we perform a more complex rearrangement\n            segment = new_solution[i:j]\n            new_solution[i:j] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above operations cause issues\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 176,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a promising solution from the archive (here, we select the one with the lowest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [sum(obj) for _, obj in archive]\n    selected_solution = archive_solutions[np.argmin(archive_objectives)].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a custom edge-swap heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a custom edge-swap heuristic based on both distance matrices\n    for _ in range(5):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost = (distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                         distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]] +\n                         distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                         distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                    distance_matrix_1[selected_solution[i], selected_solution[(j+1)%n]] +\n                    distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                    distance_matrix_2[selected_solution[i], selected_solution[(j+1)%n]])\n\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7845428604031014,
            1.4591130018234253
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a promising solution from the archive (here, we select the one with the lowest sum of objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [sum(obj) for _, obj in archive]\n    selected_solution = archive_solutions[np.argmin(archive_objectives)].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a custom edge-swap heuristic\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # First, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a custom edge-swap heuristic based on both distance matrices\n    for _ in range(5):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        current_cost = (distance_matrix_1[selected_solution[i-1], selected_solution[i]] +\n                         distance_matrix_1[selected_solution[j], selected_solution[(j+1)%n]] +\n                         distance_matrix_2[selected_solution[i-1], selected_solution[i]] +\n                         distance_matrix_2[selected_solution[j], selected_solution[(j+1)%n]])\n\n        new_cost = (distance_matrix_1[selected_solution[i-1], selected_solution[j]] +\n                    distance_matrix_1[selected_solution[i], selected_solution[(j+1)%n]] +\n                    distance_matrix_2[selected_solution[i-1], selected_solution[j]] +\n                    distance_matrix_2[selected_solution[i], selected_solution[(j+1)%n]])\n\n        if new_cost < current_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 177,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a non-dominated objective (lower cost in at least one objective)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: random segment inversion with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate the segment in both objectives\n    def segment_cost(sol, i, j):\n        cost1 = distance_matrix_1[sol[j], sol[(j+1)%n]] - distance_matrix_1[sol[i], sol[(j+1)%n]]\n        cost2 = distance_matrix_2[sol[j], sol[(j+1)%n]] - distance_matrix_2[sol[i], sol[(j+1)%n]]\n        if i > 0:\n            cost1 += distance_matrix_1[sol[i-1], sol[i]] - distance_matrix_1[sol[i-1], sol[j]]\n            cost2 += distance_matrix_2[sol[i-1], sol[i]] - distance_matrix_2[sol[i-1], sol[j]]\n        return (cost1, cost2)\n\n    current_cost = segment_cost(new_solution, i, j)\n    reversed_segment = segment[::-1]\n    reversed_cost = segment_cost(new_solution, i, j)\n\n    # Accept the change if it improves at least one objective\n    if (reversed_cost[0] < current_cost[0] or reversed_cost[1] < current_cost[1]):\n        new_solution[i:j+1] = reversed_segment\n\n    # Additional improvement: try swapping two random nodes if the segment inversion didn't help\n    if new_solution[i:j+1].tolist() == segment.tolist():\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.9772838578616356,
            1.9745737314224243
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a non-dominated objective (lower cost in at least one objective)\n    candidates = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            candidates.append(sol)\n\n    if not candidates:\n        candidates = [sol for sol, _ in archive]\n\n    base_solution = random.choice(candidates).copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: random segment inversion with objective-aware selection\n    n = len(new_solution)\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate the segment in both objectives\n    def segment_cost(sol, i, j):\n        cost1 = distance_matrix_1[sol[j], sol[(j+1)%n]] - distance_matrix_1[sol[i], sol[(j+1)%n]]\n        cost2 = distance_matrix_2[sol[j], sol[(j+1)%n]] - distance_matrix_2[sol[i], sol[(j+1)%n]]\n        if i > 0:\n            cost1 += distance_matrix_1[sol[i-1], sol[i]] - distance_matrix_1[sol[i-1], sol[j]]\n            cost2 += distance_matrix_2[sol[i-1], sol[i]] - distance_matrix_2[sol[i-1], sol[j]]\n        return (cost1, cost2)\n\n    current_cost = segment_cost(new_solution, i, j)\n    reversed_segment = segment[::-1]\n    reversed_cost = segment_cost(new_solution, i, j)\n\n    # Accept the change if it improves at least one objective\n    if (reversed_cost[0] < current_cost[0] or reversed_cost[1] < current_cost[1]):\n        new_solution[i:j+1] = reversed_segment\n\n    # Additional improvement: try swapping two random nodes if the segment inversion didn't help\n    if new_solution[i:j+1].tolist() == segment.tolist():\n        k, l = sorted(random.sample(range(n), 2))\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 178,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower objective values are better)\n    normalized_potentials = []\n    for obj in archive_objectives:\n        # Simple heuristic: penalize solutions with high objectives\n        potential = (obj[0] + obj[1]) / (len(instance) * 2)  # Normalize by problem size\n        normalized_potentials.append(1 - potential)  # Higher potential for lower objectives\n\n    # Select a solution with probability proportional to its potential\n    selected_idx = random.choices(range(len(archive)), weights=normalized_potentials, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move (select 3 random edges and reconnect them)\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reconnect the edges in a different order\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Then perform a custom edge-swap based on distance improvement\n    for _ in range(2):  # Perform 2 edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Evaluate the current and swapped edges in both objective spaces\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if swapped_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7441122271969891,
            2.3048821687698364
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate the normalized improvement potential (lower objective values are better)\n    normalized_potentials = []\n    for obj in archive_objectives:\n        # Simple heuristic: penalize solutions with high objectives\n        potential = (obj[0] + obj[1]) / (len(instance) * 2)  # Normalize by problem size\n        normalized_potentials.append(1 - potential)  # Higher potential for lower objectives\n\n    # Select a solution with probability proportional to its potential\n    selected_idx = random.choices(range(len(archive)), weights=normalized_potentials, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move (select 3 random edges and reconnect them)\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reconnect the edges in a different order\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Then perform a custom edge-swap based on distance improvement\n    for _ in range(2):  # Perform 2 edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Evaluate the current and swapped edges in both objective spaces\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]])\n        swapped_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        if swapped_cost < current_cost:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == len(instance), \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 179,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its objective values (lower is better)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-6)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: 2-opt with segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, min(n - j, j - i))\n\n    # Segment inversion operator\n    segment = new_solution[i:i+j]\n    reversed_segment = segment[::-1]\n    new_solution[i:i+j] = reversed_segment\n\n    # 2-opt operator on the inverted segment\n    if k > 0:\n        l = random.randint(i, i + k)\n        m = random.randint(i + k, min(i + j, n - 1))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.780187296459448,
            2.269585132598877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its objective values (lower is better)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-6)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: 2-opt with segment inversion\n    i, j = sorted(random.sample(range(n), 2))\n    k = random.randint(0, min(n - j, j - i))\n\n    # Segment inversion operator\n    segment = new_solution[i:i+j]\n    reversed_segment = segment[::-1]\n    new_solution[i:i+j] = reversed_segment\n\n    # 2-opt operator on the inverted segment\n    if k > 0:\n        l = random.randint(i, i + k)\n        m = random.randint(i + k, min(i + j, n - 1))\n        new_solution[l:m] = new_solution[l:m][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if segment inversion causes duplicates\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 180,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge insertion with segment swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Edge Insertion (for local refinement)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have at least one node to move\n        node_to_move = new_solution[i+1]\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [node_to_move], new_solution[j+1:]])\n\n    # Step 2: Segment Swap (novel operator for multi-objective improvement)\n    if n >= 6:\n        # Select two non-overlapping segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if b - a > 2:  # Ensure segments are large enough\n            # Swap segments to potentially improve both objectives\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:]\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[:a]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.38171974635716294,
            0.4441152811050415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost in either objective)\n    archive_sorted = sorted(archive, key=lambda x: min(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: combine edge insertion with segment swap\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Step 1: Edge Insertion (for local refinement)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure we have at least one node to move\n        node_to_move = new_solution[i+1]\n        new_solution = np.concatenate([new_solution[:i+1], new_solution[i+2:j+1], [node_to_move], new_solution[j+1:]])\n\n    # Step 2: Segment Swap (novel operator for multi-objective improvement)\n    if n >= 6:\n        # Select two non-overlapping segments\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if b - a > 2:  # Ensure segments are large enough\n            # Swap segments to potentially improve both objectives\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:]\n            new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[:a]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 181,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of the sum of objectives)\n    potentials = [1 / (obj[0] + obj[1] + 1e-10) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to exchange or insert\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Edge exchange between segments [a, b] and [c, d]\n    if random.random() < 0.5:\n        # Exchange segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n    else:\n        # Insert segment [a, b] before position c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n        new_solution = np.delete(new_solution, np.s_[c+b+1:c+b+1+(b-a+1)])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8259164106953167,
            2.0708601474761963
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of the sum of objectives)\n    potentials = [1 / (obj[0] + obj[1] + 1e-10) for _, obj in archive]\n    total_potential = sum(potentials)\n    probabilities = [p / total_potential for p in potentials]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to exchange or insert\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Edge exchange between segments [a, b] and [c, d]\n    if random.random() < 0.5:\n        # Exchange segments\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n    else:\n        # Insert segment [a, b] before position c\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n        new_solution = np.delete(new_solution, np.s_[c+b+1:c+b+1+(b-a+1)])\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts > 1):\n        # If invalid, revert to a simple swap\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 182,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel operator: reinsert a randomly selected segment elsewhere\n    if n > 4:\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler operation if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7557657892760001,
            2.0462403297424316
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high diversity)\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel operator\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select a segment to reverse (2-opt)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel operator: reinsert a randomly selected segment elsewhere\n    if n > 4:\n        k, l = sorted(random.sample(range(n), 2))\n        segment = new_solution[k:l+1]\n        new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simpler operation if invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 183,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with higher costs)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Perform 3-opt: try all possible permutations of the selected segment\n    segment = new_solution[i:j+1]\n    permutations = [\n        np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]]),\n        np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]]),\n        np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n    ]\n\n    # Evaluate all permutations and select the best one based on both objectives\n    best_perm = None\n    min_cost = float('inf')\n    for perm in permutations:\n        cost1 = sum(distance_matrix_1[perm[l], perm[l+1]] for l in range(n-1)) + distance_matrix_1[perm[-1], perm[0]]\n        cost2 = sum(distance_matrix_2[perm[l], perm[l+1]] for l in range(n-1)) + distance_matrix_2[perm[-1], perm[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_perm = perm\n\n    if best_perm is not None:\n        new_solution = best_perm\n\n    # Novel edge insertion: try inserting a random node in a different position\n    if n > 3:\n        node_to_move = np.random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.964701793899569,
            2.423728108406067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with higher costs)\n    archive_sorted = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct nodes to perform 3-opt\n    indices = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted(indices)\n\n    # Perform 3-opt: try all possible permutations of the selected segment\n    segment = new_solution[i:j+1]\n    permutations = [\n        np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]]),\n        np.concatenate([new_solution[:i], segment[::-1], new_solution[j+1:]]),\n        np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n    ]\n\n    # Evaluate all permutations and select the best one based on both objectives\n    best_perm = None\n    min_cost = float('inf')\n    for perm in permutations:\n        cost1 = sum(distance_matrix_1[perm[l], perm[l+1]] for l in range(n-1)) + distance_matrix_1[perm[-1], perm[0]]\n        cost2 = sum(distance_matrix_2[perm[l], perm[l+1]] for l in range(n-1)) + distance_matrix_2[perm[-1], perm[0]]\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_perm = perm\n\n    if best_perm is not None:\n        new_solution = best_perm\n\n    # Novel edge insertion: try inserting a random node in a different position\n    if n > 3:\n        node_to_move = np.random.choice(new_solution)\n        new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 184,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n else np.array([])\n\n    # Reconstruct the solution with reversed segments\n    new_solution = np.concatenate([new_solution[:i], segment2[::-1], segment1[::-1], segment3])\n\n    # Additional edge-swap based on distance reduction\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Check if swapping edges a-b and a+1-b+1 reduces total distance\n        current_dist = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        swapped_dist = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[(b+1)%n]]\n\n        if (swapped_dist < current_dist):\n            # Perform the swap\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8538927760717189,
            2.586686849594116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select segments for 3-opt\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k < n else np.array([])\n\n    # Reconstruct the solution with reversed segments\n    new_solution = np.concatenate([new_solution[:i], segment2[::-1], segment1[::-1], segment3])\n\n    # Additional edge-swap based on distance reduction\n    for _ in range(2):  # Limit the number of swaps to avoid excessive computation\n        a, b = np.random.choice(n, size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n\n        # Check if swapping edges a-b and a+1-b+1 reduces total distance\n        current_dist = distance_matrix_1[new_solution[a], new_solution[a+1]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n        swapped_dist = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[a+1], new_solution[(b+1)%n]]\n\n        if (swapped_dist < current_dist):\n            # Perform the swap\n            new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 185,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = random.choices(archive_sorted[:max(1, len(archive)//2)], k=1)[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Edge swapping (similar to 2-opt but more selective)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            # Calculate cost change for both objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            # Accept if both objectives improve or at least one improves\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation with objective-aware selection\n    for _ in range(3):  # Limit iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n        if j - i > 1 and k - j > 1:  # Ensure meaningful segments\n            # Extract segments\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n\n            # Calculate cost change for both objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                         distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j+1]] +\n                         distance_matrix_1[new_solution[k], new_solution[i]] +\n                         distance_matrix_1[segment2[-1], segment1[0]])\n\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                         distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j+1]] +\n                         distance_matrix_2[new_solution[k], new_solution[i]] +\n                         distance_matrix_2[segment2[-1], segment1[0]])\n\n            # Accept if both objectives improve or at least one improves\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                # Relocate segments\n                new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n",
        "score": [
            -0.6119257669849052,
            2.6688966751098633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = random.choices(archive_sorted[:max(1, len(archive)//2)], k=1)[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Edge swapping (similar to 2-opt but more selective)\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:  # Ensure we're not just swapping adjacent nodes\n            # Calculate cost change for both objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            # Accept if both objectives improve or at least one improves\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation with objective-aware selection\n    for _ in range(3):  # Limit iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n        if j - i > 1 and k - j > 1:  # Ensure meaningful segments\n            # Extract segments\n            segment1 = new_solution[i:j+1]\n            segment2 = new_solution[j+1:k+1]\n\n            # Calculate cost change for both objectives\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j], new_solution[j+1]] +\n                         distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j+1]] +\n                         distance_matrix_1[new_solution[k], new_solution[i]] +\n                         distance_matrix_1[segment2[-1], segment1[0]])\n\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j], new_solution[j+1]] +\n                         distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j+1]] +\n                         distance_matrix_2[new_solution[k], new_solution[i]] +\n                         distance_matrix_2[segment2[-1], segment1[0]])\n\n            # Accept if both objectives improve or at least one improves\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n               (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n                # Relocate segments\n                new_solution[i:k+1] = np.concatenate([segment2, segment1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 186,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% by objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = archive_sorted[:max(1, len(archive) // 5)]\n    selected_idx = np.random.choice(len(candidate_solutions))\n    base_solution = candidate_solutions[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 3-opt\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Then perform a custom edge swap based on both distance matrices\n    if n >= 2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Evaluate the swap in both objective spaces\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        swapped_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n        swapped_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (swapped_cost1 < current_cost1 and swapped_cost2 <= current_cost2 * 1.05) or \\\n           (swapped_cost2 < current_cost2 and swapped_cost1 <= current_cost1 * 1.05):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.8503434929217409,
            2.446568727493286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% by objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_solutions = archive_sorted[:max(1, len(archive) // 5)]\n    selected_idx = np.random.choice(len(candidate_solutions))\n    base_solution = candidate_solutions[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a random 3-opt\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[b:c] = np.flip(new_solution[b:c])\n\n    # Then perform a custom edge swap based on both distance matrices\n    if n >= 2:\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Evaluate the swap in both objective spaces\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]])\n\n        swapped_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]])\n        swapped_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]])\n\n        # Accept if both objectives improve or at least one improves significantly\n        if (swapped_cost1 < current_cost1 and swapped_cost2 <= current_cost2 * 1.05) or \\\n           (swapped_cost2 < current_cost2 and swapped_cost1 <= current_cost1 * 1.05):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 187,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    selected_idx = np.argmax([(obj[0] - obj[1])**2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else []\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Custom edge swap: swap two non-adjacent edges if it improves both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge swap\n        a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.39671989326796236,
            2.6222569346427917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., one with high variance in objectives)\n    selected_idx = np.argmax([(obj[0] - obj[1])**2 for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge swap\n    n = len(new_solution)\n    i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else []\n\n    # Reconstruct the tour\n    new_solution = np.concatenate([new_solution[:i], segment2, segment1, segment3])\n\n    # Custom edge swap: swap two non-adjacent edges if it improves both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge swap\n        a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[b+1]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b+1]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[b+1]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b+1]]\n\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 188,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost difference)\n    costs = np.array([obj for _, obj in archive])\n    cost_diff = np.abs(costs[:, 0] - costs[:, 1])\n    selected_idx = np.argmin(cost_diff)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt on a random segment\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n    segment = new_solution[i:j+1]\n    np.random.shuffle(segment)\n    new_solution[i:j+1] = segment\n\n    # Novel segment swap: replace a middle segment with a reversed version\n    if n >= 6:\n        a, b = sorted(np.random.choice(range(2, n-2), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if infeasible\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7986521092308656,
            2.2663549184799194
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest cost difference)\n    costs = np.array([obj for _, obj in archive])\n    cost_diff = np.abs(costs[:, 0] - costs[:, 1])\n    selected_idx = np.argmin(cost_diff)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt on a random segment\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n    segment = new_solution[i:j+1]\n    np.random.shuffle(segment)\n    new_solution[i:j+1] = segment\n\n    # Novel segment swap: replace a middle segment with a reversed version\n    if n >= 6:\n        a, b = sorted(np.random.choice(range(2, n-2), size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if infeasible\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 189,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of both objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: apply a combination of edge insertion and segment reversal\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to reverse (to avoid getting stuck in local optima)\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Randomly select two edges and perform a cross-exchange (edge insertion)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    if i + 1 < j:\n        # Insert the segment between i and j\n        segment = new_solution[i+1:j]\n        new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes detected\"\n    assert np.array_equal(np.sort(new_solution), np.sort(best_solution)), \"Invalid tour: nodes missing or duplicated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7296481780145904,
            2.21594899892807
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of both objectives)\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Hybrid local search: apply a combination of edge insertion and segment reversal\n    n = len(best_solution)\n    new_solution = best_solution.copy()\n\n    # Randomly select a segment to reverse (to avoid getting stuck in local optima)\n    seg_start = np.random.randint(0, n - 2)\n    seg_end = np.random.randint(seg_start + 1, n)\n    new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    # Randomly select two edges and perform a cross-exchange (edge insertion)\n    i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n    if i + 1 < j:\n        # Insert the segment between i and j\n        segment = new_solution[i+1:j]\n        new_solution = np.concatenate([new_solution[:i+1], segment[::-1], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes detected\"\n    assert np.array_equal(np.sort(new_solution), np.sort(best_solution)), \"Invalid tour: nodes missing or duplicated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 190,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (e.g., sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized_obj.sum(axis=1)\n        probabilities = np.exp(-scores)  # Prefer solutions with lower scores\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel insertion-based move\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel insertion-based move (guided by both distance matrices)\n    # Select a segment to remove and reinsert elsewhere\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[k:l+1]\n    remaining = np.concatenate([new_solution[:k], new_solution[l+1:]])\n\n    # Find the best insertion point for the segment based on both distance matrices\n    best_insert_pos = 0\n    min_total_cost = float('inf')\n\n    for pos in range(len(remaining)):\n        # Insert segment at position 'pos' in remaining\n        candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = pos\n\n    # Perform the best insertion\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8480494621052526,
            8.913023710250854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combined score (e.g., sum of normalized objectives)\n        objectives = np.array([obj for _, obj in archive])\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        scores = normalized_obj.sum(axis=1)\n        probabilities = np.exp(-scores)  # Prefer solutions with lower scores\n        probabilities /= probabilities.sum()\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combine 2-opt with a novel insertion-based move\n    n = len(new_solution)\n\n    # First, perform a 2-opt move (standard local search)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel insertion-based move (guided by both distance matrices)\n    # Select a segment to remove and reinsert elsewhere\n    k, l = sorted(random.sample(range(n), 2))\n    segment = new_solution[k:l+1]\n    remaining = np.concatenate([new_solution[:k], new_solution[l+1:]])\n\n    # Find the best insertion point for the segment based on both distance matrices\n    best_insert_pos = 0\n    min_total_cost = float('inf')\n\n    for pos in range(len(remaining)):\n        # Insert segment at position 'pos' in remaining\n        candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n        # Calculate the total cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < min_total_cost:\n            min_total_cost = total_cost\n            best_insert_pos = pos\n\n    # Perform the best insertion\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 191,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution with higher probability for solutions with lower combined cost\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    min_cost, max_cost = min(costs), max(costs)\n    if min_cost == max_cost:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        probs = [cost / sum(normalized_costs) for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search strategy\n    n = len(new_solution)\n\n    # 1. Edge swap: randomly swap two edges\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # 2. Node relocation: move a random node to a new position\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        new_pos = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # 3. Double-bridge move: swap two segments of the tour\n    if n > 5:\n        a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]\n        ])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, fall back to a simple edge swap\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n",
        "score": [
            -0.842698060988201,
            3.0157521963119507
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a random solution with higher probability for solutions with lower combined cost\n    costs = [obj[0] + obj[1] for _, obj in archive]\n    min_cost, max_cost = min(costs), max(costs)\n    if min_cost == max_cost:\n        probs = [1.0 / len(archive)] * len(archive)\n    else:\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in costs]\n        probs = [cost / sum(normalized_costs) for cost in normalized_costs]\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search strategy\n    n = len(new_solution)\n\n    # 1. Edge swap: randomly swap two edges\n    if n > 3:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # 2. Node relocation: move a random node to a new position\n    if n > 2:\n        node_idx = np.random.randint(0, n)\n        new_pos = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # 3. Double-bridge move: swap two segments of the tour\n    if n > 5:\n        a, b, c, d = sorted(np.random.choice(range(n), 4, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[c:d]\n        new_solution = np.concatenate([\n            new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]\n        ])\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, fall back to a simple edge swap\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 192,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()  # Example: select the worst solution to improve\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for very small tours\n\n    # Select three random indices ensuring they are distinct and in order\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour with the 3-opt move\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Randomly reverse a segment to add diversity\n    if random.random() < 0.5:  # 50% chance to reverse a random segment\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8997191490307564,
            1.8090198040008545
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()  # Example: select the worst solution to improve\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with random segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible for very small tours\n\n    # Select three random indices ensuring they are distinct and in order\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt move\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j]\n    segment3 = new_solution[j:k]\n    segment4 = new_solution[k:]\n\n    # Reconstruct the tour with the 3-opt move\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Randomly reverse a segment to add diversity\n    if random.random() < 0.5:  # 50% chance to reverse a random segment\n        seg_start, seg_end = sorted(random.sample(range(n), 2))\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 193,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution  # Trivial case\n\n    # Step 1: Edge Insertion (for diversification)\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Step 2: Segment Inversion (for intensification)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9162929690202928,
            1.7856897711753845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = random.choice(range(len(archive)))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion + segment inversion\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution  # Trivial case\n\n    # Step 1: Edge Insertion (for diversification)\n    i, j = sorted(random.sample(range(n), 2))\n    node = new_solution[j]\n    new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    # Step 2: Segment Inversion (for intensification)\n    k, l = sorted(random.sample(range(n), 2))\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 194,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its dominance rank (lower rank = better)\n    ranks = np.arange(len(archive)) + 1  # Rank 1 is best\n    probabilities = 1 / ranks\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply 3-opt with a random segment\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse segments with probability 0.5 to explore different configurations\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8040102509689901,
            2.6438900232315063
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its dominance rank (lower rank = better)\n    ranks = np.arange(len(archive)) + 1  # Rank 1 is best\n    probabilities = 1 / ranks\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: apply 3-opt with a random segment\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Reverse segments with probability 0.5 to explore different configurations\n    if random.random() < 0.5:\n        segment1 = segment1[::-1]\n    if random.random() < 0.5:\n        segment2 = segment2[::-1]\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]])\n\n    # Ensure the solution remains a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to 2-opt if 3-opt fails\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 195,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]  # Inverse of combined cost\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with segment inversion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 50% probability, perform a segment inversion\n        if random.random() < 0.5:\n            # Select a random segment to invert\n            start, end = sorted(random.sample(range(n), 2))\n            segment = new_solution[start:end+1]\n            new_solution[start:end+1] = segment[::-1]\n        else:\n            # Otherwise, perform a 3-opt move (a more complex edge swap)\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Reorder the segment between i, j, k to find a better arrangement\n            segment = new_solution[i:j+1]\n            if random.random() < 0.5:\n                new_solution[i:j+1] = segment[::-1]  # Reverse the segment\n            else:\n                # Rotate the segment\n                new_solution[i:j+1] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid.\"\n    return new_solution\n\n",
        "score": [
            -0.9770731016547166,
            2.507254123687744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]  # Inverse of combined cost\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps with segment inversion\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # With 50% probability, perform a segment inversion\n        if random.random() < 0.5:\n            # Select a random segment to invert\n            start, end = sorted(random.sample(range(n), 2))\n            segment = new_solution[start:end+1]\n            new_solution[start:end+1] = segment[::-1]\n        else:\n            # Otherwise, perform a 3-opt move (a more complex edge swap)\n            i, j, k = sorted(random.sample(range(n), 3))\n            # Reorder the segment between i, j, k to find a better arrangement\n            segment = new_solution[i:j+1]\n            if random.random() < 0.5:\n                new_solution[i:j+1] = segment[::-1]  # Reverse the segment\n            else:\n                # Rotate the segment\n                new_solution[i:j+1] = np.roll(segment, random.randint(1, len(segment)-1))\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == len(base_solution), \"Generated solution is invalid.\"\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 196,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with a probability inversely proportional to its objective values\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to avoid bias towards one objective\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    else:\n        objectives = np.ones_like(objectives)\n\n    # Calculate selection probabilities (higher for solutions with lower objective values)\n    selection_probs = 1 / (1 + np.sum(objectives, axis=1))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    # Select a base solution\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment of the tour\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    segment = new_solution[segment_start:segment_end + 1]\n\n    # Step 2: Reverse the segment with a probability of 0.5 to introduce diversity\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Step 3: Insert the segment at a new random position\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end + 1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9079142637928421,
            2.0994473695755005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n    import numpy as np\n\n    # Select a solution with a probability inversely proportional to its objective values\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to avoid bias towards one objective\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    else:\n        objectives = np.ones_like(objectives)\n\n    # Calculate selection probabilities (higher for solutions with lower objective values)\n    selection_probs = 1 / (1 + np.sum(objectives, axis=1))\n    selection_probs = selection_probs / np.sum(selection_probs)\n\n    # Select a base solution\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select a segment of the tour\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 1, n - 1)\n    segment = new_solution[segment_start:segment_end + 1]\n\n    # Step 2: Reverse the segment with a probability of 0.5 to introduce diversity\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    # Step 3: Insert the segment at a new random position\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end + 1:]])\n    insert_pos = random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution is a valid tour (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 197,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Higher probability for non-dominated or less explored solutions\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n\n    # Identify dominated solutions\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and not (objectives[j][0] == objectives[i][0] and objectives[j][1] == objectives[i][1]):\n                dominated[i] = True\n                break\n\n    # Assign selection probabilities (higher for non-dominated solutions)\n    probabilities = np.where(dominated, 0.1, 1.0)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for 3-opt\n\n    # Randomly select 3 edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Edge exchange: swap two edges with a probability based on their quality\n    if random.random() < 0.3:  # 30% chance to perform edge exchange\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate quality of edges in both objectives\n            edge_quality = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                           (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n            # Swap edges if it improves overall quality\n            if edge_quality > (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                           (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Invalid tour: nodes missing\"\n\n    return new_solution\n\n",
        "score": [
            -0.8560759487653152,
            3.849254608154297
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    # Higher probability for non-dominated or less explored solutions\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n\n    # Identify dominated solutions\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and not (objectives[j][0] == objectives[i][0] and objectives[j][1] == objectives[i][1]):\n                dominated[i] = True\n                break\n\n    # Assign selection probabilities (higher for non-dominated solutions)\n    probabilities = np.where(dominated, 0.1, 1.0)\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge exchange\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for 3-opt\n\n    # Randomly select 3 edges to modify\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = new_solution[j:k][::-1]  # Reverse another segment\n\n    # Edge exchange: swap two edges with a probability based on their quality\n    if random.random() < 0.3:  # 30% chance to perform edge exchange\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Calculate quality of edges in both objectives\n            edge_quality = (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]) + \\\n                           (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n            # Swap edges if it improves overall quality\n            if edge_quality > (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]) + \\\n                           (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]):\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid tour: duplicate nodes\"\n    assert np.array_equal(np.sort(new_solution), np.sort(base_solution)), \"Invalid tour: nodes missing\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 198,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a higher probability if it has lower costs\n    # Normalize costs to [0, 1] range for selection probability\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    combined_scores = 1 / (1 + normalized_costs.sum(axis=1))  # Higher score for better solutions\n\n    # Select a solution based on combined scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores/combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First operation: Edge exchange (2-opt but with a twist)\n    i, j = sorted(random.sample(range(1, n), 2))\n    if j - i > 1:\n        # Reverse a segment with probability 0.5 to explore more neighbors\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Edge exchange: swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Second operation: Segment relocation with objective-aware selection\n    if random.random() < 0.3:  # 30% chance to apply this operation\n        a, b = sorted(random.sample(range(1, n), 2))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            # Evaluate the impact on both objectives\n            original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Try inserting the segment at a different position\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n            # Check if the new solution is better in at least one objective\n            new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Revert if not better in at least one objective\n            if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2):\n                new_solution = base_solution.copy()\n                new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n                new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9128356688446855,
            2.6584606766700745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a higher probability if it has lower costs\n    # Normalize costs to [0, 1] range for selection probability\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    combined_scores = 1 / (1 + normalized_costs.sum(axis=1))  # Higher score for better solutions\n\n    # Select a solution based on combined scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores/combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First operation: Edge exchange (2-opt but with a twist)\n    i, j = sorted(random.sample(range(1, n), 2))\n    if j - i > 1:\n        # Reverse a segment with probability 0.5 to explore more neighbors\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Edge exchange: swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Second operation: Segment relocation with objective-aware selection\n    if random.random() < 0.3:  # 30% chance to apply this operation\n        a, b = sorted(random.sample(range(1, n), 2))\n        if b - a > 1:\n            segment = new_solution[a:b]\n            # Evaluate the impact on both objectives\n            original_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            original_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Try inserting the segment at a different position\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n            # Check if the new solution is better in at least one objective\n            new_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(1, n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Revert if not better in at least one objective\n            if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2):\n                new_solution = base_solution.copy()\n                new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n                new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 199,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a random edge swap (2-opt move)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Perform a segment relocation (novel operator)\n    # Select a random segment and insert it elsewhere\n    seg_start, seg_end = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[seg_start:seg_end+1].copy()\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n    # Insert the segment at a random position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9166212293601708,
            2.0200142860412598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search strategy:\n    # 1. Perform a random edge swap (2-opt move)\n    n = len(new_solution)\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    if i < j:\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # 2. Perform a segment relocation (novel operator)\n    # Select a random segment and insert it elsewhere\n    seg_start, seg_end = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[seg_start:seg_end+1].copy()\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_end+1:]])\n\n    # Insert the segment at a random position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 200,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its current cost\n    objectives = [obj for _, obj in archive]\n    costs = [sum(obj) for obj in objectives]\n    if all(c == 0 for c in costs):\n        weights = [1.0 / len(costs)] * len(costs)\n    else:\n        weights = [1.0 / (c + 1e-6) for c in costs]\n    weights = [w / sum(weights) for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (segment reversal)\n    seg_start = random.randint(0, n - 2)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    new_solution[seg_start:seg_end + 1] = new_solution[seg_start:seg_end + 1][::-1]\n\n    # Randomly select an edge to remove and reinsert (edge insertion)\n    if n > 2:\n        edge_idx = random.randint(0, n - 1)\n        node = new_solution[edge_idx]\n        new_solution = np.delete(new_solution, edge_idx)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7726271534833078,
            2.5820319652557373
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its current cost\n    objectives = [obj for _, obj in archive]\n    costs = [sum(obj) for obj in objectives]\n    if all(c == 0 for c in costs):\n        weights = [1.0 / len(costs)] * len(costs)\n    else:\n        weights = [1.0 / (c + 1e-6) for c in costs]\n    weights = [w / sum(weights) for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (segment reversal)\n    seg_start = random.randint(0, n - 2)\n    seg_end = random.randint(seg_start + 1, n - 1)\n    new_solution[seg_start:seg_end + 1] = new_solution[seg_start:seg_end + 1][::-1]\n\n    # Randomly select an edge to remove and reinsert (edge insertion)\n    if n > 2:\n        edge_idx = random.randint(0, n - 1)\n        node = new_solution[edge_idx]\n        new_solution = np.delete(new_solution, edge_idx)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 201,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic preference for those with lower costs\n    objectives = np.array([obj for _, obj in archive])\n    costs = objectives.sum(axis=1)\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Reverse the segment (similar to 2-opt but with a twist)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back at a different position\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n    # Further improve by moving a random node to a new position\n    if n > 3:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operations fail\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9341879009890113,
            2.417052388191223
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probabilistic preference for those with lower costs\n    objectives = np.array([obj for _, obj in archive])\n    costs = objectives.sum(axis=1)\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Reverse the segment (similar to 2-opt but with a twist)\n    reversed_segment = segment[::-1]\n\n    # Insert the reversed segment back at a different position\n    new_solution = np.concatenate([new_solution[:a], reversed_segment, new_solution[b:]])\n\n    # Further improve by moving a random node to a new position\n    if n > 3:\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the above operations fail\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 202,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and segment relocation\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Randomly choose between edge swap and segment relocation\n        if np.random.rand() < 0.5:\n            # Edge swap (2-opt variant)\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Segment relocation (novel operator)\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate((new_solution[:i], new_solution[j:], segment))\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected_solution.copy()\n            continue\n\n        # Accept if improvement in at least one objective\n        old_cost1 = sum(distance_matrix_1[selected_solution[k-1], selected_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[selected_solution[k-1], selected_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            selected_solution = new_solution.copy()\n        else:\n            new_solution = selected_solution.copy()\n\n    return selected_solution\n\n",
        "score": [
            -0.8763152954825125,
            6.917603492736816
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest combined cost)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and segment relocation\n    for _ in range(10):  # Limit iterations to balance exploration and exploitation\n        # Randomly choose between edge swap and segment relocation\n        if np.random.rand() < 0.5:\n            # Edge swap (2-opt variant)\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Segment relocation (novel operator)\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            segment = new_solution[i:j]\n            new_solution = np.concatenate((new_solution[:i], new_solution[j:], segment))\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            new_solution = selected_solution.copy()\n            continue\n\n        # Accept if improvement in at least one objective\n        old_cost1 = sum(distance_matrix_1[selected_solution[k-1], selected_solution[k]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[selected_solution[k-1], selected_solution[k]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n))\n\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            selected_solution = new_solution.copy()\n        else:\n            new_solution = selected_solution.copy()\n\n    return selected_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 203,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (low objective values)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swap heuristic\n    n = len(new_solution)\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select 3 distinct edges to modify\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n        # Apply edge-swap heuristic: check if swapping two edges improves both objectives\n        for _ in range(2):  # Try 2 random edge swaps\n            a, b = sorted(random.sample(range(n), 2))\n            if a != b:\n                # Calculate change in both objectives\n                delta_obj1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta_obj2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n                # If both objectives improve, perform the swap\n                if delta_obj1 < 0 and delta_obj2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.802195907631336,
            2.42956805229187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (low objective values)\n    selected = min(archive, key=lambda x: sum(x[1]))\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with edge-swap heuristic\n    n = len(new_solution)\n    for _ in range(3):  # Perform 3 iterations of the hybrid operator\n        # Randomly select 3 distinct edges to modify\n        i, j, k = sorted(random.sample(range(1, n), 3))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment i to j\n        new_solution[j:k] = new_solution[j:k][::-1]  # Reverse segment j to k\n\n        # Apply edge-swap heuristic: check if swapping two edges improves both objectives\n        for _ in range(2):  # Try 2 random edge swaps\n            a, b = sorted(random.sample(range(n), 2))\n            if a != b:\n                # Calculate change in both objectives\n                delta_obj1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]) - \\\n                            (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n                delta_obj2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                             distance_matrix_2[new_solution[b], new_solution[(a+1)%n]]) - \\\n                            (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                             distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n                # If both objectives improve, perform the swap\n                if delta_obj1 < 0 and delta_obj2 < 0:\n                    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 204,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Randomly select three segments to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Perform a novel 3-opt-like operation with segment relocation\n    # Reverse the middle segment and relocate it to a different position\n    segment = new_solution[b:c+1][::-1]\n    remaining = np.concatenate([new_solution[:b], new_solution[c+1:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Add a small perturbation to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of additional perturbation\n        # Swap two random nodes that are not adjacent\n        i, j = np.random.choice(n, 2, replace=False)\n        while abs(i - j) == 1 or abs(i - j) == n - 1:  # Ensure non-adjacent\n            i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 4: Ensure the solution remains feasible (valid TSP tour)\n    # Verify that all nodes are visited exactly once and no duplicates exist\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8817449188431614,
            2.5835644602775574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful improvement possible\n\n    # Step 1: Randomly select three segments to modify\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Step 2: Perform a novel 3-opt-like operation with segment relocation\n    # Reverse the middle segment and relocate it to a different position\n    segment = new_solution[b:c+1][::-1]\n    remaining = np.concatenate([new_solution[:b], new_solution[c+1:]])\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Step 3: Add a small perturbation to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of additional perturbation\n        # Swap two random nodes that are not adjacent\n        i, j = np.random.choice(n, 2, replace=False)\n        while abs(i - j) == 1 or abs(i - j) == n - 1:  # Ensure non-adjacent\n            i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 4: Ensure the solution remains feasible (valid TSP tour)\n    # Verify that all nodes are visited exactly once and no duplicates exist\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 205,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    # Here, we randomly select among the top 30% of solutions with the highest combined cost\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    base_solution, _ = random.choice(selection_pool)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment-based exchange with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Select a random segment to move (3-5 nodes)\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(3, min(5, n - seg_start - 1))\n    segment = new_solution[seg_start:seg_start + seg_length]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply a novel operator - swap two edges based on both distance matrices\n    # Select two edges that are \"bad\" in at least one objective\n    edge_indices = list(range(1, n - 1))  # Exclude the last edge (circular)\n    random.shuffle(edge_indices)\n    for i in edge_indices:\n        a, b = new_solution[i-1], new_solution[i]\n        c, d = new_solution[i], new_solution[i+1]\n        # Check if swapping edges a-b and c-d would improve either objective\n        original_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n        original_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n        new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n        new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            # Perform the swap\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n            break  # Only one swap per iteration\n\n    return new_solution\n\n",
        "score": [
            -0.857851908691617,
            2.057304263114929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    # Here, we randomly select among the top 30% of solutions with the highest combined cost\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]), reverse=True)\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    base_solution, _ = random.choice(selection_pool)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment-based exchange with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful changes\n\n    # Step 1: Select a random segment to move (3-5 nodes)\n    seg_start = random.randint(0, n - 4)\n    seg_length = random.randint(3, min(5, n - seg_start - 1))\n    segment = new_solution[seg_start:seg_start + seg_length]\n\n    # Step 2: Remove the segment and insert it elsewhere\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:]])\n    insert_pos = random.randint(0, len(new_solution) - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Step 3: Apply a novel operator - swap two edges based on both distance matrices\n    # Select two edges that are \"bad\" in at least one objective\n    edge_indices = list(range(1, n - 1))  # Exclude the last edge (circular)\n    random.shuffle(edge_indices)\n    for i in edge_indices:\n        a, b = new_solution[i-1], new_solution[i]\n        c, d = new_solution[i], new_solution[i+1]\n        # Check if swapping edges a-b and c-d would improve either objective\n        original_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n        original_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n        new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n        new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n        if (new_cost1 < original_cost1) or (new_cost2 < original_cost2):\n            # Perform the swap\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n            break  # Only one swap per iteration\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 206,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost sum\n    costs = np.array([sum(obj) for _, obj in archive])\n    selection_probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion with guided random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 2, n - 1)\n\n    # Extract the segment and remaining nodes\n    segment = new_solution[segment_start:segment_end + 1]\n    remaining_nodes = np.concatenate([new_solution[:segment_start], new_solution[segment_end + 1:]])\n\n    # Shuffle the segment to introduce diversity\n    np.random.shuffle(segment)\n\n    # Reinsert the shuffled segment into the remaining nodes\n    insertion_point = random.randint(0, len(remaining_nodes))\n    new_solution = np.concatenate([remaining_nodes[:insertion_point], segment, remaining_nodes[insertion_point:]])\n\n    # Apply a guided random walk: swap nodes that improve at least one objective\n    for _ in range(min(10, n // 2)):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7913008447034512,
            2.117989242076874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its cost sum\n    costs = np.array([sum(obj) for _, obj in archive])\n    selection_probs = 1 / (costs + 1e-6)  # Avoid division by zero\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion with guided random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    segment_start = random.randint(0, n - 3)\n    segment_end = random.randint(segment_start + 2, n - 1)\n\n    # Extract the segment and remaining nodes\n    segment = new_solution[segment_start:segment_end + 1]\n    remaining_nodes = np.concatenate([new_solution[:segment_start], new_solution[segment_end + 1:]])\n\n    # Shuffle the segment to introduce diversity\n    np.random.shuffle(segment)\n\n    # Reinsert the shuffled segment into the remaining nodes\n    insertion_point = random.randint(0, len(remaining_nodes))\n    new_solution = np.concatenate([remaining_nodes[:insertion_point], segment, remaining_nodes[insertion_point:]])\n\n    # Apply a guided random walk: swap nodes that improve at least one objective\n    for _ in range(min(10, n // 2)):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Evaluate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 207,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (top 30% by Pareto dominance)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Simple sort for selection\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal operator (like 2-opt but for segments)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Node insertion operator\n    if n >= 3:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility (though our operators already maintain it)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.616487339989527,
            1.9112029075622559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (top 30% by Pareto dominance)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))  # Simple sort for selection\n    selection_pool = archive_sorted[:max(1, len(archive_sorted) // 3)]\n    selected = random.choice(selection_pool)\n    base_solution = selected[0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal operator (like 2-opt but for segments)\n    if n >= 4:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution[i:j+1] = segment[::-1]\n\n    # Node insertion operator\n    if n >= 3:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure feasibility (though our operators already maintain it)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 208,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    normalized_objectives = objectives / np.sum(objectives, axis=0)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (like segment reversal in iterated local search)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node to move to a new position (like edge insertion)\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, fall back to a simpler operation\n        new_solution = base_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.809749327917057,
            1.7158504724502563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    normalized_objectives = objectives / np.sum(objectives, axis=0)\n    weights = 1 / (1 + np.sum(normalized_objectives, axis=1))\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (like segment reversal in iterated local search)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly select a node to move to a new position (like edge insertion)\n    if n > 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, fall back to a simpler operation\n        new_solution = base_solution.copy()\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 209,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    # Here, we select a random solution with probability proportional to its objective values\n    weights = np.array([1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge exchange with segment inversion\n    if n > 4:\n        # Randomly select two distinct segments\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        k, l = sorted(random.sample(range(1, n-1), 2))\n\n        # Perform segment inversion between i and j, and between k and l\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to a simpler local search (edge exchange)\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # If the solution is too small, perform a simple edge exchange\n    else:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7659432832581808,
            2.541009306907654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    # Here, we select a random solution with probability proportional to its objective values\n    weights = np.array([1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge exchange with segment inversion\n    if n > 4:\n        # Randomly select two distinct segments\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        k, l = sorted(random.sample(range(1, n-1), 2))\n\n        # Perform segment inversion between i and j, and between k and l\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Ensure validity (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            # If invalid, revert to a simpler local search (edge exchange)\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # If the solution is too small, perform a simple edge exchange\n    else:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 210,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high-cost solutions)\n    selected_index = np.random.choice(len(archive))\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with a novel multi-objective move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct segments to perturb\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply a novel move: reverse segments and rotate the middle segment\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse first segment\n    new_solution[j:k] = np.roll(new_solution[j:k], shift=1)  # Rotate middle segment\n\n    # Ensure feasibility by checking for duplicates (should not happen due to proper selection)\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
        "score": [
            -0.8115529264441452,
            2.4369698762893677
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., Pareto-dominated or high-cost solutions)\n    selected_index = np.random.choice(len(archive))\n    base_solution = archive[selected_index][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with a novel multi-objective move\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct segments to perturb\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply a novel move: reverse segments and rotate the middle segment\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse first segment\n    new_solution[j:k] = np.roll(new_solution[j:k], shift=1)  # Rotate middle segment\n\n    # Ensure feasibility by checking for duplicates (should not happen due to proper selection)\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 211,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to prioritize solutions with better trade-offs\n    objectives = np.array(archive_objectives)\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate a score for each solution (simple sum of normalized objectives)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(scores)  # Select the solution with the best trade-off\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a biased edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify (3-opt)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Create a new tour by reversing the segment between j and k\n    new_segment = new_solution[j:k+1][::-1]\n    new_solution[j:k+1] = new_segment\n\n    # Apply a biased edge swap to further improve the solution\n    # Select edges with high potential for improvement in either objective\n    for _ in range(2):  # Perform a few biased swaps\n        # Calculate edge costs in both objectives\n        edge_costs_1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        edge_costs_2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n        # Combine costs with a bias towards the objective with higher variance\n        combined_costs = np.array(edge_costs_1) + np.array(edge_costs_2)\n        combined_costs = combined_costs / combined_costs.sum()  # Normalize to probabilities\n\n        # Select an edge to swap with probability proportional to its cost\n        edge_idx = np.random.choice(n, p=combined_costs)\n\n        # Perform a biased swap (move the selected edge to a better position)\n        node_to_move = new_solution[edge_idx]\n        remaining_nodes = np.delete(new_solution, edge_idx)\n\n        # Find the best insertion point for the moved node\n        best_insert_pos = 0\n        best_improvement = 0\n\n        for pos in range(len(remaining_nodes)):\n            # Insert node_to_move at position pos\n            candidate_solution = np.insert(remaining_nodes, pos, node_to_move)\n\n            # Calculate the improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[edge_idx], new_solution[(edge_idx+1)%n]] + \\\n                        distance_matrix_1[new_solution[(edge_idx-1)%n], new_solution[edge_idx]]\n            old_cost2 = distance_matrix_2[new_solution[edge_idx], new_solution[(edge_idx+1)%n]] + \\\n                        distance_matrix_2[new_solution[(edge_idx-1)%n], new_solution[edge_idx]]\n\n            new_cost1 = distance_matrix_1[candidate_solution[pos], candidate_solution[(pos+1)%n]] + \\\n                        distance_matrix_1[candidate_solution[(pos-1)%n], candidate_solution[pos]]\n            new_cost2 = distance_matrix_2[candidate_solution[pos], candidate_solution[(pos+1)%n]] + \\\n                        distance_matrix_2[candidate_solution[(pos-1)%n], candidate_solution[pos]]\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        # Apply the best insertion found\n        new_solution = np.insert(remaining_nodes, best_insert_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.832795328669811,
            8.740945935249329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Normalize objectives to prioritize solutions with better trade-offs\n    objectives = np.array(archive_objectives)\n    min_obj = objectives.min(axis=0)\n    max_obj = objectives.max(axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n\n    # Calculate a score for each solution (simple sum of normalized objectives)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmin(scores)  # Select the solution with the best trade-off\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: combine 3-opt with a biased edge selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to modify (3-opt)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Create a new tour by reversing the segment between j and k\n    new_segment = new_solution[j:k+1][::-1]\n    new_solution[j:k+1] = new_segment\n\n    # Apply a biased edge swap to further improve the solution\n    # Select edges with high potential for improvement in either objective\n    for _ in range(2):  # Perform a few biased swaps\n        # Calculate edge costs in both objectives\n        edge_costs_1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        edge_costs_2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n\n        # Combine costs with a bias towards the objective with higher variance\n        combined_costs = np.array(edge_costs_1) + np.array(edge_costs_2)\n        combined_costs = combined_costs / combined_costs.sum()  # Normalize to probabilities\n\n        # Select an edge to swap with probability proportional to its cost\n        edge_idx = np.random.choice(n, p=combined_costs)\n\n        # Perform a biased swap (move the selected edge to a better position)\n        node_to_move = new_solution[edge_idx]\n        remaining_nodes = np.delete(new_solution, edge_idx)\n\n        # Find the best insertion point for the moved node\n        best_insert_pos = 0\n        best_improvement = 0\n\n        for pos in range(len(remaining_nodes)):\n            # Insert node_to_move at position pos\n            candidate_solution = np.insert(remaining_nodes, pos, node_to_move)\n\n            # Calculate the improvement in both objectives\n            old_cost1 = distance_matrix_1[new_solution[edge_idx], new_solution[(edge_idx+1)%n]] + \\\n                        distance_matrix_1[new_solution[(edge_idx-1)%n], new_solution[edge_idx]]\n            old_cost2 = distance_matrix_2[new_solution[edge_idx], new_solution[(edge_idx+1)%n]] + \\\n                        distance_matrix_2[new_solution[(edge_idx-1)%n], new_solution[edge_idx]]\n\n            new_cost1 = distance_matrix_1[candidate_solution[pos], candidate_solution[(pos+1)%n]] + \\\n                        distance_matrix_1[candidate_solution[(pos-1)%n], candidate_solution[pos]]\n            new_cost2 = distance_matrix_2[candidate_solution[pos], candidate_solution[(pos+1)%n]] + \\\n                        distance_matrix_2[candidate_solution[(pos-1)%n], candidate_solution[pos]]\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_insert_pos = pos\n\n        # Apply the best insertion found\n        new_solution = np.insert(remaining_nodes, best_insert_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 212,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly choose between two local search strategies\n    if random.random() < 0.5:\n        # Edge insertion with objective-aware selection\n        i, j = sorted(random.sample(range(N), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate insertion points considering both objectives\n        best_insert_pos = -1\n        min_total_cost = float('inf')\n\n        for pos in range(N):\n            if pos >= i and pos <= j:\n                continue\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos],\n                segment,\n                new_solution[best_insert_pos:]\n            ])\n    else:\n        # Node relocation with objective-aware selection\n        i = random.randint(0, N-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Evaluate relocation points considering both objectives\n        best_relocate_pos = -1\n        min_total_cost = float('inf')\n\n        for pos in range(N-1):\n            if pos == i:\n                continue\n\n            # Create candidate solution\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_relocate_pos = pos\n\n        if best_relocate_pos != -1:\n            new_solution = np.insert(new_solution, best_relocate_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8637788470066057,
            10.494857668876648
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = np.array([sum(obj) for _, obj in archive])\n    probabilities = 1 / (costs + 1e-6)  # Avoid division by zero\n    probabilities /= probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using a hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly choose between two local search strategies\n    if random.random() < 0.5:\n        # Edge insertion with objective-aware selection\n        i, j = sorted(random.sample(range(N), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate insertion points considering both objectives\n        best_insert_pos = -1\n        min_total_cost = float('inf')\n\n        for pos in range(N):\n            if pos >= i and pos <= j:\n                continue\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_insert_pos],\n                segment,\n                new_solution[best_insert_pos:]\n            ])\n    else:\n        # Node relocation with objective-aware selection\n        i = random.randint(0, N-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        # Evaluate relocation points considering both objectives\n        best_relocate_pos = -1\n        min_total_cost = float('inf')\n\n        for pos in range(N-1):\n            if pos == i:\n                continue\n\n            # Create candidate solution\n            candidate = np.insert(new_solution, pos, node)\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(N))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_relocate_pos = pos\n\n        if best_relocate_pos != -1:\n            new_solution = np.insert(new_solution, best_relocate_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 213,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance (better solutions are more likely to be selected)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.sum(objectives, axis=1))  # Sum of objectives as a simple proxy for dominance\n    selection_probs = np.exp(-ranks / len(archive))  # Exponential decay for selection probability\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine edge swapping with a novel insertion-based move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge swap (2-opt-like but more flexible)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Novel insertion-based move (move a random segment to a new position)\n    if n > 4:\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(3, n - seg_start - 1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - seg_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8161743829978388,
            2.561906635761261
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance (better solutions are more likely to be selected)\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.sum(objectives, axis=1))  # Sum of objectives as a simple proxy for dominance\n    selection_probs = np.exp(-ranks / len(archive))  # Exponential decay for selection probability\n    selection_probs = selection_probs / np.sum(selection_probs)  # Normalize to probabilities\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine edge swapping with a novel insertion-based move\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Random edge swap (2-opt-like but more flexible)\n    if n > 3:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Novel insertion-based move (move a random segment to a new position)\n    if n > 4:\n        seg_start = random.randint(0, n-3)\n        seg_length = random.randint(2, min(3, n - seg_start - 1))\n        segment = new_solution[seg_start:seg_start+seg_length]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_length:]\n        ])\n        insert_pos = random.randint(0, len(new_solution) - seg_length)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 214,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    inv_objectives = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probs = inv_objectives[:, 0] * inv_objectives[:, 1]\n    probs = probs / probs.sum()  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge swapping with segment relocation\n    if random.random() < 0.7:  # 70% chance to perform edge swapping\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        # Swap the segments between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance to perform segment relocation\n        # Randomly select a segment and relocate it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        # Remove the segment and insert it at a random position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n",
        "score": [
            -0.7802961343849382,
            2.185781717300415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    inv_objectives = 1 / (objectives + 1e-6)  # Avoid division by zero\n    probs = inv_objectives[:, 0] * inv_objectives[:, 1]\n    probs = probs / probs.sum()  # Normalize to form a probability distribution\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine edge swapping with segment relocation\n    if random.random() < 0.7:  # 70% chance to perform edge swapping\n        # Randomly select two edges to swap\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        # Swap the segments between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:  # 30% chance to perform segment relocation\n        # Randomly select a segment and relocate it\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        segment = new_solution[a:b+1]\n        # Remove the segment and insert it at a random position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is not a valid tour\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 215,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    n = len(selected_solution)\n\n    # Hybrid local search: combine edge swapping with segment reversal\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments to swap or reverse\n    i, j = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([i, j])\n\n    # Option 1: Swap segments\n    if np.random.rand() < 0.5:\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:n] if b < n else np.array([])\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[n:]])\n    # Option 2: Reverse a segment\n    else:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: perform a simple 2-opt move if the above fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7887184395971788,
            2.270340859889984
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with potential for improvement (e.g., not the best in both objectives)\n    selected_idx = np.random.choice(len(archive))\n    selected_solution = archive[selected_idx][0].copy()\n    n = len(selected_solution)\n\n    # Hybrid local search: combine edge swapping with segment reversal\n    new_solution = selected_solution.copy()\n\n    # Randomly select two distinct segments to swap or reverse\n    i, j = np.random.choice(n, size=2, replace=False)\n    a, b = sorted([i, j])\n\n    # Option 1: Swap segments\n    if np.random.rand() < 0.5:\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:n] if b < n else np.array([])\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[n:]])\n    # Option 2: Reverse a segment\n    else:\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback: perform a simple 2-opt move if the above fails\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 216,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower costs in both objectives\n    # Normalize the objectives to make them comparable\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined = normalized.mean(axis=1)\n    probabilities = 1 / (combined + 1e-8)  # Higher probability for solutions with lower combined cost\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge insertion with segment reversal\n    if n > 3:\n        # Select a random segment to reverse\n        segment_start = random.randint(0, n - 2)\n        segment_end = random.randint(segment_start + 1, min(segment_start + 3, n - 1))\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Select a random edge to insert elsewhere\n        edge_start = random.randint(0, n - 2)\n        edge_end = edge_start + 1\n        if edge_end < n:\n            # Remove the edge\n            removed_edge = new_solution[edge_start:edge_end + 1]\n            new_solution = np.concatenate([new_solution[:edge_start], new_solution[edge_end + 1:]])\n\n            # Insert the edge at a new position\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, removed_edge)\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7878965722567657,
            1.9099118113517761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower costs in both objectives\n    # Normalize the objectives to make them comparable\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined = normalized.mean(axis=1)\n    probabilities = 1 / (combined + 1e-8)  # Higher probability for solutions with lower combined cost\n    probabilities = probabilities / probabilities.sum()\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: edge insertion with segment reversal\n    if n > 3:\n        # Select a random segment to reverse\n        segment_start = random.randint(0, n - 2)\n        segment_end = random.randint(segment_start + 1, min(segment_start + 3, n - 1))\n        new_solution[segment_start:segment_end + 1] = new_solution[segment_start:segment_end + 1][::-1]\n\n        # Select a random edge to insert elsewhere\n        edge_start = random.randint(0, n - 2)\n        edge_end = edge_start + 1\n        if edge_end < n:\n            # Remove the edge\n            removed_edge = new_solution[edge_start:edge_end + 1]\n            new_solution = np.concatenate([new_solution[:edge_start], new_solution[edge_end + 1:]])\n\n            # Insert the edge at a new position\n            insert_pos = random.randint(0, len(new_solution) - 1)\n            new_solution = np.insert(new_solution, insert_pos, removed_edge)\n\n    # Ensure the solution remains a valid tour\n    assert len(np.unique(new_solution)) == len(base_solution), \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 217,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution probabilistically based on its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    total_cost = sum(sum(obj) for obj in objectives)\n\n    if total_cost == 0:\n        # If all costs are zero, select a random solution\n        base_solution = random.choice(solutions).copy()\n    else:\n        # Probabilistically select a solution with higher potential for improvement\n        weights = [sum(obj) / total_cost for obj in objectives]\n        base_solution = random.choices(solutions, weights=weights, k=1)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap heuristic\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        if random.random() < 0.7:  # 70% chance to use 3-opt\n            # Select three distinct edges to modify\n            i, j, k = sorted(random.sample(range(1, n), 3))\n            # Apply 3-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:  # 30% chance to use custom edge-swap\n            # Select two distinct edges to swap\n            a, b = sorted(random.sample(range(1, n), 2))\n            if a != b:\n                # Swap edges (a, a+1) and (b, b+1)\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        # If duplicates exist, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8475984405070125,
            1.8542428016662598
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution probabilistically based on its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    total_cost = sum(sum(obj) for obj in objectives)\n\n    if total_cost == 0:\n        # If all costs are zero, select a random solution\n        base_solution = random.choice(solutions).copy()\n    else:\n        # Probabilistically select a solution with higher potential for improvement\n        weights = [sum(obj) / total_cost for obj in objectives]\n        base_solution = random.choices(solutions, weights=weights, k=1)[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap heuristic\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        if random.random() < 0.7:  # 70% chance to use 3-opt\n            # Select three distinct edges to modify\n            i, j, k = sorted(random.sample(range(1, n), 3))\n            # Apply 3-opt move\n            new_solution[i:j] = new_solution[i:j][::-1]\n            new_solution[j:k] = new_solution[j:k][::-1]\n        else:  # 30% chance to use custom edge-swap\n            # Select two distinct edges to swap\n            a, b = sorted(random.sample(range(1, n), 2))\n            if a != b:\n                # Swap edges (a, a+1) and (b, b+1)\n                new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        # If duplicates exist, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 218,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability weighted by its rank in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    weights = 1 / (ranks[:, 0] + ranks[:, 1] + 1)  # Inverse rank sum for multi-objective selection\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a greedy edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Greedy edge swap: evaluate swaps in both objective spaces and accept if beneficial\n    for _ in range(10):  # Limit the number of swaps to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Current cost in both spaces\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]])\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        # Proposed cost after swap\n        proposed_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[a]])\n        proposed_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Accept if at least one objective improves\n        if (proposed_cost1 < current_cost1) or (proposed_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7879888224255895,
            2.79597407579422
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability weighted by its rank in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives, axis=0), axis=0)\n    weights = 1 / (ranks[:, 0] + ranks[:, 1] + 1)  # Inverse rank sum for multi-objective selection\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a greedy edge swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct indices\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move: reverse the segment between j and k\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Greedy edge swap: evaluate swaps in both objective spaces and accept if beneficial\n    for _ in range(10):  # Limit the number of swaps to avoid excessive computation\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            continue\n\n        # Current cost in both spaces\n        current_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[b]])\n        current_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        # Proposed cost after swap\n        proposed_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[a]])\n        proposed_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                           distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        # Accept if at least one objective improves\n        if (proposed_cost1 < current_cost1) or (proposed_cost2 < current_cost2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 219,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt move (reversing segments)\n    if random.random() < 0.7:  # Higher probability for 3-opt\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:n-1]\n\n        # Try all possible combinations of these segments\n        combinations = [\n            np.concatenate([new_solution[:a], segment1, segment2, segment3, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1, segment2[::-1], segment3, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1, segment3, segment2, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1, segment3[::-1], segment2, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment3, segment2, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment3[::-1], segment2, new_solution[n-1:]])\n        ]\n\n        # Evaluate all combinations based on both objectives\n        best_solution = new_solution\n        best_score = np.inf\n        for candidate in combinations:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            total_score = cost1 + cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_solution = candidate.copy()\n\n        new_solution = best_solution\n    else:\n        # Novel edge insertion heuristic\n        # Select a random edge to remove and reinsert\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-1)\n        while abs(i-j) < 2:  # Ensure we're not just swapping adjacent nodes\n            j = random.randint(0, n-1)\n\n        # Remove edge i->i+1 and j->j+1\n        removed_edges = [(i, i+1), (j, j+1)]\n\n        # Reinsert them in a different order\n        new_order = list(range(n))\n        for edge in removed_edges:\n            new_order.remove(edge[0])\n\n        # Find best insertion points for the removed nodes\n        best_insertion = None\n        best_score = np.inf\n\n        for _ in range(10):  # Try multiple random insertions\n            temp_order = new_order.copy()\n            for edge in removed_edges:\n                node = edge[0]\n                pos = random.randint(0, len(temp_order))\n                temp_order.insert(pos, node)\n\n            # Ensure it's a valid tour\n            if len(set(temp_order)) == n and temp_order[0] == new_solution[0]:\n                # Calculate cost\n                cost1 = sum(distance_matrix_1[temp_order[k], temp_order[k+1]] for k in range(n-1))\n                cost2 = sum(distance_matrix_2[temp_order[k], temp_order[k+1]] for k in range(n-1))\n                total_score = cost1 + cost2\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_insertion = temp_order.copy()\n\n        if best_insertion is not None:\n            new_solution = np.array(best_insertion)\n\n    return new_solution\n\n",
        "score": [
            -0.795767442788077,
            4.088421106338501
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a novel edge insertion heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct segments\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n\n    # Apply 3-opt move (reversing segments)\n    if random.random() < 0.7:  # Higher probability for 3-opt\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = new_solution[c:n-1]\n\n        # Try all possible combinations of these segments\n        combinations = [\n            np.concatenate([new_solution[:a], segment1, segment2, segment3, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1, segment2[::-1], segment3, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment2, segment3, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment2[::-1], segment3, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1, segment3, segment2, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1, segment3[::-1], segment2, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment3, segment2, new_solution[n-1:]]),\n            np.concatenate([new_solution[:a], segment1[::-1], segment3[::-1], segment2, new_solution[n-1:]])\n        ]\n\n        # Evaluate all combinations based on both objectives\n        best_solution = new_solution\n        best_score = np.inf\n        for candidate in combinations:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            total_score = cost1 + cost2\n\n            if total_score < best_score:\n                best_score = total_score\n                best_solution = candidate.copy()\n\n        new_solution = best_solution\n    else:\n        # Novel edge insertion heuristic\n        # Select a random edge to remove and reinsert\n        i = random.randint(0, n-2)\n        j = random.randint(0, n-1)\n        while abs(i-j) < 2:  # Ensure we're not just swapping adjacent nodes\n            j = random.randint(0, n-1)\n\n        # Remove edge i->i+1 and j->j+1\n        removed_edges = [(i, i+1), (j, j+1)]\n\n        # Reinsert them in a different order\n        new_order = list(range(n))\n        for edge in removed_edges:\n            new_order.remove(edge[0])\n\n        # Find best insertion points for the removed nodes\n        best_insertion = None\n        best_score = np.inf\n\n        for _ in range(10):  # Try multiple random insertions\n            temp_order = new_order.copy()\n            for edge in removed_edges:\n                node = edge[0]\n                pos = random.randint(0, len(temp_order))\n                temp_order.insert(pos, node)\n\n            # Ensure it's a valid tour\n            if len(set(temp_order)) == n and temp_order[0] == new_solution[0]:\n                # Calculate cost\n                cost1 = sum(distance_matrix_1[temp_order[k], temp_order[k+1]] for k in range(n-1))\n                cost2 = sum(distance_matrix_2[temp_order[k], temp_order[k+1]] for k in range(n-1))\n                total_score = cost1 + cost2\n\n                if total_score < best_score:\n                    best_score = total_score\n                    best_insertion = temp_order.copy()\n\n        if best_insertion is not None:\n            new_solution = np.array(best_insertion)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 220,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from average objectives)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - avg_objectives, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select three non-consecutive edges to perturb\n    i, j, k = sorted(np.random.choice(range(1, N-1), size=3, replace=False))\n\n    # Apply 3-opt-like move\n    if np.random.rand() < 0.5:\n        # Option 1: Reverse segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Option 2: Shift segment between j and k to position i\n        segment = new_solution[j:k+1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[k+1:]])\n\n    # Additional edge-swap based on distance reduction\n    for _ in range(2):  # Perform 2 random edge swaps\n        a, b = sorted(np.random.choice(range(1, N), size=2, replace=False))\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if potential_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.3997794385533661,
            2.5248011350631714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity (far from average objectives)\n    objectives = np.array([obj for _, obj in archive])\n    avg_objectives = np.mean(objectives, axis=0)\n    distances = np.linalg.norm(objectives - avg_objectives, axis=1)\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a custom edge-swap\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select three non-consecutive edges to perturb\n    i, j, k = sorted(np.random.choice(range(1, N-1), size=3, replace=False))\n\n    # Apply 3-opt-like move\n    if np.random.rand() < 0.5:\n        # Option 1: Reverse segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Option 2: Shift segment between j and k to position i\n        segment = new_solution[j:k+1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[i:j], new_solution[k+1:]])\n\n    # Additional edge-swap based on distance reduction\n    for _ in range(2):  # Perform 2 random edge swaps\n        a, b = sorted(np.random.choice(range(1, N), size=2, replace=False))\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                        distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[b-1], new_solution[b]])\n\n        potential_cost = (distance_matrix_1[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_1[new_solution[b-1], new_solution[a]] +\n                         distance_matrix_2[new_solution[a-1], new_solution[b]] +\n                         distance_matrix_2[new_solution[b-1], new_solution[a]])\n\n        if potential_cost < current_cost:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 221,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower cost in either objective)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (simplified heuristic)\n    improvement_potential = [obj[0] + obj[1] for obj in archive_objectives]\n    selected_idx = np.argmin(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive 2-opt with objective-aware selection\n    for _ in range(5):  # Limited iterations to balance exploration\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate cost before and after 2-opt\n        before_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        after_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if after_cost < before_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation with objective-aware selection\n    for _ in range(3):  # Limited iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i == j or j == k:\n            continue\n\n        # Calculate cost before and after relocation\n        before_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        segment = new_solution[i:j+1]\n        temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        after_cost = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                     distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] +\n                     distance_matrix_1[temp_solution[(k+1)%n], temp_solution[(k+2)%n]] +\n                     distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                     distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] +\n                     distance_matrix_2[temp_solution[(k+1)%n], temp_solution[(k+2)%n]])\n\n        if after_cost < before_cost:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8219076886130382,
            4.591262102127075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lower cost in either objective)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Calculate improvement potential (simplified heuristic)\n    improvement_potential = [obj[0] + obj[1] for obj in archive_objectives]\n    selected_idx = np.argmin(improvement_potential)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive 2-opt with objective-aware selection\n    for _ in range(5):  # Limited iterations to balance exploration\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Calculate cost before and after 2-opt\n        before_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        after_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                      distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if after_cost < before_cost:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment relocation with objective-aware selection\n    for _ in range(3):  # Limited iterations\n        i, j, k = sorted(random.sample(range(n), 3))\n        if i == j or j == k:\n            continue\n\n        # Calculate cost before and after relocation\n        before_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] +\n                      distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] +\n                      distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n        segment = new_solution[i:j+1]\n        temp_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n        after_cost = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                     distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] +\n                     distance_matrix_1[temp_solution[(k+1)%n], temp_solution[(k+2)%n]] +\n                     distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                     distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] +\n                     distance_matrix_2[temp_solution[(k+1)%n], temp_solution[(k+2)%n]])\n\n        if after_cost < before_cost:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 222,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)  # Higher weights for better solutions\n    weights = weights / weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge swap followed by segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge swap: randomly select two edges and swap their nodes\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion: invert a random segment of the tour\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) == n and set(new_solution) == set(base_solution):\n        return new_solution\n    else:\n        return base_solution  # Fallback to original if invalid\n\n",
        "score": [
            -0.9050847066873282,
            2.435416340827942
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)  # Avoid division by zero\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)  # Higher weights for better solutions\n    weights = weights / weights.sum()  # Normalize weights\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge swap followed by segment inversion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge swap: randomly select two edges and swap their nodes\n    i, j = sorted(random.sample(range(1, n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment inversion: invert a random segment of the tour\n    a, b = sorted(random.sample(range(1, n), 2))\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(set(new_solution)) == n and set(new_solution) == set(base_solution):\n        return new_solution\n    else:\n        return base_solution  # Fallback to original if invalid\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 223,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Randomly select a candidate with some bias towards non-dominated solutions\n        non_dominated = [sol for sol, obj in archive if all(obj[0] <= other_obj[0] and obj[1] <= other_obj[1] and (obj[0] < other_obj[0] or obj[1] < other_obj[1]) for _, other_obj in archive)]\n        if non_dominated:\n            base_solution = random.choice(non_dominated).copy()\n        else:\n            base_solution = random.choice(candidates).copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt with a novel edge-swap strategy\n    # Step 1: Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Apply a novel edge-swap strategy (swap edges between two randomly selected segments)\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        # Swap edges between segments [a, b] and [b, a]\n        if b - a > 1:\n            # Swap edges between a and b\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7634171804751869,
            1.6610884070396423
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    candidates = [sol for sol, _ in archive]\n    if len(candidates) > 1:\n        # Randomly select a candidate with some bias towards non-dominated solutions\n        non_dominated = [sol for sol, obj in archive if all(obj[0] <= other_obj[0] and obj[1] <= other_obj[1] and (obj[0] < other_obj[0] or obj[1] < other_obj[1]) for _, other_obj in archive)]\n        if non_dominated:\n            base_solution = random.choice(non_dominated).copy()\n        else:\n            base_solution = random.choice(candidates).copy()\n    else:\n        base_solution = candidates[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: combine 2-opt with a novel edge-swap strategy\n    # Step 1: Perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Apply a novel edge-swap strategy (swap edges between two randomly selected segments)\n    if n > 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        # Swap edges between segments [a, b] and [b, a]\n        if b - a > 1:\n            # Swap edges between a and b\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 224,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    combined_costs = np.sum(normalized_costs, axis=1)\n    best_idx = np.argmin(combined_costs)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with biased edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random edges to modify (with bias towards high-cost edges)\n    def get_biased_indices():\n        # Calculate edge costs in both objective spaces\n        edge_costs_1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        edge_costs_2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        total_costs = np.array(edge_costs_1) + np.array(edge_costs_2)\n\n        # Select edges with probability proportional to their cost\n        probs = total_costs / np.sum(total_costs)\n        return np.random.choice(n, size=3, p=probs, replace=False)\n\n    i, j, k = sorted(get_biased_indices())\n\n    # Apply 3-opt move\n    if np.random.rand() < 0.5:\n        # Reverse the segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Rotate the segment between j and k\n        new_solution[j:k+1] = np.roll(new_solution[j:k+1], shift=1)\n\n    return new_solution\n\n",
        "score": [
            -0.5843989835613305,
            2.6023095846176147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    combined_costs = np.sum(normalized_costs, axis=1)\n    best_idx = np.argmin(combined_costs)\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with biased edge selection\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select three random edges to modify (with bias towards high-cost edges)\n    def get_biased_indices():\n        # Calculate edge costs in both objective spaces\n        edge_costs_1 = [distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        edge_costs_2 = [distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)]\n        total_costs = np.array(edge_costs_1) + np.array(edge_costs_2)\n\n        # Select edges with probability proportional to their cost\n        probs = total_costs / np.sum(total_costs)\n        return np.random.choice(n, size=3, p=probs, replace=False)\n\n    i, j, k = sorted(get_biased_indices())\n\n    # Apply 3-opt move\n    if np.random.rand() < 0.5:\n        # Reverse the segment between j and k\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n    else:\n        # Rotate the segment between j and k\n        new_solution[j:k+1] = np.roll(new_solution[j:k+1], shift=1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 225,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0, len(archive)) / np.sum(np.linspace(1, 0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Select two random segments\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are not overlapping and have at least 2 nodes\n    if a >= c or b >= d or (b - a) < 2 or (d - c) < 2:\n        a, b = 0, min(3, n)\n        c, d = min(4, n), n\n\n    # Extract segments\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[c:d]\n\n    # Step 2: Reverse one segment and insert it elsewhere\n    reversed_segment = segment1[::-1]\n    new_solution = np.concatenate([\n        base_solution[:a],\n        reversed_segment,\n        base_solution[b:c],\n        segment2,\n        base_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[i:j][::-1],\n            base_solution[j:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7607747520062496,
            2.1207576394081116
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_idx = np.random.choice(len(archive), p=np.linspace(1, 0, len(archive)) / np.sum(np.linspace(1, 0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Select two random segments\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    c, d = sorted(np.random.choice(n, 2, replace=False))\n\n    # Ensure segments are not overlapping and have at least 2 nodes\n    if a >= c or b >= d or (b - a) < 2 or (d - c) < 2:\n        a, b = 0, min(3, n)\n        c, d = min(4, n), n\n\n    # Extract segments\n    segment1 = base_solution[a:b]\n    segment2 = base_solution[c:d]\n\n    # Step 2: Reverse one segment and insert it elsewhere\n    reversed_segment = segment1[::-1]\n    new_solution = np.concatenate([\n        base_solution[:a],\n        reversed_segment,\n        base_solution[b:c],\n        segment2,\n        base_solution[d:]\n    ])\n\n    # Ensure the solution remains a valid tour (no duplicates, all nodes included)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, fall back to a simpler 2-opt move\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([\n            base_solution[:i],\n            base_solution[i:j][::-1],\n            base_solution[j:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 226,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    total_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reverse segments between a-b, b-c, and c-a\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:] = new_solution[c:][::-1]\n\n    # Then perform guided edge insertion based on both distance matrices\n    if n >= 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Calculate edge costs in both spaces\n            edge_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            edge_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            new_edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            new_edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            # Accept if both objectives improve or if one improves significantly\n            if (new_edge_cost1 < edge_cost1 and new_edge_cost2 < edge_cost2) or \\\n               (new_edge_cost1 < edge_cost1 * 0.9 or new_edge_cost2 < edge_cost2 * 0.9):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8646286548958888,
            2.4327767491340637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = objectives / np.max(objectives, axis=0)\n    total_costs = np.sum(normalized_costs, axis=1)\n    probabilities = 1 / (total_costs + 1e-6)  # Avoid division by zero\n    probabilities /= np.sum(probabilities)\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a guided edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 3-opt move\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reverse segments between a-b, b-c, and c-a\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[c:] = new_solution[c:][::-1]\n\n    # Then perform guided edge insertion based on both distance matrices\n    if n >= 3:\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            # Calculate edge costs in both spaces\n            edge_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            edge_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            new_edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n            new_edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            # Accept if both objectives improve or if one improves significantly\n            if (new_edge_cost1 < edge_cost1 and new_edge_cost2 < edge_cost2) or \\\n               (new_edge_cost1 < edge_cost1 * 0.9 or new_edge_cost2 < edge_cost2 * 0.9):\n                new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 227,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select 3 distinct edges to break and reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = np.concatenate([new_solution[c:], new_solution[:a]])\n\n    # Step 2: Reconnect segments in a different order\n    new_order = [segment2, segment1, segment3]\n    new_solution = np.concatenate(new_order)\n\n    # Step 3: Apply a novel edge-swap strategy to further improve\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate the current and swapped edges in both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept the swap if it improves at least one objective\n        if (swapped_cost1 < current_cost1) or (swapped_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.762726859026215,
            1.985179603099823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select 3 distinct edges to break and reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = np.concatenate([new_solution[c:], new_solution[:a]])\n\n    # Step 2: Reconnect segments in a different order\n    new_order = [segment2, segment1, segment3]\n    new_solution = np.concatenate(new_order)\n\n    # Step 3: Apply a novel edge-swap strategy to further improve\n    for _ in range(2):  # Limit iterations to avoid excessive computation\n        i, j = sorted(random.sample(range(n), 2))\n        if i == j:\n            continue\n\n        # Evaluate the current and swapped edges in both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept the swap if it improves at least one objective\n        if (swapped_cost1 < current_cost1) or (swapped_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 228,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_scores)  # Prefer solutions with better combined scores\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform a 3-opt move (randomly select 3 edges and reconnect them)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create a new segment by reversing the middle part\n    segment = new_solution[i:j+1][::-1]\n    new_solution[i:j+1] = segment\n\n    # Step 2: Custom edge-swap heuristic (swap edges if it improves both objectives)\n    for _ in range(5):  # Limit the number of attempts for efficiency\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the cost before and after the swap\n        before_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        before_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        after_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        after_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept the swap if it improves both objectives\n        if (after_cost1 < before_cost1) and (after_cost2 < before_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7574076426219625,
            1.8992611765861511
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by a combined objective score (e.g., sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_objectives.sum(axis=1)\n    selected_idx = np.argmin(combined_scores)  # Prefer solutions with better combined scores\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap heuristic\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Perform a 3-opt move (randomly select 3 edges and reconnect them)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Create a new segment by reversing the middle part\n    segment = new_solution[i:j+1][::-1]\n    new_solution[i:j+1] = segment\n\n    # Step 2: Custom edge-swap heuristic (swap edges if it improves both objectives)\n    for _ in range(5):  # Limit the number of attempts for efficiency\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the cost before and after the swap\n        before_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        before_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        after_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b-1]] + distance_matrix_1[new_solution[a], new_solution[b]]\n        after_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b-1]] + distance_matrix_2[new_solution[a], new_solution[b]]\n\n        # Accept the swap if it improves both objectives\n        if (after_cost1 < before_cost1) and (after_cost2 < before_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 229,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with adaptive step selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct edges to modify\n    i, j, k = random.sample(range(n), 3)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move: reverse segments between i-j and j-k, then connect optimally\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[j:k] = base_solution[j:k][::-1]\n\n    # Evaluate the new solution's cost in both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, solution[1:]):\n            cost += distance_matrix[a, b]\n        cost += distance_matrix[solution[-1], solution[0]]  # return to start\n        return cost\n\n    cost1_new = calculate_cost(new_solution, distance_matrix_1)\n    cost2_new = calculate_cost(new_solution, distance_matrix_2)\n\n    # If the new solution is worse in both objectives, revert to a simpler 2-opt move\n    if (cost1_new > archive[selected_idx][1][0] and cost2_new > archive[selected_idx][1][1]):\n        # Perform 2-opt move instead\n        a, b = random.sample(range(n), 2)\n        a, b = min(a, b), max(a, b)\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8157191548704196,
            1.6801738739013672
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with adaptive step selection\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct edges to modify\n    i, j, k = random.sample(range(n), 3)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move: reverse segments between i-j and j-k, then connect optimally\n    new_solution[i:j] = base_solution[i:j][::-1]\n    new_solution[j:k] = base_solution[j:k][::-1]\n\n    # Evaluate the new solution's cost in both objectives\n    def calculate_cost(solution, distance_matrix):\n        cost = 0\n        for a, b in zip(solution, solution[1:]):\n            cost += distance_matrix[a, b]\n        cost += distance_matrix[solution[-1], solution[0]]  # return to start\n        return cost\n\n    cost1_new = calculate_cost(new_solution, distance_matrix_1)\n    cost2_new = calculate_cost(new_solution, distance_matrix_2)\n\n    # If the new solution is worse in both objectives, revert to a simpler 2-opt move\n    if (cost1_new > archive[selected_idx][1][0] and cost2_new > archive[selected_idx][1][1]):\n        # Perform 2-opt move instead\n        a, b = random.sample(range(n), 2)\n        a, b = min(a, b), max(a, b)\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 230,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in objectives]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n\n    if min_cost == max_cost:\n        weights = [1.0 / len(solutions)] * len(solutions)\n    else:\n        # Normalize costs to [0, 1] range and invert for selection probability\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs]\n        total_weight = sum(normalized_costs)\n        weights = [cost / total_weight for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(solutions)), weights=weights, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel edge insertion move\n    if n > 3:\n        # Select three distinct positions\n        a, b, c = random.sample(range(n), 3)\n        a, b, c = sorted([a, b, c])\n\n        # Remove the middle node and reinsert it at a different position\n        node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.6971581387214107,
            3.2580609917640686
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    total_costs = [sum(obj) for obj in objectives]\n    min_cost = min(total_costs)\n    max_cost = max(total_costs)\n\n    if min_cost == max_cost:\n        weights = [1.0 / len(solutions)] * len(solutions)\n    else:\n        # Normalize costs to [0, 1] range and invert for selection probability\n        normalized_costs = [(max_cost - cost) / (max_cost - min_cost) for cost in total_costs]\n        total_weight = sum(normalized_costs)\n        weights = [cost / total_weight for cost in normalized_costs]\n\n    selected_idx = random.choices(range(len(solutions)), weights=weights, k=1)[0]\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # First, perform a 2-opt move on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, perform a novel edge insertion move\n    if n > 3:\n        # Select three distinct positions\n        a, b, c = random.sample(range(n), 3)\n        a, b, c = sorted([a, b, c])\n\n        # Remove the middle node and reinsert it at a different position\n        node = new_solution[b]\n        new_solution = np.concatenate([new_solution[:b], new_solution[b+1:]])\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains valid\n    assert len(new_solution) == len(base_solution)\n    assert len(set(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 231,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 10% of solutions based on combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(archive_sorted) // 10)\n    selected_solutions = archive_sorted[:top_k]\n    base_solution, _ = random.choice(selected_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 1: Edge exchange (swap two adjacent edges)\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, min(i+2, n-1))\n    if j < n-1:\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n    # Step 2: Segment reversal (reverse a random segment)\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 3: Edge swap (swap two random edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7951456211528386,
            2.240838885307312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select top 10% of solutions based on combined objective values\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_k = max(1, len(archive_sorted) // 10)\n    selected_solutions = archive_sorted[:top_k]\n    base_solution, _ = random.choice(selected_solutions)\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For very small instances, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 1: Edge exchange (swap two adjacent edges)\n    i = random.randint(0, n-2)\n    j = random.randint(i+1, min(i+2, n-1))\n    if j < n-1:\n        new_solution[i], new_solution[i+1], new_solution[j], new_solution[j+1] = (\n            new_solution[j], new_solution[j+1], new_solution[i], new_solution[i+1]\n        )\n\n    # Step 2: Segment reversal (reverse a random segment)\n    start = random.randint(0, n-2)\n    end = random.randint(start+1, n-1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 3: Edge swap (swap two random edges)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 232,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined objective value (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select 3 distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Generate all possible 3-opt moves and evaluate them\n    candidates = []\n    current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[k-1], new_solution[k]])\n\n    # Try all 8 possible 3-opt configurations\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        if a == b or b == c or a == c:\n            continue\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b] = new_solution[a:b][::-1]\n        candidate[b:c] = new_solution[b:c][::-1]\n\n        # Calculate new cost\n        new_cost = (distance_matrix_1[candidate[a-1], candidate[a]] +\n                    distance_matrix_1[candidate[b-1], candidate[b]] +\n                    distance_matrix_1[candidate[c-1], candidate[c]])\n\n        if new_cost < current_cost:\n            candidates.append((new_cost, candidate))\n\n    # If no improvement found with 3-opt, try edge insertion\n    if not candidates:\n        # Select a random edge to remove\n        remove_idx = np.random.randint(1, n-1)\n        node_to_insert = new_solution[remove_idx]\n\n        # Create candidate solution by removing the edge\n        candidate = np.delete(new_solution, remove_idx)\n        candidate = np.insert(candidate, np.random.randint(1, n-1), node_to_insert)\n\n        new_solution = candidate\n    else:\n        # Select the best candidate from 3-opt moves\n        best_cost, best_candidate = min(candidates, key=lambda x: x[0])\n        new_solution = best_candidate\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8587338184493906,
            2.850900411605835
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined objective value (promising for improvement)\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = objectives.sum(axis=1)\n    selected_idx = np.argmax(combined_objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of 3-opt and edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No improvement possible\n\n    # Step 1: Randomly select 3 distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Generate all possible 3-opt moves and evaluate them\n    candidates = []\n    current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[k-1], new_solution[k]])\n\n    # Try all 8 possible 3-opt configurations\n    for a, b, c in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n        if a == b or b == c or a == c:\n            continue\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[a:b] = new_solution[a:b][::-1]\n        candidate[b:c] = new_solution[b:c][::-1]\n\n        # Calculate new cost\n        new_cost = (distance_matrix_1[candidate[a-1], candidate[a]] +\n                    distance_matrix_1[candidate[b-1], candidate[b]] +\n                    distance_matrix_1[candidate[c-1], candidate[c]])\n\n        if new_cost < current_cost:\n            candidates.append((new_cost, candidate))\n\n    # If no improvement found with 3-opt, try edge insertion\n    if not candidates:\n        # Select a random edge to remove\n        remove_idx = np.random.randint(1, n-1)\n        node_to_insert = new_solution[remove_idx]\n\n        # Create candidate solution by removing the edge\n        candidate = np.delete(new_solution, remove_idx)\n        candidate = np.insert(candidate, np.random.randint(1, n-1), node_to_insert)\n\n        new_solution = candidate\n    else:\n        # Select the best candidate from 3-opt moves\n        best_cost, best_candidate = min(candidates, key=lambda x: x[0])\n        new_solution = best_candidate\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 233,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined fitness (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt-like move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel edge insertion strategy: reinsert the first node after a random position\n    if n > 3:\n        pos = np.random.randint(1, n-1)\n        node = new_solution[0]\n        new_solution = np.concatenate([new_solution[1:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility by verifying no duplicates and all nodes are present\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7460374131084648,
            1.4760419726371765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined fitness (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    selected_solution = min(archive, key=lambda x: weights[0] * x[1][0] + weights[1] * x[1][1])[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge insertion strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct indices\n    a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Apply 3-opt-like move\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n\n    # Novel edge insertion strategy: reinsert the first node after a random position\n    if n > 3:\n        pos = np.random.randint(1, n-1)\n        node = new_solution[0]\n        new_solution = np.concatenate([new_solution[1:pos], [node], new_solution[pos:]])\n\n    # Ensure feasibility by verifying no duplicates and all nodes are present\n    assert len(new_solution) == len(selected_solution)\n    assert len(np.unique(new_solution)) == len(selected_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 234,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt: reverse the middle segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Novel edge-swap: swap two edges if it improves both objectives\n        if j+1 < n and k+1 < n:\n            a, b = new_solution[j], new_solution[j+1]\n            c, d = new_solution[k], new_solution[k+1]\n\n            # Calculate original and swapped costs\n            original_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n            swapped_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n\n            original_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n            swapped_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n            # Swap if both objectives improve\n            if (swapped_cost1 < original_cost1) and (swapped_cost2 < original_cost2):\n                new_solution[j+1], new_solution[k] = new_solution[k], new_solution[j+1]\n\n    return new_solution\n\n",
        "score": [
            -0.7736786971942592,
            2.40623939037323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (lowest objective values)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap strategy\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select three distinct edges to modify\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt: reverse the middle segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Novel edge-swap: swap two edges if it improves both objectives\n        if j+1 < n and k+1 < n:\n            a, b = new_solution[j], new_solution[j+1]\n            c, d = new_solution[k], new_solution[k+1]\n\n            # Calculate original and swapped costs\n            original_cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n            swapped_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n\n            original_cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n            swapped_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n            # Swap if both objectives improve\n            if (swapped_cost1 < original_cost1) and (swapped_cost2 < original_cost2):\n                new_solution[j+1], new_solution[k] = new_solution[k], new_solution[j+1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 235,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for balancing objectives\n    best_idx = np.argmin([weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    n = len(base_solution)\n\n    # Make a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Randomly choose between three local search strategies\n    strategy = np.random.choice(['edge_inversion', 'segment_reversal', 'random_insertion'])\n\n    if strategy == 'edge_inversion':\n        # Invert a random edge by swapping two adjacent nodes\n        if n > 2:\n            i = np.random.randint(0, n - 1)\n            new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n\n    elif strategy == 'segment_reversal':\n        # Reverse a random segment of the tour\n        if n > 2:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'random_insertion':\n        # Remove a random node and reinsert it at a random position\n        if n > 2:\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = np.random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n",
        "score": [
            -0.6719179920477257,
            2.0896072387695312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.random.uniform(0.3, 0.7)  # Random weight for balancing objectives\n    best_idx = np.argmin([weights * obj[0] + (1 - weights) * obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n    n = len(base_solution)\n\n    # Make a copy of the base solution\n    new_solution = base_solution.copy()\n\n    # Randomly choose between three local search strategies\n    strategy = np.random.choice(['edge_inversion', 'segment_reversal', 'random_insertion'])\n\n    if strategy == 'edge_inversion':\n        # Invert a random edge by swapping two adjacent nodes\n        if n > 2:\n            i = np.random.randint(0, n - 1)\n            new_solution[i], new_solution[i + 1] = new_solution[i + 1], new_solution[i]\n\n    elif strategy == 'segment_reversal':\n        # Reverse a random segment of the tour\n        if n > 2:\n            i, j = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    elif strategy == 'random_insertion':\n        # Remove a random node and reinsert it at a random position\n        if n > 2:\n            i = np.random.randint(0, n)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            j = np.random.randint(0, n - 1)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n, \"Generated solution is invalid\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 236,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(int(0.3 * len(sorted_archive)), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt (select three random edges and try all possible reconnections)\n    i, j, k = sorted(random.sample(range(n), 3))\n    # Try all possible 3-opt moves\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]]),\n    ]\n\n    # Also consider a custom edge exchange (swap two non-adjacent edges)\n    if n >= 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a != b and abs(a - b) > 1:\n            candidate = new_solution.copy()\n            candidate[a], candidate[b] = candidate[b], candidate[a]\n            candidates.append(candidate)\n\n    # Evaluate all candidates and select the best one\n    best_candidate = new_solution.copy()\n    best_cost = (np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]),\n                 np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]))\n\n    for candidate in candidates:\n        cost1 = np.sum(distance_matrix_1[candidate[:-1], candidate[1:]])\n        cost2 = np.sum(distance_matrix_2[candidate[:-1], candidate[1:]])\n        if (cost1, cost2) < best_cost:\n            best_candidate = candidate.copy()\n            best_cost = (cost1, cost2)\n\n    return best_candidate\n\n",
        "score": [
            -0.8222875720792115,
            2.967576324939728
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 30% in either objective)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = min(int(0.3 * len(sorted_archive)), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform 3-opt (select three random edges and try all possible reconnections)\n    i, j, k = sorted(random.sample(range(n), 3))\n    # Try all possible 3-opt moves\n    candidates = [\n        np.concatenate([new_solution[:i], new_solution[j:k+1][::-1], new_solution[i:j], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j][::-1], new_solution[k+1:]]),\n        np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:j], new_solution[k+1:]]),\n    ]\n\n    # Also consider a custom edge exchange (swap two non-adjacent edges)\n    if n >= 4:\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        if a != b and abs(a - b) > 1:\n            candidate = new_solution.copy()\n            candidate[a], candidate[b] = candidate[b], candidate[a]\n            candidates.append(candidate)\n\n    # Evaluate all candidates and select the best one\n    best_candidate = new_solution.copy()\n    best_cost = (np.sum(distance_matrix_1[new_solution[:-1], new_solution[1:]]),\n                 np.sum(distance_matrix_2[new_solution[:-1], new_solution[1:]]))\n\n    for candidate in candidates:\n        cost1 = np.sum(distance_matrix_1[candidate[:-1], candidate[1:]])\n        cost2 = np.sum(distance_matrix_2[candidate[:-1], candidate[1:]])\n        if (cost1, cost2) < best_cost:\n            best_candidate = candidate.copy()\n            best_cost = (cost1, cost2)\n\n    return best_candidate\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 237,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    # Here, we select a solution that is not dominated by any other solution in the archive\n    non_dominated = []\n    for sol, _ in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= archive[0][1][0] and other_obj[1] <= archive[0][1][1] and\n                (other_obj[0] < archive[0][1][0] or other_obj[1] < archive[0][1][1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice([sol for sol, _ in archive]).copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment swap\n    if n >= 4:\n        # 3-opt: randomly select 3 edges and reconnect them in a different order\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a new order\n        new_order = [segment1, segment2, segment3, segment4]\n        random.shuffle(new_order)\n        new_solution = np.concatenate(new_order)\n\n    else:\n        # For small instances, use a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8996386643885708,
            2.019137740135193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    # Here, we select a solution that is not dominated by any other solution in the archive\n    non_dominated = []\n    for sol, _ in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= archive[0][1][0] and other_obj[1] <= archive[0][1][1] and\n                (other_obj[0] < archive[0][1][0] or other_obj[1] < archive[0][1][1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        base_solution = random.choice([sol for sol, _ in archive]).copy()\n    else:\n        base_solution = random.choice(non_dominated).copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel segment swap\n    if n >= 4:\n        # 3-opt: randomly select 3 edges and reconnect them in a different order\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a new order\n        new_order = [segment1, segment2, segment3, segment4]\n        random.shuffle(new_order)\n        new_solution = np.concatenate(new_order)\n\n    else:\n        # For small instances, use a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 238,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply edge insertion followed by segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge insertion: move a random segment of 2-3 nodes to a new position\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(3, n - seg_start - 1))\n    segment = new_solution[seg_start:seg_start + seg_length]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:], segment])\n\n    # Segment reversal: reverse a random segment of 2-4 nodes\n    rev_start = random.randint(0, n - 2)\n    rev_length = random.randint(2, min(4, n - rev_start))\n    new_solution[rev_start:rev_start + rev_length] = new_solution[rev_start:rev_start + rev_length][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7568591331054861,
            2.4010049700737
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected_idx = random.choices(range(len(archive)), weights=[1.0 / (i + 1) for i in range(len(archive))])[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: apply edge insertion followed by segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Edge insertion: move a random segment of 2-3 nodes to a new position\n    seg_start = random.randint(0, n - 3)\n    seg_length = random.randint(2, min(3, n - seg_start - 1))\n    segment = new_solution[seg_start:seg_start + seg_length]\n    new_solution = np.concatenate([new_solution[:seg_start], new_solution[seg_start + seg_length:], segment])\n\n    # Segment reversal: reverse a random segment of 2-4 nodes\n    rev_start = random.randint(0, n - 2)\n    rev_length = random.randint(2, min(4, n - rev_start))\n    new_solution[rev_start:rev_start + rev_length] = new_solution[rev_start:rev_start + rev_length][::-1]\n\n    # Ensure the solution remains a valid tour (no duplicates or missing nodes)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 239,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    def selection_criteria(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        # Prefer solutions with lower objectives and higher diversity\n        return (obj[0] + obj[1]) * (1 + 0.1 * np.random.random())\n\n    # Sort solutions by selection criteria and pick the top 10% for random selection\n    sorted_solutions = sorted(archive, key=selection_criteria)\n    top_k = max(1, len(sorted_solutions) // 10)\n    selected_solution = random.choice(sorted_solutions[:top_k])[0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure at least two edges are being considered\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion (move a node to a different position)\n    if n > 3:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Segment reversal with objective-aware selection\n    if n > 4:\n        # Choose a segment that would likely improve both objectives\n        best_improvement = 0\n        best_i, best_j = 0, 0\n        for _ in range(min(10, n)):  # Limit the number of trials for efficiency\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n                improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.012421696098845,
            2.7803531885147095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of objective values and diversity\n    def selection_criteria(sol_obj_pair):\n        sol, obj = sol_obj_pair\n        # Prefer solutions with lower objectives and higher diversity\n        return (obj[0] + obj[1]) * (1 + 0.1 * np.random.random())\n\n    # Sort solutions by selection criteria and pick the top 10% for random selection\n    sorted_solutions = sorted(archive, key=selection_criteria)\n    top_k = max(1, len(sorted_solutions) // 10)\n    selected_solution = random.choice(sorted_solutions[:top_k])[0].copy()\n\n    # Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n), 2))\n    if j - i > 1:  # Ensure at least two edges are being considered\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Node insertion (move a node to a different position)\n    if n > 3:\n        k = random.randint(0, n-1)\n        l = random.randint(0, n-1)\n        if k != l:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, l, node)\n\n    # Step 3: Segment reversal with objective-aware selection\n    if n > 4:\n        # Choose a segment that would likely improve both objectives\n        best_improvement = 0\n        best_i, best_j = 0, 0\n        for _ in range(min(10, n)):  # Limit the number of trials for efficiency\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i > 1:\n                # Calculate potential improvement\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n                improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_i, best_j = i, j\n\n        if best_improvement > 0:\n            new_solution[best_i:best_j+1] = new_solution[best_i:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 240,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge swap, node insertion, and segment reversal\n    n = len(new_solution)\n    operator = random.choice(['swap', 'insert', 'reverse'])\n\n    if operator == 'swap':\n        # Edge swap: swap two non-adjacent edges\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'insert':\n        # Node insertion: move a node to a different position\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'reverse':\n        # Segment reversal: reverse a random segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8715167892257576,
            2.2111538648605347
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_objectives.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge swap, node insertion, and segment reversal\n    n = len(new_solution)\n    operator = random.choice(['swap', 'insert', 'reverse'])\n\n    if operator == 'swap':\n        # Edge swap: swap two non-adjacent edges\n        i, j = sorted(random.sample(range(n), 2))\n        if abs(i - j) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    elif operator == 'insert':\n        # Node insertion: move a node to a different position\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, len(new_solution)-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    elif operator == 'reverse':\n        # Segment reversal: reverse a random segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 241,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its dominance rank (higher rank = more promising)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Edge exchange (2-opt variant)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment inversion with probabilistic segment length\n    seg_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - seg_length)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback to a random swap if inversion causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9509826383602927,
            1.8042206764221191
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability proportional to its dominance rank (higher rank = more promising)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange with segment inversion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply operators\n\n    # Edge exchange (2-opt variant)\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment inversion with probabilistic segment length\n    seg_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - seg_length)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility (no duplicates and all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # Fallback to a random swap if inversion causes duplicates\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 242,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (biased toward lower cost solutions)\n    weights = [1.0 / (1 + obj[0] + obj[1]) for (_, obj) in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    # Case 1: a -> b -> c -> (rest)\n    # Case 2: a -> c -> b -> (rest)\n    # Case 3: a -> b -> (rest) -> c\n    # We randomly choose one of these cases\n    case = random.randint(1, 3)\n\n    if case == 1:\n        # No change needed (original order)\n        pass\n    elif case == 2:\n        # Reverse segment between b and c\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    elif case == 3:\n        # Move segment between b and c to the end\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # With 20% probability, perform a biased random walk to escape local optima\n    if random.random() < 0.2:\n        # Select two random nodes and swap them\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8619948358061534,
            2.4421711564064026
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (biased toward lower cost solutions)\n    weights = [1.0 / (1 + obj[0] + obj[1]) for (_, obj) in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    # Case 1: a -> b -> c -> (rest)\n    # Case 2: a -> c -> b -> (rest)\n    # Case 3: a -> b -> (rest) -> c\n    # We randomly choose one of these cases\n    case = random.randint(1, 3)\n\n    if case == 1:\n        # No change needed (original order)\n        pass\n    elif case == 2:\n        # Reverse segment between b and c\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n    elif case == 3:\n        # Move segment between b and c to the end\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # With 20% probability, perform a biased random walk to escape local optima\n    if random.random() < 0.2:\n        # Select two random nodes and swap them\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 243,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Solutions with higher potential (lower cost) are more likely to be selected\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(costs == costs[0]):\n        # If all costs are equal, choose randomly\n        idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to probabilities\n        probs = (costs.max() - costs) / (costs.max() - costs.min() + 1e-10)\n        probs = probs / probs.sum()\n        idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine segment reversal with node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to reverse\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Select a random node to insert elsewhere\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8502438267410466,
            2.343727767467499
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    # Solutions with higher potential (lower cost) are more likely to be selected\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(costs == costs[0]):\n        # If all costs are equal, choose randomly\n        idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to probabilities\n        probs = (costs.max() - costs) / (costs.max() - costs.min() + 1e-10)\n        probs = probs / probs.sum()\n        idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine segment reversal with node insertion\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, just swap two random nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select a random segment to reverse\n        start, end = sorted(random.sample(range(n), 2))\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Select a random node to insert elsewhere\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 244,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with a bi-objective aware perturbation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_segment = np.concatenate([segment1, segment2[::-1]])\n    new_solution[i:k] = new_segment\n\n    # Bi-objective aware perturbation: swap two nodes if it improves both objectives\n    for _ in range(min(3, n // 2)):  # Limit perturbations to avoid excessive changes\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and new costs for both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept swap if both objectives improve\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.7183182653618915,
            2.217693567276001
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Combine 3-opt with a bi-objective aware perturbation\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # No improvement possible\n\n    # Randomly select three distinct edges to modify\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_segment = np.concatenate([segment1, segment2[::-1]])\n    new_solution[i:k] = new_segment\n\n    # Bi-objective aware perturbation: swap two nodes if it improves both objectives\n    for _ in range(min(3, n // 2)):  # Limit perturbations to avoid excessive changes\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and new costs for both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n        # Accept swap if both objectives improve\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 245,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge swap\n    if j - i > 1:\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Segment reversal (random segment flip)\n    k, l = np.random.choice(n, 2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l] = base_solution[k:l][::-1]\n\n    # Ensure feasibility: check for duplicates or missing nodes\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8802677060339796,
            1.4875909090042114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high potential for improvement (e.g., not Pareto-optimal or with high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge swaps and segment reversals\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge swap\n    if j - i > 1:\n        new_solution[i:j] = base_solution[i:j][::-1]\n\n    # Segment reversal (random segment flip)\n    k, l = np.random.choice(n, 2, replace=False)\n    k, l = min(k, l), max(k, l)\n    new_solution[k:l] = base_solution[k:l][::-1]\n\n    # Ensure feasibility: check for duplicates or missing nodes\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 246,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution in the archive based on their objective values\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize costs to avoid bias towards one objective\n        normalized_cost = (cost1 - np.min(distance_matrix_1)) / (np.max(distance_matrix_1) - np.min(distance_matrix_1) + 1e-10) + \\\n                          (cost2 - np.min(distance_matrix_2)) / (np.max(distance_matrix_2) - np.min(distance_matrix_2) + 1e-10)\n        scores.append(normalized_cost)\n\n    # Select the solution with the lowest score (best combined performance)\n    min_score_idx = np.argmin(scores)\n    base_solution = archive[min_score_idx][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with segment-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select 3 random points to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform the 3-opt move\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # There are 8 possible ways to reconnect the segments in 3-opt\n    # We'll randomly select one of them\n    reconnection = random.randint(0, 7)\n\n    if reconnection == 0:\n        new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n    elif reconnection == 1:\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3, segment4])\n    elif reconnection == 2:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    elif reconnection == 3:\n        new_solution = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    elif reconnection == 4:\n        new_solution = np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    elif reconnection == 5:\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n    elif reconnection == 6:\n        new_solution = np.concatenate([segment1, segment3, segment2[::-1], segment4])\n    else:\n        new_solution = np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n\n    # Additionally, apply a segment-based perturbation to further explore the neighborhood\n    if n > 5 and random.random() < 0.3:  # 30% chance to apply perturbation\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, min(seg_start+5, n-1))\n        segment = new_solution[seg_start:seg_end]\n\n        # Choose a perturbation: reverse, rotate, or shuffle\n        perturbation = random.choice(['reverse', 'rotate', 'shuffle'])\n\n        if perturbation == 'reverse':\n            new_solution[seg_start:seg_end] = segment[::-1]\n        elif perturbation == 'rotate':\n            shift = random.randint(1, len(segment)-1)\n            new_solution[seg_start:seg_end] = np.roll(segment, shift)\n        else:  # shuffle\n            np.random.shuffle(new_solution[seg_start:seg_end])\n\n    return new_solution\n\n",
        "score": [
            -0.7316277516975358,
            5.728785693645477
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate a score for each solution in the archive based on their objective values\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize costs to avoid bias towards one objective\n        normalized_cost = (cost1 - np.min(distance_matrix_1)) / (np.max(distance_matrix_1) - np.min(distance_matrix_1) + 1e-10) + \\\n                          (cost2 - np.min(distance_matrix_2)) / (np.max(distance_matrix_2) - np.min(distance_matrix_2) + 1e-10)\n        scores.append(normalized_cost)\n\n    # Select the solution with the lowest score (best combined performance)\n    min_score_idx = np.argmin(scores)\n    base_solution = archive[min_score_idx][0].copy()\n\n    # Create a copy of the base solution to modify\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt with segment-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # For very small tours, just perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select 3 random points to perform 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Perform the 3-opt move\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # There are 8 possible ways to reconnect the segments in 3-opt\n    # We'll randomly select one of them\n    reconnection = random.randint(0, 7)\n\n    if reconnection == 0:\n        new_solution = np.concatenate([segment1, segment2, segment3, segment4])\n    elif reconnection == 1:\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3, segment4])\n    elif reconnection == 2:\n        new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n    elif reconnection == 3:\n        new_solution = np.concatenate([segment1, segment3[::-1], segment2, segment4])\n    elif reconnection == 4:\n        new_solution = np.concatenate([segment1, segment2, segment3[::-1], segment4])\n    elif reconnection == 5:\n        new_solution = np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n    elif reconnection == 6:\n        new_solution = np.concatenate([segment1, segment3, segment2[::-1], segment4])\n    else:\n        new_solution = np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n\n    # Additionally, apply a segment-based perturbation to further explore the neighborhood\n    if n > 5 and random.random() < 0.3:  # 30% chance to apply perturbation\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, min(seg_start+5, n-1))\n        segment = new_solution[seg_start:seg_end]\n\n        # Choose a perturbation: reverse, rotate, or shuffle\n        perturbation = random.choice(['reverse', 'rotate', 'shuffle'])\n\n        if perturbation == 'reverse':\n            new_solution[seg_start:seg_end] = segment[::-1]\n        elif perturbation == 'rotate':\n            shift = random.randint(1, len(segment)-1)\n            new_solution[seg_start:seg_end] = np.roll(segment, shift)\n        else:  # shuffle\n            np.random.shuffle(new_solution[seg_start:seg_end])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 247,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, _ in archive:\n        # Check if the solution is not dominated by others in the archive\n        is_dominated = False\n        for _, (obj1, obj2) in archive:\n            if (obj1 < sol[0] and obj2 < sol[1]) or (obj1 <= sol[0] and obj2 < sol[1]) or (obj1 < sol[0] and obj2 <= sol[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge exchange strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge exchange strategy: swap edges based on both objectives\n    for _ in range(2):  # Perform a few exchanges\n        a, b, c, d = random.sample(range(n), 4)\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                  distance_matrix_1[new_solution[b], new_solution[d]]) - \\\n                 (distance_matrix_1[new_solution[a], new_solution[b]] +\n                  distance_matrix_1[new_solution[c], new_solution[d]])\n        delta2 = (distance_matrix_2[new_solution[a], new_solution[c]] +\n                  distance_matrix_2[new_solution[b], new_solution[d]]) - \\\n                 (distance_matrix_2[new_solution[a], new_solution[b]] +\n                  distance_matrix_2[new_solution[c], new_solution[d]])\n\n        # Apply the exchange if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n",
        "score": [
            -0.7460513182893417,
            2.643548309803009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, _ in archive:\n        # Check if the solution is not dominated by others in the archive\n        is_dominated = False\n        for _, (obj1, obj2) in archive:\n            if (obj1 < sol[0] and obj2 < sol[1]) or (obj1 <= sol[0] and obj2 < sol[1]) or (obj1 < sol[0] and obj2 <= sol[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge exchange strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform 2-opt on a random segment\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge exchange strategy: swap edges based on both objectives\n    for _ in range(2):  # Perform a few exchanges\n        a, b, c, d = random.sample(range(n), 4)\n        # Calculate the change in both objectives\n        delta1 = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                  distance_matrix_1[new_solution[b], new_solution[d]]) - \\\n                 (distance_matrix_1[new_solution[a], new_solution[b]] +\n                  distance_matrix_1[new_solution[c], new_solution[d]])\n        delta2 = (distance_matrix_2[new_solution[a], new_solution[c]] +\n                  distance_matrix_2[new_solution[b], new_solution[d]]) - \\\n                 (distance_matrix_2[new_solution[a], new_solution[b]] +\n                  distance_matrix_2[new_solution[c], new_solution[d]])\n\n        # Apply the exchange if it improves at least one objective\n        if delta1 < 0 or delta2 < 0:\n            new_solution[[a, b, c, d]] = new_solution[[a, c, b, d]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 248,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    total_cost = sum(cost1 + cost2 for _, (cost1, cost2) in archive)\n    if total_cost == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        weights = [(cost1 + cost2) / total_cost for _, (cost1, cost2) in archive]\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two distinct segments to operate on\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Determine the operation to perform\n        operation = random.choice(['insertion', 'reversal'])\n\n        if operation == 'insertion':\n            # Edge insertion: move segment [a:b] to position c\n            segment = new_solution[a:b].copy()\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n        else:\n            # Segment reversal: reverse segment [a:b]\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8380549867145631,
            1.9611135125160217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability proportional to its potential for improvement\n    total_cost = sum(cost1 + cost2 for _, (cost1, cost2) in archive)\n    if total_cost == 0:\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        weights = [(cost1 + cost2) / total_cost for _, (cost1, cost2) in archive]\n        selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two distinct segments to operate on\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        c, d = sorted(random.sample(range(1, n-1), 2))\n\n        # Determine the operation to perform\n        operation = random.choice(['insertion', 'reversal'])\n\n        if operation == 'insertion':\n            # Edge insertion: move segment [a:b] to position c\n            segment = new_solution[a:b].copy()\n            new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n            new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:]])\n        else:\n            # Segment reversal: reverse segment [a:b]\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 249,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        top_20_percent = int(0.2 * len(sorted_archive)) + 1\n        candidates = sorted_archive[:top_20_percent]\n        selected = random.choice(candidates)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and node swap\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion: insert a node between two existing edges\n        if j - i > 1:\n            k = random.randint(0, n - 1)\n            while k in [i, j, (i+1)%n, (j+1)%n]:\n                k = random.randint(0, n - 1)\n            # Insert node k between i and j\n            new_solution = np.insert(new_solution, i+1, new_solution[k])\n            new_solution = np.delete(new_solution, k if k > i+1 else k+1)\n\n        # Node swap: swap two nodes to improve local structure\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(set(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6174576840886673,
            13.974957406520844
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n        top_20_percent = int(0.2 * len(sorted_archive)) + 1\n        candidates = sorted_archive[:top_20_percent]\n        selected = random.choice(candidates)\n        base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combination of edge insertion and node swap\n    n = len(new_solution)\n    for _ in range(10):  # Perform multiple iterations for better exploration\n        # Randomly select two distinct edges to modify\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Edge insertion: insert a node between two existing edges\n        if j - i > 1:\n            k = random.randint(0, n - 1)\n            while k in [i, j, (i+1)%n, (j+1)%n]:\n                k = random.randint(0, n - 1)\n            # Insert node k between i and j\n            new_solution = np.insert(new_solution, i+1, new_solution[k])\n            new_solution = np.delete(new_solution, k if k > i+1 else k+1)\n\n        # Node swap: swap two nodes to improve local structure\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains a valid tour\n    if len(new_solution) != len(base_solution) or len(set(new_solution)) != len(base_solution):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 250,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (could be replaced with other selection criteria)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a solution that is not the best or worst to ensure diversity\n        selected_idx = min(1, len(sorted_archive) - 2)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine a custom operator with a randomized approach\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments to reverse (similar to 2-opt but more flexible)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    if j - i < 2:\n        # Ensure segments are not too small\n        i, j = (i - 1) % n, (j + 1) % n\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a randomized swap to further diversify\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7875373142025143,
            1.9753959774971008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (could be replaced with other selection criteria)\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select a solution that is not the best or worst to ensure diversity\n        selected_idx = min(1, len(sorted_archive) - 2)\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine a custom operator with a randomized approach\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select two non-adjacent segments to reverse (similar to 2-opt but more flexible)\n    i, j = np.random.choice(n, size=2, replace=False)\n    i, j = min(i, j), max(i, j)\n    if j - i < 2:\n        # Ensure segments are not too small\n        i, j = (i - 1) % n, (j + 1) % n\n\n    # Reverse the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Apply a randomized swap to further diversify\n    a, b = np.random.choice(n, size=2, replace=False)\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 251,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with probability proportional to its rank in the archive\n    ranks = np.argsort([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment-based perturbation\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment-based perturbation: reverse a random segment of the tour\n    if random.random() < 0.3:  # 30% chance to apply segment-based perturbation\n        seg_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - seg_length)\n        end = start + seg_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n_nodes:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7843895900457293,
            2.2031601667404175
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution with probability proportional to its rank in the archive\n    ranks = np.argsort([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = random.choices(range(len(archive)), weights=[1/(i+1) for i in ranks])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine edge exchange with segment-based perturbation\n    new_solution = base_solution.copy()\n    n_nodes = len(new_solution)\n\n    # Edge exchange (similar to 2-opt but with a twist)\n    i, j = sorted(random.sample(range(n_nodes), 2))\n    new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment-based perturbation: reverse a random segment of the tour\n    if random.random() < 0.3:  # 30% chance to apply segment-based perturbation\n        seg_length = random.randint(2, min(5, n_nodes // 2))\n        start = random.randint(0, n_nodes - seg_length)\n        end = start + seg_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n_nodes:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 252,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection probability\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = objectives / (max_obj + 1e-10)  # Avoid division by zero\n    total_obj = np.sum(normalized_obj, axis=1)\n    probabilities = total_obj / np.sum(total_obj)\n\n    # Select a solution based on the calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge swapping and segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Edge swapping (2-opt variant but with objective-aware selection)\n    a, b = sorted(random.sample(range(n), 2))\n    if a == b or (a + 1) % n == b or (b + 1) % n == a:\n        return new_solution  # Skip invalid swaps\n\n    # Evaluate the current and swapped segments\n    current_cost_1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    current_cost_2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    swapped_cost_1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n    swapped_cost_2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n    # Accept the swap if it improves both objectives\n    if (swapped_cost_1 < current_cost_1) and (swapped_cost_2 < current_cost_2):\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    # Segment relocation (novel operator)\n    if n >= 6:\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, min(seg_start+3, n-1))\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Evaluate insertion points\n        best_insert_pos = -1\n        best_cost_1 = float('inf')\n        best_cost_2 = float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos <= seg_end:\n                continue  # Skip positions within the segment\n\n            # Calculate cost of inserting the segment at position 'pos'\n            prev_node = new_solution[(pos-1) % n]\n            next_node = new_solution[pos % n]\n            cost_1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            cost_2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n            if cost_1 < best_cost_1 and cost_2 < best_cost_2:\n                best_cost_1 = cost_1\n                best_cost_2 = cost_2\n                best_insert_pos = pos\n\n        # Perform the relocation if beneficial\n        if best_insert_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_end+1:],\n                segment\n            ])\n            new_solution = np.roll(new_solution, -best_insert_pos)\n\n    return new_solution\n\n",
        "score": [
            -0.6659557354184817,
            3.0332460403442383
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate normalized objective values for selection probability\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = objectives / (max_obj + 1e-10)  # Avoid division by zero\n    total_obj = np.sum(normalized_obj, axis=1)\n    probabilities = total_obj / np.sum(total_obj)\n\n    # Select a solution based on the calculated probabilities\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge swapping and segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # Edge swapping (2-opt variant but with objective-aware selection)\n    a, b = sorted(random.sample(range(n), 2))\n    if a == b or (a + 1) % n == b or (b + 1) % n == a:\n        return new_solution  # Skip invalid swaps\n\n    # Evaluate the current and swapped segments\n    current_cost_1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    current_cost_2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    swapped_cost_1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n    swapped_cost_2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n    # Accept the swap if it improves both objectives\n    if (swapped_cost_1 < current_cost_1) and (swapped_cost_2 < current_cost_2):\n        new_solution[a+1:b+1] = new_solution[a+1:b+1][::-1]\n\n    # Segment relocation (novel operator)\n    if n >= 6:\n        seg_start = random.randint(0, n-3)\n        seg_end = random.randint(seg_start+2, min(seg_start+3, n-1))\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Evaluate insertion points\n        best_insert_pos = -1\n        best_cost_1 = float('inf')\n        best_cost_2 = float('inf')\n\n        for pos in range(n):\n            if pos >= seg_start and pos <= seg_end:\n                continue  # Skip positions within the segment\n\n            # Calculate cost of inserting the segment at position 'pos'\n            prev_node = new_solution[(pos-1) % n]\n            next_node = new_solution[pos % n]\n            cost_1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n            cost_2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n            if cost_1 < best_cost_1 and cost_2 < best_cost_2:\n                best_cost_1 = cost_1\n                best_cost_2 = cost_2\n                best_insert_pos = pos\n\n        # Perform the relocation if beneficial\n        if best_insert_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_end+1:],\n                segment\n            ])\n            new_solution = np.roll(new_solution, -best_insert_pos)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 253,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Segment relocation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # Too small to perform meaningful operations, return a random neighbor\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 2, n)\n    segment = base_solution[segment_start:segment_end]\n\n    # Step 2: Remove the segment from the solution\n    remaining = np.concatenate([base_solution[:segment_start], base_solution[segment_end:]])\n\n    # Step 3: Find the best insertion point for the segment\n    best_insert_pos = 0\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Insert segment after position i\n        candidate = np.concatenate([remaining[:i+1], segment, remaining[i+1:]])\n        # Calculate cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Simple weighted sum for selection\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = i + 1\n\n    # Step 4: Insert the segment at the best position\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Step 5: Additional edge insertion for further improvement\n    for _ in range(2):  # Perform 2 edge insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and abs(i - j) > 1:\n            # Insert node j after node i\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:]])\n            new_solution = np.delete(new_solution, j if j > i else j + 1)\n\n    return new_solution\n\n",
        "score": [
            -0.9433060405446734,
            6.7309765219688416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: Segment relocation with edge insertion\n    n = len(base_solution)\n    if n < 4:\n        # Too small to perform meaningful operations, return a random neighbor\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Step 1: Select a random segment to relocate\n    segment_start = np.random.randint(0, n - 2)\n    segment_end = np.random.randint(segment_start + 2, n)\n    segment = base_solution[segment_start:segment_end]\n\n    # Step 2: Remove the segment from the solution\n    remaining = np.concatenate([base_solution[:segment_start], base_solution[segment_end:]])\n\n    # Step 3: Find the best insertion point for the segment\n    best_insert_pos = 0\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Insert segment after position i\n        candidate = np.concatenate([remaining[:i+1], segment, remaining[i+1:]])\n        # Calculate cost in both objective spaces\n        cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2  # Simple weighted sum for selection\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = i + 1\n\n    # Step 4: Insert the segment at the best position\n    new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Step 5: Additional edge insertion for further improvement\n    for _ in range(2):  # Perform 2 edge insertions\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j and abs(i - j) > 1:\n            # Insert node j after node i\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:]])\n            new_solution = np.delete(new_solution, j if j > i else j + 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 254,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives[:, 0]) + np.argsort(objectives[:, 1]))  # Non-dominated sorting\n    probabilities = 1 / (ranks + 1)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of segment inversion and node reinsertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two local search strategies\n    if random.random() < 0.5:\n        # Segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node reinsertion\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7977885750815356,
            1.9866222143173218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance\n    objectives = np.array([obj for _, obj in archive])\n    ranks = np.argsort(np.argsort(objectives[:, 0]) + np.argsort(objectives[:, 1]))  # Non-dominated sorting\n    probabilities = 1 / (ranks + 1)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of segment inversion and node reinsertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two local search strategies\n    if random.random() < 0.5:\n        # Segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Node reinsertion\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains feasible (no duplicates and all nodes visited)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 255,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we choose a solution with a balanced objective trade-off)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: a combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but with more flexibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly insert a node into a different position (edge insertion)\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != len(base_solution):\n        return base_solution  # Revert to original if invalid\n\n    return new_solution\n\n",
        "score": [
            -0.8550033625001825,
            1.8354024291038513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (here, we choose a solution with a balanced objective trade-off)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: a combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Step 1: Randomly select a segment to reverse (similar to 2-opt but with more flexibility)\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Randomly insert a node into a different position (edge insertion)\n    k = random.randint(0, n - 1)\n    node = new_solution[k]\n    new_solution = np.delete(new_solution, k)\n    insert_pos = random.randint(0, n - 2)\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != len(base_solution):\n        return base_solution  # Revert to original if invalid\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 256,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance count\n    # (simplified approach for selection)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
        "score": [
            -0.860153778242637,
            1.6245670318603516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance count\n    # (simplified approach for selection)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combination of edge insertion and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly select an edge to insert elsewhere\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    assert len(new_solution) == n\n    assert len(np.unique(new_solution)) == n\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 257,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high probability if it has low cost in either objective\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize costs to prioritize solutions with better performance\n        norm_cost = min(cost1 / distance_matrix_1.max(), cost2 / distance_matrix_2.max())\n        candidates.append((sol, norm_cost))\n\n    # Sort by normalized cost (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 20% or at least 1 solution\n    top_k = max(1, len(candidates) // 5)\n    selected_sol, _ = random.choice(candidates[:top_k])\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two segments to exchange\n    i, j = sorted(random.sample(range(1, n), 2))\n\n    # Edge exchange: swap edges (i-1, i) and (j-1, j) with (i-1, j) and (i, j-1)\n    if random.random() < 0.7:  # 70% chance of edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance of segment reversal\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to a small perturbation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4098716924514865,
            2.3422122597694397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high probability if it has low cost in either objective\n    candidates = []\n    for sol, (cost1, cost2) in archive:\n        # Normalize costs to prioritize solutions with better performance\n        norm_cost = min(cost1 / distance_matrix_1.max(), cost2 / distance_matrix_2.max())\n        candidates.append((sol, norm_cost))\n\n    # Sort by normalized cost (lower is better)\n    candidates.sort(key=lambda x: x[1])\n    # Select top 20% or at least 1 solution\n    top_k = max(1, len(candidates) // 5)\n    selected_sol, _ = random.choice(candidates[:top_k])\n\n    new_solution = selected_sol.copy()\n\n    # Hybrid local search strategy: combination of edge exchange and segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select two segments to exchange\n    i, j = sorted(random.sample(range(1, n), 2))\n\n    # Edge exchange: swap edges (i-1, i) and (j-1, j) with (i-1, j) and (i, j-1)\n    if random.random() < 0.7:  # 70% chance of edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance of segment reversal\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to a small perturbation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 258,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    # Solutions with higher costs are more likely to be selected for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    costs = objectives.sum(axis=1)\n    probs = costs / costs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion with segment relocation\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Edge insertion: randomly select two edges and insert a segment between them\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Remove the segment from its current position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Insert the segment at a new random position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Segment relocation: move a random segment to a new position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Insert the segment at a new position, ensuring feasibility\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (visits each node exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8055668047462801,
            2.423059105873108
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    # Solutions with higher costs are more likely to be selected for improvement\n    solutions, objectives = zip(*archive)\n    objectives = np.array(objectives)\n    costs = objectives.sum(axis=1)\n    probs = costs / costs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge insertion with segment relocation\n    for _ in range(2):  # Perform multiple iterations for better exploration\n        # Edge insertion: randomly select two edges and insert a segment between them\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Remove the segment from its current position\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Insert the segment at a new random position\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Segment relocation: move a random segment to a new position\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:]])\n\n        # Insert the segment at a new position, ensuring feasibility\n        insert_pos = random.randint(0, len(new_solution) - 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains a valid tour (visits each node exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 259,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of diversification and intensification criteria\n    # Here we use a simple approach: select a solution with a good balance between both objectives\n    # using a weighted sum of the normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)  # Select the solution with the best score\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # First, perform a segment relocation (move a random segment of the tour to a different position)\n    segment_length = random.randint(2, min(5, n // 3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Then, perform a limited number of edge exchanges (2-opt-like) to improve the solution\n    for _ in range(min(3, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.751782574258263,
            2.540235459804535
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution based on a combination of diversification and intensification criteria\n    # Here we use a simple approach: select a solution with a good balance between both objectives\n    # using a weighted sum of the normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    weights = np.array([0.5, 0.5])  # Equal weight for both objectives\n    scores = np.dot(normalized_obj, weights)\n    selected_idx = np.argmin(scores)  # Select the solution with the best score\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # First, perform a segment relocation (move a random segment of the tour to a different position)\n    segment_length = random.randint(2, min(5, n // 3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start + segment_length:]])\n\n    # Insert the segment at a new random position\n    insert_pos = random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Then, perform a limited number of edge exchanges (2-opt-like) to improve the solution\n    for _ in range(min(3, n // 2)):\n        i, j = sorted(random.sample(range(n), 2))\n        if i != j:\n            # Reverse the segment between i and j\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 260,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(total_costs == total_costs[0]):\n        # If all costs are equal, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to get probabilities\n        inv_costs = 1.0 / (total_costs + 1e-10)  # Add small epsilon to avoid division by zero\n        probabilities = inv_costs / np.sum(inv_costs)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful operations\n\n    # First, perform a randomized 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create three possible 3-opt moves and choose the best one\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[c:b-1:-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b][::-1], new_solution[c+1:]])\n    ]\n\n    # Evaluate each option using both distance matrices\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return cost1 + cost2\n\n    best_option = min(options, key=evaluate)\n    new_solution = best_option.copy()\n\n    # Then perform a custom edge-swap based on both objectives\n    for _ in range(2):  # Try a few edge swaps\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue  # Avoid trivial swaps\n\n        # Try swapping edges (i,i+1) and (j,j+1) with (i,j) and (i+1,j+1)\n        i, j = sorted([i, j])\n        if j - i < 2:\n            continue\n\n        # Create two possible swaps\n        swap1 = new_solution.copy()\n        swap1[i+1:j+1] = swap1[i+1:j+1][::-1]\n\n        swap2 = new_solution.copy()\n        swap2[i] = new_solution[j]\n        swap2[j] = new_solution[i]\n\n        # Evaluate both swaps\n        current_cost = evaluate(new_solution)\n        cost1 = evaluate(swap1)\n        cost2 = evaluate(swap2)\n\n        if cost1 < current_cost:\n            new_solution = swap1.copy()\n        elif cost2 < current_cost:\n            new_solution = swap2.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8684646856472362,
            3.1970882415771484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    total_costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(total_costs == total_costs[0]):\n        # If all costs are equal, select randomly\n        selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        # Normalize costs to get probabilities\n        inv_costs = 1.0 / (total_costs + 1e-10)  # Add small epsilon to avoid division by zero\n        probabilities = inv_costs / np.sum(inv_costs)\n        selected_idx = np.random.choice(len(archive), p=probabilities)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a custom edge-swap\n    n = len(new_solution)\n    if n < 3:\n        return new_solution  # Too small for meaningful operations\n\n    # First, perform a randomized 3-opt\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create three possible 3-opt moves and choose the best one\n    options = [\n        np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[c:b-1:-1], new_solution[a:b], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b][::-1], new_solution[c+1:]])\n    ]\n\n    # Evaluate each option using both distance matrices\n    def evaluate(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return cost1 + cost2\n\n    best_option = min(options, key=evaluate)\n    new_solution = best_option.copy()\n\n    # Then perform a custom edge-swap based on both objectives\n    for _ in range(2):  # Try a few edge swaps\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) < 2:\n            continue  # Avoid trivial swaps\n\n        # Try swapping edges (i,i+1) and (j,j+1) with (i,j) and (i+1,j+1)\n        i, j = sorted([i, j])\n        if j - i < 2:\n            continue\n\n        # Create two possible swaps\n        swap1 = new_solution.copy()\n        swap1[i+1:j+1] = swap1[i+1:j+1][::-1]\n\n        swap2 = new_solution.copy()\n        swap2[i] = new_solution[j]\n        swap2[j] = new_solution[i]\n\n        # Evaluate both swaps\n        current_cost = evaluate(new_solution)\n        cost1 = evaluate(swap1)\n        cost2 = evaluate(swap2)\n\n        if cost1 < current_cost:\n            new_solution = swap1.copy()\n        elif cost2 < current_cost:\n            new_solution = swap2.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 261,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by cost)\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (costs - costs.min()) / (costs.max() - costs.min() + 1e-10)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of 3-opt and edge exchange\n    for _ in range(10):  # Number of iterations\n        # Randomly select 3 distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Evaluate the new solution\n        cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # If the solution is worse, revert with probability based on the temperature\n        if random.random() < 0.3:  # Simulated annealing acceptance probability\n            new_solution = base_solution.copy()\n\n    # Edge exchange: swap two random edges\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7933935181823049,
            4.837022006511688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by cost)\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (costs - costs.min()) / (costs.max() - costs.min() + 1e-10)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combination of 3-opt and edge exchange\n    for _ in range(10):  # Number of iterations\n        # Randomly select 3 distinct positions\n        i, j, k = sorted(random.sample(range(n), 3))\n\n        # Apply 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n        # Evaluate the new solution\n        cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        # If the solution is worse, revert with probability based on the temperature\n        if random.random() < 0.3:  # Simulated annealing acceptance probability\n            new_solution = base_solution.copy()\n\n    # Edge exchange: swap two random edges\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 262,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 3-opt and node insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply 3-opt\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = base_solution[a:b]\n        segment2 = base_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        # Apply node insertion\n        if random.random() < 0.5:  # 50% chance to apply insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to simple swap if infeasible\n        i, j = random.sample(range(n), 2)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7545421480296853,
            2.5393940210342407
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (lowest sum of objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = min(3, len(archive_sorted) - 1)  # Select from top 3 solutions\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combination of 3-opt and node insertion\n    n = len(base_solution)\n    if n < 4:\n        # For small instances, just swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Apply 3-opt\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = base_solution[a:b]\n        segment2 = base_solution[b:c]\n        new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        # Apply node insertion\n        if random.random() < 0.5:  # 50% chance to apply insertion\n            i, j = random.sample(range(n), 2)\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = random.randint(0, n-2)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to simple swap if infeasible\n        i, j = random.sample(range(n), 2)\n        new_solution = base_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 263,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (1 / costs) / np.sum(1 / costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Probabilistic segment reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if np.random.random() < 0.7:  # Higher probability for segment reversal\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Edge insertion with probabilistic selection\n    if np.random.random() < 0.5:  # Probability to apply edge insertion\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if c != a and d != b:  # Ensure distinct segments\n            segment = new_solution[c:d]\n            new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:d], new_solution[d:]])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to a simple 2-opt move if the above operations break validity\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8089033435087765,
            2.0515211820602417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards those with lower combined cost\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    probabilities = (1 / costs) / np.sum(1 / costs)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: probabilistic segment reversal with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Probabilistic segment reversal\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if np.random.random() < 0.7:  # Higher probability for segment reversal\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Edge insertion with probabilistic selection\n    if np.random.random() < 0.5:  # Probability to apply edge insertion\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        if c != a and d != b:  # Ensure distinct segments\n            segment = new_solution[c:d]\n            new_solution = np.concatenate([new_solution[:c], segment, new_solution[c:d], new_solution[d:]])\n\n    # Ensure the solution remains a valid tour\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to a simple 2-opt move if the above operations break validity\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 264,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    objectives = np.array([obj for (sol, obj) in archive])\n    # Normalize objectives to [0, 1] range for comparison\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    # Select the solution with the highest combined normalized objective value\n    selected_idx = np.argmax(normalized_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move (reversing the middle segment)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom edge-swap strategy: swap two edges if it improves both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge-swap\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]]\n\n        # Apply swap if it improves both objectives\n        if (new_dist1 < current_dist1) and (new_dist2 < current_dist2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8574607149214495,
            2.0721744298934937
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., solutions with high objective values)\n    objectives = np.array([obj for (sol, obj) in archive])\n    # Normalize objectives to [0, 1] range for comparison\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    # Select the solution with the highest combined normalized objective value\n    selected_idx = np.argmax(normalized_obj.sum(axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt with a custom edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, size=3, replace=False))\n\n    # Perform 3-opt move (reversing the middle segment)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Custom edge-swap strategy: swap two edges if it improves both objectives\n    if np.random.rand() < 0.5:  # 50% chance to apply edge-swap\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        # Calculate current and new distances for both objectives\n        current_dist1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        new_dist1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n\n        current_dist2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n        new_dist2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]]\n\n        # Apply swap if it improves both objectives\n        if (new_dist1 < current_dist1) and (new_dist2 < current_dist2):\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 265,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(sorted_archive) * 0.7), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverses the middle segment)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge-swap operator: swap edges between segments\n    if random.random() < 0.5:  # 50% chance to apply this operator\n        # Select two additional distinct positions\n        a, b = sorted(random.sample(range(n), 2))\n        # Swap edges between segments\n        new_solution[a], new_solution[i] = new_solution[i], new_solution[a]\n        new_solution[b], new_solution[j] = new_solution[j], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8434944620890275,
            1.9841108918190002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not too close to the Pareto front)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    selected_idx = min(int(len(sorted_archive) * 0.7), len(sorted_archive) - 1)\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct positions\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move (reverses the middle segment)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Novel edge-swap operator: swap edges between segments\n    if random.random() < 0.5:  # 50% chance to apply this operator\n        # Select two additional distinct positions\n        a, b = sorted(random.sample(range(n), 2))\n        # Swap edges between segments\n        new_solution[a], new_solution[i] = new_solution[i], new_solution[a]\n        new_solution[b], new_solution[j] = new_solution[j], new_solution[b]\n\n    # Ensure the solution remains valid (no duplicates, all nodes present)\n    if len(set(new_solution)) != n:\n        # Fallback to simple 2-opt if the solution becomes invalid\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 266,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (minimize both objectives)\n    # We prioritize solutions that are not dominated by others and have high variance in objectives\n    archive_with_metrics = []\n    for sol, obj in archive:\n        # Calculate dominance count (number of solutions that dominate this one)\n        dominance_count = sum(1 for _, other_obj in archive if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]))\n        # Calculate objective variance (to identify solutions that are balanced)\n        obj_variance = abs(obj[0] - obj[1])\n        archive_with_metrics.append((sol, obj, dominance_count, obj_variance))\n\n    # Sort by dominance count (ascending) and then by objective variance (descending)\n    archive_with_metrics.sort(key=lambda x: (x[2], -x[3]))\n    base_solution = archive_with_metrics[0][0].copy()\n\n    # Novel local search strategy: \"Bi-Objective Edge Swap with Relocation\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify (prevents getting stuck in local optima)\n    segment_length = max(2, min(n // 3, np.random.randint(2, 5)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Reverse the segment (similar to 2-opt but more disruptive)\n    segment = segment[::-1]\n\n    # Reinsert the modified segment\n    new_solution[start:end] = segment\n\n    # Additional improvement: Relocate a random node to a random position\n    if np.random.random() < 0.3:  # 30% chance to apply relocation\n        node_to_relocate = np.random.randint(0, n)\n        new_pos = np.random.randint(0, n)\n        node = new_solution[node_to_relocate]\n        new_solution = np.concatenate([new_solution[:node_to_relocate], new_solution[node_to_relocate+1:]])\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.3899260947696599,
            2.2421799898147583
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement (minimize both objectives)\n    # We prioritize solutions that are not dominated by others and have high variance in objectives\n    archive_with_metrics = []\n    for sol, obj in archive:\n        # Calculate dominance count (number of solutions that dominate this one)\n        dominance_count = sum(1 for _, other_obj in archive if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]))\n        # Calculate objective variance (to identify solutions that are balanced)\n        obj_variance = abs(obj[0] - obj[1])\n        archive_with_metrics.append((sol, obj, dominance_count, obj_variance))\n\n    # Sort by dominance count (ascending) and then by objective variance (descending)\n    archive_with_metrics.sort(key=lambda x: (x[2], -x[3]))\n    base_solution = archive_with_metrics[0][0].copy()\n\n    # Novel local search strategy: \"Bi-Objective Edge Swap with Relocation\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify (prevents getting stuck in local optima)\n    segment_length = max(2, min(n // 3, np.random.randint(2, 5)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Extract the segment\n    segment = new_solution[start:end]\n\n    # Reverse the segment (similar to 2-opt but more disruptive)\n    segment = segment[::-1]\n\n    # Reinsert the modified segment\n    new_solution[start:end] = segment\n\n    # Additional improvement: Relocate a random node to a random position\n    if np.random.random() < 0.3:  # 30% chance to apply relocation\n        node_to_relocate = np.random.randint(0, n)\n        new_pos = np.random.randint(0, n)\n        node = new_solution[node_to_relocate]\n        new_solution = np.concatenate([new_solution[:node_to_relocate], new_solution[node_to_relocate+1:]])\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains valid (visits each node exactly once)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 267,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Avoid division by zero\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Hybrid of 3-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select 3 distinct edges to modify\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt-like move (reconnect edges to form a new tour)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse another segment\n\n        # Edge exchange: swap two edges if it improves both objectives\n        if np.random.rand() < 0.5:  # 50% chance to perform edge exchange\n            a, b = np.random.choice(n, size=2, replace=False)\n            if a > b:\n                a, b = b, a\n            # Swap edges (a,a+1) and (b,b+1)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)  # All nodes visited exactly once\n\n    return new_solution\n\n",
        "score": [
            -0.8295217805640747,
            2.4448533058166504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]  # Avoid division by zero\n    selected_idx = np.random.choice(len(archive), p=np.array(weights) / sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search operator: Hybrid of 3-opt and edge exchange\n    n = len(new_solution)\n    for _ in range(3):  # Perform multiple iterations for better exploration\n        # Randomly select 3 distinct edges to modify\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt-like move (reconnect edges to form a new tour)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse another segment\n\n        # Edge exchange: swap two edges if it improves both objectives\n        if np.random.rand() < 0.5:  # 50% chance to perform edge exchange\n            a, b = np.random.choice(n, size=2, replace=False)\n            if a > b:\n                a, b = b, a\n            # Swap edges (a,a+1) and (b,b+1)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Ensure the solution remains feasible (valid TSP tour)\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)  # All nodes visited exactly once\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 268,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Choose the solution with the highest sum of objectives (indicating worse performance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom swap operator\n    n = len(new_solution)\n    for _ in range(3):  # Apply the operator multiple times\n        # Randomly select three distinct positions\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Apply 3-opt-like move\n        if np.random.rand() < 0.5:\n            # Reverse a segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Swap segments with custom logic\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    # Additional improvement: apply a custom swap based on distance reduction\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if potential_cost < current_cost:\n            # Apply the swap if it improves both objectives\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8002632305604831,
            3.0455432534217834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    # Choose the solution with the highest sum of objectives (indicating worse performance)\n    selected_idx = np.argmax([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a custom swap operator\n    n = len(new_solution)\n    for _ in range(3):  # Apply the operator multiple times\n        # Randomly select three distinct positions\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n\n        # Apply 3-opt-like move\n        if np.random.rand() < 0.5:\n            # Reverse a segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Swap segments with custom logic\n            segment1 = new_solution[a:b]\n            segment2 = new_solution[b:c]\n            new_solution[a:c] = np.concatenate([segment2, segment1])\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n\n    # Additional improvement: apply a custom swap based on distance reduction\n    for _ in range(2):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate current and potential costs\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        potential_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                         distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        if potential_cost < current_cost:\n            # Apply the swap if it improves both objectives\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 269,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = np.dot(objectives, weights)\n    best_idx = np.argmin(combined_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search: combination of 3-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else new_solution[:0]\n\n    # Reconnect the segments in a different order\n    new_order = np.concatenate([segment1, segment3, segment2])\n\n    # Ensure the solution remains a valid tour\n    if len(new_order) == n:\n        new_solution = new_order\n\n    # Apply edge exchange (swap two edges if it improves both objectives)\n    for _ in range(3):  # Limited number of attempts\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and new costs for both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]]\n\n        # Accept if both objectives improve\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5188066389927649,
            3.8337512612342834
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = np.array([0.5, 0.5])  # Equal weights for both objectives\n    objectives = np.array([obj for _, obj in archive])\n    combined_objectives = np.dot(objectives, weights)\n    best_idx = np.argmin(combined_objectives)\n    base_solution = archive[best_idx][0].copy()\n\n    # Apply a hybrid local search: combination of 3-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three edges to perform 3-opt\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Perform 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:] if k != n else new_solution[:0]\n\n    # Reconnect the segments in a different order\n    new_order = np.concatenate([segment1, segment3, segment2])\n\n    # Ensure the solution remains a valid tour\n    if len(new_order) == n:\n        new_solution = new_order\n\n    # Apply edge exchange (swap two edges if it improves both objectives)\n    for _ in range(3):  # Limited number of attempts\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n\n        # Calculate current and new costs for both objectives\n        current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n        current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n        new_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[b-1]]\n        new_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[b-1]]\n\n        # Accept if both objectives improve\n        if (new_cost1 < current_cost1) and (new_cost2 < current_cost2):\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 270,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = float('inf')\n\n    for i, (sol, obj) in enumerate(archive):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move (reverse a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply novel edge insertion: move a segment to a new position\n    if c > b + 1:\n        segment = new_solution[b+1:c]\n        new_solution = np.concatenate([new_solution[:b+1], new_solution[c:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8046069184321454,
            2.353676915168762
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for simplicity\n    best_idx = 0\n    best_score = float('inf')\n\n    for i, (sol, obj) in enumerate(archive):\n        score = weights[0] * obj[0] + weights[1] * obj[1]\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge insertion\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(np.random.choice(range(n), size=3, replace=False))\n\n    # Apply 3-opt move (reverse a segment)\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply novel edge insertion: move a segment to a new position\n    if c > b + 1:\n        segment = new_solution[b+1:c]\n        new_solution = np.concatenate([new_solution[:b+1], new_solution[c:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 271,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solution_costs = np.array([cost for _, cost in archive])\n    normalized_costs = solution_costs - solution_costs.min(axis=0)\n    potential_scores = 1 / (1 + normalized_costs.sum(axis=1))\n    potential_scores = potential_scores / potential_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # First, perform a randomized 3-opt (more disruptive than 2-opt)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse another segment\n\n    # Then apply a segment relocation heuristic\n    if n >= 4:\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8518750443443941,
            2.0466861724853516
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solution_costs = np.array([cost for _, cost in archive])\n    normalized_costs = solution_costs - solution_costs.min(axis=0)\n    potential_scores = 1 / (1 + normalized_costs.sum(axis=1))\n    potential_scores = potential_scores / potential_scores.sum()\n    selected_idx = np.random.choice(len(archive), p=potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # First, perform a randomized 3-opt (more disruptive than 2-opt)\n    if n >= 4:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]  # Reverse segment\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]  # Reverse another segment\n\n    # Then apply a segment relocation heuristic\n    if n >= 4:\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length - 1)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = random.randint(0, len(new_solution) - segment_length)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure the solution remains valid (no duplicates, all nodes visited)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 272,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    # Hybrid local search: combination of edge swap and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap: swap two edges by reversing a segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment reversal: reverse a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8173337258032991,
            2.010279059410095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    # Hybrid local search: combination of edge swap and segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between edge swap or segment reversal\n    if random.random() < 0.5:\n        # Edge swap: swap two edges by reversing a segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment reversal: reverse a random segment\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j+1] = new_solution[j:i-1:-1]\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 273,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt combined with edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment between i and j\n        new_solution[j:k] = new_solution[j:k][::-1]   # Reverse segment between j and k\n\n        # Apply edge-swap heuristic to further improve the solution\n        for _ in range(2):  # Limit the number of swaps to control computational cost\n            # Select two edges to swap\n            a, b, c, d = np.random.choice(n, 4, replace=False)\n            a, b, c, d = sorted([a, b, c, d])\n\n            # Calculate current and potential costs for both objectives\n            current_cost1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                            distance_matrix_1[new_solution[c], new_solution[d]])\n            current_cost2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                            distance_matrix_2[new_solution[c], new_solution[d]])\n\n            potential_cost1 = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                              distance_matrix_1[new_solution[b], new_solution[d]])\n            potential_cost2 = (distance_matrix_2[new_solution[a], new_solution[c]] +\n                              distance_matrix_2[new_solution[b], new_solution[d]])\n\n            # Perform swap if it improves both objectives\n            if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2):\n                new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.8131589904320027,
            2.5013632774353027
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a high probability of being non-dominated or with potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: 3-opt combined with edge-swap heuristic\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Perform 3-opt\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment between i and j\n        new_solution[j:k] = new_solution[j:k][::-1]   # Reverse segment between j and k\n\n        # Apply edge-swap heuristic to further improve the solution\n        for _ in range(2):  # Limit the number of swaps to control computational cost\n            # Select two edges to swap\n            a, b, c, d = np.random.choice(n, 4, replace=False)\n            a, b, c, d = sorted([a, b, c, d])\n\n            # Calculate current and potential costs for both objectives\n            current_cost1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                            distance_matrix_1[new_solution[c], new_solution[d]])\n            current_cost2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                            distance_matrix_2[new_solution[c], new_solution[d]])\n\n            potential_cost1 = (distance_matrix_1[new_solution[a], new_solution[c]] +\n                              distance_matrix_1[new_solution[b], new_solution[d]])\n            potential_cost2 = (distance_matrix_2[new_solution[a], new_solution[c]] +\n                              distance_matrix_2[new_solution[b], new_solution[d]])\n\n            # Perform swap if it improves both objectives\n            if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2):\n                new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 274,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 30% of solutions for consideration\n    top_k = max(1, int(len(archive_sorted) * 0.3))\n    candidates = archive_sorted[:top_k]\n\n    # Randomly select a candidate solution with probability proportional to its rank\n    weights = [1.0 / (i + 1) for i in range(len(candidates))]\n    weights = [w / sum(weights) for w in weights]\n    selected_idx = random.choices(range(len(candidates)), weights=weights, k=1)[0]\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to consider for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt operation\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Try all possible combinations of these segments\n    combinations = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment3, segment2]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment3, segment1]),\n        np.concatenate([new_solution[:i], segment3, segment1, segment2]),\n        np.concatenate([new_solution[:i], segment3, segment2, segment1])\n    ]\n\n    # Evaluate all combinations based on both objectives\n    best_combination = new_solution.copy()\n    best_cost = (float('inf'), float('inf'))\n\n    for comb in combinations:\n        cost1 = sum(distance_matrix_1[comb[i-1], comb[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[comb[i-1], comb[i]] for i in range(n))\n        if (cost1 < best_cost[0] or (cost1 == best_cost[0] and cost2 < best_cost[1])):\n            best_combination = comb.copy()\n            best_cost = (cost1, cost2)\n\n    # Apply edge insertion for further improvement\n    for _ in range(2):  # Perform a few edge insertions\n        a, b = sorted(random.sample(range(n), 2))\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node], new_solution[b:]])\n\n    # Ensure the solution remains feasible (all nodes are visited exactly once)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the best combination from 3-opt\n        new_solution = best_combination.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.718925591127999,
            3.251189112663269
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by their combined objective values (ascending)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n\n    # Select the top 30% of solutions for consideration\n    top_k = max(1, int(len(archive_sorted) * 0.3))\n    candidates = archive_sorted[:top_k]\n\n    # Randomly select a candidate solution with probability proportional to its rank\n    weights = [1.0 / (i + 1) for i in range(len(candidates))]\n    weights = [w / sum(weights) for w in weights]\n    selected_idx = random.choices(range(len(candidates)), weights=weights, k=1)[0]\n    base_solution = candidates[selected_idx][0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to consider for 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Perform 3-opt operation\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:]\n\n    # Try all possible combinations of these segments\n    combinations = [\n        np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n        np.concatenate([new_solution[:i], segment1, segment3, segment2]),\n        np.concatenate([new_solution[:i], segment2, segment1, segment3]),\n        np.concatenate([new_solution[:i], segment2, segment3, segment1]),\n        np.concatenate([new_solution[:i], segment3, segment1, segment2]),\n        np.concatenate([new_solution[:i], segment3, segment2, segment1])\n    ]\n\n    # Evaluate all combinations based on both objectives\n    best_combination = new_solution.copy()\n    best_cost = (float('inf'), float('inf'))\n\n    for comb in combinations:\n        cost1 = sum(distance_matrix_1[comb[i-1], comb[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[comb[i-1], comb[i]] for i in range(n))\n        if (cost1 < best_cost[0] or (cost1 == best_cost[0] and cost2 < best_cost[1])):\n            best_combination = comb.copy()\n            best_cost = (cost1, cost2)\n\n    # Apply edge insertion for further improvement\n    for _ in range(2):  # Perform a few edge insertions\n        a, b = sorted(random.sample(range(n), 2))\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node], new_solution[b:]])\n\n    # Ensure the solution remains feasible (all nodes are visited exactly once)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the best combination from 3-opt\n        new_solution = best_combination.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 275,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of edge insertion and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to modify\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    k, l = sorted(random.sample(range(1, n-1), 2))\n\n    # Edge insertion: insert segment [i:j] after position k\n    if i < k < j:\n        # Avoid invalid insertion by ensuring the segment is moved\n        k = j if k < j else k\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Node swap: swap nodes at positions l and l+1\n    if l < n-1:\n        new_solution[l], new_solution[l+1] = new_solution[l+1], new_solution[l]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above operation fails\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8300125773086348,
            0.7779401540756226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability weighted by its potential for improvement\n    weights = [1 / (1 + obj[0] + obj[1]) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: a combination of edge insertion and node swap\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to modify\n    i, j = sorted(random.sample(range(1, n-1), 2))\n    k, l = sorted(random.sample(range(1, n-1), 2))\n\n    # Edge insertion: insert segment [i:j] after position k\n    if i < k < j:\n        # Avoid invalid insertion by ensuring the segment is moved\n        k = j if k < j else k\n    segment = new_solution[i:j]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Node swap: swap nodes at positions l and l+1\n    if l < n-1:\n        new_solution[l], new_solution[l+1] = new_solution[l+1], new_solution[l]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the above operation fails\n        a, b = sorted(random.sample(range(1, n-1), 2))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 276,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    costs = np.array(objectives)\n    # Normalize costs to avoid division by zero\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    # Compute a score for each solution (lower is better, so we invert)\n    scores = 1 - np.mean(normalized_costs, axis=1)\n    # Ensure scores are positive and sum to 1\n    scores = np.maximum(scores, 0)\n    if np.sum(scores) == 0:\n        scores = np.ones_like(scores)\n    scores = scores / np.sum(scores)\n\n    selected_idx = np.random.choice(len(archive), p=scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine a random swap with a segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal with dynamic length\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + n // 4, n - 1))  # Limit segment length to avoid excessive changes\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8978579204133268,
            2.210937738418579
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    solutions, objectives = zip(*archive)\n    costs = np.array(objectives)\n    # Normalize costs to avoid division by zero\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    # Compute a score for each solution (lower is better, so we invert)\n    scores = 1 - np.mean(normalized_costs, axis=1)\n    # Ensure scores are positive and sum to 1\n    scores = np.maximum(scores, 0)\n    if np.sum(scores) == 0:\n        scores = np.ones_like(scores)\n    scores = scores / np.sum(scores)\n\n    selected_idx = np.random.choice(len(archive), p=scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator: combine a random swap with a segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Segment reversal with dynamic length\n    start = random.randint(0, n - 2)\n    end = random.randint(start + 1, min(start + n // 4, n - 1))  # Limit segment length to avoid excessive changes\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 277,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their total cost (sum of both objectives)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select top 30% of solutions with the lowest total cost\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the top solutions\n        selected_idx = np.random.randint(0, len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap based on both objectives\n    if n > 3:\n        # Randomly select 3 distinct positions\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move (a generalization of 2-opt)\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Create all possible permutations of the 3 segments\n        permutations = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n        ]\n\n        # Evaluate all permutations based on both objectives\n        costs = []\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n            costs.append((cost1 + cost2, perm))\n\n        # Select the best permutation\n        best_cost, best_perm = min(costs, key=lambda x: x[0])\n        new_solution = best_perm.copy()\n\n        # Apply novel edge-swap based on both objectives\n        # Find edges with high potential for improvement in both spaces\n        for _ in range(2):  # Limit the number of swaps to maintain diversity\n            # Find the worst edge in both objectives\n            worst_edge = -1\n            max_penalty = -float('inf')\n\n            for idx in range(n):\n                node1 = new_solution[idx]\n                node2 = new_solution[(idx+1)%n]\n\n                # Calculate penalty for removing this edge in both spaces\n                penalty1 = distance_matrix_1[node1, node2]\n                penalty2 = distance_matrix_2[node1, node2]\n                total_penalty = penalty1 + penalty2\n\n                if total_penalty > max_penalty:\n                    max_penalty = total_penalty\n                    worst_edge = idx\n\n            if worst_edge != -1:\n                # Find the best edge to swap with\n                best_swap = -1\n                min_gain = float('inf')\n\n                for idx in range(n):\n                    if idx != worst_edge and idx != (worst_edge+1)%n:\n                        node1 = new_solution[worst_edge]\n                        node2 = new_solution[(worst_edge+1)%n]\n                        node3 = new_solution[idx]\n                        node4 = new_solution[(idx+1)%n]\n\n                        # Calculate potential gain from swapping\n                        old_edges = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4] + \\\n                                   distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n                        new_edges = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4] + \\\n                                    distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n                        gain = old_edges - new_edges\n\n                        if gain < min_gain:\n                            min_gain = gain\n                            best_swap = idx\n\n                if best_swap != -1 and min_gain > 0:\n                    # Perform the swap\n                    if worst_edge < best_swap:\n                        segment1 = new_solution[worst_edge+1:best_swap]\n                        new_solution[worst_edge+1:best_swap] = segment1[::-1]\n                    else:\n                        segment1 = new_solution[best_swap+1:worst_edge]\n                        new_solution[best_swap+1:worst_edge] = segment1[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.562815430706104,
            5.8314162492752075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their total cost (sum of both objectives)\n        archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n        # Select top 30% of solutions with the lowest total cost\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 3)]\n        # Randomly select one from the top solutions\n        selected_idx = np.random.randint(0, len(top_solutions))\n        base_solution = top_solutions[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: combine 3-opt with a novel edge-swap based on both objectives\n    if n > 3:\n        # Randomly select 3 distinct positions\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Apply 3-opt move (a generalization of 2-opt)\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Create all possible permutations of the 3 segments\n        permutations = [\n            np.concatenate([segment1, segment2, segment3, segment4]),\n            np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n            np.concatenate([segment1, segment3, segment2, segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n            np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n            np.concatenate([segment1, segment3[::-1], segment2[::-1], segment4])\n        ]\n\n        # Evaluate all permutations based on both objectives\n        costs = []\n        for perm in permutations:\n            cost1 = sum(distance_matrix_1[perm[i], perm[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[perm[i], perm[(i+1)%n]] for i in range(n))\n            costs.append((cost1 + cost2, perm))\n\n        # Select the best permutation\n        best_cost, best_perm = min(costs, key=lambda x: x[0])\n        new_solution = best_perm.copy()\n\n        # Apply novel edge-swap based on both objectives\n        # Find edges with high potential for improvement in both spaces\n        for _ in range(2):  # Limit the number of swaps to maintain diversity\n            # Find the worst edge in both objectives\n            worst_edge = -1\n            max_penalty = -float('inf')\n\n            for idx in range(n):\n                node1 = new_solution[idx]\n                node2 = new_solution[(idx+1)%n]\n\n                # Calculate penalty for removing this edge in both spaces\n                penalty1 = distance_matrix_1[node1, node2]\n                penalty2 = distance_matrix_2[node1, node2]\n                total_penalty = penalty1 + penalty2\n\n                if total_penalty > max_penalty:\n                    max_penalty = total_penalty\n                    worst_edge = idx\n\n            if worst_edge != -1:\n                # Find the best edge to swap with\n                best_swap = -1\n                min_gain = float('inf')\n\n                for idx in range(n):\n                    if idx != worst_edge and idx != (worst_edge+1)%n:\n                        node1 = new_solution[worst_edge]\n                        node2 = new_solution[(worst_edge+1)%n]\n                        node3 = new_solution[idx]\n                        node4 = new_solution[(idx+1)%n]\n\n                        # Calculate potential gain from swapping\n                        old_edges = distance_matrix_1[node1, node2] + distance_matrix_1[node3, node4] + \\\n                                   distance_matrix_2[node1, node2] + distance_matrix_2[node3, node4]\n                        new_edges = distance_matrix_1[node1, node3] + distance_matrix_1[node2, node4] + \\\n                                    distance_matrix_2[node1, node3] + distance_matrix_2[node2, node4]\n                        gain = old_edges - new_edges\n\n                        if gain < min_gain:\n                            min_gain = gain\n                            best_swap = idx\n\n                if best_swap != -1 and min_gain > 0:\n                    # Perform the swap\n                    if worst_edge < best_swap:\n                        segment1 = new_solution[worst_edge+1:best_swap]\n                        new_solution[worst_edge+1:best_swap] = segment1[::-1]\n                    else:\n                        segment1 = new_solution[best_swap+1:worst_edge]\n                        new_solution[best_swap+1:worst_edge] = segment1[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 278,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not the best in either objective\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    candidates = [(sol, obj) for sol, obj in archive if obj[0] > min_obj1 or obj[1] > min_obj2]\n\n    if not candidates:\n        # If all solutions are optimal, select the one with the highest combined cost\n        candidates = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n\n    selected_sol, _ = random.choice(candidates)\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge-swap operation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # First, perform a standard 2-opt move\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Then, perform a novel edge-swap operation\n    # Select two non-adjacent edges and swap their connections\n    k, l = sorted(random.sample(range(n), 2))\n    while abs(k - l) <= 1:  # Ensure edges are not adjacent\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Swap the connections between the edges\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8909695171511187,
            1.573015034198761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not already optimal)\n    # Here, we select a solution that is not the best in either objective\n    objectives = [obj for _, obj in archive]\n    min_obj1 = min(obj[0] for obj in objectives)\n    min_obj2 = min(obj[1] for obj in objectives)\n    candidates = [(sol, obj) for sol, obj in archive if obj[0] > min_obj1 or obj[1] > min_obj2]\n\n    if not candidates:\n        # If all solutions are optimal, select the one with the highest combined cost\n        candidates = sorted(archive, key=lambda x: -(x[1][0] + x[1][1]))\n\n    selected_sol, _ = random.choice(candidates)\n    base_solution = selected_sol.copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel edge-swap operation\n    n = len(base_solution)\n    i, j = sorted(random.sample(range(n), 2))\n\n    # First, perform a standard 2-opt move\n    new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    # Then, perform a novel edge-swap operation\n    # Select two non-adjacent edges and swap their connections\n    k, l = sorted(random.sample(range(n), 2))\n    while abs(k - l) <= 1:  # Ensure edges are not adjacent\n        k, l = sorted(random.sample(range(n), 2))\n\n    # Swap the connections between the edges\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 279,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined cost (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine elements of 3-opt and relocate with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three distinct positions to modify\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Objective-aware selection: choose the modification that improves both objectives the most\n        candidates = [\n            new_solution.copy(),  # original\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),  # 3-opt style\n            np.concatenate([new_solution[:i], new_solution[j+1:k], new_solution[i:j+1], new_solution[k:]]),  # relocate segment\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:k], new_solution[j:]]),  # reverse segment\n        ]\n\n        # Evaluate all candidates\n        best_candidate = new_solution\n        best_cost = (np.inf, np.inf)\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n                best_cost = (cost1, cost2)\n                best_candidate = candidate\n\n        new_solution = best_candidate.copy()\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.40984358159001844,
            4.6102190017700195
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined cost (sum of both objectives)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy: combine elements of 3-opt and relocate with objective-aware selection\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, just swap two random nodes\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three distinct positions to modify\n        i, j, k = np.random.choice(n, size=3, replace=False)\n        i, j, k = sorted([i, j, k])\n\n        # Objective-aware selection: choose the modification that improves both objectives the most\n        candidates = [\n            new_solution.copy(),  # original\n            np.concatenate([new_solution[:i], new_solution[j:k+1], new_solution[i:j], new_solution[k+1:]]),  # 3-opt style\n            np.concatenate([new_solution[:i], new_solution[j+1:k], new_solution[i:j+1], new_solution[k:]]),  # relocate segment\n            np.concatenate([new_solution[:i], new_solution[k:j-1:-1], new_solution[i:k], new_solution[j:]]),  # reverse segment\n        ]\n\n        # Evaluate all candidates\n        best_candidate = new_solution\n        best_cost = (np.inf, np.inf)\n\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            if (cost1 + cost2) < (best_cost[0] + best_cost[1]):\n                best_cost = (cost1, cost2)\n                best_candidate = candidate\n\n        new_solution = best_candidate.copy()\n\n    # Ensure the solution is valid (visits each node exactly once)\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 280,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to apply 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = selected_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = selected_solution[j:k][::-1]  # Reverse segment\n\n    # Objective-aware edge selection: swap edges if it improves both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(selected_solution)\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    # If the move doesn't improve both objectives, try a different segment\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # Try a different 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        temp_solution = selected_solution.copy()\n        temp_solution[i:j] = selected_solution[i:j][::-1]\n        temp_solution[j:k] = selected_solution[j:k][::-1]\n        temp_cost1, temp_cost2 = calculate_cost(temp_solution)\n\n        if temp_cost1 < original_cost1 and temp_cost2 < original_cost2:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8531830010441175,
            2.4621631503105164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal)\n    selected_idx = random.randint(0, len(archive) - 1)\n    selected_solution = archive[selected_idx][0].copy()\n    objectives = archive[selected_idx][1]\n\n    # Hybrid local search operator: 3-opt with objective-aware edge selection\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct edges to apply 3-opt\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    new_solution[i:j] = selected_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = selected_solution[j:k][::-1]  # Reverse segment\n\n    # Objective-aware edge selection: swap edges if it improves both objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_cost(selected_solution)\n    new_cost1, new_cost2 = calculate_cost(new_solution)\n\n    # If the move doesn't improve both objectives, try a different segment\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # Try a different 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        temp_solution = selected_solution.copy()\n        temp_solution[i:j] = selected_solution[i:j][::-1]\n        temp_solution[j:k] = selected_solution[j:k][::-1]\n        temp_cost1, temp_cost2 = calculate_cost(temp_solution)\n\n        if temp_cost1 < original_cost1 and temp_cost2 < original_cost2:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 281,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = [sum(obj) for _, obj in archive]\n    if not costs:\n        return archive[0][0].copy()\n\n    total_cost = sum(costs)\n    probabilities = [1.0 - (cost / total_cost) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for modification\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:n]\n\n    # Reverse segments to create a new tour\n    new_solution = np.concatenate([new_solution[:i], segment2[::-1], segment1[::-1], segment3])\n\n    # Apply edge exchange to further improve\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9090756620261642,
            2.050105631351471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = [sum(obj) for _, obj in archive]\n    if not costs:\n        return archive[0][0].copy()\n\n    total_cost = sum(costs)\n    probabilities = [1.0 - (cost / total_cost) for cost in costs]\n    probabilities = [p / sum(probabilities) for p in probabilities]\n\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator: combine 3-opt and edge exchange\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for modification\n    i, j, k = sorted(random.sample(range(1, n), 3))\n\n    # Apply 3-opt move\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:n]\n\n    # Reverse segments to create a new tour\n    new_solution = np.concatenate([new_solution[:i], segment2[::-1], segment1[::-1], segment3])\n\n    # Apply edge exchange to further improve\n    a, b = sorted(random.sample(range(1, n-1), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 282,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them (novel segment reversal)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments [i:j] and [k:l] to explore new neighborhoods\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility by checking for duplicates (though segment reversal should maintain feasibility)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = selected_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8511252294778654,
            1.6078933477401733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or with high variance in objectives)\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]))[0].copy()\n\n    # Hybrid local search strategy: combine 2-opt with a novel segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select two segments and reverse them (novel segment reversal)\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Reverse segments [i:j] and [k:l] to explore new neighborhoods\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[k:l] = new_solution[k:l][::-1]\n\n    # Ensure feasibility by checking for duplicates (though segment reversal should maintain feasibility)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal causes duplicates\n        new_solution = selected_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 283,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of current objective values)\n    objectives = np.array([obj for _, obj in archive])\n    potentials = 1.0 / (objectives[:, 0] + objectives[:, 1] + 1e-10)\n    probabilities = potentials / np.sum(potentials)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt + novel edge-reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reverse segments between a-b, b-c, and a-c\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel edge-reversal operator: reverse a random segment of length 2-4\n    if n >= 4:\n        segment_length = random.randint(2, min(4, n-1))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure feasibility (no duplicate nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7687641011540407,
            2.2268301248550415
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate potential for improvement (inverse of current objective values)\n    objectives = np.array([obj for _, obj in archive])\n    potentials = 1.0 / (objectives[:, 0] + objectives[:, 1] + 1e-10)\n    probabilities = potentials / np.sum(potentials)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: 3-opt + novel edge-reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # 3-opt move\n    if n >= 4:\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Reverse segments between a-b, b-c, and a-c\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n        new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel edge-reversal operator: reverse a random segment of length 2-4\n    if n >= 4:\n        segment_length = random.randint(2, min(4, n-1))\n        start = random.randint(0, n - segment_length)\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Ensure feasibility (no duplicate nodes)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 284,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the top 30% of the archive\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_30_percent = int(len(archive_sorted) * 0.3)\n    selected_idx = random.randint(0, max(0, top_30_percent - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply hybrid local search (3-opt + relocation)\n    if n >= 4:\n        # 3-opt move: Select three random edges and reconnect them in a different way\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a different order\n        new_order = np.concatenate([segment1, segment3, segment2, segment4])\n        new_solution = new_order\n\n    # Relocation move: Move a random node to a new position\n    if n >= 2:\n        node_idx = random.randint(1, n-1)\n        new_pos = random.randint(0, n-1)\n        if new_pos != node_idx and new_pos != (node_idx - 1) % n:\n            node = new_solution[node_idx]\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6514870156876417,
            1.8157130479812622
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the top 30% of the archive\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    top_30_percent = int(len(archive_sorted) * 0.3)\n    selected_idx = random.randint(0, max(0, top_30_percent - 1))\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Apply hybrid local search (3-opt + relocation)\n    if n >= 4:\n        # 3-opt move: Select three random edges and reconnect them in a different way\n        i, j, k = sorted(random.sample(range(1, n-1), 3))\n        segment1 = new_solution[:i]\n        segment2 = new_solution[i:j]\n        segment3 = new_solution[j:k]\n        segment4 = new_solution[k:]\n\n        # Reconnect segments in a different order\n        new_order = np.concatenate([segment1, segment3, segment2, segment4])\n        new_solution = new_order\n\n    # Relocation move: Move a random node to a new position\n    if n >= 2:\n        node_idx = random.randint(1, n-1)\n        new_pos = random.randint(0, n-1)\n        if new_pos != node_idx and new_pos != (node_idx - 1) % n:\n            node = new_solution[node_idx]\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            new_solution = np.insert(new_solution, new_pos, node)\n\n    # Ensure the solution remains feasible (no duplicate nodes)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if the solution becomes invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 285,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 1:\n        # Sort by sum of objectives to find solutions with moderate cost\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution in the middle of the archive (not too good, not too bad)\n        idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly select a segment and reverse it (novel segment reversal)\n    if n > 3:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly swap two edges (edge swapping)\n    if n > 2:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Randomly insert a node in a different position (edge insertion)\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.867862708789876,
            1.4812553524971008
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 1:\n        # Sort by sum of objectives to find solutions with moderate cost\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select a solution in the middle of the archive (not too good, not too bad)\n        idx = min(len(sorted_archive) // 2, len(sorted_archive) - 1)\n        base_solution = sorted_archive[idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Randomly select a segment and reverse it (novel segment reversal)\n    if n > 3:\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Step 2: Randomly swap two edges (edge swapping)\n    if n > 2:\n        i, j = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Randomly insert a node in a different position (edge insertion)\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution is valid (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or not np.array_equal(np.sort(unique_nodes), np.arange(n)):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 286,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance count\n    # (simulating a form of Pareto-based selection)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Adaptive segment swapping with edge insertion\n    if n > 4:\n        # Determine segment length adaptively based on problem size\n        segment_length = max(2, min(5, n // 10))\n\n        # Randomly select two segments to swap\n        start1 = random.randint(0, n - segment_length - 1)\n        start2 = random.randint(0, n - segment_length - 1)\n\n        # Ensure segments are distinct\n        while abs(start1 - start2) < segment_length:\n            start2 = random.randint(0, n - segment_length - 1)\n\n        # Swap the segments\n        segment1 = new_solution[start1:start1 + segment_length]\n        segment2 = new_solution[start2:start2 + segment_length]\n        new_solution[start1:start1 + segment_length] = segment2\n        new_solution[start2:start2 + segment_length] = segment1\n\n        # Edge insertion to improve local connectivity\n        for _ in range(2):  # Limited number of insertions to maintain diversity\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                # Remove node at i and insert at j\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                insert_pos = random.randint(0, n - 2)\n                new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # For small instances, use a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9115889254545313,
            0.2322511076927185
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a probability inversely proportional to its dominance count\n    # (simulating a form of Pareto-based selection)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy: Adaptive segment swapping with edge insertion\n    if n > 4:\n        # Determine segment length adaptively based on problem size\n        segment_length = max(2, min(5, n // 10))\n\n        # Randomly select two segments to swap\n        start1 = random.randint(0, n - segment_length - 1)\n        start2 = random.randint(0, n - segment_length - 1)\n\n        # Ensure segments are distinct\n        while abs(start1 - start2) < segment_length:\n            start2 = random.randint(0, n - segment_length - 1)\n\n        # Swap the segments\n        segment1 = new_solution[start1:start1 + segment_length]\n        segment2 = new_solution[start2:start2 + segment_length]\n        new_solution[start1:start1 + segment_length] = segment2\n        new_solution[start2:start2 + segment_length] = segment1\n\n        # Edge insertion to improve local connectivity\n        for _ in range(2):  # Limited number of insertions to maintain diversity\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            if i != j:\n                # Remove node at i and insert at j\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                insert_pos = random.randint(0, n - 2)\n                new_solution = np.insert(new_solution, insert_pos, node)\n    else:\n        # For small instances, use a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 287,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (here, we randomly select from top 30% of solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    base_solution, _ = random.choice(top_solutions)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search strategy (combination of edge insertion and relocate)\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a more sophisticated operator\n        # Hybrid operator: edge insertion + relocate\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n - 1)\n\n        # Edge insertion: insert segment [i+1, j] before position k\n        segment = new_solution[i+1:j+1]\n        remaining = np.concatenate([new_solution[:i+1], new_solution[j+1:]])\n        new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n        # Relocate: move a random node to another position\n        m = random.randint(0, n - 1)\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n        new_pos = random.randint(0, n - 2)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7375306174174682,
            1.8941761255264282
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution (here, we randomly select from top 30% of solutions)\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n    base_solution, _ = random.choice(top_solutions)\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply a hybrid local search strategy (combination of edge insertion and relocate)\n    n = len(new_solution)\n    if n < 4:\n        # For small tours, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # For larger tours, use a more sophisticated operator\n        # Hybrid operator: edge insertion + relocate\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(0, n - 1)\n\n        # Edge insertion: insert segment [i+1, j] before position k\n        segment = new_solution[i+1:j+1]\n        remaining = np.concatenate([new_solution[:i+1], new_solution[j+1:]])\n        new_solution = np.concatenate([remaining[:k], segment, remaining[k:]])\n\n        # Relocate: move a random node to another position\n        m = random.randint(0, n - 1)\n        node = new_solution[m]\n        new_solution = np.concatenate([new_solution[:m], new_solution[m+1:]])\n        new_pos = random.randint(0, n - 2)\n        new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 288,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple average-based selection\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge swap + segment relocation\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge swap (2-opt variant)\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment relocation (novel component)\n    if n > 3:\n        k = np.random.randint(1, n-1)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure feasibility (valid TSP tour)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if relocation fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8789911752563228,
            1.1808879375457764
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or diverse)\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)  # Simple average-based selection\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Edge swap + segment relocation\n    n = len(base_solution)\n    i, j = np.random.choice(n, 2, replace=False)\n    i, j = min(i, j), max(i, j)\n\n    # Edge swap (2-opt variant)\n    if j - i > 1:\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Segment relocation (novel component)\n    if n > 3:\n        k = np.random.randint(1, n-1)\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Ensure feasibility (valid TSP tour)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback: simple swap if relocation fails\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 289,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards non-dominated solutions\n    non_dominated = [sol for sol, obj in archive if not any(obj1[0] <= obj[0] and obj1[1] <= obj[1] and (obj1[0] < obj[0] or obj1[1] < obj[1]) for _, obj1 in archive)]\n    if non_dominated:\n        selected_solution = random.choice(non_dominated)\n    else:\n        selected_solution = random.choice(archive)[0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Apply segment reversal\n    segment_reversed = segment[::-1]\n\n    # Try to insert the reversed segment elsewhere\n    c, d = sorted(random.sample(range(n), 2))\n    if c > d:\n        c, d = d, c\n\n    # Create new solution by inserting reversed segment\n    new_solution = np.concatenate([new_solution[:c], segment_reversed, new_solution[d:]])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n        # Fix duplicates by replacing with missing nodes\n        for node in extra:\n            if missing:\n                replace_idx = np.where(new_solution == node)[0][0]\n                new_solution[replace_idx] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.5725509923910982,
            0.8019732236862183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias towards non-dominated solutions\n    non_dominated = [sol for sol, obj in archive if not any(obj1[0] <= obj[0] and obj1[1] <= obj[1] and (obj1[0] < obj[0] or obj1[1] < obj[1]) for _, obj1 in archive)]\n    if non_dominated:\n        selected_solution = random.choice(non_dominated)\n    else:\n        selected_solution = random.choice(archive)[0]\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combination of edge insertion and segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select a segment to modify\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b]\n\n    # Apply segment reversal\n    segment_reversed = segment[::-1]\n\n    # Try to insert the reversed segment elsewhere\n    c, d = sorted(random.sample(range(n), 2))\n    if c > d:\n        c, d = d, c\n\n    # Create new solution by inserting reversed segment\n    new_solution = np.concatenate([new_solution[:c], segment_reversed, new_solution[d:]])\n\n    # Ensure all nodes are visited exactly once\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing = set(range(n)) - set(unique_nodes)\n        extra = [node for node in new_solution if list(new_solution).count(node) > 1]\n\n        # Fix duplicates by replacing with missing nodes\n        for node in extra:\n            if missing:\n                replace_idx = np.where(new_solution == node)[0][0]\n                new_solution[replace_idx] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 290,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n\n    # Step 1: Perform a random segment inversion (novel operator)\n    if n > 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a random edge swap (standard but effective)\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a random feasible solution if invalid\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.8247869039475133,
            1.5737152099609375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive must not be empty\")\n\n    # Select a solution with high potential for improvement (e.g., non-dominated or high diversity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search strategy\n    n = len(base_solution)\n\n    # Step 1: Perform a random segment inversion (novel operator)\n    if n > 3:\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Step 2: Perform a random edge swap (standard but effective)\n    if n > 2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    if len(set(new_solution)) != n:\n        # Fallback to a random feasible solution if invalid\n        new_solution = np.random.permutation(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 291,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with probability proportional to its diversity\n    non_dominated = []\n    objectives = [obj for _, obj in archive]\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select with probability based on objective values (lower is better)\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in non_dominated]\n    total_weight = sum(weights)\n    probs = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(non_dominated), p=probs)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (like 2-opt but more disruptive)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent edges (like edge swap but more disruptive)\n    if n > 4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if abs(i - j) > 1:  # Ensure they're not adjacent\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Randomly insert a node somewhere else (like insertion mutation)\n    if n > 2:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
        "score": [
            -0.7619967416941829,
            1.9059810638427734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with probability proportional to its diversity\n    non_dominated = []\n    objectives = [obj for _, obj in archive]\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select with probability based on objective values (lower is better)\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in non_dominated]\n    total_weight = sum(weights)\n    probs = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(non_dominated), p=probs)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select a segment to reverse (like 2-opt but more disruptive)\n    if n > 3:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Step 2: Randomly swap two non-adjacent edges (like edge swap but more disruptive)\n    if n > 4:\n        i, j = sorted(random.sample(range(1, n), 2))\n        if abs(i - j) > 1:  # Ensure they're not adjacent\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Randomly insert a node somewhere else (like insertion mutation)\n    if n > 2:\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure the solution remains a valid tour\n    assert len(new_solution) == len(base_solution)\n    assert len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 292,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 3-opt move\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply a novel edge swap strategy based on distance matrices\n    # Select two random edges and swap their endpoints if it improves both objectives\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    c, d = (a + 1) % n, (b + 1) % n\n\n    # Calculate cost changes for both objectives\n    original_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n\n    original_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n\n    # Apply swap if it improves both objectives\n    if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.40066749307870486,
            4.361715018749237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., those with high variance in objectives)\n    objectives = [obj for _, obj in archive]\n    variances = [np.var(obj) for obj in objectives]\n    selected_idx = np.argmax(variances)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a random 3-opt move\n    i, j, k = sorted(np.random.choice(range(n), size=3, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    # Apply a novel edge swap strategy based on distance matrices\n    # Select two random edges and swap their endpoints if it improves both objectives\n    a, b = sorted(np.random.choice(range(n), size=2, replace=False))\n    c, d = (a + 1) % n, (b + 1) % n\n\n    # Calculate cost changes for both objectives\n    original_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n    new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n\n    original_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n    new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n\n    # Apply swap if it improves both objectives\n    if (new_cost1 < original_cost1) and (new_cost2 < original_cost2):\n        new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[c], new_solution[d], new_solution[a], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 293,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probabilistic favor to those with better diversity (lower cost in both objectives)\n    costs = np.array([obj for _, obj in archive])\n    # Normalize costs to avoid division by zero\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    # Calculate diversity score (lower is better)\n    diversity_scores = np.sum(normalized_costs, axis=1)\n    # Select a solution with probability inversely proportional to its diversity score\n    probabilities = 1 / (diversity_scores + 1e-10)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with edge insertion\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Step 1: Randomly select 3 distinct edges to modify\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Step 2: Perform 3-opt move (reconnect the edges)\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        # Step 3: Edge insertion heuristic to improve both objectives\n        for _ in range(2):  # Perform limited edge insertions\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate cost change for both objectives\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                # Insert node j between i and i+1\n                new_order = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n                new_cost1 = distance_matrix_1[new_order[i-1], new_order[i]] + distance_matrix_1[new_order[i], new_order[i+1]] + distance_matrix_1[new_order[j-1], new_order[j]]\n                new_cost2 = distance_matrix_2[new_order[i-1], new_order[i]] + distance_matrix_2[new_order[i], new_order[i+1]] + distance_matrix_2[new_order[j-1], new_order[j]]\n                # Accept if both objectives improve or one improves significantly\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 * 0.95 or new_cost2 < old_cost2 * 0.95):\n                    new_solution = new_order\n\n    return new_solution\n\n",
        "score": [
            -0.8326965052369533,
            2.0665111541748047
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with probabilistic favor to those with better diversity (lower cost in both objectives)\n    costs = np.array([obj for _, obj in archive])\n    # Normalize costs to avoid division by zero\n    normalized_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    # Calculate diversity score (lower is better)\n    diversity_scores = np.sum(normalized_costs, axis=1)\n    # Select a solution with probability inversely proportional to its diversity score\n    probabilities = 1 / (diversity_scores + 1e-10)\n    probabilities = probabilities / probabilities.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with edge insertion\n    for _ in range(5):  # Perform multiple iterations for better exploration\n        # Step 1: Randomly select 3 distinct edges to modify\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Step 2: Perform 3-opt move (reconnect the edges)\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        # Step 3: Edge insertion heuristic to improve both objectives\n        for _ in range(2):  # Perform limited edge insertions\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                # Calculate cost change for both objectives\n                old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n                # Insert node j between i and i+1\n                new_order = np.concatenate([new_solution[:i], [new_solution[j]], new_solution[i:j], new_solution[j+1:]])\n                new_cost1 = distance_matrix_1[new_order[i-1], new_order[i]] + distance_matrix_1[new_order[i], new_order[i+1]] + distance_matrix_1[new_order[j-1], new_order[j]]\n                new_cost2 = distance_matrix_2[new_order[i-1], new_order[i]] + distance_matrix_2[new_order[i], new_order[i+1]] + distance_matrix_2[new_order[j-1], new_order[j]]\n                # Accept if both objectives improve or one improves significantly\n                if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 * 0.95 or new_cost2 < old_cost2 * 0.95):\n                    new_solution = new_order\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 294,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Edge insertion: randomly select two edges and insert a segment between them\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(1, n-1)\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Segment reversal: reverse a random segment to explore different configurations\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7402765864522852,
            1.1624804735183716
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective (weighted sum)\n    weights = [0.5, 0.5]  # Equal weights for both objectives\n    best_idx = min(range(len(archive)), key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge insertion followed by segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to apply the operator\n\n    # Edge insertion: randomly select two edges and insert a segment between them\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k = np.random.randint(1, n-1)\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    # Segment reversal: reverse a random segment to explore different configurations\n    a, b = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 295,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Random edge swap (2-opt like operation)\n    if n > 2:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Novel segment reversal with objective-aware selection\n    if n > 4:\n        # Select a segment based on high distance in either objective space\n        for _ in range(3):  # Try 3 times to find a beneficial segment\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            segment = new_solution[a:b]\n\n            # Calculate segment cost in both spaces\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Reverse if it improves at least one objective\n            if random.random() < 0.7:  # 70% chance to reverse (exploration)\n                new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8892558168885549,
            2.093981623649597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    selected_solution = None\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            selected_solution = sol.copy()\n            break\n\n    if selected_solution is None:\n        selected_solution = random.choice(archive)[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Step 1: Random edge swap (2-opt like operation)\n    if n > 2:\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Novel segment reversal with objective-aware selection\n    if n > 4:\n        # Select a segment based on high distance in either objective space\n        for _ in range(3):  # Try 3 times to find a beneficial segment\n            a, b = sorted(random.sample(range(1, n-1), 2))\n            segment = new_solution[a:b]\n\n            # Calculate segment cost in both spaces\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n\n            # Reverse if it improves at least one objective\n            if random.random() < 0.7:  # 70% chance to reverse (exploration)\n                new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 296,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are dominated, select the least dominated one\n        base_solution, _ = min(archive, key=lambda x: (x[1][0] + x[1][1]))\n    else:\n        # Select a random non-dominated solution\n        base_solution, _ = random.choice(non_dominated)\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: segment relocation + edge insertion\n    if n > 3:\n        # Segment relocation: select a random segment and relocate it\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size - 1)\n        segment = new_solution[start:start + segment_size]\n        remaining = np.concatenate([new_solution[:start], new_solution[start + segment_size:]])\n\n        # Find the best insertion point for the segment\n        best_insert_pos = 0\n        min_cost = float('inf')\n        for i in range(len(remaining)):\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2  # Simple weighted sum for selection\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insert_pos = i\n\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n        # Edge insertion: randomly select two edges and reinsert between them\n        if n > 4:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8955322772008321,
            11.603555679321289
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., not dominated by others)\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        # If all solutions are dominated, select the least dominated one\n        base_solution, _ = min(archive, key=lambda x: (x[1][0] + x[1][1]))\n    else:\n        # Select a random non-dominated solution\n        base_solution, _ = random.choice(non_dominated)\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Apply hybrid local search: segment relocation + edge insertion\n    if n > 3:\n        # Segment relocation: select a random segment and relocate it\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size - 1)\n        segment = new_solution[start:start + segment_size]\n        remaining = np.concatenate([new_solution[:start], new_solution[start + segment_size:]])\n\n        # Find the best insertion point for the segment\n        best_insert_pos = 0\n        min_cost = float('inf')\n        for i in range(len(remaining)):\n            candidate = np.concatenate([remaining[:i], segment, remaining[i:]])\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[k+1]] for k in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2  # Simple weighted sum for selection\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_insert_pos = i\n\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n        # Edge insertion: randomly select two edges and reinsert between them\n        if n > 4:\n            i, j = sorted(random.sample(range(n), 2))\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 297,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values and diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], random.random()))\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n > 4:  # Ensure enough nodes for meaningful operations\n        # Randomly select a segment to modify\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Edge exchange: reverse the segment\n        new_solution[a:b+1] = segment[::-1]\n\n        # Node insertion: move a random node from the segment to a new position\n        if len(segment) > 1:\n            node_to_move = random.choice(segment)\n            new_pos = random.randint(0, n-1)\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.7409661276784851,
            2.0078462958335876
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by a combination of objective values and diversity\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], random.random()))\n        selected_solution = archive_sorted[0][0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator: combination of edge exchange and node insertion\n    n = len(new_solution)\n    if n > 4:  # Ensure enough nodes for meaningful operations\n        # Randomly select a segment to modify\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Edge exchange: reverse the segment\n        new_solution[a:b+1] = segment[::-1]\n\n        # Node insertion: move a random node from the segment to a new position\n        if len(segment) > 1:\n            node_to_move = random.choice(segment)\n            new_pos = random.randint(0, n-1)\n            new_solution = np.delete(new_solution, np.where(new_solution == node_to_move)[0])\n            new_solution = np.insert(new_solution, new_pos, node_to_move)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 298,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank (higher rank = more likely to be selected)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance ranks (simplified: higher rank for solutions with better combined objective)\n    ranks = []\n    for obj in objectives:\n        rank = 1 - (obj[0] + obj[1]) / (np.sum([o[0] + o[1] for o in objectives]) + 1e-10)\n        ranks.append(rank)\n\n    # Normalize ranks to get probabilities\n    probs = np.array(ranks) / np.sum(ranks)\n\n    # Select a base solution\n    base_solution = random.choices(solutions, weights=probs, k=1)[0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    if a + 1 < b and b + 1 < c:\n        # Reconnect the nodes in a different order\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Apply edge insertion move\n    if n > 4:\n        # Select a random segment and reinsert it elsewhere\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1].copy()\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    # Verify all nodes are present and unique\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8749899191030971,
            2.459556460380554
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its dominance rank (higher rank = more likely to be selected)\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance ranks (simplified: higher rank for solutions with better combined objective)\n    ranks = []\n    for obj in objectives:\n        rank = 1 - (obj[0] + obj[1]) / (np.sum([o[0] + o[1] for o in objectives]) + 1e-10)\n        ranks.append(rank)\n\n    # Normalize ranks to get probabilities\n    probs = np.array(ranks) / np.sum(ranks)\n\n    # Select a base solution\n    base_solution = random.choices(solutions, weights=probs, k=1)[0].copy()\n\n    # Hybrid local search operator: combination of 3-opt and edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Apply 3-opt move\n    if a + 1 < b and b + 1 < c:\n        # Reconnect the nodes in a different order\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b+1:c+1] = new_solution[b+1:c+1][::-1]\n\n    # Apply edge insertion move\n    if n > 4:\n        # Select a random segment and reinsert it elsewhere\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1].copy()\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    # Verify all nodes are present and unique\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 299,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability weighted by its rank in the archive (better solutions have higher probability)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n = len(base_solution)\n\n    # Randomly choose one of the three local search operators\n    operator = random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Perform a random edge swap (3-opt move)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n        new_solution[j:k+1] = base_solution[j:k+1][::-1]\n\n    elif operator == 'segment_reversal':\n        # Reverse a random segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    elif operator == 'node_insertion':\n        # Remove a random node and reinsert it at a random position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7762288789128042,
            1.4509933590888977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with a probability weighted by its rank in the archive (better solutions have higher probability)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    total_weight = sum(weights)\n    normalized_weights = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(archive), p=normalized_weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search strategy\n    n = len(base_solution)\n\n    # Randomly choose one of the three local search operators\n    operator = random.choice(['edge_swap', 'segment_reversal', 'node_insertion'])\n\n    if operator == 'edge_swap':\n        # Perform a random edge swap (3-opt move)\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n        new_solution[j:k+1] = base_solution[j:k+1][::-1]\n\n    elif operator == 'segment_reversal':\n        # Reverse a random segment of the tour\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = base_solution[i:j+1][::-1]\n\n    elif operator == 'node_insertion':\n        # Remove a random node and reinsert it at a random position\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are an expert in the domain of optimization heuristics. Your task is to design heuristics that can effectively solve optimization problems. Your response outputs Python code and nothing else. Format your code as a Python code string: \"```python ...```\"\nYou are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.  \ndef select_neighbor_v1(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n  \nImprove `select_neighbor_v1` to give `select_neighbor_v2`. Output code only and enclose your code with Python code block: ```python ...```.  \n",
        "sample_order": 300,
        "algorithm": "",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objective values and solution quality\n    # Here, we prioritize solutions with lower objective values but also consider diversity\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], random.random()))  # Sort by sum of objectives and randomness for diversity\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment inversion operator\n    if n > 4:\n        # Choose a random segment to invert\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 5, n - 1))  # Keep segment length reasonable\n        new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n\n    # Apply edge exchange with a probability to ensure diversity\n    if random.random() < 0.5 and n > 2:\n        # Choose two random edges to exchange\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if not (np.array_equal(np.sort(new_solution), np.sort(selected_solution)) and len(np.unique(new_solution)) == n):\n        # If the solution is invalid, revert to the original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6365450627911341,
            1.941504180431366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution based on a combination of objective values and solution quality\n    # Here, we prioritize solutions with lower objective values but also consider diversity\n    archive.sort(key=lambda x: (x[1][0] + x[1][1], random.random()))  # Sort by sum of objectives and randomness for diversity\n    selected_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search strategy\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply a novel segment inversion operator\n    if n > 4:\n        # Choose a random segment to invert\n        start = random.randint(0, n - 3)\n        end = random.randint(start + 2, min(start + 5, n - 1))  # Keep segment length reasonable\n        new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n\n    # Apply edge exchange with a probability to ensure diversity\n    if random.random() < 0.5 and n > 2:\n        # Choose two random edges to exchange\n        i, j = sorted(random.sample(range(1, n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if not (np.array_equal(np.sort(new_solution), np.sort(selected_solution)) and len(np.unique(new_solution)) == n):\n        # If the solution is invalid, revert to the original\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n"
    }
]